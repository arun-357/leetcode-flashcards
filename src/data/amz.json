[
  {
    "title": "Two Sum",
    "difficulty": "EASY",
    "category": "Array, Hash Table",
    "link": "https://leetcode.com/problems/two-sum",
    "slug": "two-sum",
    "description": "Given an array of integers \nnums\n and an integer \ntarget\n, return \nindices of the two numbers such that they add up to \ntarget\n.\n\n\nYou may assume that each input would have \nexactly\n one solution\n, and you may not use the \nsame\n element twice.\n\n\nYou can return the answer in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,7,11,15], target = 9\n\nOutput:\n [0,1]\n\nExplanation:\n Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,4], target = 6\n\nOutput:\n [1,2]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,3], target = 6\n\nOutput:\n [0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n-10\n9\n <= target <= 10\n9\n\n\nOnly one valid answer exists.\n\n\n\n\n \n\n\nFollow-up: \nCan you come up with an algorithm that is less than \nO(n\n2\n)\n \ntime complexity?",
    "solution": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        lookup = {}\n        for i, num in enumerate(nums):\n            if target - num in lookup:\n                return [lookup[target - num], i]\n            lookup[num] = i\n\n    def twoSum2(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        for i in nums:\n            j = target - i\n            tmp_nums_start_index = nums.index(i) + 1\n            tmp_nums = nums[tmp_nums_start_index:]\n            if j in tmp_nums:\n                return [nums.index(i), tmp_nums_start_index + tmp_nums.index(j)]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "EASY",
    "category": "Array, Dynamic Programming",
    "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
    "slug": "best-time-to-buy-and-sell-stock",
    "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nYou want to maximize your profit by choosing a \nsingle day\n to buy one stock and choosing a \ndifferent day in the future\n to sell that stock.\n\n\nReturn \nthe maximum profit you can achieve from this transaction\n. If you cannot achieve any profit, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 5\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transactions are done and the max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n4",
    "solution": "class Solution(object):\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, prices):\n        max_profit, min_price = 0, float(\"inf\")\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "LRU Cache",
    "difficulty": "MEDIUM",
    "category": "Hash Table, Linked List, Design, Doubly-Linked List",
    "link": "https://leetcode.com/problems/lru-cache",
    "slug": "lru-cache",
    "description": "Design a data structure that follows the constraints of a \nLeast Recently Used (LRU) cache\n.\n\n\nImplement the \nLRUCache\n class:\n\n\n\n\nLRUCache(int capacity)\n Initialize the LRU cache with \npositive\n size \ncapacity\n.\n\n\nint get(int key)\n Return the value of the \nkey\n if the key exists, otherwise return \n-1\n.\n\n\nvoid put(int key, int value)\n Update the value of the \nkey\n if the \nkey\n exists. Otherwise, add the \nkey-value\n pair to the cache. If the number of keys exceeds the \ncapacity\n from this operation, \nevict\n the least recently used key.\n\n\n\n\nThe functions \nget\n and \nput\n must each run in \nO(1)\n average time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n\nOutput\n\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n\nExplanation\n\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= capacity <= 3000\n\n\n0 <= key <= 10\n4\n\n\n0 <= value <= 10\n5\n\n\nAt most \n2 * 10\n5\n calls will be made to \nget\n and \nput\n.",
    "solution": "\nimport collections\n\n\n# using OrderedDictclass LRUCache(object):\n    def __init__(self, capacity):\n        self.cache = collections.OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        val = self.cache[key]\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.cache and len(self.cache) == self.capacity:\n            self.cache.popitem(last=False)\n        self.__update(key, val)\n    \n    def __update(self, key, val):\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = val\n\n\n\nclass ListNode(object):\n    def __init__(self, key, val):\n        self.val = val\n        self.key = key\n        self.next = None\n        self.prev = None\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\nclass LRUCache2(object):\n\n    def __init__(self, capacity):\n        self.list = LinkedList()\n        self.dict = {}\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.dict:\n            return -1\n        val = self.dict[key].val\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.dict and len(self.dict) == self.capacity:\n            del self.dict[self.list.head.key]\n            self.list.delete(self.list.head)\n        self.__update(key, val)\n\n    def __update(self, key, val):\n        if key in self.dict:\n            self.list.delete(self.dict[key])\n        node = ListNode(key, val)\n        self.list.insert(node)\n        self.dict[key] = node",
    "explanation": "N/A",
    "time_complexity": "O(1), per operation.",
    "space_complexity": "O(k), k is the capacity of cache."
  },
  {
    "title": "Number of Islands",
    "difficulty": "MEDIUM",
    "category": "Array, Depth-First Search, Breadth-First Search, Union Find, Matrix",
    "link": "https://leetcode.com/problems/number-of-islands",
    "slug": "number-of-islands",
    "description": "Given an \nm x n\n 2D binary grid \ngrid\n which represents a map of \n'1'\ns (land) and \n'0'\ns (water), return \nthe number of islands\n.\n\n\nAn \nisland\n is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 300\n\n\ngrid[i][j]\n is \n'0'\n or \n'1'\n.",
    "solution": "class UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n       if self.set[x] != x:\n           self.set[x] = self.find_set(self.set[x])  # path compression.\n       return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root != y_root:\n            self.set[min(x_root, y_root)] = max(x_root, y_root)\n            self.count -= 1\n\nclass Solution(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        def index(n, i, j):\n            return i*n + j\n    \n        if not grid:\n            return 0\n\n        zero_count = 0\n        union_find = UnionFind(len(grid)*len(grid[0]))\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j] == '1':\n                    if i and grid[i-1][j] == '1':\n                        union_find.union_set(index(len(grid[0]), i-1, j),\n                                             index(len(grid[0]),i, j))\n                    if j and grid[i][j-1] == '1':\n                        union_find.union_set(index(len(grid[0]), i, j-1),\n                                             index(len(grid[0]), i, j))\n                else:\n                    zero_count += 1        \n        return union_find.count-zero_count\n\n\n# dfs solutionclass Solution2(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def dfs(grid, i, j):\n            if grid[i][j] == '0':\n                return False\n            grid[i][j] = '0'\n            stk = [(i, j)]\n            while stk:\n                r, c = stk.pop()\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(grid) and\n                            0 <= nc < len(grid[0]) and\n                            grid[nr][nc] == '1'):\n                        continue\n                    grid[nr][nc] = '0'\n                    stk.append((nr, nc))\n            return True\n\n        count = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if dfs(grid, i, j):\n                    count += 1\n        return count\n\n \nimport collections\n\n\n# bfs solutionclass Solution3(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def bfs(grid, i, j):\n            if grid[i][j] == '0':\n                return False\n            grid[i][j] ='0'\n            q = collections.deque([(i, j)])\n            while q:\n                r, c = q.popleft()\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(grid) and\n                            0 <= nc < len(grid[0]) and\n                            grid[nr][nc] == '1'):\n                        continue\n                    grid[nr][nc] = '0'\n                    q.append((nr, nc))\n            return True\n\n        count = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if bfs(grid, i, j):\n                    count += 1\n        return count",
    "explanation": "N/A",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m * n)"
  },
  {
    "title": "Reorganize String",
    "difficulty": "MEDIUM",
    "category": "Hash Table, String, Greedy, Sorting, Heap (Priority Queue), Counting",
    "link": "https://leetcode.com/problems/reorganize-string",
    "slug": "reorganize-string",
    "description": "Given a string \ns\n, rearrange the characters of \ns\n so that any two adjacent characters are not the same.\n\n\nReturn \nany possible rearrangement of\n \ns\n \nor return\n \n\"\"\n \nif not possible\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"aab\"\n\nOutput:\n \"aba\"\n\nExample 2:\n\n\nInput:\n s = \"aaab\"\n\nOutput:\n \"\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 500\n\n\ns\n consists of lowercase English letters.",
    "solution": "\nimport collections\nimport heapq\n\nclass Solution(object):\n    def reorganizeString(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n        counts = collections.Counter(S)\n        if any(v > (len(S)+1)/2 for k, v in counts.iteritems()):\n            return \"\"\n\n        result = []\n        max_heap = []\n        for k, v in counts.iteritems():\n            heapq.heappush(max_heap, (-v, k))\n        while len(max_heap) > 1:\n            count1, c1 = heapq.heappop(max_heap)\n            count2, c2 = heapq.heappop(max_heap)\n            if not result or c1 != result[-1]:\n                result.extend([c1, c2])\n                if count1+1: heapq.heappush(max_heap, (count1+1, c1))\n                if count2+1: heapq.heappush(max_heap, (count2+1, c2))\n        return \"\".join(result) + (max_heap[0][1] if max_heap else '')",
    "explanation": "N/A",
    "time_complexity": "O(nloga) = O(n), a is the size of alphabet",
    "space_complexity": "O(a) = O(1)"
  },
  {
    "title": "Maximum Frequency After Subarray Operation",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Dynamic Programming, Greedy, Enumeration, Prefix Sum",
    "link": "https://leetcode.com/problems/maximum-frequency-after-subarray-operation",
    "slug": "maximum-frequency-after-subarray-operation",
    "description": "You are given an array \nnums\n of length \nn\n. You are also given an integer \nk\n.\n\n\nYou perform the following operation on \nnums\n \nonce\n:\n\n\n\n\nSelect a \nsubarray\n \nnums[i..j]\n where \n0 <= i <= j <= n - 1\n.\n\n\nSelect an integer \nx\n and add \nx\n to \nall\n the elements in \nnums[i..j]\n.\n\n\n\n\nFind the \nmaximum\n frequency of the value \nk\n after the operation.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,3,4,5,6], k = 1\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nAfter adding -5 to \nnums[2..5]\n, 1 has a frequency of 2 in \n[1, 2, -2, -1, 0, 1]\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [10,2,3,4,5,5,4,3,2,2], k = 10\n\n\nOutput:\n \n4\n\n\nExplanation:\n\n\nAfter adding 8 to \nnums[1..9]\n, 10 has a frequency of 4 in \n[10, 10, 11, 12, 13, 13, 12, 11, 10, 10]\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == nums.length <= 10\n5\n\n\n1 <= nums[i] <= 50\n\n\n1 <= k <= 50",
    "solution": "\nimport collections\n\n\n# freq table, dpclass Solution(object):\n    def maxFrequency(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        cnt = collections.defaultdict(int)\n        for x in nums:\n            cnt[x] = max(cnt[x], cnt[k])+1\n            result = max(result+int(x == k), cnt[x])\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Longest Palindromic Substring",
    "difficulty": "MEDIUM",
    "category": "Two Pointers, String, Dynamic Programming",
    "link": "https://leetcode.com/problems/longest-palindromic-substring",
    "slug": "longest-palindromic-substring",
    "description": "Given a string \ns\n, return \nthe longest\n \npalindromic\n \nsubstring\n in \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"babad\"\n\nOutput:\n \"bab\"\n\nExplanation:\n \"aba\" is also a valid answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"cbbd\"\n\nOutput:\n \"bb\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consist of only digits and English letters.",
    "solution": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def preProcess(s):\n            if not s:\n                return ['^', '$']\n            T = ['^']\n            for c in s:\n                T +=  ['#', c]\n            T += ['#', '$']\n            return T\n\n        T = preProcess(s)\n        P = [0] * len(T)\n        center, right = 0, 0\n        for i in xrange(1, len(T) - 1):\n            i_mirror = 2 * center - i\n            if right > i:\n                P[i] = min(right - i, P[i_mirror])\n            else:\n                P[i] = 0\n\n            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:\n                P[i] += 1\n\n            if i + P[i] > right:\n                center, right = i, i + P[i]\n\n        max_i = 0\n        for i in xrange(1, len(T) - 1):\n            if P[i] > P[max_i]:\n                max_i = i\n        start = (max_i - 1 - P[max_i]) // 2\n        return s[start : start + P[max_i]]\n\nclass Solution2(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return (right-left+1)-2\n        \n        left, right = -1, -2\n        for i in xrange(len(s)):\n            l = max(expand(s, i, i), expand(s, i, i+1))\n            if l > right-left+1:\n                right = i+l//2\n                left = right-l+1\n        return s[left:right+1] if left >= 0 else \"\"",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Add Two Numbers",
    "difficulty": "MEDIUM",
    "category": "Linked List, Math, Recursion",
    "link": "https://leetcode.com/problems/add-two-numbers",
    "slug": "add-two-numbers",
    "description": "You are given two \nnon-empty\n linked lists representing two non-negative integers. The digits are stored in \nreverse order\n, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n l1 = [2,4,3], l2 = [5,6,4]\n\nOutput:\n [7,0,8]\n\nExplanation:\n 342 + 465 = 807.\n\n\n\nExample 2:\n\n\n\n\nInput:\n l1 = [0], l2 = [0]\n\nOutput:\n [0]\n\n\n\nExample 3:\n\n\n\n\nInput:\n l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n\nOutput:\n [8,9,9,9,0,0,0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in each linked list is in the range \n[1, 100]\n.\n\n\n0 <= Node.val <= 9\n\n\nIt is guaranteed that the list represents a number that does not have leading zeros.",
    "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        current, carry = dummy, 0\n\n        while l1 or l2:\n            val = carry\n            if l1:\n                val += l1.val\n                l1 = l1.next\n            if l2:\n                val += l2.val\n                l2 = l2.next\n            carry, val = divmod(val, 10)\n            current.next = ListNode(val)\n            current = current.next\n\n        if carry == 1:\n            current.next = ListNode(1)\n\n        return dummy.next",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Koko Eating Bananas",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/koko-eating-bananas",
    "slug": "koko-eating-bananas",
    "description": "Koko loves to eat bananas. There are \nn\n piles of bananas, the \ni\nth\n pile has \npiles[i]\n bananas. The guards have gone and will come back in \nh\n hours.\n\n\nKoko can decide her bananas-per-hour eating speed of \nk\n. Each hour, she chooses some pile of bananas and eats \nk\n bananas from that pile. If the pile has less than \nk\n bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\n\nReturn \nthe minimum integer\n \nk\n \nsuch that she can eat all the bananas within\n \nh\n \nhours\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n piles = [3,6,7,11], h = 8\n\nOutput:\n 4\n\n\n\nExample 2:\n\n\n\n\nInput:\n piles = [30,11,23,4,20], h = 5\n\nOutput:\n 30\n\n\n\nExample 3:\n\n\n\n\nInput:\n piles = [30,11,23,4,20], h = 6\n\nOutput:\n 23\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= piles.length <= 10\n4\n\n\npiles.length <= h <= 10\n9\n\n\n1 <= piles[i] <= 10\n9",
    "solution": "class Solution(object):\n    def minEatingSpeed(self, piles, H):\n        \"\"\"\n        :type piles: List[int]\n        :type H: int\n        :rtype: int\n        \"\"\"\n        def possible(piles, H, K):\n            return sum((pile-1)//K+1 for pile in piles) <= H\n\n        left, right = 1, max(piles)\n        while left <= right:\n            mid = left + (right-left)//2\n            if possible(piles, H, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left",
    "explanation": "N/A",
    "time_complexity": "O(nlogr)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "MEDIUM",
    "category": "Hash Table, String, Sliding Window",
    "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters",
    "slug": "longest-substring-without-repeating-characters",
    "description": "Given a string \ns\n, find the length of the \nlongest\n \nsubstring\n without duplicate characters.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abcabcbb\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"abc\", with the length of 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"bbbbb\"\n\nOutput:\n 1\n\nExplanation:\n The answer is \"b\", with the length of 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"pwwkew\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 5 * 10\n4\n\n\ns\n consists of English letters, digits, symbols and spaces.",
    "solution": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, left = 0, 0\n        lookup = {}\n        for right in xrange(len(s)):\n            if s[right] in lookup:\n                left = max(left, lookup[s[right]]+1)\n            lookup[s[right]] = right\n            result = max(result, right-left+1)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Find First and Last Position of Element in Sorted Array",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array",
    "slug": "find-first-and-last-position-of-element-in-sorted-array",
    "description": "Given an array of integers \nnums\n sorted in non-decreasing order, find the starting and ending position of a given \ntarget\n value.\n\n\nIf \ntarget\n is not found in the array, return \n[-1, -1]\n.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [5,7,7,8,8,10], target = 8\n\nOutput:\n [3,4]\n\nExample 2:\n\n\nInput:\n nums = [5,7,7,8,8,10], target = 6\n\nOutput:\n [-1,-1]\n\nExample 3:\n\n\nInput:\n nums = [], target = 0\n\nOutput:\n [-1,-1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\nnums\n is a non-decreasing array.\n\n\n-10\n9\n <= target <= 10\n9",
    "solution": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        def binarySearch(n, check):  # usually use\n            left, right = 0, n-1  # search in [0, n-1], return n if not found\n            while left <= right:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left  # or return right+1\n\n        def binarySearch2(n, check):  # frequently use\n            left, right = 0, n  # search in [0, n), return n if not found\n            while left < right:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid\n                else:\n                    left = mid+1\n            return left  # or return right\n\n        def binarySearch3(n, check):  # never use\n            left, right = -1, n-1  # search in (-1, n-1], return n if not found\n            while left < right:\n                mid = right - (right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid\n            return left+1  # or return right+1\n\n        def binarySearch4(n, check):  # sometimes use\n            left, right = -1, n  # search in (-1, n), return n if not found\n            while right-left >= 2:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid\n                else:\n                    left = mid\n            return left+1  # or return right\n\n        # Find the first idx where nums[idx] >= target\n        left = binarySearch(len(nums), lambda i: nums[i] >= target)\n        if left == len(nums) or nums[left] != target:\n            return [-1, -1]\n        # Find the first idx where nums[idx] > target\n        right = binarySearch(len(nums), lambda i: nums[i] > target)\n        return [left, right-1]",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Trapping Rain Water",
    "difficulty": "HARD",
    "category": "Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack",
    "link": "https://leetcode.com/problems/trapping-rain-water",
    "slug": "trapping-rain-water",
    "description": "Given \nn\n non-negative integers representing an elevation map where the width of each bar is \n1\n, compute how much water it can trap after raining.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [0,1,0,2,1,0,1,3,2,1,2,1]\n\nOutput:\n 6\n\nExplanation:\n The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [4,2,0,3,2,5]\n\nOutput:\n 9\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n1 <= n <= 2 * 10\n4\n\n\n0 <= height[i] <= 10\n5",
    "solution": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result, left, right, level = 0, 0, len(height)-1, 0\n        while left < right:\n            if height[left] < height[right]:\n                lower = height[left]\n                left += 1\n            else:\n                lower = height[right]\n                right -= 1\n            level = max(level, lower)\n            result += level-lower\n        return result\n\nclass Solution2(object):\n    # @param A, a list of integers\n    # @return an integer\n    def trap(self, A):\n        result = 0\n        top = 0\n        for i in xrange(len(A)):\n            if A[top] < A[i]:\n                top = i\n\n        second_top = 0\n        for i in xrange(top):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        second_top = len(A) - 1\n        for i in reversed(xrange(top, len(A))):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        return result\n\nclass Solution3(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        right = [0]*len(height)\n        mx = 0\n        for i in reversed(xrange(len(height))):\n            right[i] = mx\n            mx = max(mx, height[i])\n        result = left = 0\n        for i in xrange(len(height)):\n            left = max(left, height[i])\n            result += max(min(left, right[i])-height[i], 0)\n        return result\n\nclass Solution4(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        stk = []\n        for i in xrange(len(height)):\n            prev = 0\n            while stk and height[stk[-1]] <= height[i]:\n                j = stk.pop()\n                result += (height[j] - prev) * (i - j - 1)\n                prev = height[j]\n            if stk:\n                result += (height[i] - prev) * (i - stk[-1] - 1)\n            stk.append(i)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Top K Frequent Elements",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Divide and Conquer, Sorting, Heap (Priority Queue), Bucket Sort, Counting, Quickselect",
    "link": "https://leetcode.com/problems/top-k-frequent-elements",
    "slug": "top-k-frequent-elements",
    "description": "Given an integer array \nnums\n and an integer \nk\n, return \nthe\n \nk\n \nmost frequent elements\n. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,1,1,2,2,3], k = 2\n\nOutput:\n [1,2]\n\nExample 2:\n\n\nInput:\n nums = [1], k = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nk\n is in the range \n[1, the number of unique elements in the array]\n.\n\n\nIt is \nguaranteed\n that the answer is \nunique\n.\n\n\n\n\n \n\n\nFollow up:\n Your algorithm's time complexity must be better than \nO(n log n)\n, where n is the array's size.",
    "solution": "\nimport collections\n\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        counts = collections.Counter(nums)\n        buckets = [[] for _ in xrange(len(nums)+1)]\n        for i, count in counts.iteritems():\n            buckets[count].append(i)\n\n        result = []\n        for i in reversed(xrange(len(buckets))):\n            for j in xrange(len(buckets[i])):\n                result.append(buckets[i][j])\n                if len(result) == k:\n                    return result\n        return result\n\n\n# Quick Select Solution\nfrom random import randintclass Solution2(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        counts = collections.Counter(nums)\n        p = []\n        for key, val in counts.iteritems():\n            p.append((-val, key))\n        self.kthElement(p, k-1)\n\n        result = []\n        for i in xrange(k):\n            result.append(p[i][1])\n        return result\n\n    def kthElement(self, nums, k):\n        def PartitionAroundPivot(left, right, pivot_idx, nums):\n            pivot_value = nums[pivot_idx]\n            new_pivot_idx = left\n            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n            for i in xrange(left, right):\n                if nums[i] < pivot_value:\n                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                    new_pivot_idx += 1\n\n            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n            return new_pivot_idx\n\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k:\n                return\n            elif new_pivot_idx > k:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k.\n                left = new_pivot_idx + 1\n\nclass Solution3(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        return [key for key, _ in collections.Counter(nums).most_common(k)]",
    "explanation": "N/A",
    "time_complexity": "O(nlogk)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Merge k Sorted Lists",
    "difficulty": "HARD",
    "category": "Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort",
    "link": "https://leetcode.com/problems/merge-k-sorted-lists",
    "slug": "merge-k-sorted-lists",
    "description": "You are given an array of \nk\n linked-lists \nlists\n, each linked-list is sorted in ascending order.\n\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n lists = [[1,4,5],[1,3,4],[2,6]]\n\nOutput:\n [1,1,2,3,4,4,5,6]\n\nExplanation:\n The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted linked list:\n1->1->2->3->4->4->5->6\n\n\n\nExample 2:\n\n\n\n\nInput:\n lists = []\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n lists = [[]]\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nk == lists.length\n\n\n0 <= k <= 10\n4\n\n\n0 <= lists[i].length <= 500\n\n\n-10\n4\n <= lists[i][j] <= 10\n4\n\n\nlists[i]\n is sorted in \nascending order\n.\n\n\nThe sum of \nlists[i].length\n will not exceed \n10\n4\n.",
    "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\t\t\n        if self:\t\t\n            return \"{} -> {}\".format(self.val, self.next)\n\n\n# Merge two by two solution.class Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        if not lists:\n            return None\n        left, right = 0, len(lists) - 1\n        while right > 0:\n            lists[left] = mergeTwoLists(lists[left], lists[right])\n            left += 1\n            right -= 1\n            if left >= right:\n                left = 0\n        return lists[0]\n\n\n# Divide and Conquer solution.class Solution2(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        def mergeKListsHelper(lists, begin, end):\n            if begin > end:\n                return None\n            if begin == end:\n                return lists[begin]\n            return mergeTwoLists(mergeKListsHelper(lists, begin, (begin + end) / 2), \\\n                                 mergeKListsHelper(lists, (begin + end) / 2 + 1, end))\n\n        return mergeKListsHelper(lists, 0, len(lists) - 1)\n\n\n# Heap solution.\nimport heapqclass Solution3(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        dummy = ListNode(0)\n        current = dummy\n\n        heap = []\n        for sorted_list in lists:\n            if sorted_list:\n                heapq.heappush(heap, (sorted_list.val, sorted_list))\n\n        while heap:\n            smallest = heapq.heappop(heap)[1]\n            current.next = smallest\n            current = current.next\n            if smallest.next:\n                heapq.heappush(heap, (smallest.next.val, smallest.next))\n\n        return dummy.next",
    "explanation": "N/A",
    "time_complexity": "O(nlogk)",
    "space_complexity": "O(k)"
  },
  {
    "title": "Jump Game II",
    "difficulty": "MEDIUM",
    "category": "Array, Dynamic Programming, Greedy",
    "link": "https://leetcode.com/problems/jump-game-ii",
    "slug": "jump-game-ii",
    "description": "You are given a \n0-indexed\n array of integers \nnums\n of length \nn\n. You are initially positioned at \nnums[0]\n.\n\n\nEach element \nnums[i]\n represents the maximum length of a forward jump from index \ni\n. In other words, if you are at \nnums[i]\n, you can jump to any \nnums[i + j]\n where:\n\n\n\n\n0 <= j <= nums[i]\n and\n\n\ni + j < n\n\n\n\n\nReturn \nthe minimum number of jumps to reach \nnums[n - 1]\n. The test cases are generated such that you can reach \nnums[n - 1]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,3,1,1,4]\n\nOutput:\n 2\n\nExplanation:\n The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,3,0,1,4]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n0 <= nums[i] <= 1000\n\n\nIt's guaranteed that you can reach \nnums[n - 1]\n.",
    "solution": "class Solution(object):\n    # @param A, a list of integers\n    # @return an integer\n    def jump(self, A):\n        jump_count = 0\n        reachable = 0\n        curr_reachable = 0\n        for i, length in enumerate(A):\n            if i > reachable:\n                return -1\n            if i > curr_reachable:\n                curr_reachable = reachable\n                jump_count += 1\n            reachable = max(reachable, i + length)\n        return jump_count",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Merge Intervals",
    "difficulty": "MEDIUM",
    "category": "Array, Sorting",
    "link": "https://leetcode.com/problems/merge-intervals",
    "slug": "merge-intervals",
    "description": "Given an array of \nintervals\n where \nintervals[i] = [start\ni\n, end\ni\n]\n, merge all overlapping intervals, and return \nan array of the non-overlapping intervals that cover all the intervals in the input\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n intervals = [[1,3],[2,6],[8,10],[15,18]]\n\nOutput:\n [[1,6],[8,10],[15,18]]\n\nExplanation:\n Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\n\n\nExample 2:\n\n\n\n\nInput:\n intervals = [[1,4],[4,5]]\n\nOutput:\n [[1,5]]\n\nExplanation:\n Intervals [1,4] and [4,5] are considered overlapping.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= intervals.length <= 10\n4\n\n\nintervals[i].length == 2\n\n\n0 <= start\ni\n <= end\ni\n <= 10\n4",
    "solution": "class Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        intervals.sort()\n        result = []\n        for interval in intervals:\n            if not result or interval[0] > result[-1][1]:\n                result.append(interval)\n            else:\n                result[-1][1] = max(result[-1][1], interval[1])\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Group Anagrams",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, String, Sorting",
    "link": "https://leetcode.com/problems/group-anagrams",
    "slug": "group-anagrams",
    "description": "Given an array of strings \nstrs\n, group the \nanagrams\n together. You can return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nstrs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n\n\nOutput:\n \n[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\n\nExplanation:\n\n\n\n\nThere is no string in strs that can be rearranged to form \n\"bat\"\n.\n\n\nThe strings \n\"nat\"\n and \n\"tan\"\n are anagrams as they can be rearranged to form each other.\n\n\nThe strings \n\"ate\"\n, \n\"eat\"\n, and \n\"tea\"\n are anagrams as they can be rearranged to form each other.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nstrs = [\"\"]\n\n\nOutput:\n \n[[\"\"]]\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nstrs = [\"a\"]\n\n\nOutput:\n \n[[\"a\"]]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 10\n4\n\n\n0 <= strs[i].length <= 100\n\n\nstrs[i]\n consists of lowercase English letters.",
    "solution": "\nimport collections\n\nclass Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagrams_map, result = collections.defaultdict(list), []\n        for s in strs:\n            sorted_str = (\"\").join(sorted(s))\n            anagrams_map[sorted_str].append(s)\n        for anagram in anagrams_map.values():\n            anagram.sort()\n            result.append(anagram)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n * glogg), g is the max size of groups.",
    "space_complexity": "O(n)"
  },
  {
    "title": "Lowest Common Ancestor of a Binary Tree",
    "difficulty": "MEDIUM",
    "category": "Tree, Depth-First Search, Binary Tree",
    "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree",
    "slug": "lowest-common-ancestor-of-a-binary-tree",
    "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\n\nAccording to the \ndefinition of LCA on Wikipedia\n: “The lowest common ancestor is defined between two nodes \np\n and \nq\n as the lowest node in \nT\n that has both \np\n and \nq\n as descendants (where we allow \na node to be a descendant of itself\n).”\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n\nOutput:\n 3\n\nExplanation:\n The LCA of nodes 5 and 1 is 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n\nOutput:\n 5\n\nExplanation:\n The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [1,2], p = 1, q = 2\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 10\n5\n]\n.\n\n\n-10\n9\n <= Node.val <= 10\n9\n\n\nAll \nNode.val\n are \nunique\n.\n\n\np != q\n\n\np\n and \nq\n will exist in the tree.",
    "solution": "class Solution(object):\n    # @param {TreeNode} root\n    # @param {TreeNode} p\n    # @param {TreeNode} q\n    # @return {TreeNode}\n    def lowestCommonAncestor(self, root, p, q):\n        if root in (None, p, q):\n            return root\n\n        left, right = [self.lowestCommonAncestor(child, p, q) \\\n                         for child in (root.left, root.right)]\n        # 1. If the current subtree contains both p and q,\n        #    return their LCA.\n        # 2. If only one of them is in that subtree,\n        #    return that one of them.\n        # 3. If neither of them is in that subtree,\n        #    return the node of that subtree.\n        return root if left and right else left or right",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(h)"
  },
  {
    "title": "Longest Repeating Character Replacement",
    "difficulty": "MEDIUM",
    "category": "Hash Table, String, Sliding Window",
    "link": "https://leetcode.com/problems/longest-repeating-character-replacement",
    "slug": "longest-repeating-character-replacement",
    "description": "You are given a string \ns\n and an integer \nk\n. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most \nk\n times.\n\n\nReturn \nthe length of the longest substring containing the same letter you can get after performing the above operations\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"ABAB\", k = 2\n\nOutput:\n 4\n\nExplanation:\n Replace the two 'A's with two 'B's or vice versa.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"AABABBA\", k = 1\n\nOutput:\n 4\n\nExplanation:\n Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\nThere may exists other ways to achieve this answer too.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns\n consists of only uppercase English letters.\n\n\n0 <= k <= s.length",
    "solution": "\nimport collections\n\nclass Solution(object):\n    def characterReplacement(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result, max_count = 0, 0\n        count = collections.Counter()\n        for i in xrange(len(s)):\n            count[s[i]] += 1\n            max_count = max(max_count, count[s[i]])\n            if result - max_count >= k:\n                count[s[i-result]] -= 1\n            else:\n                result += 1\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Candy",
    "difficulty": "HARD",
    "category": "Array, Greedy",
    "link": "https://leetcode.com/problems/candy",
    "slug": "candy",
    "description": "There are \nn\n children standing in a line. Each child is assigned a rating value given in the integer array \nratings\n.\n\n\nYou are giving candies to these children subjected to the following requirements:\n\n\n\n\nEach child must have at least one candy.\n\n\nChildren with a higher rating get more candies than their neighbors.\n\n\n\n\nReturn \nthe minimum number of candies you need to have to distribute the candies to the children\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n ratings = [1,0,2]\n\nOutput:\n 5\n\nExplanation:\n You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\n\n\nExample 2:\n\n\n\n\nInput:\n ratings = [1,2,2]\n\nOutput:\n 4\n\nExplanation:\n You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == ratings.length\n\n\n1 <= n <= 2 * 10\n4\n\n\n0 <= ratings[i] <= 2 * 10\n4",
    "solution": "class Solution(object):\n    # @param ratings, a list of integer\n    # @return an integer\n    def candy(self, ratings):\n        candies = [1 for _ in xrange(len(ratings))]\n        for i in xrange(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        for i in reversed(xrange(1, len(ratings))):\n            if ratings[i - 1] > ratings[i] and candies[i - 1] <= candies[i]:\n                candies[i - 1] = candies[i] + 1\n\n        return sum(candies)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Meeting Rooms II",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers, Greedy, Sorting, Heap (Priority Queue), Prefix Sum",
    "link": "https://leetcode.com/problems/meeting-rooms-ii",
    "slug": "meeting-rooms-ii",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "class Solution(object):\n    # @param {Interval[]} intervals\n    # @return {integer}\n    def minMeetingRooms(self, intervals):\n        result, curr = 0, 0\n        line = [x for i, j in intervals for x in [[i, 1], [j, -1]]]\n        line.sort()\n        for _, num in line:\n            curr += num\n            result = max(result, curr)\n        return result\n\nclass Solution2(object):\n    # @param {Interval[]} intervals\n    # @return {integer}\n    def minMeetingRooms(self, intervals):\n        starts, ends = [], []\n        for start, end in intervals:\n            starts.append(start)\n            ends.append(end)\n\n        starts.sort()\n        ends.sort()\n\n        s, e = 0, 0\n        min_rooms, cnt_rooms = 0, 0\n        while s < len(starts):\n            if starts[s] < ends[e]:\n                cnt_rooms += 1  # Acquire a room.\n                # Update the min number of rooms.\n                min_rooms = max(min_rooms, cnt_rooms)\n                s += 1\n            else:\n                cnt_rooms -= 1  # Release a room.\n                e += 1\n\n        return min_rooms\n\n\nfrom heapq import heappush, heappop\n\nclass Solution3(object):\n    def minMeetingRooms(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return 0\n        \n        intervals.sort(key=lambda x: x[0])\n        free_rooms = []\n        \n        heappush(free_rooms, intervals[0][1])\n        for interval in intervals[1:]:\n            if free_rooms[0] <= interval[0]:\n                heappop(free_rooms)\n            \n            heappush(free_rooms, interval[1])\n        \n        return len(free_rooms)",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Valid Parentheses",
    "difficulty": "EASY",
    "category": "String, Stack",
    "link": "https://leetcode.com/problems/valid-parentheses",
    "slug": "valid-parentheses",
    "description": "Given a string \ns\n containing just the characters \n'('\n, \n')'\n, \n'{'\n, \n'}'\n, \n'['\n and \n']'\n, determine if the input string is valid.\n\n\nAn input string is valid if:\n\n\n\n\nOpen brackets must be closed by the same type of brackets.\n\n\nOpen brackets must be closed in the correct order.\n\n\nEvery close bracket has a corresponding open bracket of the same type.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"()\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"()[]{}\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"(]\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"([])\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"([)]\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of parentheses only \n'()[]{}'\n.",
    "solution": "class Solution(object):\n    # @return a boolean\n    def isValid(self, s):\n        stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        for parenthese in s:\n            if parenthese in lookup:\n                stack.append(parenthese)\n            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:\n                return False\n        return len(stack) == 0",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Minimum Window Substring",
    "difficulty": "HARD",
    "category": "Hash Table, String, Sliding Window",
    "link": "https://leetcode.com/problems/minimum-window-substring",
    "slug": "minimum-window-substring",
    "description": "Given two strings \ns\n and \nt\n of lengths \nm\n and \nn\n respectively, return \nthe \nminimum window\n \nsubstring\n of \ns\n such that every character in \nt\n (\nincluding duplicates\n) is included in the window\n. If there is no such substring, return \nthe empty string \n\"\"\n.\n\n\nThe testcases will be generated such that the answer is \nunique\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"ADOBECODEBANC\", t = \"ABC\"\n\nOutput:\n \"BANC\"\n\nExplanation:\n The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"a\", t = \"a\"\n\nOutput:\n \"a\"\n\nExplanation:\n The entire string s is the minimum window.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"a\", t = \"aa\"\n\nOutput:\n \"\"\n\nExplanation:\n Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == s.length\n\n\nn == t.length\n\n\n1 <= m, n <= 10\n5\n\n\ns\n and \nt\n consist of uppercase and lowercase English letters.\n\n\n\n\n \n\n\nFollow up:\n Could you find an algorithm that runs in \nO(m + n)\n time?",
    "solution": "\nimport collections\n\nclass Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        count, remain = collections.Counter(t), len(t)\n        i, left, right = 0, -1, -1\n        for j, c in enumerate(s):\n            remain -= count[c] > 0\n            count[c] -= 1\n            if remain:\n                continue\n            while count[s[i]] < 0:  # greedily discard uneeds\n                count[s[i]] += 1\n                i += 1\n            if right == -1 or j-i+1 < right-left+1:\n                left, right = i, j\n        return s[left:right+1]\n\nclass Solution2(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        current_count = [0 for i in xrange(52)]\n        expected_count = [0 for i in xrange(52)]\n\n        for char in t:\n            expected_count[ord(char) - ord('a')] += 1\n\n        i, count, start, min_width, min_start = 0, 0, 0, float(\"inf\"), 0\n        while i < len(s):\n            current_count[ord(s[i]) - ord('a')] += 1\n            if current_count[ord(s[i]) - ord('a')] <= expected_count[ord(s[i]) - ord('a')]:\n                count += 1\n\n            if count == len(t):\n                while expected_count[ord(s[start]) - ord('a')] == 0 or \\\n                      current_count[ord(s[start]) - ord('a')] > expected_count[ord(s[start]) - ord('a')]:\n                    current_count[ord(s[start]) - ord('a')] -= 1\n                    start += 1\n\n                if min_width > i - start + 1:\n                    min_width = i - start + 1\n                    min_start = start\n            i += 1\n\n        if min_width == float(\"inf\"):\n            return \"\"\n\n        return s[min_start:min_start + min_width]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(k), k is the number of different characters"
  },
  {
    "title": "House Robber",
    "difficulty": "MEDIUM",
    "category": "Array, Dynamic Programming",
    "link": "https://leetcode.com/problems/house-robber",
    "slug": "house-robber",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and \nit will automatically contact the police if two adjacent houses were broken into on the same night\n.\n\n\nGiven an integer array \nnums\n representing the amount of money of each house, return \nthe maximum amount of money you can rob tonight \nwithout alerting the police\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,1]\n\nOutput:\n 4\n\nExplanation:\n Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,7,9,3,1]\n\nOutput:\n 12\n\nExplanation:\n Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 400",
    "solution": "class Solution(object):\n    # @param num, a list of integer\n    # @return an integer\n    def rob(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        last, now = 0, 0\n        for i in nums:\n            last, now = now, max(last + i, now)\n        return now",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Median of Two Sorted Arrays",
    "difficulty": "HARD",
    "category": "Array, Binary Search, Divide and Conquer",
    "link": "https://leetcode.com/problems/median-of-two-sorted-arrays",
    "slug": "median-of-two-sorted-arrays",
    "description": "Given two sorted arrays \nnums1\n and \nnums2\n of size \nm\n and \nn\n respectively, return \nthe median\n of the two sorted arrays.\n\n\nThe overall run time complexity should be \nO(log (m+n))\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,3], nums2 = [2]\n\nOutput:\n 2.00000\n\nExplanation:\n merged array = [1,2,3] and median is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1,2], nums2 = [3,4]\n\nOutput:\n 2.50000\n\nExplanation:\n merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m\n\n\nnums2.length == n\n\n\n0 <= m <= 1000\n\n\n0 <= n <= 1000\n\n\n1 <= m + n <= 2000\n\n\n-10\n6\n <= nums1[i], nums2[i] <= 10\n6",
    "solution": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(A, B, k):\n            m, n = len(A), len(B)\n            if m > n:\n                m, n = n, m\n                A, B = B, A\n            i = binary_search(max(k-n, 0), min(m, k)-1, lambda i: A[i] >= B[k-1-i])\n            return max(A[i-1] if i-1 >= 0 else float(\"-inf\"), B[k-1-i] if k-1-i >= 0 else float(\"-inf\"))\n\n        len1, len2 = len(nums1), len(nums2)\n        if (len1+len2) % 2 == 1:\n            return getKth(nums1, nums2, (len1+len2)//2+1)\n        else:\n            return (getKth(nums1, nums2, (len1+len2)//2)+getKth(nums1, nums2, (len1+len2)//2+1))*0.5    \n\n\n# Generic solution.class Solution_Generic(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(arrays, k):\n            def check(num):\n                # count the number of values which are less or equal to num\n                return sum(binary_search(0, len(arr)-1, lambda x: arr[x] > num) for arr in arrays) >= k\n    \n            return binary_search(min(arr[0] for arr in arrays if arr), max(arr[-1] for arr in arrays if arr), check)\n\n        array = [nums1, nums2]\n        total = sum(len(nums) for nums in array)\n        if total % 2 == 1:\n            return getKth(array, total//2+1)\n        else:\n            return (getKth(array, total//2)+getKth(array, total//2+1))*0.5",
    "explanation": "N/A",
    "time_complexity": "O(log(max(m, n)) * log(max_val - min_val))",
    "space_complexity": "O(1)"
  },
  {
    "title": "Min Stack",
    "difficulty": "MEDIUM",
    "category": "Stack, Design",
    "link": "https://leetcode.com/problems/min-stack",
    "slug": "min-stack",
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\n\nImplement the \nMinStack\n class:\n\n\n\n\nMinStack()\n initializes the stack object.\n\n\nvoid push(int val)\n pushes the element \nval\n onto the stack.\n\n\nvoid pop()\n removes the element on the top of the stack.\n\n\nint top()\n gets the top element of the stack.\n\n\nint getMin()\n retrieves the minimum element in the stack.\n\n\n\n\nYou must implement a solution with \nO(1)\n time complexity for each function.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n\nOutput\n\n[null,null,null,null,-3,null,0,-2]\n\n\nExplanation\n\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= val <= 2\n31\n - 1\n\n\nMethods \npop\n, \ntop\n and \ngetMin\n operations will always be called on \nnon-empty\n stacks.\n\n\nAt most \n3 * 10\n4\n calls will be made to \npush\n, \npop\n, \ntop\n, and \ngetMin\n.",
    "solution": "class MinStack(object):\n    def __init__(self):\n        self.min = None\n        self.stack = []\n\n    # @param x, an integer\n    # @return an integer\n    def push(self, x):\n        if not self.stack:\n            self.stack.append(0)\n            self.min = x\n        else:\n            self.stack.append(x - self.min)\n            if x < self.min:\n                self.min = x\n\n    # @return nothing\n    def pop(self):\n        x = self.stack.pop()\n        if x < 0:\n            self.min = self.min - x\n\n    # @return an integer\n    def top(self):\n        x = self.stack[-1]\n        if x > 0:\n            return x + self.min\n        else:\n            return self.min\n\n    # @return an integer\n    def getMin(self):\n        return self.min\nclass MinStack2(object):\n    def __init__(self):\n        self.stack, self.minStack = [], []\n    # @param x, an integer\n    # @return an integer\n    def push(self, x):\n        self.stack.append(x)\n        if len(self.minStack):\n            if x < self.minStack[-1][0]:\n                self.minStack.append([x, 1])\n            elif x == self.minStack[-1][0]:\n                self.minStack[-1][1] += 1\n        else:\n            self.minStack.append([x, 1])\n\n    # @return nothing\n    def pop(self):\n        x = self.stack.pop()\n        if x == self.minStack[-1][0]:\n            self.minStack[-1][1] -= 1\n            if self.minStack[-1][1] == 0:\n                self.minStack.pop()\n\n    # @return an integer\n    def top(self):\n        return self.stack[-1]\n\n    # @return an integer\n    def getMin(self):\n        return self.minStack[-1][0]\n\n# time: O(1)\n# space: O(n)\nclass MinStack3(object):\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x):\n        if self.stack:\n            current_min = min(x, self.stack[-1][0])\n            self.stack.append((current_min, x))\n        else:\n            self.stack.append((x, x))\n\n    def pop(self):\n        return self.stack.pop()[1]\n\n    def top(self):\n        return self.stack[-1][1]\n\n    def getMin(self):\n        return self.stack[-1][0]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Rotate Image",
    "difficulty": "MEDIUM",
    "category": "Array, Math, Matrix",
    "link": "https://leetcode.com/problems/rotate-image",
    "slug": "rotate-image",
    "description": "You are given an \nn x n\n 2D \nmatrix\n representing an image, rotate the image by \n90\n degrees (clockwise).\n\n\nYou have to rotate the image \nin-place\n, which means you have to modify the input 2D matrix directly. \nDO NOT\n allocate another 2D matrix and do the rotation.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [[7,4,1],[8,5,2],[9,6,3]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n\nOutput:\n [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 20\n\n\n-1000 <= matrix[i][j] <= 1000",
    "solution": "class Solution(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        n = len(matrix)\n\n        # anti-diagonal mirror\n        for i in xrange(n):\n            for j in xrange(n - i):\n                matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j]\n\n        # horizontal mirror\n        for i in xrange(n / 2):\n            for j in xrange(n):\n                matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]\n\n        return matrix\nclass Solution2(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        return [list(reversed(x)) for x in zip(*matrix)]",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n^2)"
  },
  {
    "title": "Best Time to Buy and Sell Stock II",
    "difficulty": "MEDIUM",
    "category": "Array, Dynamic Programming, Greedy",
    "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii",
    "slug": "best-time-to-buy-and-sell-stock-ii",
    "description": "You are given an integer array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold \nat most one\n share of the stock at any time. However, you can buy it then immediately sell it on the \nsame day\n.\n\n\nFind and return \nthe \nmaximum\n profit you can achieve\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 7\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [1,2,3,4,5]\n\nOutput:\n 4\n\nExplanation:\n Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n\n\n\nExample 3:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 3 * 10\n4\n\n\n0 <= prices[i] <= 10\n4",
    "solution": "\nclass Solution(object):\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, prices):\n        profit = 0\n        for i in xrange(len(prices) - 1):\n            profit += max(0, prices[i + 1] - prices[i])\n        return profit\n\n    def maxProfit2(self, prices):\n        return sum(map(lambda x: max(prices[x + 1] - prices[x], 0),\n                       xrange(len(prices[:-1]))))",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Concatenated Words",
    "difficulty": "HARD",
    "category": "Array, String, Dynamic Programming, Depth-First Search, Trie",
    "link": "https://leetcode.com/problems/concatenated-words",
    "slug": "concatenated-words",
    "description": "Given an array of strings \nwords\n (\nwithout duplicates\n), return \nall the \nconcatenated words\n in the given list of\n \nwords\n.\n\n\nA \nconcatenated word\n is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct) in the given array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\n\nOutput:\n [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\n\nExplanation:\n \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; \n\"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \n\"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"cat\",\"dog\",\"catdog\"]\n\nOutput:\n [\"catdog\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 10\n4\n\n\n1 <= words[i].length <= 30\n\n\nwords[i]\n consists of only lowercase English letters.\n\n\nAll the strings of \nwords\n are \nunique\n.\n\n\n1 <= sum(words[i].length) <= 10\n5",
    "solution": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        lookup = set(words)\n        result = []\n        for word in words:\n            dp = [False] * (len(word)+1)\n            dp[0] = True\n            for i in xrange(len(word)):\n                if not dp[i]:\n                    continue\n\n                for j in xrange(i+1, len(word)+1):\n                    if j - i < len(word) and word[i:j] in lookup:\n                        dp[j] = True\n\n                if dp[len(word)]:\n                    result.append(word)\n                    break\n\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n * l^2)",
    "space_complexity": "O(n * l)"
  },
  {
    "title": "Generate Parentheses",
    "difficulty": "MEDIUM",
    "category": "String, Dynamic Programming, Backtracking",
    "link": "https://leetcode.com/problems/generate-parentheses",
    "slug": "generate-parentheses",
    "description": "Given \nn\n pairs of parentheses, write a function to \ngenerate all combinations of well-formed parentheses\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n n = 3\n\nOutput:\n [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n\nExample 2:\n\n\nInput:\n n = 1\n\nOutput:\n [\"()\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 8",
    "solution": "\n# iterative solutionclass Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result, curr = [], []\n        stk = [(1, (n, n))]\n        while stk:\n            step, args = stk.pop()\n            if step == 1:\n                left, right = args\n                if left == 0 and right == 0:\n                    result.append(\"\".join(curr))\n                if left < right:\n                    stk.append((3, tuple()))\n                    stk.append((1, (left, right-1)))\n                    stk.append((2, (')')))\n                if left > 0:\n                    stk.append((3, tuple()))\n                    stk.append((1, (left-1, right)))\n                    stk.append((2, ('(')))\n            elif step == 2:\n                curr.append(args[0])\n            elif step == 3:\n                curr.pop()\n        return result\n\n\n# recursive solutionclass Solution2(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        def generateParenthesisRecu(left, right, curr, result):\n            if left == 0 and right == 0:\n                result.append(\"\".join(curr))\n            if left > 0:\n                curr.append('(')\n                generateParenthesisRecu(left-1, right, curr, result)\n                curr.pop()\n            if left < right:\n                curr.append(')')\n                generateParenthesisRecu(left, right-1, curr, result)\n                curr.pop()\n\n        result = []\n        generateParenthesisRecu(n, n, [], result)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(4^n / n^(3/2)) ~= Catalan numbers",
    "space_complexity": "O(n)"
  },
  {
    "title": "Search a 2D Matrix",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search, Matrix",
    "link": "https://leetcode.com/problems/search-a-2d-matrix",
    "slug": "search-a-2d-matrix",
    "description": "You are given an \nm x n\n integer matrix \nmatrix\n with the following two properties:\n\n\n\n\nEach row is sorted in non-decreasing order.\n\n\nThe first integer of each row is greater than the last integer of the previous row.\n\n\n\n\nGiven an integer \ntarget\n, return \ntrue\n \nif\n \ntarget\n \nis in\n \nmatrix\n \nor\n \nfalse\n \notherwise\n.\n\n\nYou must write a solution in \nO(log(m * n))\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 100\n\n\n-10\n4\n <= matrix[i][j], target <= 10\n4",
    "solution": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not matrix:\n            return False\n\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n\n        while left < right:\n            mid = left + (right - left) / 2\n            if matrix[mid / n][mid % n] >= target:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left < m * n and matrix[left / n][left % n] == target",
    "explanation": "N/A",
    "time_complexity": "O(logm + logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Coin Change",
    "difficulty": "MEDIUM",
    "category": "Array, Dynamic Programming, Breadth-First Search",
    "link": "https://leetcode.com/problems/coin-change",
    "slug": "coin-change",
    "description": "You are given an integer array \ncoins\n representing coins of different denominations and an integer \namount\n representing a total amount of money.\n\n\nReturn \nthe fewest number of coins that you need to make up that amount\n. If that amount of money cannot be made up by any combination of the coins, return \n-1\n.\n\n\nYou may assume that you have an infinite number of each kind of coin.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n coins = [1,2,5], amount = 11\n\nOutput:\n 3\n\nExplanation:\n 11 = 5 + 5 + 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n coins = [2], amount = 3\n\nOutput:\n -1\n\n\n\nExample 3:\n\n\n\n\nInput:\n coins = [1], amount = 0\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= coins.length <= 12\n\n\n1 <= coins[i] <= 2\n31\n - 1\n\n\n0 <= amount <= 10\n4",
    "solution": "class Solution(object):\n    def coinChange(self, coins, amount):\n        \"\"\"\n        :type coins: List[int]\n        :type amount: int\n        :rtype: int\n        \"\"\"\n        INF = 0x7fffffff  # Using float(\"inf\") would be slower.\n        dp = [INF] * (amount + 1)\n        dp[0] = 0\n        for i in xrange(amount + 1):\n            if dp[i] != INF:\n                for coin in coins:\n                    if i + coin <= amount:\n                        dp[i + coin] = min(dp[i + coin], dp[i] + 1)\n        return dp[amount] if dp[amount] != INF else -1",
    "explanation": "N/A",
    "time_complexity": "O(n * k), n is the number of coins, k is the amount of money",
    "space_complexity": "O(k)"
  },
  {
    "title": "Unique Paths",
    "difficulty": "MEDIUM",
    "category": "Math, Dynamic Programming, Combinatorics",
    "link": "https://leetcode.com/problems/unique-paths",
    "slug": "unique-paths",
    "description": "There is a robot on an \nm x n\n grid. The robot is initially located at the \ntop-left corner\n (i.e., \ngrid[0][0]\n). The robot tries to move to the \nbottom-right corner\n (i.e., \ngrid[m - 1][n - 1]\n). The robot can only move either down or right at any point in time.\n\n\nGiven the two integers \nm\n and \nn\n, return \nthe number of possible unique paths that the robot can take to reach the bottom-right corner\n.\n\n\nThe test cases are generated so that the answer will be less than or equal to \n2 * 10\n9\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 3, n = 7\n\nOutput:\n 28\n\n\n\nExample 2:\n\n\n\n\nInput:\n m = 3, n = 2\n\nOutput:\n 3\n\nExplanation:\n From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 100",
    "solution": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def nCr(n, r):  # Time: O(n), Space: O(1)\n            if n-r < r:\n                r = n-r\n            c = 1\n            for k in xrange(1, r+1):\n                c *= n-k+1\n                c //= k\n            return c\n\n        return nCr((m-1)+(n-1), n-1)\n\nclass Solution2(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if m < n:\n            m, n  = n, m\n\n        dp = [1]*n\n        for i in xrange(1, m):\n            for j in xrange(1, n):\n                dp[j] += dp[j-1]\n        return dp[n-1]",
    "explanation": "N/A",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(min(m, n))"
  },
  {
    "title": "LFU Cache",
    "difficulty": "HARD",
    "category": "Hash Table, Linked List, Design, Doubly-Linked List",
    "link": "https://leetcode.com/problems/lfu-cache",
    "slug": "lfu-cache",
    "description": "Design and implement a data structure for a \nLeast Frequently Used (LFU)\n cache.\n\n\nImplement the \nLFUCache\n class:\n\n\n\n\nLFUCache(int capacity)\n Initializes the object with the \ncapacity\n of the data structure.\n\n\nint get(int key)\n Gets the value of the \nkey\n if the \nkey\n exists in the cache. Otherwise, returns \n-1\n.\n\n\nvoid put(int key, int value)\n Update the value of the \nkey\n if present, or inserts the \nkey\n if not already present. When the cache reaches its \ncapacity\n, it should invalidate and remove the \nleast frequently used\n key before inserting a new item. For this problem, when there is a \ntie\n (i.e., two or more keys with the same frequency), the \nleast recently used\n \nkey\n would be invalidated.\n\n\n\n\nTo determine the least frequently used key, a \nuse counter\n is maintained for each key in the cache. The key with the smallest \nuse counter\n is the least frequently used key.\n\n\nWhen a key is first inserted into the cache, its \nuse counter\n is set to \n1\n (due to the \nput\n operation). The \nuse counter\n for a key in the cache is incremented either a \nget\n or \nput\n operation is called on it.\n\n\nThe functions \nget\n and \nput\n must each run in \nO(1)\n average time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\n\nOutput\n\n[null, null, null, 1, null, -1, 3, null, -1, 3, 4]\n\n\nExplanation\n\n// cnt(x) = the use counter for key x\n// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)\nLFUCache lfu = new LFUCache(2);\nlfu.put(1, 1);   // cache=[1,_], cnt(1)=1\nlfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1\nlfu.get(1);      // return 1\n                 // cache=[1,2], cnt(2)=1, cnt(1)=2\nlfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.\n                 // cache=[3,1], cnt(3)=1, cnt(1)=2\nlfu.get(2);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=[3,1], cnt(3)=2, cnt(1)=2\nlfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.\n                 // cache=[4,3], cnt(4)=1, cnt(3)=2\nlfu.get(1);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=[3,4], cnt(4)=1, cnt(3)=3\nlfu.get(4);      // return 4\n                 // cache=[4,3], cnt(4)=2, cnt(3)=3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= capacity <= 10\n4\n\n\n0 <= key <= 10\n5\n\n\n0 <= value <= 10\n9\n\n\nAt most \n2 * 10\n5\n calls will be made to \nget\n and \nput\n.",
    "solution": "\nimport collections\n\n\n# using OrderedDictclass LFUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.__capa = capacity\n        self.__size = 0\n        self.__min_freq = float(\"inf\")\n        self.__freq_to_nodes = collections.defaultdict(collections.OrderedDict)\n        self.__key_to_freq = {}\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.__key_to_freq:\n            return -1\n        value = self.__freq_to_nodes[self.__key_to_freq[key]][key]\n        self.__update(key, value)\n        return value\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: void\n        \"\"\"\n        if self.__capa <= 0:\n            return\n\n        if key not in self.__key_to_freq and self.__size == self.__capa:\n            del self.__key_to_freq[self.__freq_to_nodes[self.__min_freq].popitem(last=False)[0]]\n            if not self.__freq_to_nodes[self.__min_freq]:\n                del self.__freq_to_nodes[self.__min_freq]\n            self.__size -= 1\n        self.__update(key, value)\n        \n    def __update(self, key, value):\n        freq = 0\n        if key in self.__key_to_freq:\n            freq = self.__key_to_freq[key]\n            del self.__freq_to_nodes[freq][key]\n            if not self.__freq_to_nodes[freq]:\n                del self.__freq_to_nodes[freq]\n                if self.__min_freq == freq:\n                    self.__min_freq += 1\n            self.__size -= 1\n\n        freq += 1\n        self.__min_freq = min(self.__min_freq, freq)\n        self.__key_to_freq[key] = freq\n        self.__freq_to_nodes[freq][key] = value\n        self.__size += 1\n\n\nimport collections\n\nclass ListNode(object):\n    def __init__(self, key, value, freq):\n        self.key = key\n        self.val = value\n        self.freq = freq\n        self.next = None\n        self.prev = None\n\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def append(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\n\nclass LFUCache2(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.__capa = capacity\n        self.__size = 0\n        self.__min_freq = float(\"inf\")\n        self.__freq_to_nodes = collections.defaultdict(LinkedList)\n        self.__key_to_node = {}\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.__key_to_node:\n            return -1\n        value = self.__key_to_node[key].val\n        self.__update(key, value)\n        return value\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: void\n        \"\"\"\n        if self.__capa <= 0:\n            return\n\n        if key not in self.__key_to_node and self.__size == self.__capa:\n            del self.__key_to_node[self.__freq_to_nodes[self.__min_freq].head.key]\n            self.__freq_to_nodes[self.__min_freq].delete(self.__freq_to_nodes[self.__min_freq].head)\n            if not self.__freq_to_nodes[self.__min_freq].head:\n                del self.__freq_to_nodes[self.__min_freq]\n            self.__size -= 1\n        self.__update(key, value)\n        \n    def __update(self, key, value):\n        freq = 0\n        if key in self.__key_to_node:\n            old_node = self.__key_to_node[key]\n            freq = old_node.freq\n            self.__freq_to_nodes[freq].delete(old_node)\n            if not self.__freq_to_nodes[freq].head:\n                del self.__freq_to_nodes[freq]\n                if self.__min_freq == freq:\n                    self.__min_freq += 1\n            self.__size -= 1\n\n        freq += 1\n        self.__min_freq = min(self.__min_freq, freq)\n        self.__key_to_node[key] = ListNode(key, value, freq)\n        self.__freq_to_nodes[freq].append(self.__key_to_node[key])\n        self.__size += 1",
    "explanation": "N/A",
    "time_complexity": "O(1), per operation",
    "space_complexity": "O(k), k is the capacity of cache"
  },
  {
    "title": "Search in Rotated Sorted Array",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/search-in-rotated-sorted-array",
    "slug": "search-in-rotated-sorted-array",
    "description": "There is an integer array \nnums\n sorted in ascending order (with \ndistinct\n values).\n\n\nPrior to being passed to your function, \nnums\n is \npossibly rotated\n at an unknown pivot index \nk\n (\n1 <= k < nums.length\n) such that the resulting array is \n[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]\n (\n0-indexed\n). For example, \n[0,1,2,4,5,6,7]\n might be rotated at pivot index \n3\n and become \n[4,5,6,7,0,1,2]\n.\n\n\nGiven the array \nnums\n \nafter\n the possible rotation and an integer \ntarget\n, return \nthe index of \ntarget\n if it is in \nnums\n, or \n-1\n if it is not in \nnums\n.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [4,5,6,7,0,1,2], target = 0\n\nOutput:\n 4\n\nExample 2:\n\n\nInput:\n nums = [4,5,6,7,0,1,2], target = 3\n\nOutput:\n -1\n\nExample 3:\n\n\nInput:\n nums = [1], target = 0\n\nOutput:\n -1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 5000\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nAll values of \nnums\n are \nunique\n.\n\n\nnums\n is an ascending array that is possibly rotated.\n\n\n-10\n4\n <= target <= 10\n4",
    "solution": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) / 2\n\n            if nums[mid] == target:\n                return mid\n            elif (nums[mid] >= nums[left] and nums[left] <= target < nums[mid]) or \\\n                 (nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])):\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return -1",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Next Permutation",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers",
    "link": "https://leetcode.com/problems/next-permutation",
    "slug": "next-permutation",
    "description": "A \npermutation\n of an array of integers is an arrangement of its members into a sequence or linear order.\n\n\n\n\nFor example, for \narr = [1,2,3]\n, the following are all the permutations of \narr\n: \n[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]\n.\n\n\n\n\nThe \nnext permutation\n of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the \nnext permutation\n of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n\n\n\nFor example, the next permutation of \narr = [1,2,3]\n is \n[1,3,2]\n.\n\n\nSimilarly, the next permutation of \narr = [2,3,1]\n is \n[3,1,2]\n.\n\n\nWhile the next permutation of \narr = [3,2,1]\n is \n[1,2,3]\n because \n[3,2,1]\n does not have a lexicographical larger rearrangement.\n\n\n\n\nGiven an array of integers \nnums\n, \nfind the next permutation of\n \nnums\n.\n\n\nThe replacement must be \nin place\n and use only constant extra memory.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n [1,3,2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,1]\n\nOutput:\n [1,2,3]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,1,5]\n\nOutput:\n [1,5,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 100",
    "solution": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in reversed(xrange(len(nums)-1)):\n            if nums[i] < nums[i+1]:\n                k = i\n                break\n        else:\n            nums.reverse()\n            return\n\n        for i in reversed(xrange(k+1, len(nums))):\n            if nums[i] > nums[k]:\n                l = i\n                break\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]\n        \nclass Solution2(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in xrange(len(nums)-1):\n            if nums[i] < nums[i+1]:\n                k = i\n\n        if k == -1:\n            nums.reverse()\n            return\n\n        for i in xrange(k+1, len(nums)):\n            if nums[i] > nums[k]:\n                l = i\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Rotting Oranges",
    "difficulty": "MEDIUM",
    "category": "Array, Breadth-First Search, Matrix",
    "link": "https://leetcode.com/problems/rotting-oranges",
    "slug": "rotting-oranges",
    "description": "You are given an \nm x n\n \ngrid\n where each cell can have one of three values:\n\n\n\n\n0\n representing an empty cell,\n\n\n1\n representing a fresh orange, or\n\n\n2\n representing a rotten orange.\n\n\n\n\nEvery minute, any fresh orange that is \n4-directionally adjacent\n to a rotten orange becomes rotten.\n\n\nReturn \nthe minimum number of minutes that must elapse until no cell has a fresh orange\n. If \nthis is impossible, return\n \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[2,1,1],[1,1,0],[0,1,1]]\n\nOutput:\n 4\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[2,1,1],[0,1,1],[1,0,1]]\n\nOutput:\n -1\n\nExplanation:\n The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[0,2]]\n\nOutput:\n 0\n\nExplanation:\n Since there are already no fresh oranges at minute 0, the answer is just 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 10\n\n\ngrid[i][j]\n is \n0\n, \n1\n, or \n2\n.",
    "solution": "\nimport collections\n\nclass Solution(object):\n    def orangesRotting(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        count = 0\n        q = collections.deque()\n        for r, row in enumerate(grid):\n            for c, val in enumerate(row):\n                if val == 2:\n                    q.append((r, c, 0))\n                elif val == 1:\n                    count += 1\n\n        result = 0\n        while q:\n            r, c, result = q.popleft()\n            for d in directions:\n                nr, nc = r+d[0], c+d[1]\n                if not (0 <= nr < len(grid) and \\\n                        0 <= nc < len(grid[r])):\n                    continue\n                if grid[nr][nc] == 1:\n                    count -= 1\n                    grid[nr][nc] = 2\n                    q.append((nr, nc, result+1))\n        return result if count == 0 else -1",
    "explanation": "N/A",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m * n)"
  },
  {
    "title": "Insert Delete GetRandom O(1)",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Math, Design, Randomized",
    "link": "https://leetcode.com/problems/insert-delete-getrandom-o1",
    "slug": "insert-delete-getrandom-o1",
    "description": "Implement the \nRandomizedSet\n class:\n\n\n\n\nRandomizedSet()\n Initializes the \nRandomizedSet\n object.\n\n\nbool insert(int val)\n Inserts an item \nval\n into the set if not present. Returns \ntrue\n if the item was not present, \nfalse\n otherwise.\n\n\nbool remove(int val)\n Removes an item \nval\n from the set if present. Returns \ntrue\n if the item was present, \nfalse\n otherwise.\n\n\nint getRandom()\n Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the \nsame probability\n of being returned.\n\n\n\n\nYou must implement the functions of the class such that each function works in \naverage\n \nO(1)\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], [], [1], [2], []]\n\nOutput\n\n[null, true, false, true, 2, true, false, 2]\n\n\nExplanation\n\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= val <= 2\n31\n - 1\n\n\nAt most \n2 * \n10\n5\n calls will be made to \ninsert\n, \nremove\n, and \ngetRandom\n.\n\n\nThere will be \nat least one\n element in the data structure when \ngetRandom\n is called.",
    "solution": "\nfrom random import randint\nclass RandomizedSet(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__set = []\n        self.__used = {}\n\n\n    def insert(self, val):\n        \"\"\"\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        if val in self.__used:\n            return False\n\n        self.__set += val,\n        self.__used[val] = len(self.__set)-1\n\n        return True\n\n\n    def remove(self, val):\n        \"\"\"\n        Removes a value from the set. Returns true if the set contained the specified element.\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        if val not in self.__used:\n            return False\n\n        self.__used[self.__set[-1]] = self.__used[val]\n        self.__set[self.__used[val]], self.__set[-1] = self.__set[-1], self.__set[self.__used[val]]\n\n        self.__used.pop(val)\n        self.__set.pop()\n\n        return True\n\n    def getRandom(self):\n        \"\"\"\n        Get a random element from the set.\n        :rtype: int\n        \"\"\"\n        return self.__set[randint(0, len(self.__set)-1)]",
    "explanation": "N/A",
    "time_complexity": "O(1)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Flood Fill",
    "difficulty": "EASY",
    "category": "Array, Depth-First Search, Breadth-First Search, Matrix",
    "link": "https://leetcode.com/problems/flood-fill",
    "slug": "flood-fill",
    "description": "You are given an image represented by an \nm x n\n grid of integers \nimage\n, where \nimage[i][j]\n represents the pixel value of the image. You are also given three integers \nsr\n, \nsc\n, and \ncolor\n. Your task is to perform a \nflood fill\n on the image starting from the pixel \nimage[sr][sc]\n.\n\n\nTo perform a \nflood fill\n:\n\n\n\n\nBegin with the starting pixel and change its color to \ncolor\n.\n\n\nPerform the same process for each pixel that is \ndirectly adjacent\n (pixels that share a side with the original pixel, either horizontally or vertically) and shares the \nsame color\n as the starting pixel.\n\n\nKeep \nrepeating\n this process by checking neighboring pixels of the \nupdated\n pixels and modifying their color if it matches the original color of the starting pixel.\n\n\nThe process \nstops\n when there are \nno more\n adjacent pixels of the original color to update.\n\n\n\n\nReturn the \nmodified\n image after performing the flood fill.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nimage = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\n\n\nOutput:\n \n[[2,2,2],[2,2,0],[2,0,1]]\n\n\nExplanation:\n\n\n\n\nFrom the center of the image with position \n(sr, sc) = (1, 1)\n (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\n\n\nNote the bottom corner is \nnot\n colored 2, because it is not horizontally or vertically connected to the starting pixel.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nimage = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0\n\n\nOutput:\n \n[[0,0,0],[0,0,0]]\n\n\nExplanation:\n\n\nThe starting pixel is already colored with 0, which is the same as the target color. Therefore, no changes are made to the image.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == image.length\n\n\nn == image[i].length\n\n\n1 <= m, n <= 50\n\n\n0 <= image[i][j], color < 2\n16\n\n\n0 <= sr < m\n\n\n0 <= sc < n",
    "solution": "class Solution(object):\n    def floodFill(self, image, sr, sc, newColor):\n        \"\"\"\n        :type image: List[List[int]]\n        :type sr: int\n        :type sc: int\n        :type newColor: int\n        :rtype: List[List[int]]\n        \"\"\"\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n        def dfs(image, r, c, newColor, color):\n            if not (0 <= r < len(image) and \\\n                    0 <= c < len(image[0]) and \\\n                    image[r][c] == color):\n                return\n\n            image[r][c] = newColor\n            for d in directions:\n                dfs(image, r+d[0], c+d[1], newColor, color)\n\n        color = image[sr][sc]\n        if color == newColor: return image\n        dfs(image, sr, sc, newColor, color)\n        return image",
    "explanation": "N/A",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m * n)"
  },
  {
    "title": "Fizz Buzz",
    "difficulty": "EASY",
    "category": "Math, String, Simulation",
    "link": "https://leetcode.com/problems/fizz-buzz",
    "slug": "fizz-buzz",
    "description": "Given an integer \nn\n, return \na string array \nanswer\n (\n1-indexed\n) where\n:\n\n\n\n\nanswer[i] == \"FizzBuzz\"\n if \ni\n is divisible by \n3\n and \n5\n.\n\n\nanswer[i] == \"Fizz\"\n if \ni\n is divisible by \n3\n.\n\n\nanswer[i] == \"Buzz\"\n if \ni\n is divisible by \n5\n.\n\n\nanswer[i] == i\n (as a string) if none of the above conditions are true.\n\n\n\n\n \n\n\nExample 1:\n\n\nInput:\n n = 3\n\nOutput:\n [\"1\",\"2\",\"Fizz\"]\n\nExample 2:\n\n\nInput:\n n = 5\n\nOutput:\n [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]\n\nExample 3:\n\n\nInput:\n n = 15\n\nOutput:\n [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n4",
    "solution": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result = []\n\n        for i in xrange(1, n+1):\n            if i % 15 == 0:\n                result.append(\"FizzBuzz\")\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            else:\n                result.append(str(i))\n\n        return result\n\n    def fizzBuzz2(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        l = [str(x) for x in range(n + 1)]\n        l3 = range(0, n + 1, 3)\n        l5 = range(0, n + 1, 5)\n        for i in l3:\n            l[i] = 'Fizz'\n        for i in l5:\n            if l[i] == 'Fizz':\n                l[i] += 'Buzz'\n            else:\n                l[i] = 'Buzz'\n        return l[1:]\n\n    def fizzBuzz3(self, n):\n        return ['Fizz' * (not i % 3) + 'Buzz' * (not i % 5) or str(i) for i in range(1, n + 1)]\n\n    def fizzBuzz4(self, n):\n        return ['FizzBuzz'[i % -3 & -4:i % -5 & 8 ^ 12] or repr(i) for i in range(1, n + 1)]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Top K Frequent Words",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, String, Trie, Sorting, Heap (Priority Queue), Bucket Sort, Counting",
    "link": "https://leetcode.com/problems/top-k-frequent-words",
    "slug": "top-k-frequent-words",
    "description": "Given an array of strings \nwords\n and an integer \nk\n, return \nthe \nk\n most frequent strings\n.\n\n\nReturn the answer \nsorted\n by \nthe frequency\n from highest to lowest. Sort the words with the same frequency by their \nlexicographical order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2\n\nOutput:\n [\"i\",\"love\"]\n\nExplanation:\n \"i\" and \"love\" are the two most frequent words.\nNote that \"i\" comes before \"love\" due to a lower alphabetical order.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4\n\nOutput:\n [\"the\",\"is\",\"sunny\",\"day\"]\n\nExplanation:\n \"the\", \"is\", \"sunny\" and \"day\" are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 500\n\n\n1 <= words[i].length <= 10\n\n\nwords[i]\n consists of lowercase English letters.\n\n\nk\n is in the range \n[1, The number of \nunique\n words[i]]\n\n\n\n\n \n\n\nFollow-up:\n Could you solve it in \nO(n log(k))\n time and \nO(n)\n extra space?",
    "solution": "\nimport collections\nimport heapq\nfrom random import randint\n\nclass Solution(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counts = collections.Counter(words)\n        p = []\n        for key, val in counts.iteritems():\n            p.append((-val, key))\n        self.kthElement(p, k-1)\n\n        result = []\n        sorted_p = sorted(p[:k])\n        for i in xrange(k):\n            result.append(sorted_p[i][1])\n        return result\n\n    def kthElement(self, nums, k):  # O(n) on average\n        def PartitionAroundPivot(left, right, pivot_idx, nums):\n            pivot_value = nums[pivot_idx]\n            new_pivot_idx = left\n            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n            for i in xrange(left, right):\n                if nums[i] < pivot_value:\n                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                    new_pivot_idx += 1\n\n            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n            return new_pivot_idx\n\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k:\n                return\n            elif new_pivot_idx > k:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k.\n                left = new_pivot_idx + 1\n\n\n# Heap Solutionclass Solution2(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        class MinHeapObj(object):\n            def __init__(self,val):\n                self.val = val\n            def __lt__(self,other):\n                return self.val[1] > other.val[1] if self.val[0] == other.val[0] else \\\n                       self.val < other.val\n            def __eq__(self,other):\n                return self.val == other.val\n            def __str__(self):\n                return str(self.val)\n\n        counts = collections.Counter(words)\n        min_heap = []\n        for word, count in counts.iteritems():\n            heapq.heappush(min_heap, MinHeapObj((count, word)))\n            if len(min_heap) == k+1:\n                heapq.heappop(min_heap)\n        result = []\n        while min_heap:\n            result.append(heapq.heappop(min_heap).val[1])\n        return result[::-1]\n\n\n# Bucket Sort Solutionclass Solution3(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counts = collections.Counter(words)\n        buckets = [[] for _ in xrange(len(words)+1)]\n        for word, count in counts.iteritems():\n            buckets[count].append(word)\n        pairs = []\n        for i in reversed(xrange(len(words))):\n            for word in buckets[i]:\n                pairs.append((-i, word))\n            if len(pairs) >= k:\n                break\n        pairs.sort()\n        return [pair[1] for pair in pairs[:k]]\n\n\n# time: O(nlogn)\n# space: O(n)\n\nfrom collections import Counter\n\nclass Solution4(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counter = Counter(words)\n        candidates = counter.keys()\n        candidates.sort(key=lambda w: (-counter[w], w))\n        return candidates[:k]",
    "explanation": "N/A",
    "time_complexity": "O(n + klogk) ~ O(n + nlogn)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Integer to Roman",
    "difficulty": "MEDIUM",
    "category": "Hash Table, Math, String",
    "link": "https://leetcode.com/problems/integer-to-roman",
    "slug": "integer-to-roman",
    "description": "Seven different symbols represent Roman numerals with the following values:\n\n\n\n\n\n\n\n\nSymbol\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nI\n\n\n1\n\n\n\n\n\n\nV\n\n\n5\n\n\n\n\n\n\nX\n\n\n10\n\n\n\n\n\n\nL\n\n\n50\n\n\n\n\n\n\nC\n\n\n100\n\n\n\n\n\n\nD\n\n\n500\n\n\n\n\n\n\nM\n\n\n1000\n\n\n\n\n\n\n\n\nRoman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\n\n\n\n\nIf the value does not start with 4 or 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.\n\n\nIf the value starts with 4 or 9 use the \nsubtractive form\n representing one symbol subtracted from the following symbol, for example, 4 is 1 (\nI\n) less than 5 (\nV\n): \nIV\n and 9 is 1 (\nI\n) less than 10 (\nX\n): \nIX\n. Only the following subtractive forms are used: 4 (\nIV\n), 9 (\nIX\n), 40 (\nXL\n), 90 (\nXC\n), 400 (\nCD\n) and 900 (\nCM\n).\n\n\nOnly powers of 10 (\nI\n, \nX\n, \nC\n, \nM\n) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5 (\nV\n), 50 (\nL\n), or 500 (\nD\n) multiple times. If you need to append a symbol 4 times use the \nsubtractive form\n.\n\n\n\n\nGiven an integer, convert it to a Roman numeral.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnum = 3749\n\n\nOutput:\n \n\"MMMDCCXLIX\"\n\n\nExplanation:\n\n\n\n3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC as 500 (D) + 100 (C) + 100 (C)\n  40 = XL as 10 (X) less of 50 (L)\n   9 = IX as 1 (I) less of 10 (X)\nNote: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnum = 58\n\n\nOutput:\n \n\"LVIII\"\n\n\nExplanation:\n\n\n\n50 = L\n 8 = VIII\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnum = 1994\n\n\nOutput:\n \n\"MCMXCIV\"\n\n\nExplanation:\n\n\n\n1000 = M\n 900 = CM\n  90 = XC\n   4 = IV\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num <= 3999",
    "solution": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        numeral_map = {1: \"I\", 4: \"IV\", 5: \"V\", 9: \"IX\", \\\n                       10: \"X\", 40: \"XL\", 50: \"L\", 90: \"XC\", \\\n                       100: \"C\", 400: \"CD\", 500: \"D\", 900: \"CM\", \\\n                       1000: \"M\"}\n        keyset, result = sorted(numeral_map.keys()), []\n\n        while num > 0:\n            for key in reversed(keyset):\n                while num / key > 0:\n                    num -= key\n                    result += numeral_map[key]\n\n        return \"\".join(result)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Invert Binary Tree",
    "difficulty": "EASY",
    "category": "Tree, Depth-First Search, Breadth-First Search, Binary Tree",
    "link": "https://leetcode.com/problems/invert-binary-tree",
    "slug": "invert-binary-tree",
    "description": "Given the \nroot\n of a binary tree, invert the tree, and return \nits root\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,2,7,1,3,6,9]\n\nOutput:\n [4,7,2,9,6,3,1]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [2,1,3]\n\nOutput:\n [2,3,1]\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100",
    "solution": "\nimport collections\n\n\n# BFS solution.class Queue(object):\n    def __init__(self):\n        self.data = collections.deque()\n\n    def push(self, x):\n        self.data.append(x)\n\n    def peek(self):\n        return self.data[0]\n\n    def pop(self):\n        return self.data.popleft()\n\n    def size(self):\n        return len(self.data)\n\n    def empty(self):\n        return len(self.data) == 0\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\nclass Solution(object):\n    # @param {TreeNode} root\n    # @return {TreeNode}\n    def invertTree(self, root):\n        if root is not None:\n            nodes = Queue()\n            nodes.push(root)\n            while not nodes.empty():\n                node = nodes.pop()\n                node.left, node.right = node.right, node.left\n                if node.left is not None:\n                    nodes.push(node.left)\n                if node.right is not None:\n                    nodes.push(node.right)\n\n        return root\n\n# Stack solution.class Solution2(object):\n    # @param {TreeNode} root\n    # @return {TreeNode}\n    def invertTree(self, root):\n        if root is not None:\n            nodes = []\n            nodes.append(root)\n            while nodes:\n                node = nodes.pop()\n                node.left, node.right = node.right, node.left\n                if node.left is not None:\n                    nodes.append(node.left)\n                if node.right is not None:\n                    nodes.append(node.right)\n\n        return root\n\n# DFS, Recursive solution.class Solution3(object):\n    # @param {TreeNode} root\n    # @return {TreeNode}\n    def invertTree(self, root):\n        if root is not None:\n            root.left, root.right = self.invertTree(root.right), \\\n                                    self.invertTree(root.left)\n\n        return root",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(h)"
  },
  {
    "title": "Move Zeroes",
    "difficulty": "EASY",
    "category": "Array, Two Pointers",
    "link": "https://leetcode.com/problems/move-zeroes",
    "slug": "move-zeroes",
    "description": "Given an integer array \nnums\n, move all \n0\n's to the end of it while maintaining the relative order of the non-zero elements.\n\n\nNote\n that you must do this in-place without making a copy of the array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [0,1,0,3,12]\n\nOutput:\n [1,3,12,0,0]\n\nExample 2:\n\n\nInput:\n nums = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you minimize the total number of operations done?",
    "solution": "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i]:\n                nums[i], nums[pos] = nums[pos], nums[i]\n                pos += 1\n\n    def moveZeroes2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort(cmp=lambda a, b: 0 if b else -1)\n\nclass Solution2(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i]:\n                nums[pos] = nums[i]\n                pos += 1\n\n        for i in xrange(pos, len(nums)):\n            nums[i] = 0",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Basic Calculator",
    "difficulty": "HARD",
    "category": "Math, String, Stack, Recursion",
    "link": "https://leetcode.com/problems/basic-calculator",
    "slug": "basic-calculator",
    "description": "Given a string \ns\n representing a valid expression, implement a basic calculator to evaluate it, and return \nthe result of the evaluation\n.\n\n\nNote:\n You are \nnot\n allowed to use any built-in function which evaluates strings as mathematical expressions, such as \neval()\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"1 + 1\"\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \" 2-1 + 2 \"\n\nOutput:\n 3\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"(1+(4+5+2)-3)+(6+8)\"\n\nOutput:\n 23\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 3 * 10\n5\n\n\ns\n consists of digits, \n'+'\n, \n'-'\n, \n'('\n, \n')'\n, and \n' '\n.\n\n\ns\n represents a valid expression.\n\n\n'+'\n is \nnot\n used as a unary operation (i.e., \n\"+1\"\n and \n\"+(2 + 3)\"\n is invalid).\n\n\n'-'\n could be used as a unary operation (i.e., \n\"-1\"\n and \n\"-(2 + 3)\"\n is valid).\n\n\nThere will be no two consecutive operators in the input.\n\n\nEvery number and running calculation will fit in a signed 32-bit integer.",
    "solution": "\nimport operator\n\nclass Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def compute(operands, operators):\n            right, left = operands.pop(), operands.pop()\n            operands.append(ops[operators.pop()](left, right))\n\n        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}\n        precedence = {'+':0, '-':0, '*':1, '/':1}\n        operands, operators, operand = [], [], 0\n        for i in xrange(len(s)):\n            if s[i].isdigit():\n                operand = operand*10 + int(s[i])\n                if i == len(s)-1 or not s[i+1].isdigit():\n                    operands.append(operand)\n                    operand = 0\n            elif s[i] == '(':\n                operators.append(s[i])\n            elif s[i] == ')':\n                while operators[-1] != '(':\n                    compute(operands, operators)\n                operators.pop()\n            elif s[i] in precedence:\n                while operators and operators[-1] in precedence and \\\n                      precedence[operators[-1]] >= precedence[s[i]]:\n                    compute(operands, operators)\n                operators.append(s[i])\n        while operators:\n            compute(operands, operators)\n        return operands[-1]\n\nclass Solution2(object):\n    # @param {string} s\n    # @return {integer}\n    def calculate(self, s):\n        operands, operators = [], []\n        operand = \"\"\n        for i in reversed(xrange(len(s))):\n            if s[i].isdigit():\n                operand += s[i]\n                if i == 0 or not s[i-1].isdigit():\n                    operands.append(int(operand[::-1]))\n                    operand = \"\"\n            elif s[i] == ')' or s[i] == '+' or s[i] == '-':\n                operators.append(s[i])\n            elif s[i] == '(':\n                while operators[-1] != ')':\n                    self.compute(operands, operators)\n                operators.pop()\n\n        while operators:\n            self.compute(operands, operators)\n\n        return operands[-1]\n\n    def compute(self, operands, operators):\n        left, right = operands.pop(), operands.pop()\n        op = operators.pop()\n        if op == '+':\n            operands.append(left + right)\n        elif op == '-':\n            operands.append(left - right)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Find All Possible Recipes from Given Supplies",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, String, Graph, Topological Sort",
    "link": "https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies",
    "slug": "find-all-possible-recipes-from-given-supplies",
    "description": "You have information about \nn\n different recipes. You are given a string array \nrecipes\n and a 2D string array \ningredients\n. The \ni\nth\n recipe has the name \nrecipes[i]\n, and you can \ncreate\n it if you have \nall\n the needed ingredients from \ningredients[i]\n. A recipe can also be an ingredient for \nother \nrecipes, i.e., \ningredients[i]\n may contain a string that is in \nrecipes\n.\n\n\nYou are also given a string array \nsupplies\n containing all the ingredients that you initially have, and you have an infinite supply of all of them.\n\n\nReturn \na list of all the recipes that you can create. \nYou may return the answer in \nany order\n.\n\n\nNote that two recipes may contain each other in their ingredients.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\n\nOutput:\n [\"bread\"]\n\nExplanation:\n\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\n\nOutput:\n [\"bread\",\"sandwich\"]\n\nExplanation:\n\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\n\nOutput:\n [\"bread\",\"sandwich\",\"burger\"]\n\nExplanation:\n\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == recipes.length == ingredients.length\n\n\n1 <= n <= 100\n\n\n1 <= ingredients[i].length, supplies.length <= 100\n\n\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\n\n\nrecipes[i], ingredients[i][j]\n, and \nsupplies[k]\n consist only of lowercase English letters.\n\n\nAll the values of \nrecipes\n and \nsupplies\n combined are unique.\n\n\nEach \ningredients[i]\n does not contain any duplicate values.",
    "solution": "\nimport collections\nimport itertools\nclass Solution(object):\n    def findAllRecipes(self, recipes, ingredients, supplies):\n        \"\"\"\n        :type recipes: List[str]\n        :type ingredients: List[List[str]]\n        :type supplies: List[str]\n        :rtype: List[str]\n        \"\"\"\n        indegree = collections.defaultdict(int)\n        adj = collections.defaultdict(list)\n        for r, ingredient in itertools.izip(recipes, ingredients): \n            indegree[r] = len(ingredient)\n            for ing in ingredient:\n                adj[ing].append(r)\n        result = []\n        recipes = set(recipes)\n        q = supplies\n        while q: \n            new_q = []\n            for u in q:\n                if u in recipes:\n                    result.append(u)\n                for v in adj[u]:\n                    indegree[v] -= 1\n                    if not indegree[v]:\n                        new_q.append(v)\n            q = new_q\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(|E|)",
    "space_complexity": "O(|E|)"
  },
  {
    "title": "String to Integer (atoi)",
    "difficulty": "MEDIUM",
    "category": "String",
    "link": "https://leetcode.com/problems/string-to-integer-atoi",
    "slug": "string-to-integer-atoi",
    "description": "Implement the \nmyAtoi(string s)\n function, which converts a string to a 32-bit signed integer.\n\n\nThe algorithm for \nmyAtoi(string s)\n is as follows:\n\n\n\n\nWhitespace\n: Ignore any leading whitespace (\n\" \"\n).\n\n\nSignedness\n: Determine the sign by checking if the next character is \n'-'\n or \n'+'\n, assuming positivity if neither present.\n\n\nConversion\n: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.\n\n\nRounding\n: If the integer is out of the 32-bit signed integer range \n[-2\n31\n, 2\n31\n - 1]\n, then round the integer to remain in the range. Specifically, integers less than \n-2\n31\n should be rounded to \n-2\n31\n, and integers greater than \n2\n31\n - 1\n should be rounded to \n2\n31\n - 1\n.\n\n\n\n\nReturn the integer as the final result.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"42\"\n\n\nOutput:\n \n42\n\n\nExplanation:\n\n\n\nThe underlined characters are what is read in and the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n42\n\" (\"42\" is read in)\n           ^\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \" -042\"\n\n\nOutput:\n \n-42\n\n\nExplanation:\n\n\n\nStep 1: \"\n   \n-042\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   \n-\n042\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -\n042\n\" (\"042\" is read in, leading zeros ignored in the result)\n               ^\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"1337c0d3\"\n\n\nOutput:\n \n1337\n\n\nExplanation:\n\n\n\nStep 1: \"1337c0d3\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"1337c0d3\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n1337\nc0d3\" (\"1337\" is read in; reading stops because the next character is a non-digit)\n             ^\n\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"0-1\"\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\nStep 1: \"0-1\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"0-1\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n0\n-1\" (\"0\" is read in; reading stops because the next character is a non-digit)\n          ^\n\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"words and 987\"\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nReading stops at the first non-digit character 'w'.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 200\n\n\ns\n consists of English letters (lower-case and upper-case), digits (\n0-9\n), \n' '\n, \n'+'\n, \n'-'\n, and \n'.'\n.",
    "solution": "class Solution(object):\n    def myAtoi(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: int\n        \"\"\"\n        INT_MAX =  2147483647\n        INT_MIN = -2147483648\n        result = 0\n\n        if not str:\n            return result\n\n        i = 0\n        while i < len(str) and str[i].isspace():\n            i += 1\n\n        if len(str) == i:\n            return result\n\n        sign = 1\n        if str[i] == \"+\":\n            i += 1\n        elif str[i] == \"-\":\n            sign = -1\n            i += 1\n\n        while i < len(str) and '0' <= str[i] <= '9':\n            if result > (INT_MAX - int(str[i])) / 10:\n                return INT_MAX if sign > 0 else INT_MIN\n            result = result * 10 + int(str[i])\n            i += 1\n\n        return sign * result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Capacity To Ship Packages Within D Days",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/capacity-to-ship-packages-within-d-days",
    "slug": "capacity-to-ship-packages-within-d-days",
    "description": "A conveyor belt has packages that must be shipped from one port to another within \ndays\n days.\n\n\nThe \ni\nth\n package on the conveyor belt has a weight of \nweights[i]\n. Each day, we load the ship with packages on the conveyor belt (in the order given by \nweights\n). We may not load more weight than the maximum weight capacity of the ship.\n\n\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within \ndays\n days.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n weights = [1,2,3,4,5,6,7,8,9,10], days = 5\n\nOutput:\n 15\n\nExplanation:\n A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\n1st day: 1, 2, 3, 4, 5\n2nd day: 6, 7\n3rd day: 8\n4th day: 9\n5th day: 10\n\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.\n\n\n\nExample 2:\n\n\n\n\nInput:\n weights = [3,2,2,4,1,4], days = 3\n\nOutput:\n 6\n\nExplanation:\n A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:\n1st day: 3, 2\n2nd day: 2, 4\n3rd day: 1, 4\n\n\n\nExample 3:\n\n\n\n\nInput:\n weights = [1,2,3,1,1], days = 4\n\nOutput:\n 3\n\nExplanation:\n\n1st day: 1\n2nd day: 2\n3rd day: 3\n4th day: 1, 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= days <= weights.length <= 5 * 10\n4\n\n\n1 <= weights[i] <= 500",
    "solution": "class Solution(object):\n    def shipWithinDays(self, weights, D):\n        \"\"\"\n        :type weights: List[int]\n        :type D: int\n        :rtype: int\n        \"\"\"\n        def possible(weights, D, mid):\n            result, curr = 1, 0\n            for w in weights:\n                if curr+w > mid:\n                    result += 1\n                    curr = 0\n                curr += w\n            return result <= D\n    \n        left, right = max(weights), sum(weights)\n        while left <= right:\n            mid = left + (right-left)//2\n            if possible(weights, D, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left",
    "explanation": "N/A",
    "time_complexity": "O(nlogr)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Roman to Integer",
    "difficulty": "EASY",
    "category": "Hash Table, Math, String",
    "link": "https://leetcode.com/problems/roman-to-integer",
    "slug": "roman-to-integer",
    "description": "Roman numerals are represented by seven different symbols: \nI\n, \nV\n, \nX\n, \nL\n, \nC\n, \nD\n and \nM\n.\n\n\n\n\nSymbol\n       \nValue\n\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\n\nFor example, \n2\n is written as \nII\n in Roman numeral, just two ones added together. \n12\n is written as \nXII\n, which is simply \nX + II\n. The number \n27\n is written as \nXXVII\n, which is \nXX + V + II\n.\n\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not \nIIII\n. Instead, the number four is written as \nIV\n. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as \nIX\n. There are six instances where subtraction is used:\n\n\n\n\nI\n can be placed before \nV\n (5) and \nX\n (10) to make 4 and 9. \n\n\nX\n can be placed before \nL\n (50) and \nC\n (100) to make 40 and 90. \n\n\nC\n can be placed before \nD\n (500) and \nM\n (1000) to make 400 and 900.\n\n\n\n\nGiven a roman numeral, convert it to an integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"III\"\n\nOutput:\n 3\n\nExplanation:\n III = 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"LVIII\"\n\nOutput:\n 58\n\nExplanation:\n L = 50, V= 5, III = 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"MCMXCIV\"\n\nOutput:\n 1994\n\nExplanation:\n M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 15\n\n\ns\n contains only the characters \n('I', 'V', 'X', 'L', 'C', 'D', 'M')\n.\n\n\nIt is \nguaranteed\n that \ns\n is a valid roman numeral in the range \n[1, 3999]\n.",
    "solution": "class Solution(object):\n    # @return an integer\n    def romanToInt(self, s):\n        numeral_map = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\":100, \"D\": 500, \"M\": 1000}\n        decimal = 0\n        for i in xrange(len(s)):\n            if i > 0 and numeral_map[s[i]] > numeral_map[s[i - 1]]:\n                decimal += numeral_map[s[i]] - 2 * numeral_map[s[i - 1]]\n            else:\n                decimal += numeral_map[s[i]]\n        return decimal",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Palindrome Number",
    "difficulty": "EASY",
    "category": "Math",
    "link": "https://leetcode.com/problems/palindrome-number",
    "slug": "palindrome-number",
    "description": "Given an integer \nx\n, return \ntrue\n if \nx\n is a \npalindrome\n, and \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 121\n\nOutput:\n true\n\nExplanation:\n 121 reads as 121 from left to right and from right to left.\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = -121\n\nOutput:\n false\n\nExplanation:\n From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n\n\nExample 3:\n\n\n\n\nInput:\n x = 10\n\nOutput:\n false\n\nExplanation:\n Reads 01 from right to left. Therefore it is not a palindrome.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= x <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you solve it without converting the integer to a string?",
    "solution": "class Solution(object):\n    # @return a boolean\n    def isPalindrome(self, x):\n        if x < 0:\n            return False\n        copy, reverse = x, 0\n\n        while copy:\n            reverse *= 10\n            reverse += copy % 10\n            copy //= 10\n\n        return x == reverse",
    "explanation": "N/A",
    "time_complexity": "O(1)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Maximum Subarray",
    "difficulty": "MEDIUM",
    "category": "Array, Divide and Conquer, Dynamic Programming",
    "link": "https://leetcode.com/problems/maximum-subarray",
    "slug": "maximum-subarray",
    "description": "Given an integer array \nnums\n, find the \nsubarray\n with the largest sum, and return \nits sum\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-2,1,-3,4,-1,2,1,-5,4]\n\nOutput:\n 6\n\nExplanation:\n The subarray [4,-1,2,1] has the largest sum 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1]\n\nOutput:\n 1\n\nExplanation:\n The subarray [1] has the largest sum 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [5,4,-1,7,8]\n\nOutput:\n 23\n\nExplanation:\n The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n If you have figured out the \nO(n)\n solution, try coding another solution using the \ndivide and conquer\n approach, which is more subtle.",
    "solution": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, curr = float(\"-inf\"), float(\"-inf\")\n        for x in nums:\n            curr = max(curr+x, x)\n            result = max(result, curr)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Word Search",
    "difficulty": "MEDIUM",
    "category": "Array, String, Backtracking, Depth-First Search, Matrix",
    "link": "https://leetcode.com/problems/word-search",
    "slug": "word-search",
    "description": "Given an \nm x n\n grid of characters \nboard\n and a string \nword\n, return \ntrue\n \nif\n \nword\n \nexists in the grid\n.\n\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == board.length\n\n\nn = board[i].length\n\n\n1 <= m, n <= 6\n\n\n1 <= word.length <= 15\n\n\nboard\n and \nword\n consists of only lowercase and uppercase English letters.\n\n\n\n\n \n\n\nFollow up:\n Could you use search pruning to make your solution faster with a larger \nboard\n?",
    "solution": "class Solution(object):\n    # @param board, a list of lists of 1 length string\n    # @param word, a string\n    # @return a boolean\n    def exist(self, board, word):\n        visited = [[False for j in xrange(len(board[0]))] for i in xrange(len(board))]\n\n        for i in xrange(len(board)):\n            for j in xrange(len(board[0])):\n                if self.existRecu(board, word, 0, i, j, visited):\n                    return True\n\n        return False\n\n    def existRecu(self, board, word, cur, i, j, visited):\n        if cur == len(word):\n            return True\n\n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[cur]:\n            return False\n\n        visited[i][j] = True\n        result = self.existRecu(board, word, cur + 1, i + 1, j, visited) or\\\n                 self.existRecu(board, word, cur + 1, i - 1, j, visited) or\\\n                 self.existRecu(board, word, cur + 1, i, j + 1, visited) or\\\n                 self.existRecu(board, word, cur + 1, i, j - 1, visited)\n        visited[i][j] = False\n\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(m * n * 4 * 3^(l - 1)) ~= O(m * n * 3^l), l is the length of the word",
    "space_complexity": "O(l)"
  },
  {
    "title": "Edit Distance",
    "difficulty": "MEDIUM",
    "category": "String, Dynamic Programming",
    "link": "https://leetcode.com/problems/edit-distance",
    "slug": "edit-distance",
    "description": "Given two strings \nword1\n and \nword2\n, return \nthe minimum number of operations required to convert \nword1\n to \nword2\n.\n\n\nYou have the following three operations permitted on a word:\n\n\n\n\nInsert a character\n\n\nDelete a character\n\n\nReplace a character\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n word1 = \"horse\", word2 = \"ros\"\n\nOutput:\n 3\n\nExplanation:\n \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n\n\n\nExample 2:\n\n\n\n\nInput:\n word1 = \"intention\", word2 = \"execution\"\n\nOutput:\n 5\n\nExplanation:\n \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= word1.length, word2.length <= 500\n\n\nword1\n and \nword2\n consist of lowercase English letters.",
    "solution": "class Solution(object):\n    # @return an integer\n    def minDistance(self, word1, word2):\n        if len(word1) < len(word2):\n            return self.minDistance(word2, word1)\n\n        distance = [i for i in xrange(len(word2) + 1)]\n\n        for i in xrange(1, len(word1) + 1):\n            pre_distance_i_j = distance[0]\n            distance[0] = i\n            for j in xrange(1, len(word2) + 1):\n                insert = distance[j - 1] + 1\n                delete = distance[j] + 1\n                replace = pre_distance_i_j\n                if word1[i - 1] != word2[j - 1]:\n                    replace += 1\n                pre_distance_i_j = distance[j]\n                distance[j] = min(insert, delete, replace)\n\n        return distance[-1]\nclass Solution2(object):\n    # @return an integer\n    def minDistance(self, word1, word2):\n        distance = [[i] for i in xrange(len(word1) + 1)]\n        distance[0] = [j for j in xrange(len(word2) + 1)]\n\n        for i in xrange(1, len(word1) + 1):\n            for j in xrange(1, len(word2) + 1):\n                insert = distance[i][j - 1] + 1\n                delete = distance[i - 1][j] + 1\n                replace = distance[i - 1][j - 1]\n                if word1[i - 1] != word2[j - 1]:\n                    replace += 1\n                distance[i].append(min(insert, delete, replace))\n\n        return distance[-1][-1]",
    "explanation": "N/A",
    "time_complexity": "O(n * m)",
    "space_complexity": "O(n * m)"
  },
  {
    "title": "Kth Largest Element in an Array",
    "difficulty": "MEDIUM",
    "category": "Array, Divide and Conquer, Sorting, Heap (Priority Queue), Quickselect",
    "link": "https://leetcode.com/problems/kth-largest-element-in-an-array",
    "slug": "kth-largest-element-in-an-array",
    "description": "Given an integer array \nnums\n and an integer \nk\n, return \nthe\n \nk\nth\n \nlargest element in the array\n.\n\n\nNote that it is the \nk\nth\n largest element in the sorted order, not the \nk\nth\n distinct element.\n\n\nCan you solve it without sorting?\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [3,2,1,5,6,4], k = 2\n\nOutput:\n 5\n\nExample 2:\n\n\nInput:\n nums = [3,2,3,1,2,4,5,5,6], k = 4\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4",
    "solution": "\nfrom random import randint\n\n\n# optimized for duplicated numsclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        nth_element(nums, k-1, compare=lambda a, b: a > b)\n        return nums[k-1]\n\nclass Solution2(object):\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = self.PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k - 1:\n                return nums[new_pivot_idx]\n            elif new_pivot_idx > k - 1:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k - 1.\n                left = new_pivot_idx + 1\n\n    def PartitionAroundPivot(self, left, right, pivot_idx, nums):\n        pivot_value = nums[pivot_idx]\n        new_pivot_idx = left\n        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n        for i in xrange(left, right):\n            if nums[i] > pivot_value:\n                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                new_pivot_idx += 1\n\n        nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n        return new_pivot_idx",
    "explanation": "N/A",
    "time_complexity": "O(n) on average, using Median of Medians could achieve O(n) (Intro Select)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Minimum Equal Sum of Two Arrays After Replacing Zeros",
    "difficulty": "MEDIUM",
    "category": "Array, Greedy",
    "link": "https://leetcode.com/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros",
    "slug": "minimum-equal-sum-of-two-arrays-after-replacing-zeros",
    "description": "You are given two arrays \nnums1\n and \nnums2\n consisting of positive integers.\n\n\nYou have to replace \nall\n the \n0\n's in both arrays with \nstrictly\n positive integers such that the sum of elements of both arrays becomes \nequal\n.\n\n\nReturn \nthe \nminimum\n equal sum you can obtain, or \n-1\n if it is impossible\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [3,2,0,1,0], nums2 = [6,5,0]\n\nOutput:\n 12\n\nExplanation:\n We can replace 0's in the following way:\n- Replace the two 0's in nums1 with the values 2 and 4. The resulting array is nums1 = [3,2,2,1,4].\n- Replace the 0 in nums2 with the value 1. The resulting array is nums2 = [6,5,1].\nBoth arrays have an equal sum of 12. It can be shown that it is the minimum sum we can obtain.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [2,0,2,0], nums2 = [1,4]\n\nOutput:\n -1\n\nExplanation:\n It is impossible to make the sum of both arrays equal.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length, nums2.length <= 10\n5\n\n\n0 <= nums1[i], nums2[i] <= 10\n6",
    "solution": "\n# greedyclass Solution(object):\n    def minSum(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        total1 = sum(max(x, 1) for x in nums1)\n        total2 = sum(max(x, 1) for x in nums2)\n        if total1 < total2:\n            return total2 if 0 in nums1 else -1\n        if total1 > total2:\n            return total1 if 0 in nums2 else -1\n        return total1",
    "explanation": "N/A",
    "time_complexity": "O(n + m)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Majority Element",
    "difficulty": "EASY",
    "category": "Array, Hash Table, Divide and Conquer, Sorting, Counting",
    "link": "https://leetcode.com/problems/majority-element",
    "slug": "majority-element",
    "description": "Given an array \nnums\n of size \nn\n, return \nthe majority element\n.\n\n\nThe majority element is the element that appears more than \n⌊n / 2⌋\n times. You may assume that the majority element always exists in the array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [3,2,3]\n\nOutput:\n 3\n\nExample 2:\n\n\nInput:\n nums = [2,2,1,1,1,2,2]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 5 * 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n\n\n \n\n\nFollow-up:\n Could you solve the problem in linear time and in \nO(1)\n space?",
    "solution": "\nimport collections\n\nclass Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def boyer_moore_majority_vote():\n            result, cnt = None, 0\n            for x in nums:\n                if not cnt:\n                    result = x\n                if x == result:\n                    cnt += 1\n                else:\n                    cnt -= 1\n            return result\n\n        return boyer_moore_majority_vote()\n\n\nimport collections\n\nclass Solution2(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return collections.Counter(nums).most_common(1)[0][0]\n\n\nimport collections\n\nclass Solution3(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sorted(collections.Counter(nums).items(), key=lambda a: a[1], reverse=True)[0][0]",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Maximum Profit in Job Scheduling",
    "difficulty": "HARD",
    "category": "Array, Binary Search, Dynamic Programming, Sorting",
    "link": "https://leetcode.com/problems/maximum-profit-in-job-scheduling",
    "slug": "maximum-profit-in-job-scheduling",
    "description": "We have \nn\n jobs, where every job is scheduled to be done from \nstartTime[i]\n to \nendTime[i]\n, obtaining a profit of \nprofit[i]\n.\n\n\nYou're given the \nstartTime\n, \nendTime\n and \nprofit\n arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\n\n\nIf you choose a job that ends at time \nX\n you will be able to start another job that starts at time \nX\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\n\nOutput:\n 120\n\nExplanation:\n The subset chosen is the first and fourth job. \nTime range [1-3]+[3-6] , we get profit of 120 = 50 + 70.\n\n\n\nExample 2:\n\n\n \n\n\n\n\nInput:\n startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\n\nOutput:\n 150\n\nExplanation:\n The subset chosen is the first, fourth and fifth job. \nProfit obtained 150 = 20 + 70 + 60.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]\n\nOutput:\n 6\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= startTime.length == endTime.length == profit.length <= 5 * 10\n4\n\n\n1 <= startTime[i] < endTime[i] <= 10\n9\n\n\n1 <= profit[i] <= 10\n4",
    "solution": "\nimport itertools\nimport bisect\n\nclass Solution(object):\n    def jobScheduling(self, startTime, endTime, profit):\n        \"\"\"\n        :type startTime: List[int]\n        :type endTime: List[int]\n        :type profit: List[int]\n        :rtype: int\n        \"\"\"\n        jobs = sorted(itertools.izip(endTime, startTime, profit))\n        dp = [(0, 0)]\n        for e, s, p in jobs:\n            i = bisect.bisect_right(dp, (s+1, 0))-1\n            if dp[i][1]+p > dp[-1][1]:\n                dp.append((e, dp[i][1]+p))\n        return dp[-1][1]\n\n\nimport heapqclass Solution(object):\n    def jobScheduling(self, startTime, endTime, profit):\n        \"\"\"\n        :type startTime: List[int]\n        :type endTime: List[int]\n        :type profit: List[int]\n        :rtype: int\n        \"\"\"\n        min_heap = zip(startTime, endTime, profit)\n        heapq.heapify(min_heap)\n        result = 0\n        while min_heap:\n            s, e, p = heapq.heappop(min_heap)\n            if s < e:\n                heapq.heappush(min_heap, (e, s, result+p))\n            else:\n                result = max(result, p)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Contains Duplicate",
    "difficulty": "EASY",
    "category": "Array, Hash Table, Sorting",
    "link": "https://leetcode.com/problems/contains-duplicate",
    "slug": "contains-duplicate",
    "description": "Given an integer array \nnums\n, return \ntrue\n if any value appears \nat least twice\n in the array, and return \nfalse\n if every element is distinct.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,3,1]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThe element 1 occurs at the indices 0 and 3.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,2,3,4]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nAll elements are distinct.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,1,1,3,3,4,3,2,4,2]\n\n\nOutput:\n \ntrue\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9",
    "solution": "class Solution(object):\n    # @param {integer[]} nums\n    # @return {boolean}\n    def containsDuplicate(self, nums):\n        return len(nums) > len(set(nums))",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Product of Array Except Self",
    "difficulty": "MEDIUM",
    "category": "Array, Prefix Sum",
    "link": "https://leetcode.com/problems/product-of-array-except-self",
    "slug": "product-of-array-except-self",
    "description": "Given an integer array \nnums\n, return \nan array\n \nanswer\n \nsuch that\n \nanswer[i]\n \nis equal to the product of all the elements of\n \nnums\n \nexcept\n \nnums[i]\n.\n\n\nThe product of any prefix or suffix of \nnums\n is \nguaranteed\n to fit in a \n32-bit\n integer.\n\n\nYou must write an algorithm that runs in \nO(n)\n time and without using the division operation.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,2,3,4]\n\nOutput:\n [24,12,8,6]\n\nExample 2:\n\n\nInput:\n nums = [-1,1,0,-3,3]\n\nOutput:\n [0,0,9,0,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n5\n\n\n-30 <= nums[i] <= 30\n\n\nThe input is generated such that \nanswer[i]\n is \nguaranteed\n to fit in a \n32-bit\n integer.\n\n\n\n\n \n\n\nFollow up:\n Can you solve the problem in \nO(1)\n extra space complexity? (The output array \ndoes not\n count as extra space for space complexity analysis.)",
    "solution": "class Solution(object):\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def productExceptSelf(self, nums):\n        if not nums:\n            return []\n\n        left_product = [1 for _ in xrange(len(nums))]\n        for i in xrange(1, len(nums)):\n            left_product[i] = left_product[i - 1] * nums[i - 1]\n\n        right_product = 1\n        for i in xrange(len(nums) - 2, -1, -1):\n            right_product *= nums[i + 1]\n            left_product[i] = left_product[i] * right_product\n\n        return left_product",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Combination Sum",
    "difficulty": "MEDIUM",
    "category": "Array, Backtracking",
    "link": "https://leetcode.com/problems/combination-sum",
    "slug": "combination-sum",
    "description": "Given an array of \ndistinct\n integers \ncandidates\n and a target integer \ntarget\n, return \na list of all \nunique combinations\n of \ncandidates\n where the chosen numbers sum to \ntarget\n.\n You may return the combinations in \nany order\n.\n\n\nThe \nsame\n number may be chosen from \ncandidates\n an \nunlimited number of times\n. Two combinations are unique if the \nfrequency\n of at least one of the chosen numbers is different.\n\n\nThe test cases are generated such that the number of unique combinations that sum up to \ntarget\n is less than \n150\n combinations for the given input.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n candidates = [2,3,6,7], target = 7\n\nOutput:\n [[2,2,3],[7]]\n\nExplanation:\n\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n\n\n\nExample 2:\n\n\n\n\nInput:\n candidates = [2,3,5], target = 8\n\nOutput:\n [[2,2,2,2],[2,3,3],[3,5]]\n\n\n\nExample 3:\n\n\n\n\nInput:\n candidates = [2], target = 1\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= candidates.length <= 30\n\n\n2 <= candidates[i] <= 40\n\n\nAll elements of \ncandidates\n are \ndistinct\n.\n\n\n1 <= target <= 40",
    "solution": "class Solution(object):\n    # @param candidates, a list of integers\n    # @param target, integer\n    # @return a list of lists of integers\n    def combinationSum(self, candidates, target):\n        result = []\n        self.combinationSumRecu(sorted(candidates), result, 0, [], target)\n        return result\n\n    def combinationSumRecu(self, candidates, result, start, intermediate, target):\n        if target == 0:\n            result.append(list(intermediate))\n        while start < len(candidates) and candidates[start] <= target:\n            intermediate.append(candidates[start])\n            self.combinationSumRecu(candidates, result, start, intermediate, target - candidates[start])\n            intermediate.pop()\n            start += 1",
    "explanation": "N/A",
    "time_complexity": "O(k * n^k)",
    "space_complexity": "O(k)"
  },
  {
    "title": "Container With Most Water",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers, Greedy",
    "link": "https://leetcode.com/problems/container-with-most-water",
    "slug": "container-with-most-water",
    "description": "You are given an integer array \nheight\n of length \nn\n. There are \nn\n vertical lines drawn such that the two endpoints of the \ni\nth\n line are \n(i, 0)\n and \n(i, height[i])\n.\n\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\n\nReturn \nthe maximum amount of water a container can store\n.\n\n\nNotice\n that you may not slant the container.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [1,8,6,2,5,4,8,3,7]\n\nOutput:\n 49\n\nExplanation:\n The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [1,1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= height[i] <= 10\n4",
    "solution": "class Solution(object):\n    # @return an integer\n    def maxArea(self, height):\n        max_area, i, j = 0, 0, len(height) - 1\n        while i < j:\n            max_area = max(max_area, min(height[i], height[j]) * (j - i))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return max_area",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Number of Provinces",
    "difficulty": "MEDIUM",
    "category": "Depth-First Search, Breadth-First Search, Union Find, Graph",
    "link": "https://leetcode.com/problems/number-of-provinces",
    "slug": "number-of-provinces",
    "description": "There are \nn\n cities. Some of them are connected, while some are not. If city \na\n is connected directly with city \nb\n, and city \nb\n is connected directly with city \nc\n, then city \na\n is connected indirectly with city \nc\n.\n\n\nA \nprovince\n is a group of directly or indirectly connected cities and no other cities outside of the group.\n\n\nYou are given an \nn x n\n matrix \nisConnected\n where \nisConnected[i][j] = 1\n if the \ni\nth\n city and the \nj\nth\n city are directly connected, and \nisConnected[i][j] = 0\n otherwise.\n\n\nReturn \nthe total number of \nprovinces\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 200\n\n\nn == isConnected.length\n\n\nn == isConnected[i].length\n\n\nisConnected[i][j]\n is \n1\n or \n0\n.\n\n\nisConnected[i][i] == 1\n\n\nisConnected[i][j] == isConnected[j][i]",
    "solution": "# Solution not found in kamyu104 repository",
    "explanation": "N/A",
    "time_complexity": "N/A",
    "space_complexity": "N/A"
  },
  {
    "title": "Reverse Integer",
    "difficulty": "MEDIUM",
    "category": "Math",
    "link": "https://leetcode.com/problems/reverse-integer",
    "slug": "reverse-integer",
    "description": "Given a signed 32-bit integer \nx\n, return \nx\n with its digits reversed\n. If reversing \nx\n causes the value to go outside the signed 32-bit integer range \n[-2\n31\n, 2\n31\n - 1]\n, then return \n0\n.\n\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 123\n\nOutput:\n 321\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = -123\n\nOutput:\n -321\n\n\n\nExample 3:\n\n\n\n\nInput:\n x = 120\n\nOutput:\n 21\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= x <= 2\n31\n - 1",
    "solution": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 0:\n            return -self.reverse(-x)\n\n        result = 0\n        while x:\n            result = result * 10 + x % 10\n            x //= 10\n        return result if result <= 0x7fffffff else 0  # Handle overflow.\n\n    def reverse2(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 0:\n            x = int(str(x)[::-1][-1] + str(x)[::-1][:-1])\n        else:\n            x = int(str(x)[::-1])\n        x = 0 if abs(x) > 0x7FFFFFFF else x\n        return x\n\n    def reverse3(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        s = cmp(x, 0)\n        r = int(repr(s * x)[::-1])\n        return s * r * (r < 2 ** 31)",
    "explanation": "N/A",
    "time_complexity": "O(logn) = O(1)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Single Number",
    "difficulty": "EASY",
    "category": "Array, Bit Manipulation",
    "link": "https://leetcode.com/problems/single-number",
    "slug": "single-number",
    "description": "Given a \nnon-empty\n array of integers \nnums\n, every element appears \ntwice\n except for one. Find that single one.\n\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,2,1]\n\n\nOutput:\n \n1\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [4,1,2,1,2]\n\n\nOutput:\n \n4\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1]\n\n\nOutput:\n \n1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 3 * 10\n4\n\n\n-3 * 10\n4\n <= nums[i] <= 3 * 10\n4\n\n\nEach element in the array appears twice except for one element which appears only once.",
    "solution": "\nimport operator\nfrom functools import reduce\n\nclass Solution(object):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    def singleNumber(self, A):\n        return reduce(operator.xor, A)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Pascal's Triangle",
    "difficulty": "EASY",
    "category": "Array, Dynamic Programming",
    "link": "https://leetcode.com/problems/pascals-triangle",
    "slug": "pascals-triangle",
    "description": "Given an integer \nnumRows\n, return the first numRows of \nPascal's triangle\n.\n\n\nIn \nPascal's triangle\n, each number is the sum of the two numbers directly above it as shown:\n\n\n\n\n \n\n\nExample 1:\n\n\nInput:\n numRows = 5\n\nOutput:\n [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n\nExample 2:\n\n\nInput:\n numRows = 1\n\nOutput:\n [[1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numRows <= 30",
    "solution": "class Solution(object):\n    # @return a list of lists of integers\n    def generate(self, numRows):\n        result = []\n        for i in xrange(numRows):\n            result.append([])\n            for j in xrange(i + 1):\n                if j in (0, i):\n                    result[i].append(1)\n                else:\n                    result[i].append(result[i - 1][j - 1] + result[i - 1][j])\n        return result\n\n    def generate2(self, numRows):\n        if not numRows: return []\n        res = [[1]]\n        for i in range(1, numRows):\n            res += [map(lambda x, y: x + y, res[-1] + [0], [0] + res[-1])]\n        return res[:numRows]\n\n    def generate3(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if numRows == 0: return []\n        if numRows == 1: return [[1]]\n        res = [[1], [1, 1]]\n\n        def add(nums):\n            res = nums[:1]\n            for i, j in enumerate(nums):\n                if i < len(nums) - 1:\n                    res += [nums[i] + nums[i + 1]]\n            res += nums[:1]\n            return res\n\n        while len(res) < numRows:\n            res.extend([add(res[-1])])\n        return res",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Min Cost Climbing Stairs",
    "difficulty": "EASY",
    "category": "Array, Dynamic Programming",
    "link": "https://leetcode.com/problems/min-cost-climbing-stairs",
    "slug": "min-cost-climbing-stairs",
    "description": "You are given an integer array \ncost\n where \ncost[i]\n is the cost of \ni\nth\n step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\n\nYou can either start from the step with index \n0\n, or the step with index \n1\n.\n\n\nReturn \nthe minimum cost to reach the top of the floor\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n cost = [10,\n15\n,20]\n\nOutput:\n 15\n\nExplanation:\n You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n\n\nExample 2:\n\n\n\n\nInput:\n cost = [\n1\n,100,\n1\n,1,\n1\n,100,\n1\n,\n1\n,100,\n1\n]\n\nOutput:\n 6\n\nExplanation:\n You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= cost.length <= 1000\n\n\n0 <= cost[i] <= 999",
    "solution": "class Solution(object):\n    def minCostClimbingStairs(self, cost):\n        \"\"\"\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [0] * 3\n        for i in reversed(xrange(len(cost))):\n            dp[i%3] = cost[i] + min(dp[(i+1)%3], dp[(i+2)%3])\n        return min(dp[0], dp[1])",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Word Search II",
    "difficulty": "HARD",
    "category": "Array, String, Backtracking, Trie, Matrix",
    "link": "https://leetcode.com/problems/word-search-ii",
    "slug": "word-search-ii",
    "description": "Given an \nm x n\n \nboard\n of characters and a list of strings \nwords\n, return \nall words on the board\n.\n\n\nEach word must be constructed from letters of sequentially adjacent cells, where \nadjacent cells\n are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n\nOutput:\n [\"eat\",\"oath\"]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == board.length\n\n\nn == board[i].length\n\n\n1 <= m, n <= 12\n\n\nboard[i][j]\n is a lowercase English letter.\n\n\n1 <= words.length <= 3 * 10\n4\n\n\n1 <= words[i].length <= 10\n\n\nwords[i]\n consists of lowercase English letters.\n\n\nAll the strings of \nwords\n are unique.",
    "solution": "class TrieNode(object):\n    # Initialize your data structure here.\n    def __init__(self):\n        self.is_string = False\n        self.leaves = {}\n\n    # Inserts a word into the trie.\n    def insert(self, word):\n        cur = self\n        for c in word:\n            if not c in cur.leaves:\n                cur.leaves[c] = TrieNode()\n            cur = cur.leaves[c]\n        cur.is_string = True\n\nclass Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        visited = [[False for j in xrange(len(board[0]))] for i in xrange(len(board))]\n        result = {}\n        trie = TrieNode()\n        for word in words:\n            trie.insert(word)\n\n        for i in xrange(len(board)):\n            for j in xrange(len(board[0])):\n                self.findWordsRecu(board, trie, 0, i, j, visited, [], result)\n\n        return result.keys()\n\n    def findWordsRecu(self, board, trie, cur, i, j, visited, cur_word, result):\n        if not trie or i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j]:\n            return\n\n        if board[i][j] not in trie.leaves:\n            return\n\n        cur_word.append(board[i][j])\n        next_node = trie.leaves[board[i][j]]\n        if next_node.is_string:\n            result[\"\".join(cur_word)] = True\n\n        visited[i][j] = True\n        self.findWordsRecu(board, next_node, cur + 1, i + 1, j, visited, cur_word, result)\n        self.findWordsRecu(board, next_node, cur + 1, i - 1, j, visited, cur_word, result)\n        self.findWordsRecu(board, next_node, cur + 1, i, j + 1, visited, cur_word, result)\n        self.findWordsRecu(board, next_node, cur + 1, i, j - 1, visited, cur_word, result)\n        visited[i][j] = False\n        cur_word.pop()",
    "explanation": "N/A",
    "time_complexity": "O(m * n * 4 * 3^(h - 1)) ~= O(m * n * 3^h), h is the height of trie",
    "space_complexity": "O(t), t is the number of nodes in trie"
  },
  {
    "title": "Next Greater Element I",
    "difficulty": "EASY",
    "category": "Array, Hash Table, Stack, Monotonic Stack",
    "link": "https://leetcode.com/problems/next-greater-element-i",
    "slug": "next-greater-element-i",
    "description": "The \nnext greater element\n of some element \nx\n in an array is the \nfirst greater\n element that is \nto the right\n of \nx\n in the same array.\n\n\nYou are given two \ndistinct 0-indexed\n integer arrays \nnums1\n and \nnums2\n, where \nnums1\n is a subset of \nnums2\n.\n\n\nFor each \n0 <= i < nums1.length\n, find the index \nj\n such that \nnums1[i] == nums2[j]\n and determine the \nnext greater element\n of \nnums2[j]\n in \nnums2\n. If there is no next greater element, then the answer for this query is \n-1\n.\n\n\nReturn \nan array \nans\n of length \nnums1.length\n such that \nans[i]\n is the \nnext greater element\n as described above.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [4,1,2], nums2 = [1,3,4,2]\n\nOutput:\n [-1,3,-1]\n\nExplanation:\n The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,\n4\n,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [\n1\n,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,\n2\n]. There is no next greater element, so the answer is -1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [2,4], nums2 = [1,2,3,4]\n\nOutput:\n [3,-1]\n\nExplanation:\n The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,\n2\n,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,\n4\n]. There is no next greater element, so the answer is -1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length <= nums2.length <= 1000\n\n\n0 <= nums1[i], nums2[i] <= 10\n4\n\n\nAll integers in \nnums1\n and \nnums2\n are \nunique\n.\n\n\nAll the integers of \nnums1\n also appear in \nnums2\n.\n\n\n\n\n \n\n\nFollow up:\n Could you find an \nO(nums1.length + nums2.length)\n solution?",
    "solution": "class Solution(object):\n    def nextGreaterElement(self, findNums, nums):\n        \"\"\"\n        :type findNums: List[int]\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        stk, lookup = [], {}\n        for num in nums:\n            while stk and num > stk[-1]:\n                lookup[stk.pop()] = num\n            stk.append(num)\n        while stk:\n            lookup[stk.pop()] = -1\n        return map(lambda x : lookup[x], findNums)",
    "explanation": "N/A",
    "time_complexity": "O(m + n)",
    "space_complexity": "O(m + n)"
  },
  {
    "title": "Analyze User Website Visit Pattern",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Sorting",
    "link": "https://leetcode.com/problems/analyze-user-website-visit-pattern",
    "slug": "analyze-user-website-visit-pattern",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nimport collections\nimport itertools\n\nclass Solution(object):\n    def mostVisitedPattern(self, username, timestamp, website):\n        \"\"\"\n        :type username: List[str]\n        :type timestamp: List[int]\n        :type website: List[str]\n        :rtype: List[str]\n        \"\"\"\n        lookup = collections.defaultdict(list)\n        A = zip(timestamp, username, website)\n        A.sort()\n        for t, u, w in A:\n            lookup[u].append(w)\n        count = sum([collections.Counter(set(itertools.combinations(lookup[u], 3))) for u in lookup], collections.Counter())\n        return list(min(count, key=lambda x: (-count[x], x)))",
    "explanation": "N/A",
    "time_complexity": "O(n^3)",
    "space_complexity": "O(n^3)"
  },
  {
    "title": "Sliding Window Maximum",
    "difficulty": "HARD",
    "category": "Array, Queue, Sliding Window, Heap (Priority Queue), Monotonic Queue",
    "link": "https://leetcode.com/problems/sliding-window-maximum",
    "slug": "sliding-window-maximum",
    "description": "You are given an array of integers \nnums\n, there is a sliding window of size \nk\n which is moving from the very left of the array to the very right. You can only see the \nk\n numbers in the window. Each time the sliding window moves right by one position.\n\n\nReturn \nthe max sliding window\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,-1,-3,5,3,6,7], k = 3\n\nOutput:\n [3,3,5,5,6,7]\n\nExplanation:\n \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       \n3\n\n 1 [3  -1  -3] 5  3  6  7       \n3\n\n 1  3 [-1  -3  5] 3  6  7      \n 5\n\n 1  3  -1 [-3  5  3] 6  7       \n5\n\n 1  3  -1  -3 [5  3  6] 7       \n6\n\n 1  3  -1  -3  5 [3  6  7]      \n7\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1], k = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n1 <= k <= nums.length",
    "solution": "\nfrom collections import deque\n\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result, dq = [], deque()\n        for i in xrange(len(nums)):\n            if dq and i-dq[0] == k:\n                dq.popleft()\n            while dq and nums[dq[-1]] <= nums[i]:\n                dq.pop()\n            dq.append(i)\n            if i >= k-1:\n                result.append(nums[dq[0]])\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(k)"
  },
  {
    "title": "Word Ladder",
    "difficulty": "HARD",
    "category": "Hash Table, String, Breadth-First Search",
    "link": "https://leetcode.com/problems/word-ladder",
    "slug": "word-ladder",
    "description": "A \ntransformation sequence\n from word \nbeginWord\n to word \nendWord\n using a dictionary \nwordList\n is a sequence of words \nbeginWord -> s\n1\n -> s\n2\n -> ... -> s\nk\n such that:\n\n\n\n\nEvery adjacent pair of words differs by a single letter.\n\n\nEvery \ns\ni\n for \n1 <= i <= k\n is in \nwordList\n. Note that \nbeginWord\n does not need to be in \nwordList\n.\n\n\ns\nk\n == endWord\n\n\n\n\nGiven two words, \nbeginWord\n and \nendWord\n, and a dictionary \nwordList\n, return \nthe \nnumber of words\n in the \nshortest transformation sequence\n from\n \nbeginWord\n \nto\n \nendWord\n, or \n0\n if no such sequence exists.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\nOutput:\n 5\n\nExplanation:\n One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\n\n\n\nExample 2:\n\n\n\n\nInput:\n beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n\nOutput:\n 0\n\nExplanation:\n The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= beginWord.length <= 10\n\n\nendWord.length == beginWord.length\n\n\n1 <= wordList.length <= 5000\n\n\nwordList[i].length == beginWord.length\n\n\nbeginWord\n, \nendWord\n, and \nwordList[i]\n consist of lowercase English letters.\n\n\nbeginWord != endWord\n\n\nAll the words in \nwordList\n are \nunique\n.",
    "solution": "\nfrom string import ascii_lowercase\n\n\n# two-end bfsclass Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        words = set(wordList)\n        if endWord not in words:\n            return 0\n        left, right = {beginWord}, {endWord}\n        ladder = 2\n        while left:\n            words -= left\n            new_left = set()\n            for word in left:\n                for new_word in (word[:i]+c+word[i+1:] for i in xrange(len(beginWord)) for c in ascii_lowercase):\n                    if new_word not in words:\n                        continue\n                    if new_word in right: \n                        return ladder\n                    new_left.add(new_word)\n            left = new_left\n            ladder += 1\n            if len(left) > len(right): \n                left, right = right, left\n        return 0\n\nclass Solution2(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        lookup = set(wordList)\n        if endWord not in lookup:\n            return 0\n        ladder = 2\n        q = [beginWord]\n        while q:\n            new_q = []\n            for word in q:\n                for i in xrange(len(word)):\n                    for j in ascii_lowercase:\n                        new_word = word[:i] + j + word[i+1:]\n                        if new_word == endWord:\n                            return ladder\n                        if new_word in lookup:\n                            lookup.remove(new_word)\n                            new_q.append(new_word)\n            q = new_q\n            ladder += 1\n        return 0",
    "explanation": "N/A",
    "time_complexity": "O(b^d), b is the branch factor of bfs, d is the result depth",
    "space_complexity": "O(w * l), w is the number of words, l is the max length of words"
  },
  {
    "title": "Valid Sudoku",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Matrix",
    "link": "https://leetcode.com/problems/valid-sudoku",
    "slug": "valid-sudoku",
    "description": "Determine if a \n9 x 9\n Sudoku board is valid. Only the filled cells need to be validated \naccording to the following rules\n:\n\n\n\n\nEach row must contain the digits \n1-9\n without repetition.\n\n\nEach column must contain the digits \n1-9\n without repetition.\n\n\nEach of the nine \n3 x 3\n sub-boxes of the grid must contain the digits \n1-9\n without repetition.\n\n\n\n\nNote:\n\n\n\n\nA Sudoku board (partially filled) could be valid but is not necessarily solvable.\n\n\nOnly the filled cells need to be validated according to the mentioned rules.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\nInput:\n board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput:\n false\n\nExplanation:\n Same as Example 1, except with the \n5\n in the top left corner being modified to \n8\n. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nboard.length == 9\n\n\nboard[i].length == 9\n\n\nboard[i][j]\n is a digit \n1-9\n or \n'.'\n.",
    "solution": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        for i in xrange(9):\n            if not self.isValidList([board[i][j] for j in xrange(9)]) or \\\n               not self.isValidList([board[j][i] for j in xrange(9)]):\n                return False\n        for i in xrange(3):\n            for j in xrange(3):\n                if not self.isValidList([board[m][n] for n in xrange(3 * j, 3 * j + 3) \\\n                                                     for m in xrange(3 * i, 3 * i + 3)]):\n                    return False\n        return True\n\n    def isValidList(self, xs):\n        xs = filter(lambda x: x != '.', xs)\n        return len(set(xs)) == len(xs)",
    "explanation": "N/A",
    "time_complexity": "O(9^2)",
    "space_complexity": "O(9)"
  },
  {
    "title": "Integer to English Words",
    "difficulty": "HARD",
    "category": "Math, String, Recursion",
    "link": "https://leetcode.com/problems/integer-to-english-words",
    "slug": "integer-to-english-words",
    "description": "Convert a non-negative integer \nnum\n to its English words representation.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 123\n\nOutput:\n \"One Hundred Twenty Three\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 12345\n\nOutput:\n \"Twelve Thousand Three Hundred Forty Five\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n num = 1234567\n\nOutput:\n \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= num <= 2\n31\n - 1",
    "solution": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return \"Zero\"\n\n        lookup = {0: \"Zero\", 1:\"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", \\\n                  5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\", \\\n                  10: \"Ten\", 11: \"Eleven\", 12: \"Twelve\", 13: \"Thirteen\", 14: \"Fourteen\", \\\n                  15: \"Fifteen\", 16: \"Sixteen\", 17: \"Seventeen\", 18: \"Eighteen\", 19: \"Nineteen\", \\\n                  20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\", 50: \"Fifty\", 60: \"Sixty\", \\\n                  70: \"Seventy\", 80: \"Eighty\", 90: \"Ninety\"}\n        unit = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        res, i = [], 0\n        while num:\n            cur = num % 1000\n            if num % 1000:\n                res.append(self.threeDigits(cur, lookup, unit[i]))\n            num //= 1000\n            i += 1\n        return \" \".join(res[::-1])\n\n    def threeDigits(self, num, lookup, unit):\n        res = []\n        if num / 100:\n            res = [lookup[num / 100] + \" \" + \"Hundred\"]\n        if num % 100:\n            res.append(self.twoDigits(num % 100, lookup))\n        if unit != \"\":\n            res.append(unit)\n        return \" \".join(res)\n\n    def twoDigits(self, num, lookup):\n        if num in lookup:\n            return lookup[num]\n        return lookup[(num / 10) * 10] + \" \" + lookup[num % 10]",
    "explanation": "N/A",
    "time_complexity": "O(logn) = O(1), n is the value of the integer, which is less than 2^31 - 1",
    "space_complexity": "O(1)"
  },
  {
    "title": "Course Schedule II",
    "difficulty": "MEDIUM",
    "category": "Depth-First Search, Breadth-First Search, Graph, Topological Sort",
    "link": "https://leetcode.com/problems/course-schedule-ii",
    "slug": "course-schedule-ii",
    "description": "There are a total of \nnumCourses\n courses you have to take, labeled from \n0\n to \nnumCourses - 1\n. You are given an array \nprerequisites\n where \nprerequisites[i] = [a\ni\n, b\ni\n]\n indicates that you \nmust\n take course \nb\ni\n first if you want to take course \na\ni\n.\n\n\n\n\nFor example, the pair \n[0, 1]\n, indicates that to take course \n0\n you have to first take course \n1\n.\n\n\n\n\nReturn \nthe ordering of courses you should take to finish all courses\n. If there are many valid answers, return \nany\n of them. If it is impossible to finish all courses, return \nan empty array\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [[1,0]]\n\nOutput:\n [0,1]\n\nExplanation:\n There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n\nOutput:\n [0,2,1,3]\n\nExplanation:\n There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n\n\n\nExample 3:\n\n\n\n\nInput:\n numCourses = 1, prerequisites = []\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numCourses <= 2000\n\n\n0 <= prerequisites.length <= numCourses * (numCourses - 1)\n\n\nprerequisites[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < numCourses\n\n\na\ni\n != b\ni\n\n\nAll the pairs \n[a\ni\n, b\ni\n]\n are \ndistinct\n.",
    "solution": "\nimport collections\n\n\n# Khan's algorithm (bfs solution)class Solution(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        q = [u for u in xrange(numCourses) if u not in in_degree]\n        while q:\n            new_q = []\n            for u in q:\n                result.append(u)\n                for v in adj[u]:\n                    in_degree[v] -= 1\n                    if in_degree[v] == 0:\n                        new_q.append(v)\n            q = new_q\n        return result if len(result) == numCourses else []\n\n\nimport collections\n\n\n# dfs solutionclass Solution2(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        stk = [u for u in xrange(numCourses) if u not in in_degree]\n        while stk:\n            u = stk.pop()\n            result.append(u)\n            for v in adj[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    stk.append(v)\n        return result if len(result) == numCourses else []\n\n\nimport collections\n\n\n# dfs solutionclass Solution3(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        WHITE, GRAY, BLACK = range(3)\n        def dfs(u):\n            if lookup[u] != WHITE:\n                return lookup[u] == BLACK\n            lookup[u] = GRAY\n            if any(not dfs(v) for v in adj[u]):\n                return False\n            lookup[u] = BLACK\n            result.append(u)  # should be postorder\n            return True\n\n        result = []\n        adj = collections.defaultdict(list)\n        for u, v in prerequisites:\n            adj[u].append(v)\n        lookup = collections.defaultdict(lambda:WHITE)\n        for u in xrange(numCourses):\n            if not dfs(u):\n                return []\n        return result\n\n    \nimport collections\n\n\n# dfs solutionclass Solution4(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        WHITE, GRAY, BLACK = range(3)\n        def dfs(u):\n            if lookup[u] != WHITE:\n                return lookup[u] == BLACK\n            lookup[u] = GRAY\n            if any(not dfs(v) for v in adj[u]):\n                return False\n            lookup[u] = BLACK\n            result.append(u)  # should be postorder\n            return True\n\n        result = []\n        adj = collections.defaultdict(list)\n        for u, v in prerequisites:\n            adj[v].append(u)\n        lookup = collections.defaultdict(lambda:WHITE)\n        for u in xrange(numCourses):\n            if not dfs(u):\n                return []\n        result.reverse()\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(|V| + |E|)",
    "space_complexity": "O(|E|)"
  },
  {
    "title": "Pacific Atlantic Water Flow",
    "difficulty": "MEDIUM",
    "category": "Array, Depth-First Search, Breadth-First Search, Matrix",
    "link": "https://leetcode.com/problems/pacific-atlantic-water-flow",
    "slug": "pacific-atlantic-water-flow",
    "description": "There is an \nm x n\n rectangular island that borders both the \nPacific Ocean\n and \nAtlantic Ocean\n. The \nPacific Ocean\n touches the island's left and top edges, and the \nAtlantic Ocean\n touches the island's right and bottom edges.\n\n\nThe island is partitioned into a grid of square cells. You are given an \nm x n\n integer matrix \nheights\n where \nheights[r][c]\n represents the \nheight above sea level\n of the cell at coordinate \n(r, c)\n.\n\n\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is \nless than or equal to\n the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\n\n\nReturn \na \n2D list\n of grid coordinates \nresult\n where \nresult[i] = [r\ni\n, c\ni\n]\n denotes that rain water can flow from cell \n(r\ni\n, c\ni\n)\n to \nboth\n the Pacific and Atlantic oceans\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\n\nOutput:\n [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n\nExplanation:\n The following cells can flow to the Pacific and Atlantic oceans, as shown below:\n[0,4]: [0,4] -> Pacific Ocean \n       [0,4] -> Atlantic Ocean\n[1,3]: [1,3] -> [0,3] -> Pacific Ocean \n       [1,3] -> [1,4] -> Atlantic Ocean\n[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \n       [1,4] -> Atlantic Ocean\n[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \n       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\n[3,0]: [3,0] -> Pacific Ocean \n       [3,0] -> [4,0] -> Atlantic Ocean\n[3,1]: [3,1] -> [3,0] -> Pacific Ocean \n       [3,1] -> [4,1] -> Atlantic Ocean\n[4,0]: [4,0] -> Pacific Ocean \n       [4,0] -> Atlantic Ocean\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\n\n\n\nExample 2:\n\n\n\n\nInput:\n heights = [[1]]\n\nOutput:\n [[0,0]]\n\nExplanation:\n The water can flow from the only cell to the Pacific and Atlantic oceans.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == heights.length\n\n\nn == heights[r].length\n\n\n1 <= m, n <= 200\n\n\n0 <= heights[r][c] <= 10\n5",
    "solution": "class Solution(object):\n    def pacificAtlantic(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        PACIFIC, ATLANTIC = 1, 2\n\n        def pacificAtlanticHelper(matrix, x, y, prev_height, prev_val, visited, res):\n            if (not 0 <= x < len(matrix)) or \\\n               (not 0 <= y < len(matrix[0])) or \\\n               matrix[x][y] < prev_height or \\\n               (visited[x][y] | prev_val) == visited[x][y]:\n                return\n\n            visited[x][y] |= prev_val\n            if visited[x][y] == (PACIFIC | ATLANTIC):\n                res.append((x, y))\n\n            for d in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                pacificAtlanticHelper(matrix, x + d[0], y + d[1], matrix[x][y], visited[x][y], visited, res)\n\n        if not matrix:\n            return []\n\n        res = []\n        m, n = len(matrix),len(matrix[0])\n        visited = [[0 for _ in xrange(n)] for _ in xrange(m)]\n\n        for i in xrange(m):\n            pacificAtlanticHelper(matrix, i, 0, float(\"-inf\"), PACIFIC, visited, res)\n            pacificAtlanticHelper(matrix, i, n - 1, float(\"-inf\"), ATLANTIC, visited, res)\n        for j in xrange(n):\n            pacificAtlanticHelper(matrix, 0, j, float(\"-inf\"), PACIFIC, visited, res)\n            pacificAtlanticHelper(matrix, m - 1, j, float(\"-inf\"), ATLANTIC, visited, res)\n\n        return res",
    "explanation": "N/A",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m * n)"
  },
  {
    "title": "Jump Game",
    "difficulty": "MEDIUM",
    "category": "Array, Dynamic Programming, Greedy",
    "link": "https://leetcode.com/problems/jump-game",
    "slug": "jump-game",
    "description": "You are given an integer array \nnums\n. You are initially positioned at the array's \nfirst index\n, and each element in the array represents your maximum jump length at that position.\n\n\nReturn \ntrue\n if you can reach the last index, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,3,1,1,4]\n\nOutput:\n true\n\nExplanation:\n Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,1,0,4]\n\nOutput:\n false\n\nExplanation:\n You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n0 <= nums[i] <= 10\n5",
    "solution": "class Solution(object):\n    # @param A, a list of integers\n    # @return a boolean\n    def canJump(self, A):\n        reachable = 0\n        for i, length in enumerate(A):\n            if i > reachable:\n                break\n            reachable = max(reachable, i + length)\n        return reachable >= len(A) - 1",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Validate Binary Search Tree",
    "difficulty": "MEDIUM",
    "category": "Tree, Depth-First Search, Binary Search Tree, Binary Tree",
    "link": "https://leetcode.com/problems/validate-binary-search-tree",
    "slug": "validate-binary-search-tree",
    "description": "Given the \nroot\n of a binary tree, \ndetermine if it is a valid binary search tree (BST)\n.\n\n\nA \nvalid BST\n is defined as follows:\n\n\n\n\nThe left \nsubtree\n of a node contains only nodes with keys \nstrictly less than\n the node's key.\n\n\nThe right subtree of a node contains only nodes with keys \nstrictly greater than\n the node's key.\n\n\nBoth the left and right subtrees must also be binary search trees.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [2,1,3]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,1,4,null,null,3,6]\n\nOutput:\n false\n\nExplanation:\n The root node's value is 5 but its right child's value is 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-2\n31\n <= Node.val <= 2\n31\n - 1",
    "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# Morris Traversal Solutionclass Solution(object):\n    # @param root, a tree node\n    # @return a list of integers\n    def isValidBST(self, root):\n        prev, cur = None, root\n        while cur:\n            if cur.left is None:\n                if prev and prev.val >= cur.val:\n                    return False\n                prev = cur\n                cur = cur.right\n            else:\n                node = cur.left\n                while node.right and node.right != cur:\n                    node = node.right\n\n                if node.right is None:\n                    node.right = cur\n                    cur = cur.left\n                else:\n                    if prev and prev.val >= cur.val:\n                        return False\n                    node.right = None\n                    prev = cur\n                    cur = cur.right\n\n        return True\n\nclass Solution2(object):\n    # @param root, a tree node\n    # @return a boolean\n    def isValidBST(self, root):\n        return self.isValidBSTRecu(root, float(\"-inf\"), float(\"inf\"))\n\n    def isValidBSTRecu(self, root, low, high):\n        if root is None:\n            return True\n\n        return low < root.val and root.val < high \\\n            and self.isValidBSTRecu(root.left, low, root.val) \\\n            and self.isValidBSTRecu(root.right, root.val, high)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(h)"
  },
  {
    "title": "Sudoku Solver",
    "difficulty": "HARD",
    "category": "Array, Hash Table, Backtracking, Matrix",
    "link": "https://leetcode.com/problems/sudoku-solver",
    "slug": "sudoku-solver",
    "description": "Write a program to solve a Sudoku puzzle by filling the empty cells.\n\n\nA sudoku solution must satisfy \nall of the following rules\n:\n\n\n\n\nEach of the digits \n1-9\n must occur exactly once in each row.\n\n\nEach of the digits \n1-9\n must occur exactly once in each column.\n\n\nEach of the digits \n1-9\n must occur exactly once in each of the 9 \n3x3\n sub-boxes of the grid.\n\n\n\n\nThe \n'.'\n character indicates empty cells.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput:\n [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n\nExplanation:\n The input board is shown above and the only valid solution is shown below:\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nboard.length == 9\n\n\nboard[i].length == 9\n\n\nboard[i][j]\n is a digit or \n'.'\n.\n\n\nIt is \nguaranteed\n that the input board has only one solution.",
    "solution": "class Solution(object):\n    # @param board, a 9x9 2D array\n    # Solve the Sudoku by modifying the input board in-place.\n    # Do not return any value.\n    def solveSudoku(self, board):\n        def isValid(board, x, y):\n            for i in xrange(9):\n                if i != x and board[i][y] == board[x][y]:\n                    return False\n            for j in xrange(9):\n                if j != y and board[x][j] == board[x][y]:\n                    return False\n            i = 3 * (x / 3)\n            while i < 3 * (x / 3 + 1):\n                j = 3 * (y / 3)\n                while j < 3 * (y / 3 + 1):\n                    if (i != x or j != y) and board[i][j] == board[x][y]:\n                        return False\n                    j += 1\n                i += 1\n            return True\n\n        def solver(board):\n            for i in xrange(len(board)):\n                for j in xrange(len(board[0])):\n                    if(board[i][j] == '.'):\n                        for k in xrange(9):\n                            board[i][j] = chr(ord('1') + k)\n                            if isValid(board, i, j) and solver(board):\n                                return True\n                            board[i][j] = '.'\n                        return False\n            return True\n\n        solver(board)",
    "explanation": "N/A",
    "time_complexity": "((9!)^9)",
    "space_complexity": "(1)"
  },
  {
    "title": "Find the Duplicate Number",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers, Binary Search, Bit Manipulation",
    "link": "https://leetcode.com/problems/find-the-duplicate-number",
    "slug": "find-the-duplicate-number",
    "description": "Given an array of integers \nnums\n containing \nn + 1\n integers where each integer is in the range \n[1, n]\n inclusive.\n\n\nThere is only \none repeated number\n in \nnums\n, return \nthis repeated number\n.\n\n\nYou must solve the problem \nwithout\n modifying the array \nnums\n and using only constant extra space.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,4,2,2]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,1,3,4,2]\n\nOutput:\n 3\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,3,3,3,3]\n\nOutput:\n 3\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5\n\n\nnums.length == n + 1\n\n\n1 <= nums[i] <= n\n\n\nAll the integers in \nnums\n appear only \nonce\n except for \nprecisely one integer\n which appears \ntwo or more\n times.\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nHow can we prove that at least one duplicate number must exist in \nnums\n?\n\n\nCan you solve the problem in linear runtime complexity?",
    "solution": "class Solution(object):\n    def findDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # Treat each (key, value) pair of the array as the (pointer, next) node of the linked list,\n        # thus the duplicated number will be the begin of the cycle in the linked list.\n        # Besides, there is always a cycle in the linked list which\n        # starts from the first element of the array.\n        slow = nums[0]\n        fast = nums[nums[0]]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n\n        fast = 0\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow\n\n\n# Binary search method.class Solution2(object):\n    def findDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 1, len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) / 2\n            # Get count of num <= mid.\n            count = 0\n            for num in nums:\n                if num <= mid:\n                    count += 1\n            if count > mid:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\nclass Solution3(object):\n    def findDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        duplicate = 0\n        # Mark the value as visited by negative.\n        for num in nums:\n            if nums[abs(num) - 1] > 0:\n                nums[abs(num) - 1] *= -1\n            else:\n                duplicate = abs(num)\n                break\n        # Rollback the value.\n        for num in nums:\n            if nums[abs(num) - 1] < 0:\n                nums[abs(num) - 1] *= -1\n            else:\n                break\n        return duplicate",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "String Compression",
    "difficulty": "MEDIUM",
    "category": "Two Pointers, String",
    "link": "https://leetcode.com/problems/string-compression",
    "slug": "string-compression",
    "description": "Given an array of characters \nchars\n, compress it using the following algorithm:\n\n\nBegin with an empty string \ns\n. For each group of \nconsecutive repeating characters\n in \nchars\n:\n\n\n\n\nIf the group's length is \n1\n, append the character to \ns\n.\n\n\nOtherwise, append the character followed by the group's length.\n\n\n\n\nThe compressed string \ns\n \nshould not be returned separately\n, but instead, be stored \nin the input character array \nchars\n. Note that group lengths that are \n10\n or longer will be split into multiple characters in \nchars\n.\n\n\nAfter you are done \nmodifying the input array,\n return \nthe new length of the array\n.\n\n\nYou must write an algorithm that uses only constant extra space.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\n\nOutput:\n Return 6, and the first 6 characters of the input array should be: [\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]\n\nExplanation:\n The groups are \"aa\", \"bb\", and \"ccc\". This compresses to \"a2b2c3\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n chars = [\"a\"]\n\nOutput:\n Return 1, and the first character of the input array should be: [\"a\"]\n\nExplanation:\n The only group is \"a\", which remains uncompressed since it's a single character.\n\n\n\nExample 3:\n\n\n\n\nInput:\n chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\n\nOutput:\n Return 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"].\n\nExplanation:\n The groups are \"a\" and \"bbbbbbbbbbbb\". This compresses to \"ab12\".\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= chars.length <= 2000\n\n\nchars[i]\n is a lowercase English letter, uppercase English letter, digit, or symbol.",
    "solution": "class Solution(object):\n    def compress(self, chars):\n        \"\"\"\n        :type chars: List[str]\n        :rtype: int\n        \"\"\"\n        anchor, write = 0, 0\n        for read, c in enumerate(chars):\n            if read+1 == len(chars) or chars[read+1] != c:\n                chars[write] = chars[anchor]\n                write += 1\n                if read > anchor:\n                    n, left = read-anchor+1, write\n                    while n > 0:\n                        chars[write] = chr(n%10+ord('0'))\n                        write += 1\n                        n /= 10\n                    right = write-1\n                    while left < right:\n                        chars[left], chars[right] = chars[right], chars[left]\n                        left += 1\n                        right -= 1\n                anchor = read+1\n        return write",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Course Schedule",
    "difficulty": "MEDIUM",
    "category": "Depth-First Search, Breadth-First Search, Graph, Topological Sort",
    "link": "https://leetcode.com/problems/course-schedule",
    "slug": "course-schedule",
    "description": "There are a total of \nnumCourses\n courses you have to take, labeled from \n0\n to \nnumCourses - 1\n. You are given an array \nprerequisites\n where \nprerequisites[i] = [a\ni\n, b\ni\n]\n indicates that you \nmust\n take course \nb\ni\n first if you want to take course \na\ni\n.\n\n\n\n\nFor example, the pair \n[0, 1]\n, indicates that to take course \n0\n you have to first take course \n1\n.\n\n\n\n\nReturn \ntrue\n if you can finish all courses. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [[1,0]]\n\nOutput:\n true\n\nExplanation:\n There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\n\n\nExample 2:\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [[1,0],[0,1]]\n\nOutput:\n false\n\nExplanation:\n There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numCourses <= 2000\n\n\n0 <= prerequisites.length <= 5000\n\n\nprerequisites[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < numCourses\n\n\nAll the pairs prerequisites[i] are \nunique\n.",
    "solution": "\nimport collections\n\n\n# Khan's algorithm (bfs solution)class Solution(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        q = [u for u in xrange(numCourses) if u not in in_degree]\n        while q:\n            new_q = []\n            for u in q:\n                result.append(u)\n                for v in adj[u]:\n                    in_degree[v] -= 1\n                    if in_degree[v] == 0:\n                        new_q.append(v)\n            q = new_q\n        return len(result) == numCourses\n\n\nimport collections\n\n\n# dfs solutionclass Solution2(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        stk = [u for u in xrange(numCourses) if u not in in_degree]\n        while stk:\n            u = stk.pop()\n            result.append(u)\n            for v in adj[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    stk.append(v)\n        return len(result) == numCourses",
    "explanation": "N/A",
    "time_complexity": "O(|V| + |E|)",
    "space_complexity": "O(|E|)"
  },
  {
    "title": "Maximize Distance to Closest Person",
    "difficulty": "MEDIUM",
    "category": "Array",
    "link": "https://leetcode.com/problems/maximize-distance-to-closest-person",
    "slug": "maximize-distance-to-closest-person",
    "description": "You are given an array representing a row of \nseats\n where \nseats[i] = 1\n represents a person sitting in the \ni\nth\n seat, and \nseats[i] = 0\n represents that the \ni\nth\n seat is empty \n(0-indexed)\n.\n\n\nThere is at least one empty seat, and at least one person sitting.\n\n\nAlex wants to sit in the seat such that the distance between him and the closest person to him is maximized. \n\n\nReturn \nthat maximum distance to the closest person\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n seats = [1,0,0,0,1,0,1]\n\nOutput:\n 2\n\nExplanation: \n\nIf Alex sits in the second open seat (i.e. seats[2]), then the closest person has distance 2.\nIf Alex sits in any other open seat, the closest person has distance 1.\nThus, the maximum distance to the closest person is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n seats = [1,0,0,0]\n\nOutput:\n 3\n\nExplanation: \n\nIf Alex sits in the last seat (i.e. seats[3]), the closest person is 3 seats away.\nThis is the maximum distance possible, so the answer is 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n seats = [0,1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= seats.length <= 2 * 10\n4\n\n\nseats[i]\n is \n0\n or \n1\n.\n\n\nAt least one seat is \nempty\n.\n\n\nAt least one seat is \noccupied\n.",
    "solution": "\nclass Solution(object):\n    def maxDistToClosest(self, seats):\n        \"\"\"\n        :type seats: List[int]\n        :rtype: int\n        \"\"\"\n        prev, result = -1, 1\n        for i in xrange(len(seats)):\n            if seats[i]:\n                if prev < 0:\n                    result = i\n                else:\n                    result = max(result, (i-prev)//2)\n                prev = i\n        return max(result, len(seats)-1-prev)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Spiral Matrix",
    "difficulty": "MEDIUM",
    "category": "Array, Matrix, Simulation",
    "link": "https://leetcode.com/problems/spiral-matrix",
    "slug": "spiral-matrix",
    "description": "Given an \nm x n\n \nmatrix\n, return \nall elements of the\n \nmatrix\n \nin spiral order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [1,2,3,6,9,8,7,4,5]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n\nOutput:\n [1,2,3,4,8,12,11,10,9,5,6,7]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 10\n\n\n-100 <= matrix[i][j] <= 100",
    "solution": "class Solution(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of integers\n    def spiralOrder(self, matrix):\n        result = []\n        if matrix == []:\n            return result\n\n        left, right, top, bottom = 0, len(matrix[0]) - 1, 0, len(matrix) - 1\n\n        while left <= right and top <= bottom:\n            for j in xrange(left, right + 1):\n                result.append(matrix[top][j])\n            for i in xrange(top + 1, bottom):\n                result.append(matrix[i][right])\n            for j in reversed(xrange(left, right + 1)):\n                if top < bottom:\n                    result.append(matrix[bottom][j])\n            for i in reversed(xrange(top + 1, bottom)):\n                if left < right:\n                    result.append(matrix[i][left])\n            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1\n\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Magnetic Force Between Two Balls",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search, Sorting",
    "link": "https://leetcode.com/problems/magnetic-force-between-two-balls",
    "slug": "magnetic-force-between-two-balls",
    "description": "In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has \nn\n empty baskets, the \ni\nth\n basket is at \nposition[i]\n, Morty has \nm\n balls and needs to distribute the balls into the baskets such that the \nminimum magnetic force\n between any two balls is \nmaximum\n.\n\n\nRick stated that magnetic force between two different balls at positions \nx\n and \ny\n is \n|x - y|\n.\n\n\nGiven the integer array \nposition\n and the integer \nm\n. Return \nthe required force\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n position = [1,2,3,4,7], m = 3\n\nOutput:\n 3\n\nExplanation:\n Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n position = [5,4,3,2,1,1000000000], m = 2\n\nOutput:\n 999999999\n\nExplanation:\n We can use baskets 1 and 1000000000.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == position.length\n\n\n2 <= n <= 10\n5\n\n\n1 <= position[i] <= 10\n9\n\n\nAll integers in \nposition\n are \ndistinct\n.\n\n\n2 <= m <= position.length",
    "solution": "class Solution(object):\n    def maxDistance(self, position, m):\n        \"\"\"\n        :type position: List[int]\n        :type m: int\n        :rtype: int\n        \"\"\"\n        def check(position, m, x):\n            count, prev = 1, position[0]\n            for i in xrange(1, len(position)):\n                if position[i]-prev >= x:\n                    count += 1\n                    prev = position[i]\n            return count >= m\n        \n        position.sort()\n        left, right = 1, position[-1]-position[0]\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(position, m, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right",
    "explanation": "N/A",
    "time_complexity": "O(nlogn + nlogr), r is the range of positions",
    "space_complexity": "O(1)"
  },
  {
    "title": "Happy Number",
    "difficulty": "EASY",
    "category": "Hash Table, Math, Two Pointers",
    "link": "https://leetcode.com/problems/happy-number",
    "slug": "happy-number",
    "description": "Write an algorithm to determine if a number \nn\n is happy.\n\n\nA \nhappy number\n is a number defined by the following process:\n\n\n\n\nStarting with any positive integer, replace the number by the sum of the squares of its digits.\n\n\nRepeat the process until the number equals 1 (where it will stay), or it \nloops endlessly in a cycle\n which does not include 1.\n\n\nThose numbers for which this process \nends in 1\n are happy.\n\n\n\n\nReturn \ntrue\n \nif\n \nn\n \nis a happy number, and\n \nfalse\n \nif not\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 19\n\nOutput:\n true\n\nExplanation:\n\n1\n2\n + 9\n2\n = 82\n8\n2\n + 2\n2\n = 68\n6\n2\n + 8\n2\n = 100\n1\n2\n + 0\n2\n + 0\n2\n = 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2\n31\n - 1",
    "solution": "class Solution(object):\n    # @param {integer} n\n    # @return {boolean}\n    def isHappy(self, n):\n        lookup = {}\n        while n != 1 and n not in lookup:\n            lookup[n] = True\n            n = self.nextNumber(n)\n        return n == 1\n\n    def nextNumber(self, n):\n        new = 0\n        for char in str(n):\n            new += int(char)**2\n        return new",
    "explanation": "N/A",
    "time_complexity": "O(k), where k is the steps to be happy number",
    "space_complexity": "O(k)"
  },
  {
    "title": "Convert Sorted Array to Binary Search Tree",
    "difficulty": "EASY",
    "category": "Array, Divide and Conquer, Tree, Binary Search Tree, Binary Tree",
    "link": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree",
    "slug": "convert-sorted-array-to-binary-search-tree",
    "description": "Given an integer array \nnums\n where the elements are sorted in \nascending order\n, convert \nit to a \nheight-balanced\n \nbinary search tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [-10,-3,0,5,9]\n\nOutput:\n [0,-3,9,-10,null,5]\n\nExplanation:\n [0,-10,5,null,-3,null,9] is also accepted:\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [1,3]\n\nOutput:\n [3,1]\n\nExplanation:\n [1,null,3] and [3,1] are both height-balanced BSTs.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nnums\n is sorted in a \nstrictly increasing\n order.",
    "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        return self.sortedArrayToBSTRecu(nums, 0, len(nums))\n\n    def sortedArrayToBSTRecu(self, nums, start, end):\n        if start == end:\n            return None\n        mid = start + self.perfect_tree_pivot(end - start)\n        node = TreeNode(nums[mid])\n        node.left = self.sortedArrayToBSTRecu(nums, start, mid)\n        node.right = self.sortedArrayToBSTRecu(nums, mid + 1, end)\n        return node\n\n    def perfect_tree_pivot(self, n):\n        \"\"\"\n        Find the point to partition n keys for a perfect binary search tree\n        \"\"\"\n        x = 1\n        # find a power of 2 <= n//2\n        # while x <= n//2:  # this loop could probably be written more elegantly :)\n        #     x *= 2\n        x = 1 << (n.bit_length() - 1)  # use the left bit shift, same as multiplying x by 2**n-1\n\n        if x // 2 - 1 <= (n - x):\n            return x - 1  # case 1: the left subtree of the root is perfect and the right subtree has less nodes\n        else:\n            return n - x // 2  # case 2 == n - (x//2 - 1) - 1 : the left subtree of the root\n                               # has more nodes and the right subtree is perfect.\nclass Solution2(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        self.iterator = iter(nums)\n        return self.helper(0, len(nums))\n    \n    def helper(self, start, end):\n        if start == end:\n            return None\n        \n        mid = (start + end) // 2\n        left = self.helper(start, mid)\n        current = TreeNode(next(self.iterator))\n        current.left = left\n        current.right = self.helper(mid+1, end)\n        return current",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(logn)"
  },
  {
    "title": "Distribute Candies Among Children II",
    "difficulty": "MEDIUM",
    "category": "Math, Combinatorics, Enumeration",
    "link": "https://leetcode.com/problems/distribute-candies-among-children-ii",
    "slug": "distribute-candies-among-children-ii",
    "description": "You are given two positive integers \nn\n and \nlimit\n.\n\n\nReturn \nthe \ntotal number\n of ways to distribute \nn\n \ncandies among \n3\n children such that no child gets more than \nlimit\n candies.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 5, limit = 2\n\nOutput:\n 3\n\nExplanation:\n There are 3 ways to distribute 5 candies such that no child gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3, limit = 3\n\nOutput:\n 10\n\nExplanation:\n There are 10 ways to distribute 3 candies such that no child gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1), (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1), (2, 1, 0) and (3, 0, 0).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n6\n\n\n1 <= limit <= 10\n6",
    "solution": "\n# stars and bars, combinatorics, principle of inclusion-exclusion class Solution(object):\n    def distributeCandies(self, n, limit):\n        \"\"\"\n        :type n: int\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        def nCr(n, r):  # Time: O(n), Space: O(1)\n            if not 0 <= r <= n:\n                return 0\n            if n-r < r:\n                r = n-r\n            c = 1\n            for k in xrange(1, r+1):\n                c *= n-k+1\n                c //= k\n            return c\n        \n        def nHr(n, r):\n            return nCr(n+(r-1), r-1)\n    \n        R = 3\n        return sum((-1 if r%2 else 1) * nCr(R, r) * nHr(n-r*(limit+1), R)for r in xrange(R+1))\n\n\n# optimized brute forceclass Solution2(object):\n    def distributeCandies(self, n, limit):\n        \"\"\"\n        :type n: int\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        return sum(min(limit, n-i)-max((n-i)-limit, 0)+1 for i in xrange(max(n-2*limit, 0), min(limit, n)+1))",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Find Eventual Safe States",
    "difficulty": "MEDIUM",
    "category": "Depth-First Search, Breadth-First Search, Graph, Topological Sort",
    "link": "https://leetcode.com/problems/find-eventual-safe-states",
    "slug": "find-eventual-safe-states",
    "description": "There is a directed graph of \nn\n nodes with each node labeled from \n0\n to \nn - 1\n. The graph is represented by a \n0-indexed\n 2D integer array \ngraph\n where \ngraph[i]\n is an integer array of nodes adjacent to node \ni\n, meaning there is an edge from node \ni\n to each node in \ngraph[i]\n.\n\n\nA node is a \nterminal node\n if there are no outgoing edges. A node is a \nsafe node\n if every possible path starting from that node leads to a \nterminal node\n (or another safe node).\n\n\nReturn \nan array containing all the \nsafe nodes\n of the graph\n. The answer should be sorted in \nascending\n order.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n graph = [[1,2],[2,3],[5],[0],[5],[],[]]\n\nOutput:\n [2,4,5,6]\n\nExplanation:\n The given graph is shown above.\nNodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.\nEvery path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.\n\n\nExample 2:\n\n\n\n\nInput:\n graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\n\nOutput:\n [4]\n\nExplanation:\n\nOnly node 4 is a terminal node, and every path starting at node 4 leads to node 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == graph.length\n\n\n1 <= n <= 10\n4\n\n\n0 <= graph[i].length <= n\n\n\n0 <= graph[i][j] <= n - 1\n\n\ngraph[i]\n is sorted in a strictly increasing order.\n\n\nThe graph may contain self-loops.\n\n\nThe number of edges in the graph will be in the range \n[1, 4 * 10\n4\n]\n.",
    "solution": "class Solution(object):\n    def eventualSafeNodes(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        WHITE, GRAY, BLACK = range(3)\n\n        def dfs(graph, node, lookup):\n            if lookup[node] != WHITE:\n                return lookup[node] == BLACK\n            lookup[node] = GRAY\n            if any(not dfs(graph, child, lookup) for child in graph[node]):\n                return False\n            lookup[node] = BLACK\n            return True\n\n        lookup = [WHITE]*len(graph)\n        return filter(lambda node: dfs(graph, node, lookup), xrange(len(graph)))",
    "explanation": "N/A",
    "time_complexity": "O(|V| + |E|)",
    "space_complexity": "O(|V|)"
  },
  {
    "title": "Combinations",
    "difficulty": "MEDIUM",
    "category": "Backtracking",
    "link": "https://leetcode.com/problems/combinations",
    "slug": "combinations",
    "description": "Given two integers \nn\n and \nk\n, return \nall possible combinations of\n \nk\n \nnumbers chosen from the range\n \n[1, n]\n.\n\n\nYou may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 4, k = 2\n\nOutput:\n [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n\nExplanation:\n There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1, k = 1\n\nOutput:\n [[1]]\n\nExplanation:\n There is 1 choose 1 = 1 total combination.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 20\n\n\n1 <= k <= n",
    "solution": "class Solution(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if k > n:\n            return []\n        nums, idxs = range(1, n+1), range(k)\n        result = [[nums[i] for i in idxs]]\n        while True:\n            for i in reversed(xrange(k)):\n                if idxs[i] != i+n-k:\n                    break\n            else:\n                break\n            idxs[i] += 1\n            for j in xrange(i+1, k):\n                idxs[j] = idxs[j-1]+1\n            result.append([nums[i] for i in idxs])\n        return result\n\nclass Solution2(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result, combination = [], []\n        i = 1\n        while True:\n            if len(combination) == k:\n                result.append(combination[:])\n            if len(combination) == k or \\\n               len(combination)+(n-i+1) < k:\n                if not combination:\n                    break\n                i = combination.pop()+1\n            else:\n                combination.append(i)\n                i += 1\n        return result\n\nclass Solution3(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def combineDFS(n, start, intermediate, k, result):\n            if k == 0:\n                result.append(intermediate[:])\n                return\n            for i in xrange(start, n):\n                intermediate.append(i+1)\n                combineDFS(n, i+1, intermediate, k-1, result)\n                intermediate.pop()\n\n        result = []\n        combineDFS(n, 0, [], k, result)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(k * C(n, k))",
    "space_complexity": "O(k)"
  },
  {
    "title": "Design Parking System",
    "difficulty": "EASY",
    "category": "Design, Simulation, Counting",
    "link": "https://leetcode.com/problems/design-parking-system",
    "slug": "design-parking-system",
    "description": "Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.\n\n\nImplement the \nParkingSystem\n class:\n\n\n\n\nParkingSystem(int big, int medium, int small)\n Initializes object of the \nParkingSystem\n class. The number of slots for each parking space are given as part of the constructor.\n\n\nbool addCar(int carType)\n Checks whether there is a parking space of \ncarType\n for the car that wants to get into the parking lot. \ncarType\n can be of three kinds: big, medium, or small, which are represented by \n1\n, \n2\n, and \n3\n respectively. \nA car can only park in a parking space of its \ncarType\n. If there is no space available, return \nfalse\n, else park the car in that size space and return \ntrue\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"]\n[[1, 1, 0], [1], [2], [3], [1]]\n\nOutput\n\n[null, true, true, false, false]\n\n\nExplanation\n\nParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\nparkingSystem.addCar(1); // return true because there is 1 available slot for a big car\nparkingSystem.addCar(2); // return true because there is 1 available slot for a medium car\nparkingSystem.addCar(3); // return false because there is no available slot for a small car\nparkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= big, medium, small <= 1000\n\n\ncarType\n is \n1\n, \n2\n, or \n3\n\n\nAt most \n1000\n calls will be made to \naddCar",
    "solution": "class ParkingSystem(object):\n\n    def __init__(self, big, medium, small):\n        \"\"\"\n        :type big: int\n        :type medium: int\n        :type small: int\n        \"\"\"\n        self.__space = [0, big, medium, small]\n\n    def addCar(self, carType):\n        \"\"\"\n        :type carType: int\n        :rtype: bool\n        \"\"\"\n        if self.__space[carType] > 0:\n            self.__space[carType] -= 1\n            return True\n        return False",
    "explanation": "N/A",
    "time_complexity": "O(1)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Divisible and Non-divisible Sums Difference",
    "difficulty": "EASY",
    "category": "Math",
    "link": "https://leetcode.com/problems/divisible-and-non-divisible-sums-difference",
    "slug": "divisible-and-non-divisible-sums-difference",
    "description": "You are given positive integers \nn\n and \nm\n.\n\n\nDefine two integers as follows:\n\n\n\n\nnum1\n: The sum of all integers in the range \n[1, n]\n (both \ninclusive\n) that are \nnot divisible\n by \nm\n.\n\n\nnum2\n: The sum of all integers in the range \n[1, n]\n (both \ninclusive\n) that are \ndivisible\n by \nm\n.\n\n\n\n\nReturn \nthe integer\n \nnum1 - num2\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 10, m = 3\n\nOutput:\n 19\n\nExplanation:\n In the given example:\n- Integers in the range [1, 10] that are not divisible by 3 are [1,2,4,5,7,8,10], num1 is the sum of those integers = 37.\n- Integers in the range [1, 10] that are divisible by 3 are [3,6,9], num2 is the sum of those integers = 18.\nWe return 37 - 18 = 19 as the answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 5, m = 6\n\nOutput:\n 15\n\nExplanation:\n In the given example:\n- Integers in the range [1, 5] that are not divisible by 6 are [1,2,3,4,5], num1 is the sum of those integers = 15.\n- Integers in the range [1, 5] that are divisible by 6 are [], num2 is the sum of those integers = 0.\nWe return 15 - 0 = 15 as the answer.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 5, m = 1\n\nOutput:\n -15\n\nExplanation:\n In the given example:\n- Integers in the range [1, 5] that are not divisible by 1 are [], num1 is the sum of those integers = 0.\n- Integers in the range [1, 5] that are divisible by 1 are [1,2,3,4,5], num2 is the sum of those integers = 15.\nWe return 0 - 15 = -15 as the answer.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n, m <= 1000",
    "solution": "\n# mathclass Solution(object):\n    def differenceOfSums(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        def arithmetic_progression_sum(a, d, l):\n            return (a+(a+(l-1)*d))*l//2\n    \n        return arithmetic_progression_sum(1, 1, n) - 2*arithmetic_progression_sum(m, m, n//m)\n\n\n# mathclass Solution2(object):\n    def differenceOfSums(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        return (n+1)*n//2 - 2*(((n//m+1)*(n//m)//2)*m)",
    "explanation": "N/A",
    "time_complexity": "O(1)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Rotate List",
    "difficulty": "MEDIUM",
    "category": "Linked List, Two Pointers",
    "link": "https://leetcode.com/problems/rotate-list",
    "slug": "rotate-list",
    "description": "Given the \nhead\n of a linked list, rotate the list to the right by \nk\n places.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 2\n\nOutput:\n [4,5,1,2,3]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [0,1,2], k = 4\n\nOutput:\n [2,0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 500]\n.\n\n\n-100 <= Node.val <= 100\n\n\n0 <= k <= 2 * 10\n9",
    "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        n, cur = 1, head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        cur.next = head\n\n        cur, tail = head, cur\n        for _ in xrange(n - k % n):\n            tail = cur\n            cur = cur.next\n        tail.next = None\n\n        return cur",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Largest Rectangle in Histogram",
    "difficulty": "HARD",
    "category": "Array, Stack, Monotonic Stack",
    "link": "https://leetcode.com/problems/largest-rectangle-in-histogram",
    "slug": "largest-rectangle-in-histogram",
    "description": "Given an array of integers \nheights\n representing the histogram's bar height where the width of each bar is \n1\n, return \nthe area of the largest rectangle in the histogram\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [2,1,5,6,2,3]\n\nOutput:\n 10\n\nExplanation:\n The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n heights = [2,4]\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= heights.length <= 10\n5\n\n\n0 <= heights[i] <= 10\n4",
    "solution": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stk, result = [-1], 0\n        for i in xrange(len(heights)+1):\n            while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):\n                result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))\n            stk.append(i) \n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Design In-Memory File System",
    "difficulty": "HARD",
    "category": "Hash Table, String, Design, Trie, Sorting",
    "link": "https://leetcode.com/problems/design-in-memory-file-system",
    "slug": "design-in-memory-file-system",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "#        mkdir: O(l)\n#        addContentToFile: O(l + c), c is the content size\n#        readContentFromFile: O(l + c)\nclass TrieNode(object):\n\n    def __init__(self):\n        self.is_file = False\n        self.children = {}\n        self.content = \"\"\nclass FileSystem(object):\n\n    def __init__(self):\n        self.__root = TrieNode()\n\n\n    def ls(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: List[str]\n        \"\"\"\n        curr = self.__getNode(path)\n\n        if curr.is_file:\n            return [self.__split(path, '/')[-1]]\n\n        return sorted(curr.children.keys())\n\n\n    def mkdir(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: void\n        \"\"\"\n        curr = self.__putNode(path)\n        curr.is_file = False\n\n\n    def addContentToFile(self, filePath, content):\n        \"\"\"\n        :type filePath: str\n        :type content: str\n        :rtype: void\n        \"\"\"\n        curr = self.__putNode(filePath)\n        curr.is_file = True\n        curr.content += content\n\n\n    def readContentFromFile(self, filePath):\n        \"\"\"\n        :type filePath: str\n        :rtype: str\n        \"\"\"\n        return self.__getNode(filePath).content\n\n\n    def __getNode(self, path):\n        curr = self.__root\n        for s in self.__split(path, '/'):\n            curr = curr.children[s]\n        return curr\n\n\n    def __putNode(self, path):\n        curr = self.__root\n        for s in self.__split(path, '/'):\n            if s not in curr.children:\n                curr.children[s] = TrieNode()\n            curr = curr.children[s]\n        return curr\n\n\n    def __split(self, path, delim):\n        if path == '/':\n            return []\n        return path.split('/')[1:]",
    "explanation": "N/A",
    "time_complexity": "ls: O(l + klogk), l is the path length, k is the number of entries in the last level directory",
    "space_complexity": "O(n + s), n is the number of dir/file nodes, s is the total content size."
  },
  {
    "title": "Decode String",
    "difficulty": "MEDIUM",
    "category": "String, Stack, Recursion",
    "link": "https://leetcode.com/problems/decode-string",
    "slug": "decode-string",
    "description": "Given an encoded string, return its decoded string.\n\n\nThe encoding rule is: \nk[encoded_string]\n, where the \nencoded_string\n inside the square brackets is being repeated exactly \nk\n times. Note that \nk\n is guaranteed to be a positive integer.\n\n\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, \nk\n. For example, there will not be input like \n3a\n or \n2[4]\n.\n\n\nThe test cases are generated so that the length of the output will never exceed \n10\n5\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"3[a]2[bc]\"\n\nOutput:\n \"aaabcbc\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"3[a2[c]]\"\n\nOutput:\n \"accaccacc\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"2[abc]3[cd]ef\"\n\nOutput:\n \"abcabccdcdcdef\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 30\n\n\ns\n consists of lowercase English letters, digits, and square brackets \n'[]'\n.\n\n\ns\n is guaranteed to be \na valid\n input.\n\n\nAll the integers in \ns\n are in the range \n[1, 300]\n.",
    "solution": "class Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n, curr, nums, strs = 0, [], [], []\n        for c in s:\n            if c.isdigit():\n                n = n*10 + ord(c)-ord('0')\n            elif c.isalpha():\n                curr.append(c)\n            elif c == '[':\n                nums.append(n)\n                strs.append(curr)\n                n, curr = 0, []\n            elif c == ']':\n                strs[-1].extend(curr*nums.pop())\n                curr = strs.pop()\n        return \"\".join(curr)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Binary Tree Level Order Traversal",
    "difficulty": "MEDIUM",
    "category": "Tree, Breadth-First Search, Binary Tree",
    "link": "https://leetcode.com/problems/binary-tree-level-order-traversal",
    "slug": "binary-tree-level-order-traversal",
    "description": "Given the \nroot\n of a binary tree, return \nthe level order traversal of its nodes' values\n. (i.e., from left to right, level by level).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n [[3],[9,20],[15,7]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n [[1]]\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 2000]\n.\n\n\n-1000 <= Node.val <= 1000",
    "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return a list of lists of integers\n    def levelOrder(self, root):\n        if root is None:\n            return []\n        result, current = [], [root]\n        while current:\n            next_level, vals = [], []\n            for node in current:\n                vals.append(node.val)\n                if node.left:\n                    next_level.append(node.left)\n                if node.right:\n                    next_level.append(node.right)\n            current = next_level\n            result.append(vals)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Subarray Sum Equals K",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Prefix Sum",
    "link": "https://leetcode.com/problems/subarray-sum-equals-k",
    "slug": "subarray-sum-equals-k",
    "description": "Given an array of integers \nnums\n and an integer \nk\n, return \nthe total number of subarrays whose sum equals to\n \nk\n.\n\n\nA subarray is a contiguous \nnon-empty\n sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,1,1], k = 2\n\nOutput:\n 2\n\nExample 2:\n\n\nInput:\n nums = [1,2,3], k = 3\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2 * 10\n4\n\n\n-1000 <= nums[i] <= 1000\n\n\n-10\n7\n <= k <= 10\n7",
    "solution": "\nimport collections\n\nclass Solution(object):\n    def subarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        accumulated_sum = 0\n        lookup = collections.defaultdict(int)\n        lookup[0] += 1\n        for num in nums:\n            accumulated_sum += num\n            result += lookup[accumulated_sum - k]\n            lookup[accumulated_sum] += 1\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Count Zero Request Servers",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Sliding Window, Sorting",
    "link": "https://leetcode.com/problems/count-zero-request-servers",
    "slug": "count-zero-request-servers",
    "description": "You are given an integer \nn\n denoting the total number of servers and a \n2D\n \n0-indexed \ninteger array \nlogs\n, where \nlogs[i] = [server_id, time]\n denotes that the server with id \nserver_id\n received a request at time \ntime\n.\n\n\nYou are also given an integer \nx\n and a \n0-indexed\n integer array \nqueries\n.\n\n\nReturn \na \n0-indexed\n integer array\n \narr\n \nof length\n \nqueries.length\n \nwhere\n \narr[i]\n \nrepresents the number of servers that \ndid not receive\n any requests during the time interval\n \n[queries[i] - x, queries[i]]\n.\n\n\nNote that the time intervals are inclusive.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 3, logs = [[1,3],[2,6],[1,5]], x = 5, queries = [10,11]\n\nOutput:\n [1,2]\n\nExplanation:\n \nFor queries[0]: The servers with ids 1 and 2 get requests in the duration of [5, 10]. Hence, only server 3 gets zero requests.\nFor queries[1]: Only the server with id 2 gets a request in duration of [6,11]. Hence, the servers with ids 1 and 3 are the only servers that do not receive any requests during that time period.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3, logs = [[2,4],[2,1],[1,2],[3,1]], x = 2, queries = [3,4]\n\nOutput:\n [0,1]\n\nExplanation:\n \nFor queries[0]: All servers get at least one request in the duration of [1, 3].\nFor queries[1]: Only server with id 3 gets no request in the duration [2,4].\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5\n\n\n1 <= logs.length <= 10\n5\n\n\n1 <= queries.length <= 10\n5\n\n\nlogs[i].length == 2\n\n\n1 <= logs[i][0] <= n\n\n\n1 <= logs[i][1] <= 10\n6\n\n\n1 <= x <= 10\n5\n\n\nx < queries[i] <= 10\n6",
    "solution": "\n# sort, two pointersclass Solution(object):\n    def countServers(self, n, logs, x, queries):\n        \"\"\"\n        :type n: int\n        :type logs: List[List[int]]\n        :type x: int\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        logs.sort(key=lambda x:x[1])\n        result = [0]*len(queries)\n        cnt = [0]*n\n        curr = left = right = 0\n        for t, i in sorted((t, i) for i, t in enumerate(queries)):\n            while right < len(logs) and logs[right][1] <= t:\n                if cnt[logs[right][0]-1] == 0:\n                    curr += 1\n                cnt[logs[right][0]-1] += 1\n                right += 1\n            while left < right and logs[left][1] < t-x:\n                cnt[logs[left][0]-1] -= 1\n                if cnt[logs[left][0]-1] == 0:\n                    curr -= 1\n                left += 1\n            result[i] = n-curr\n        return result\n\n\n# sort, line sweepclass Solution2(object):\n    def countServers(self, n, logs, x, queries):\n        \"\"\"\n        :type n: int\n        :type logs: List[List[int]]\n        :type x: int\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        events = []\n        for sid, t in logs:\n            events.append((t, +1, sid-1))\n            events.append((t+x+1, -1, sid-1))\n        events.append((float(\"inf\"), 0, 0))\n        events.sort()\n\n        events2 = []\n        for i, t in enumerate(queries):\n            events2.append((t, i))\n        events2.sort(reverse=True)\n\n        result = [0]*len(queries)\n        cnt = [0]*n\n        curr = 0\n        for t, c, i in events:\n            while events2 and events2[-1][0] < t:                \n                result[events2.pop()[1]] += n-curr\n            if cnt[i] == 0:\n                curr += 1\n            cnt[i] += c\n            if cnt[i] == 0:\n                curr -= 1\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(nlogn + mlogm)",
    "space_complexity": "O(n + m)"
  },
  {
    "title": "K Closest Points to Origin",
    "difficulty": "MEDIUM",
    "category": "Array, Math, Divide and Conquer, Geometry, Sorting, Heap (Priority Queue), Quickselect",
    "link": "https://leetcode.com/problems/k-closest-points-to-origin",
    "slug": "k-closest-points-to-origin",
    "description": "Given an array of \npoints\n where \npoints[i] = [x\ni\n, y\ni\n]\n represents a point on the \nX-Y\n plane and an integer \nk\n, return the \nk\n closest points to the origin \n(0, 0)\n.\n\n\nThe distance between two points on the \nX-Y\n plane is the Euclidean distance (i.e., \n√(x\n1\n - x\n2\n)\n2\n + (y\n1\n - y\n2\n)\n2\n).\n\n\nYou may return the answer in \nany order\n. The answer is \nguaranteed\n to be \nunique\n (except for the order that it is in).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[1,3],[-2,2]], k = 1\n\nOutput:\n [[-2,2]]\n\nExplanation:\n\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[3,3],[5,-1],[-2,4]], k = 2\n\nOutput:\n [[3,3],[-2,4]]\n\nExplanation:\n The answer [[-2,4],[3,3]] would also be accepted.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= points.length <= 10\n4\n\n\n-10\n4\n <= x\ni\n, y\ni\n <= 10\n4",
    "solution": "\n# quick select solution\nfrom random import randint\n\nclass Solution(object):\n    def kClosest(self, points, K):\n        \"\"\"\n        :type points: List[List[int]]\n        :type K: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def dist(point):\n            return point[0]**2 + point[1]**2\n        \n        def kthElement(nums, k, compare):\n            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):\n                new_pivot_idx = left\n                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                for i in xrange(left, right):\n                    if compare(nums[i], nums[right]):\n                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                        new_pivot_idx += 1\n\n                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                return new_pivot_idx\n\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)\n                if new_pivot_idx == k:\n                    return\n                elif new_pivot_idx > k:\n                    right = new_pivot_idx - 1\n                else:  # new_pivot_idx < k.\n                    left = new_pivot_idx + 1\n                    \n        kthElement(points, K-1, lambda a, b: dist(a) < dist(b))\n        return points[:K]\n\n    \nimport heapq\n\nclass Solution2(object):\n    def kClosest(self, points, K):\n        \"\"\"\n        :type points: List[List[int]]\n        :type K: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def dist(point):\n            return point[0]**2 + point[1]**2\n        \n        max_heap = []\n        for point in points:\n            heapq.heappush(max_heap, (-dist(point), point))\n            if len(max_heap) > K:\n                heapq.heappop(max_heap)\n        return [heapq.heappop(max_heap)[1] for _ in xrange(len(max_heap))]",
    "explanation": "N/A",
    "time_complexity": "O(nlogk)",
    "space_complexity": "O(k)"
  },
  {
    "title": "Evaluate Division",
    "difficulty": "MEDIUM",
    "category": "Array, String, Depth-First Search, Breadth-First Search, Union Find, Graph, Shortest Path",
    "link": "https://leetcode.com/problems/evaluate-division",
    "slug": "evaluate-division",
    "description": "You are given an array of variable pairs \nequations\n and an array of real numbers \nvalues\n, where \nequations[i] = [A\ni\n, B\ni\n]\n and \nvalues[i]\n represent the equation \nA\ni\n / B\ni\n = values[i]\n. Each \nA\ni\n or \nB\ni\n is a string that represents a single variable.\n\n\nYou are also given some \nqueries\n, where \nqueries[j] = [C\nj\n, D\nj\n]\n represents the \nj\nth\n query where you must find the answer for \nC\nj\n / D\nj\n = ?\n.\n\n\nReturn \nthe answers to all queries\n. If a single answer cannot be determined, return \n-1.0\n.\n\n\nNote:\n The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\n\n\nNote: \nThe variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n\nOutput:\n [6.00000,0.50000,-1.00000,1.00000,-1.00000]\n\nExplanation:\n \nGiven: \na / b = 2.0\n, \nb / c = 3.0\n\nqueries are: \na / c = ?\n, \nb / a = ?\n, \na / e = ?\n, \na / a = ?\n, \nx / x = ? \n\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]\nnote: x is undefined => -1.0\n\n\nExample 2:\n\n\n\n\nInput:\n equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n\nOutput:\n [3.75000,0.40000,5.00000,0.20000]\n\n\n\nExample 3:\n\n\n\n\nInput:\n equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n\nOutput:\n [0.50000,2.00000,-1.00000,-1.00000]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= equations.length <= 20\n\n\nequations[i].length == 2\n\n\n1 <= A\ni\n.length, B\ni\n.length <= 5\n\n\nvalues.length == equations.length\n\n\n0.0 < values[i] <= 20.0\n\n\n1 <= queries.length <= 20\n\n\nqueries[i].length == 2\n\n\n1 <= C\nj\n.length, D\nj\n.length <= 5\n\n\nA\ni\n, B\ni\n, C\nj\n, D\nj\n consist of lower case English letters and digits.",
    "solution": "#                                     , using  both results in α(n) ~= O(1)\n\nimport collections\nimport itertools\n\nclass UnionFind(object):\n    def __init__(self):\n        self.set = {}\n        self.rank = collections.Counter()\n\n    def find_set(self, x):\n        xp, xr = self.set.setdefault(x, (x, 1.0))\n        if x != xp:\n            pp, pr = self.find_set(xp)  # path compression.\n            self.set[x] = (pp, xr*pr)  # x/pp = xr*pr\n        return self.set[x]\n\n    def union_set(self, x, y, r):\n        (xp, xr), (yp, yr) =  map(self.find_set, (x, y))\n        if xp == yp:\n            return False\n        if self.rank[xp] < self.rank[yp]:  # union by rank\n            # to make x/yp = r*yr and merge xp into yp\n            # => since x/xp = xr, we can merge with xp/yp = r*yr/xr \n            self.set[xp] = (yp, r*yr/xr)\n        elif self.rank[xp] > self.rank[yp]:\n            # to make y/xp = 1/r*xr and merge xp into yp\n            # => since y/yp = yr, we can merge with yp/xp = 1/r*xr/yr \n            self.set[yp] = (xp, 1.0/r*xr/yr)\n        else:\n            # to make y/xp = 1/r*xr and merge xp into yp\n            # => since y/yp = yr, we can merge with yp/xp = 1/r*xr/yr \n            self.set[yp] = (xp, 1.0/r*xr/yr)\n            self.rank[xp] += 1 \n        return True\n\n    def query_set(self, x, y):\n        if x not in self.set or y not in self.set:\n            return -1.0\n        (xp, xr), (yp, yr) = map(self.find_set, (x, y))\n        return xr/yr if xp == yp else -1.0\n\nclass UnionFindPathCompressionOnly(object):\n    def __init__(self):\n        self.set = {}\n\n    def find_set(self, x):\n        xp, xr = self.set.setdefault(x, (x, 1.0))\n        if x != xp:\n            pp, pr = self.find_set(xp)  # path compression.\n            self.set[x] = (pp, xr*pr)  # x/pp = xr*pr\n        return self.set[x]\n\n    def union_set(self, x, y, r):\n        (xp, xr), (yp, yr) =  map(self.find_set, (x, y))\n        if xp == yp:\n            return False\n        # to make x/yp = r*yr and merge xp into yp\n        # => since x/xp = xr, we can merge with xp/yp = r*yr/xr \n        self.set[xp] = (yp, r*yr/xr)\n        return True\n\n    def query_set(self, x, y):\n        if x not in self.set or y not in self.set:\n            return -1.0\n        (xp, xr), (yp, yr) = map(self.find_set, (x, y))\n        return xr/yr if xp == yp else -1.0\n\nclass Solution(object):\n    def calcEquation(self, equations, values, queries):\n        \"\"\"\n        :type equations: List[List[str]]\n        :type values: List[float]\n        :type queries: List[List[str]]\n        :rtype: List[float]\n        \"\"\"\n        union_find = UnionFind()\n        for (a, b), k in itertools.izip(equations, values):\n            union_find.union_set(a, b, k)\n        return [union_find.query_set(a, b) for a, b in queries]\n\n\n# bfs solution\nimport collections\nimport itertools\n\nclass Solution2(object):\n    def calcEquation(self, equations, values, queries):\n        \"\"\"\n        :type equations: List[List[str]]\n        :type values: List[float]\n        :type queries: List[List[str]]\n        :rtype: List[float]\n        \"\"\"\n        adj = collections.defaultdict(dict)\n        for (a, b), k in itertools.izip(equations, values):\n            adj[a][b] = k\n            adj[b][a] = 1.0/k\n\n        def bfs(adj, a, b, lookup):\n            if a not in adj or b not in adj:\n                return -1.0\n            if (a, b) in lookup:\n                return lookup[a, b]\n            visited = {a}\n            q = collections.deque([(a, 1.0)])\n            while q:\n                u, val = q.popleft()\n                if u == b:\n                    lookup[a, b] = val\n                    return val\n                for v, k in adj[u].iteritems():\n                    if v in visited:\n                        continue                    \n                    visited.add(v)\n                    q.append((v, val*k))\n            lookup[a, b] = -1.0\n            return -1.0\n\n        lookup = {}\n        return [bfs(adj, a, b, lookup) for a, b in queries]\n\n\nimport collections\nimport itertools\n\n\n# variant of floyd–warshall algorithm solutionclass Solution3(object):\n    def calcEquation(self, equations, values, queries):\n        \"\"\"\n        :type equations: List[List[str]]\n        :type values: List[float]\n        :type queries: List[List[str]]\n        :rtype: List[float]\n        \"\"\"\n        adj = collections.defaultdict(dict)\n        for (a, b), k in itertools.izip(equations, values):\n            adj[a][a] = adj[b][b] = 1.0\n            adj[a][b] = k\n            adj[b][a] = 1.0/k\n        for k in adj:\n            for i in adj[k]:\n                for j in adj[k]:\n                    adj[i][j] = adj[i][k]*adj[k][j]\n        return [adj[a].get(b, -1.0) for a, b in queries]\n\n    \nimport collections\n\nclass Solution4(object):\n    def calcEquation(self, equations, values, query):\n        \"\"\"\n        :type equations: List[List[str]]\n        :type values: List[float]\n        :type query: List[List[str]]\n        :rtype: List[float]\n        \"\"\"\n        def check(up, down, lookup, visited):\n            if up in lookup and down in lookup[up]:\n                return (True, lookup[up][down])\n            for k, v in lookup[up].iteritems():\n                if k not in visited:\n                    visited.add(k)\n                    tmp = check(k, down, lookup, visited)\n                    if tmp[0]:\n                        return (True, v * tmp[1])\n            return (False, 0)\n\n        lookup = collections.defaultdict(dict)\n        for i, e in enumerate(equations):\n            lookup[e[0]][e[1]] = values[i]\n            if values[i]:\n                lookup[e[1]][e[0]] = 1.0 / values[i]\n\n        result = []\n        for q in query:\n            visited = set()\n            tmp = check(q[0], q[1], lookup, visited)\n            result.append(tmp[1] if tmp[0] else -1)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(e + q * n), at most O(n^3 + q)",
    "space_complexity": "O(e)"
  }
]