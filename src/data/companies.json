{
  "Amazon": [
    {
      "title": "Two Sum",
      "difficulty": "EASY",
      "category": "Array, Hash Table",
      "link": "https://leetcode.com/problems/two-sum",
      "slug": "two-sum",
      "description": "Given an array of integers \nnums\n and an integer \ntarget\n, return \nindices of the two numbers such that they add up to \ntarget\n.\n\n\nYou may assume that each input would have \nexactly\n one solution\n, and you may not use the \nsame\n element twice.\n\n\nYou can return the answer in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,7,11,15], target = 9\n\nOutput:\n [0,1]\n\nExplanation:\n Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,4], target = 6\n\nOutput:\n [1,2]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,3], target = 6\n\nOutput:\n [0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n-10\n9\n <= target <= 10\n9\n\n\nOnly one valid answer exists.\n\n\n\n\n \n\n\nFollow-up: \nCan you come up with an algorithm that is less than \nO(n\n2\n)\n \ntime complexity?",
      "solution": "from typing import List\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n\n        for idx in range(len(nums)):\n            val = target - nums[idx]\n            if val in seen:\n                return [idx, seen[val]]\n            else:\n                seen[nums[idx]] = idx",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Best Time to Buy and Sell Stock",
      "difficulty": "EASY",
      "category": "Array, Dynamic Programming",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
      "slug": "best-time-to-buy-and-sell-stock",
      "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nYou want to maximize your profit by choosing a \nsingle day\n to buy one stock and choosing a \ndifferent day in the future\n to sell that stock.\n\n\nReturn \nthe maximum profit you can achieve from this transaction\n. If you cannot achieve any profit, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 5\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transactions are done and the max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n4",
      "solution": "class Solution:\n    def maxProfit(self, prices) -> int:\n        profit = 0\n        buy = prices[0]\n\n        for price in range(1, len(prices)):\n            profit = max(profit, prices[price] - buy)\n            buy = min(prices[price], buy)\n\n        return profit",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "LRU Cache",
      "difficulty": "MEDIUM",
      "category": "Hash Table, Linked List, Design, Doubly-Linked List",
      "link": "https://leetcode.com/problems/lru-cache",
      "slug": "lru-cache",
      "description": "Design a data structure that follows the constraints of a \nLeast Recently Used (LRU) cache\n.\n\n\nImplement the \nLRUCache\n class:\n\n\n\n\nLRUCache(int capacity)\n Initialize the LRU cache with \npositive\n size \ncapacity\n.\n\n\nint get(int key)\n Return the value of the \nkey\n if the key exists, otherwise return \n-1\n.\n\n\nvoid put(int key, int value)\n Update the value of the \nkey\n if the \nkey\n exists. Otherwise, add the \nkey-value\n pair to the cache. If the number of keys exceeds the \ncapacity\n from this operation, \nevict\n the least recently used key.\n\n\n\n\nThe functions \nget\n and \nput\n must each run in \nO(1)\n average time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n\nOutput\n\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n\nExplanation\n\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= capacity <= 3000\n\n\n0 <= key <= 10\n4\n\n\n0 <= value <= 10\n5\n\n\nAt most \n2 * 10\n5\n calls will be made to \nget\n and \nput\n.",
      "solution": "\nimport collections\n\n\n# using OrderedDictclass LRUCache(object):\n    def __init__(self, capacity):\n        self.cache = collections.OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        val = self.cache[key]\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.cache and len(self.cache) == self.capacity:\n            self.cache.popitem(last=False)\n        self.__update(key, val)\n    \n    def __update(self, key, val):\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = val\n\n\n\nclass ListNode(object):\n    def __init__(self, key, val):\n        self.val = val\n        self.key = key\n        self.next = None\n        self.prev = None\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\nclass LRUCache2(object):\n\n    def __init__(self, capacity):\n        self.list = LinkedList()\n        self.dict = {}\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.dict:\n            return -1\n        val = self.dict[key].val\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.dict and len(self.dict) == self.capacity:\n            del self.dict[self.list.head.key]\n            self.list.delete(self.list.head)\n        self.__update(key, val)\n\n    def __update(self, key, val):\n        if key in self.dict:\n            self.list.delete(self.dict[key])\n        node = ListNode(key, val)\n        self.list.insert(node)\n        self.dict[key] = node",
      "explanation": "N/A",
      "time_complexity": "O(1), per operation.",
      "space_complexity": "O(k), k is the capacity of cache."
    },
    {
      "title": "Number of Islands",
      "difficulty": "MEDIUM",
      "category": "Array, Depth-First Search, Breadth-First Search, Union Find, Matrix",
      "link": "https://leetcode.com/problems/number-of-islands",
      "slug": "number-of-islands",
      "description": "Given an \nm x n\n 2D binary grid \ngrid\n which represents a map of \n'1'\ns (land) and \n'0'\ns (water), return \nthe number of islands\n.\n\n\nAn \nisland\n is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 300\n\n\ngrid[i][j]\n is \n'0'\n or \n'1'\n.",
      "solution": "class UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n       if self.set[x] != x:\n           self.set[x] = self.find_set(self.set[x])  # path compression.\n       return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root != y_root:\n            self.set[min(x_root, y_root)] = max(x_root, y_root)\n            self.count -= 1\n\nclass Solution(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        def index(n, i, j):\n            return i*n + j\n    \n        if not grid:\n            return 0\n\n        zero_count = 0\n        union_find = UnionFind(len(grid)*len(grid[0]))\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j] == '1':\n                    if i and grid[i-1][j] == '1':\n                        union_find.union_set(index(len(grid[0]), i-1, j),\n                                             index(len(grid[0]),i, j))\n                    if j and grid[i][j-1] == '1':\n                        union_find.union_set(index(len(grid[0]), i, j-1),\n                                             index(len(grid[0]), i, j))\n                else:\n                    zero_count += 1        \n        return union_find.count-zero_count\n\n\n# dfs solutionclass Solution2(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def dfs(grid, i, j):\n            if grid[i][j] == '0':\n                return False\n            grid[i][j] = '0'\n            stk = [(i, j)]\n            while stk:\n                r, c = stk.pop()\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(grid) and\n                            0 <= nc < len(grid[0]) and\n                            grid[nr][nc] == '1'):\n                        continue\n                    grid[nr][nc] = '0'\n                    stk.append((nr, nc))\n            return True\n\n        count = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if dfs(grid, i, j):\n                    count += 1\n        return count\n\n \nimport collections\n\n\n# bfs solutionclass Solution3(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def bfs(grid, i, j):\n            if grid[i][j] == '0':\n                return False\n            grid[i][j] ='0'\n            q = collections.deque([(i, j)])\n            while q:\n                r, c = q.popleft()\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(grid) and\n                            0 <= nc < len(grid[0]) and\n                            grid[nr][nc] == '1'):\n                        continue\n                    grid[nr][nc] = '0'\n                    q.append((nr, nc))\n            return True\n\n        count = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if bfs(grid, i, j):\n                    count += 1\n        return count",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "Reorganize String",
      "difficulty": "MEDIUM",
      "category": "Hash Table, String, Greedy, Sorting, Heap (Priority Queue), Counting",
      "link": "https://leetcode.com/problems/reorganize-string",
      "slug": "reorganize-string",
      "description": "Given a string \ns\n, rearrange the characters of \ns\n so that any two adjacent characters are not the same.\n\n\nReturn \nany possible rearrangement of\n \ns\n \nor return\n \n\"\"\n \nif not possible\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"aab\"\n\nOutput:\n \"aba\"\n\nExample 2:\n\n\nInput:\n s = \"aaab\"\n\nOutput:\n \"\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 500\n\n\ns\n consists of lowercase English letters.",
      "solution": "\nimport collections\nimport heapq\n\nclass Solution(object):\n    def reorganizeString(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n        counts = collections.Counter(S)\n        if any(v > (len(S)+1)/2 for k, v in counts.iteritems()):\n            return \"\"\n\n        result = []\n        max_heap = []\n        for k, v in counts.iteritems():\n            heapq.heappush(max_heap, (-v, k))\n        while len(max_heap) > 1:\n            count1, c1 = heapq.heappop(max_heap)\n            count2, c2 = heapq.heappop(max_heap)\n            if not result or c1 != result[-1]:\n                result.extend([c1, c2])\n                if count1+1: heapq.heappush(max_heap, (count1+1, c1))\n                if count2+1: heapq.heappush(max_heap, (count2+1, c2))\n        return \"\".join(result) + (max_heap[0][1] if max_heap else '')",
      "explanation": "N/A",
      "time_complexity": "O(nloga) = O(n), a is the size of alphabet",
      "space_complexity": "O(a) = O(1)"
    },
    {
      "title": "Maximum Frequency After Subarray Operation",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Dynamic Programming, Greedy, Enumeration, Prefix Sum",
      "link": "https://leetcode.com/problems/maximum-frequency-after-subarray-operation",
      "slug": "maximum-frequency-after-subarray-operation",
      "description": "You are given an array \nnums\n of length \nn\n. You are also given an integer \nk\n.\n\n\nYou perform the following operation on \nnums\n \nonce\n:\n\n\n\n\nSelect a \nsubarray\n \nnums[i..j]\n where \n0 <= i <= j <= n - 1\n.\n\n\nSelect an integer \nx\n and add \nx\n to \nall\n the elements in \nnums[i..j]\n.\n\n\n\n\nFind the \nmaximum\n frequency of the value \nk\n after the operation.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,3,4,5,6], k = 1\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nAfter adding -5 to \nnums[2..5]\n, 1 has a frequency of 2 in \n[1, 2, -2, -1, 0, 1]\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [10,2,3,4,5,5,4,3,2,2], k = 10\n\n\nOutput:\n \n4\n\n\nExplanation:\n\n\nAfter adding 8 to \nnums[1..9]\n, 10 has a frequency of 4 in \n[10, 10, 11, 12, 13, 13, 12, 11, 10, 10]\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == nums.length <= 10\n5\n\n\n1 <= nums[i] <= 50\n\n\n1 <= k <= 50",
      "solution": "\nimport collections\n\n\n# freq table, dpclass Solution(object):\n    def maxFrequency(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        cnt = collections.defaultdict(int)\n        for x in nums:\n            cnt[x] = max(cnt[x], cnt[k])+1\n            result = max(result+int(x == k), cnt[x])\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Longest Palindromic Substring",
      "difficulty": "MEDIUM",
      "category": "Two Pointers, String, Dynamic Programming",
      "link": "https://leetcode.com/problems/longest-palindromic-substring",
      "slug": "longest-palindromic-substring",
      "description": "Given a string \ns\n, return \nthe longest\n \npalindromic\n \nsubstring\n in \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"babad\"\n\nOutput:\n \"bab\"\n\nExplanation:\n \"aba\" is also a valid answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"cbbd\"\n\nOutput:\n \"bb\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consist of only digits and English letters.",
      "solution": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def preProcess(s):\n            if not s:\n                return ['^', '$']\n            T = ['^']\n            for c in s:\n                T +=  ['#', c]\n            T += ['#', '$']\n            return T\n\n        T = preProcess(s)\n        P = [0] * len(T)\n        center, right = 0, 0\n        for i in xrange(1, len(T) - 1):\n            i_mirror = 2 * center - i\n            if right > i:\n                P[i] = min(right - i, P[i_mirror])\n            else:\n                P[i] = 0\n\n            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:\n                P[i] += 1\n\n            if i + P[i] > right:\n                center, right = i, i + P[i]\n\n        max_i = 0\n        for i in xrange(1, len(T) - 1):\n            if P[i] > P[max_i]:\n                max_i = i\n        start = (max_i - 1 - P[max_i]) // 2\n        return s[start : start + P[max_i]]\n\nclass Solution2(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return (right-left+1)-2\n        \n        left, right = -1, -2\n        for i in xrange(len(s)):\n            l = max(expand(s, i, i), expand(s, i, i+1))\n            if l > right-left+1:\n                right = i+l//2\n                left = right-l+1\n        return s[left:right+1] if left >= 0 else \"\"",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Add Two Numbers",
      "difficulty": "MEDIUM",
      "category": "Linked List, Math, Recursion",
      "link": "https://leetcode.com/problems/add-two-numbers",
      "slug": "add-two-numbers",
      "description": "You are given two \nnon-empty\n linked lists representing two non-negative integers. The digits are stored in \nreverse order\n, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n l1 = [2,4,3], l2 = [5,6,4]\n\nOutput:\n [7,0,8]\n\nExplanation:\n 342 + 465 = 807.\n\n\n\nExample 2:\n\n\n\n\nInput:\n l1 = [0], l2 = [0]\n\nOutput:\n [0]\n\n\n\nExample 3:\n\n\n\n\nInput:\n l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n\nOutput:\n [8,9,9,9,0,0,0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in each linked list is in the range \n[1, 100]\n.\n\n\n0 <= Node.val <= 9\n\n\nIt is guaranteed that the list represents a number that does not have leading zeros.",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        current, carry = dummy, 0\n\n        while l1 or l2:\n            val = carry\n            if l1:\n                val += l1.val\n                l1 = l1.next\n            if l2:\n                val += l2.val\n                l2 = l2.next\n            carry, val = divmod(val, 10)\n            current.next = ListNode(val)\n            current = current.next\n\n        if carry == 1:\n            current.next = ListNode(1)\n\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Koko Eating Bananas",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/koko-eating-bananas",
      "slug": "koko-eating-bananas",
      "description": "Koko loves to eat bananas. There are \nn\n piles of bananas, the \ni\nth\n pile has \npiles[i]\n bananas. The guards have gone and will come back in \nh\n hours.\n\n\nKoko can decide her bananas-per-hour eating speed of \nk\n. Each hour, she chooses some pile of bananas and eats \nk\n bananas from that pile. If the pile has less than \nk\n bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\n\nReturn \nthe minimum integer\n \nk\n \nsuch that she can eat all the bananas within\n \nh\n \nhours\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n piles = [3,6,7,11], h = 8\n\nOutput:\n 4\n\n\n\nExample 2:\n\n\n\n\nInput:\n piles = [30,11,23,4,20], h = 5\n\nOutput:\n 30\n\n\n\nExample 3:\n\n\n\n\nInput:\n piles = [30,11,23,4,20], h = 6\n\nOutput:\n 23\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= piles.length <= 10\n4\n\n\npiles.length <= h <= 10\n9\n\n\n1 <= piles[i] <= 10\n9",
      "solution": "class Solution(object):\n    def minEatingSpeed(self, piles, H):\n        \"\"\"\n        :type piles: List[int]\n        :type H: int\n        :rtype: int\n        \"\"\"\n        def possible(piles, H, K):\n            return sum((pile-1)//K+1 for pile in piles) <= H\n\n        left, right = 1, max(piles)\n        while left <= right:\n            mid = left + (right-left)//2\n            if possible(piles, H, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left",
      "explanation": "N/A",
      "time_complexity": "O(nlogr)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Longest Substring Without Repeating Characters",
      "difficulty": "MEDIUM",
      "category": "Hash Table, String, Sliding Window",
      "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters",
      "slug": "longest-substring-without-repeating-characters",
      "description": "Given a string \ns\n, find the length of the \nlongest\n \nsubstring\n without duplicate characters.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abcabcbb\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"abc\", with the length of 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"bbbbb\"\n\nOutput:\n 1\n\nExplanation:\n The answer is \"b\", with the length of 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"pwwkew\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 5 * 10\n4\n\n\ns\n consists of English letters, digits, symbols and spaces.",
      "solution": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, left = 0, 0\n        lookup = {}\n        for right in xrange(len(s)):\n            if s[right] in lookup:\n                left = max(left, lookup[s[right]]+1)\n            lookup[s[right]] = right\n            result = max(result, right-left+1)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Find First and Last Position of Element in Sorted Array",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array",
      "slug": "find-first-and-last-position-of-element-in-sorted-array",
      "description": "Given an array of integers \nnums\n sorted in non-decreasing order, find the starting and ending position of a given \ntarget\n value.\n\n\nIf \ntarget\n is not found in the array, return \n[-1, -1]\n.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [5,7,7,8,8,10], target = 8\n\nOutput:\n [3,4]\n\nExample 2:\n\n\nInput:\n nums = [5,7,7,8,8,10], target = 6\n\nOutput:\n [-1,-1]\n\nExample 3:\n\n\nInput:\n nums = [], target = 0\n\nOutput:\n [-1,-1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\nnums\n is a non-decreasing array.\n\n\n-10\n9\n <= target <= 10\n9",
      "solution": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        def binarySearch(n, check):  # usually use\n            left, right = 0, n-1  # search in [0, n-1], return n if not found\n            while left <= right:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left  # or return right+1\n\n        def binarySearch2(n, check):  # frequently use\n            left, right = 0, n  # search in [0, n), return n if not found\n            while left < right:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid\n                else:\n                    left = mid+1\n            return left  # or return right\n\n        def binarySearch3(n, check):  # never use\n            left, right = -1, n-1  # search in (-1, n-1], return n if not found\n            while left < right:\n                mid = right - (right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid\n            return left+1  # or return right+1\n\n        def binarySearch4(n, check):  # sometimes use\n            left, right = -1, n  # search in (-1, n), return n if not found\n            while right-left >= 2:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid\n                else:\n                    left = mid\n            return left+1  # or return right\n\n        # Find the first idx where nums[idx] >= target\n        left = binarySearch(len(nums), lambda i: nums[i] >= target)\n        if left == len(nums) or nums[left] != target:\n            return [-1, -1]\n        # Find the first idx where nums[idx] > target\n        right = binarySearch(len(nums), lambda i: nums[i] > target)\n        return [left, right-1]",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Trapping Rain Water",
      "difficulty": "HARD",
      "category": "Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack",
      "link": "https://leetcode.com/problems/trapping-rain-water",
      "slug": "trapping-rain-water",
      "description": "Given \nn\n non-negative integers representing an elevation map where the width of each bar is \n1\n, compute how much water it can trap after raining.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [0,1,0,2,1,0,1,3,2,1,2,1]\n\nOutput:\n 6\n\nExplanation:\n The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [4,2,0,3,2,5]\n\nOutput:\n 9\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n1 <= n <= 2 * 10\n4\n\n\n0 <= height[i] <= 10\n5",
      "solution": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result, left, right, level = 0, 0, len(height)-1, 0\n        while left < right:\n            if height[left] < height[right]:\n                lower = height[left]\n                left += 1\n            else:\n                lower = height[right]\n                right -= 1\n            level = max(level, lower)\n            result += level-lower\n        return result\n\nclass Solution2(object):\n    # @param A, a list of integers\n    # @return an integer\n    def trap(self, A):\n        result = 0\n        top = 0\n        for i in xrange(len(A)):\n            if A[top] < A[i]:\n                top = i\n\n        second_top = 0\n        for i in xrange(top):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        second_top = len(A) - 1\n        for i in reversed(xrange(top, len(A))):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        return result\n\nclass Solution3(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        right = [0]*len(height)\n        mx = 0\n        for i in reversed(xrange(len(height))):\n            right[i] = mx\n            mx = max(mx, height[i])\n        result = left = 0\n        for i in xrange(len(height)):\n            left = max(left, height[i])\n            result += max(min(left, right[i])-height[i], 0)\n        return result\n\nclass Solution4(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        stk = []\n        for i in xrange(len(height)):\n            prev = 0\n            while stk and height[stk[-1]] <= height[i]:\n                j = stk.pop()\n                result += (height[j] - prev) * (i - j - 1)\n                prev = height[j]\n            if stk:\n                result += (height[i] - prev) * (i - stk[-1] - 1)\n            stk.append(i)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Top K Frequent Elements",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Divide and Conquer, Sorting, Heap (Priority Queue), Bucket Sort, Counting, Quickselect",
      "link": "https://leetcode.com/problems/top-k-frequent-elements",
      "slug": "top-k-frequent-elements",
      "description": "Given an integer array \nnums\n and an integer \nk\n, return \nthe\n \nk\n \nmost frequent elements\n. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,1,1,2,2,3], k = 2\n\nOutput:\n [1,2]\n\nExample 2:\n\n\nInput:\n nums = [1], k = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nk\n is in the range \n[1, the number of unique elements in the array]\n.\n\n\nIt is \nguaranteed\n that the answer is \nunique\n.\n\n\n\n\n \n\n\nFollow up:\n Your algorithm's time complexity must be better than \nO(n log n)\n, where n is the array's size.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        counts = collections.Counter(nums)\n        buckets = [[] for _ in xrange(len(nums)+1)]\n        for i, count in counts.iteritems():\n            buckets[count].append(i)\n\n        result = []\n        for i in reversed(xrange(len(buckets))):\n            for j in xrange(len(buckets[i])):\n                result.append(buckets[i][j])\n                if len(result) == k:\n                    return result\n        return result\n\n\n# Quick Select Solution\nfrom random import randintclass Solution2(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        counts = collections.Counter(nums)\n        p = []\n        for key, val in counts.iteritems():\n            p.append((-val, key))\n        self.kthElement(p, k-1)\n\n        result = []\n        for i in xrange(k):\n            result.append(p[i][1])\n        return result\n\n    def kthElement(self, nums, k):\n        def PartitionAroundPivot(left, right, pivot_idx, nums):\n            pivot_value = nums[pivot_idx]\n            new_pivot_idx = left\n            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n            for i in xrange(left, right):\n                if nums[i] < pivot_value:\n                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                    new_pivot_idx += 1\n\n            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n            return new_pivot_idx\n\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k:\n                return\n            elif new_pivot_idx > k:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k.\n                left = new_pivot_idx + 1\n\nclass Solution3(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        return [key for key, _ in collections.Counter(nums).most_common(k)]",
      "explanation": "N/A",
      "time_complexity": "O(nlogk)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Merge k Sorted Lists",
      "difficulty": "HARD",
      "category": "Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort",
      "link": "https://leetcode.com/problems/merge-k-sorted-lists",
      "slug": "merge-k-sorted-lists",
      "description": "You are given an array of \nk\n linked-lists \nlists\n, each linked-list is sorted in ascending order.\n\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n lists = [[1,4,5],[1,3,4],[2,6]]\n\nOutput:\n [1,1,2,3,4,4,5,6]\n\nExplanation:\n The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted linked list:\n1->1->2->3->4->4->5->6\n\n\n\nExample 2:\n\n\n\n\nInput:\n lists = []\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n lists = [[]]\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nk == lists.length\n\n\n0 <= k <= 10\n4\n\n\n0 <= lists[i].length <= 500\n\n\n-10\n4\n <= lists[i][j] <= 10\n4\n\n\nlists[i]\n is sorted in \nascending order\n.\n\n\nThe sum of \nlists[i].length\n will not exceed \n10\n4\n.",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\t\t\n        if self:\t\t\n            return \"{} -> {}\".format(self.val, self.next)\n\n\n# Merge two by two solution.class Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        if not lists:\n            return None\n        left, right = 0, len(lists) - 1\n        while right > 0:\n            lists[left] = mergeTwoLists(lists[left], lists[right])\n            left += 1\n            right -= 1\n            if left >= right:\n                left = 0\n        return lists[0]\n\n\n# Divide and Conquer solution.class Solution2(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        def mergeKListsHelper(lists, begin, end):\n            if begin > end:\n                return None\n            if begin == end:\n                return lists[begin]\n            return mergeTwoLists(mergeKListsHelper(lists, begin, (begin + end) / 2), \\\n                                 mergeKListsHelper(lists, (begin + end) / 2 + 1, end))\n\n        return mergeKListsHelper(lists, 0, len(lists) - 1)\n\n\n# Heap solution.\nimport heapqclass Solution3(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        dummy = ListNode(0)\n        current = dummy\n\n        heap = []\n        for sorted_list in lists:\n            if sorted_list:\n                heapq.heappush(heap, (sorted_list.val, sorted_list))\n\n        while heap:\n            smallest = heapq.heappop(heap)[1]\n            current.next = smallest\n            current = current.next\n            if smallest.next:\n                heapq.heappush(heap, (smallest.next.val, smallest.next))\n\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(nlogk)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Jump Game II",
      "difficulty": "MEDIUM",
      "category": "Array, Dynamic Programming, Greedy",
      "link": "https://leetcode.com/problems/jump-game-ii",
      "slug": "jump-game-ii",
      "description": "You are given a \n0-indexed\n array of integers \nnums\n of length \nn\n. You are initially positioned at \nnums[0]\n.\n\n\nEach element \nnums[i]\n represents the maximum length of a forward jump from index \ni\n. In other words, if you are at \nnums[i]\n, you can jump to any \nnums[i + j]\n where:\n\n\n\n\n0 <= j <= nums[i]\n and\n\n\ni + j < n\n\n\n\n\nReturn \nthe minimum number of jumps to reach \nnums[n - 1]\n. The test cases are generated such that you can reach \nnums[n - 1]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,3,1,1,4]\n\nOutput:\n 2\n\nExplanation:\n The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,3,0,1,4]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n0 <= nums[i] <= 1000\n\n\nIt's guaranteed that you can reach \nnums[n - 1]\n.",
      "solution": "class Solution(object):\n    # @param A, a list of integers\n    # @return an integer\n    def jump(self, A):\n        jump_count = 0\n        reachable = 0\n        curr_reachable = 0\n        for i, length in enumerate(A):\n            if i > reachable:\n                return -1\n            if i > curr_reachable:\n                curr_reachable = reachable\n                jump_count += 1\n            reachable = max(reachable, i + length)\n        return jump_count",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Merge Intervals",
      "difficulty": "MEDIUM",
      "category": "Array, Sorting",
      "link": "https://leetcode.com/problems/merge-intervals",
      "slug": "merge-intervals",
      "description": "Given an array of \nintervals\n where \nintervals[i] = [start\ni\n, end\ni\n]\n, merge all overlapping intervals, and return \nan array of the non-overlapping intervals that cover all the intervals in the input\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n intervals = [[1,3],[2,6],[8,10],[15,18]]\n\nOutput:\n [[1,6],[8,10],[15,18]]\n\nExplanation:\n Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\n\n\nExample 2:\n\n\n\n\nInput:\n intervals = [[1,4],[4,5]]\n\nOutput:\n [[1,5]]\n\nExplanation:\n Intervals [1,4] and [4,5] are considered overlapping.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= intervals.length <= 10\n4\n\n\nintervals[i].length == 2\n\n\n0 <= start\ni\n <= end\ni\n <= 10\n4",
      "solution": "class Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        intervals.sort()\n        result = []\n        for interval in intervals:\n            if not result or interval[0] > result[-1][1]:\n                result.append(interval)\n            else:\n                result[-1][1] = max(result[-1][1], interval[1])\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Group Anagrams",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, String, Sorting",
      "link": "https://leetcode.com/problems/group-anagrams",
      "slug": "group-anagrams",
      "description": "Given an array of strings \nstrs\n, group the \nanagrams\n together. You can return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nstrs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n\n\nOutput:\n \n[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\n\nExplanation:\n\n\n\n\nThere is no string in strs that can be rearranged to form \n\"bat\"\n.\n\n\nThe strings \n\"nat\"\n and \n\"tan\"\n are anagrams as they can be rearranged to form each other.\n\n\nThe strings \n\"ate\"\n, \n\"eat\"\n, and \n\"tea\"\n are anagrams as they can be rearranged to form each other.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nstrs = [\"\"]\n\n\nOutput:\n \n[[\"\"]]\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nstrs = [\"a\"]\n\n\nOutput:\n \n[[\"a\"]]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 10\n4\n\n\n0 <= strs[i].length <= 100\n\n\nstrs[i]\n consists of lowercase English letters.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagrams_map, result = collections.defaultdict(list), []\n        for s in strs:\n            sorted_str = (\"\").join(sorted(s))\n            anagrams_map[sorted_str].append(s)\n        for anagram in anagrams_map.values():\n            anagram.sort()\n            result.append(anagram)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n * glogg), g is the max size of groups.",
      "space_complexity": "O(n)"
    },
    {
      "title": "Lowest Common Ancestor of a Binary Tree",
      "difficulty": "MEDIUM",
      "category": "Tree, Depth-First Search, Binary Tree",
      "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree",
      "slug": "lowest-common-ancestor-of-a-binary-tree",
      "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\n\nAccording to the \ndefinition of LCA on Wikipedia\n: “The lowest common ancestor is defined between two nodes \np\n and \nq\n as the lowest node in \nT\n that has both \np\n and \nq\n as descendants (where we allow \na node to be a descendant of itself\n).”\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n\nOutput:\n 3\n\nExplanation:\n The LCA of nodes 5 and 1 is 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n\nOutput:\n 5\n\nExplanation:\n The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [1,2], p = 1, q = 2\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 10\n5\n]\n.\n\n\n-10\n9\n <= Node.val <= 10\n9\n\n\nAll \nNode.val\n are \nunique\n.\n\n\np != q\n\n\np\n and \nq\n will exist in the tree.",
      "solution": "class Solution(object):\n    # @param {TreeNode} root\n    # @param {TreeNode} p\n    # @param {TreeNode} q\n    # @return {TreeNode}\n    def lowestCommonAncestor(self, root, p, q):\n        if root in (None, p, q):\n            return root\n\n        left, right = [self.lowestCommonAncestor(child, p, q) \\\n                         for child in (root.left, root.right)]\n        # 1. If the current subtree contains both p and q,\n        #    return their LCA.\n        # 2. If only one of them is in that subtree,\n        #    return that one of them.\n        # 3. If neither of them is in that subtree,\n        #    return the node of that subtree.\n        return root if left and right else left or right",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Longest Repeating Character Replacement",
      "difficulty": "MEDIUM",
      "category": "Hash Table, String, Sliding Window",
      "link": "https://leetcode.com/problems/longest-repeating-character-replacement",
      "slug": "longest-repeating-character-replacement",
      "description": "You are given a string \ns\n and an integer \nk\n. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most \nk\n times.\n\n\nReturn \nthe length of the longest substring containing the same letter you can get after performing the above operations\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"ABAB\", k = 2\n\nOutput:\n 4\n\nExplanation:\n Replace the two 'A's with two 'B's or vice versa.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"AABABBA\", k = 1\n\nOutput:\n 4\n\nExplanation:\n Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\nThere may exists other ways to achieve this answer too.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns\n consists of only uppercase English letters.\n\n\n0 <= k <= s.length",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def characterReplacement(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result, max_count = 0, 0\n        count = collections.Counter()\n        for i in xrange(len(s)):\n            count[s[i]] += 1\n            max_count = max(max_count, count[s[i]])\n            if result - max_count >= k:\n                count[s[i-result]] -= 1\n            else:\n                result += 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Candy",
      "difficulty": "HARD",
      "category": "Array, Greedy",
      "link": "https://leetcode.com/problems/candy",
      "slug": "candy",
      "description": "There are \nn\n children standing in a line. Each child is assigned a rating value given in the integer array \nratings\n.\n\n\nYou are giving candies to these children subjected to the following requirements:\n\n\n\n\nEach child must have at least one candy.\n\n\nChildren with a higher rating get more candies than their neighbors.\n\n\n\n\nReturn \nthe minimum number of candies you need to have to distribute the candies to the children\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n ratings = [1,0,2]\n\nOutput:\n 5\n\nExplanation:\n You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\n\n\nExample 2:\n\n\n\n\nInput:\n ratings = [1,2,2]\n\nOutput:\n 4\n\nExplanation:\n You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == ratings.length\n\n\n1 <= n <= 2 * 10\n4\n\n\n0 <= ratings[i] <= 2 * 10\n4",
      "solution": "class Solution(object):\n    # @param ratings, a list of integer\n    # @return an integer\n    def candy(self, ratings):\n        candies = [1 for _ in xrange(len(ratings))]\n        for i in xrange(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        for i in reversed(xrange(1, len(ratings))):\n            if ratings[i - 1] > ratings[i] and candies[i - 1] <= candies[i]:\n                candies[i - 1] = candies[i] + 1\n\n        return sum(candies)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Meeting Rooms II",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers, Greedy, Sorting, Heap (Priority Queue), Prefix Sum",
      "link": "https://leetcode.com/problems/meeting-rooms-ii",
      "slug": "meeting-rooms-ii",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "class Solution(object):\n    # @param {Interval[]} intervals\n    # @return {integer}\n    def minMeetingRooms(self, intervals):\n        result, curr = 0, 0\n        line = [x for i, j in intervals for x in [[i, 1], [j, -1]]]\n        line.sort()\n        for _, num in line:\n            curr += num\n            result = max(result, curr)\n        return result\n\nclass Solution2(object):\n    # @param {Interval[]} intervals\n    # @return {integer}\n    def minMeetingRooms(self, intervals):\n        starts, ends = [], []\n        for start, end in intervals:\n            starts.append(start)\n            ends.append(end)\n\n        starts.sort()\n        ends.sort()\n\n        s, e = 0, 0\n        min_rooms, cnt_rooms = 0, 0\n        while s < len(starts):\n            if starts[s] < ends[e]:\n                cnt_rooms += 1  # Acquire a room.\n                # Update the min number of rooms.\n                min_rooms = max(min_rooms, cnt_rooms)\n                s += 1\n            else:\n                cnt_rooms -= 1  # Release a room.\n                e += 1\n\n        return min_rooms\n\n\nfrom heapq import heappush, heappop\n\nclass Solution3(object):\n    def minMeetingRooms(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return 0\n        \n        intervals.sort(key=lambda x: x[0])\n        free_rooms = []\n        \n        heappush(free_rooms, intervals[0][1])\n        for interval in intervals[1:]:\n            if free_rooms[0] <= interval[0]:\n                heappop(free_rooms)\n            \n            heappush(free_rooms, interval[1])\n        \n        return len(free_rooms)",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Valid Parentheses",
      "difficulty": "EASY",
      "category": "String, Stack",
      "link": "https://leetcode.com/problems/valid-parentheses",
      "slug": "valid-parentheses",
      "description": "Given a string \ns\n containing just the characters \n'('\n, \n')'\n, \n'{'\n, \n'}'\n, \n'['\n and \n']'\n, determine if the input string is valid.\n\n\nAn input string is valid if:\n\n\n\n\nOpen brackets must be closed by the same type of brackets.\n\n\nOpen brackets must be closed in the correct order.\n\n\nEvery close bracket has a corresponding open bracket of the same type.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"()\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"()[]{}\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"(]\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"([])\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"([)]\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of parentheses only \n'()[]{}'\n.",
      "solution": "class Solution(object):\n    # @return a boolean\n    def isValid(self, s):\n        stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        for parenthese in s:\n            if parenthese in lookup:\n                stack.append(parenthese)\n            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:\n                return False\n        return len(stack) == 0",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Minimum Window Substring",
      "difficulty": "HARD",
      "category": "Hash Table, String, Sliding Window",
      "link": "https://leetcode.com/problems/minimum-window-substring",
      "slug": "minimum-window-substring",
      "description": "Given two strings \ns\n and \nt\n of lengths \nm\n and \nn\n respectively, return \nthe \nminimum window\n \nsubstring\n of \ns\n such that every character in \nt\n (\nincluding duplicates\n) is included in the window\n. If there is no such substring, return \nthe empty string \n\"\"\n.\n\n\nThe testcases will be generated such that the answer is \nunique\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"ADOBECODEBANC\", t = \"ABC\"\n\nOutput:\n \"BANC\"\n\nExplanation:\n The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"a\", t = \"a\"\n\nOutput:\n \"a\"\n\nExplanation:\n The entire string s is the minimum window.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"a\", t = \"aa\"\n\nOutput:\n \"\"\n\nExplanation:\n Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == s.length\n\n\nn == t.length\n\n\n1 <= m, n <= 10\n5\n\n\ns\n and \nt\n consist of uppercase and lowercase English letters.\n\n\n\n\n \n\n\nFollow up:\n Could you find an algorithm that runs in \nO(m + n)\n time?",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        count, remain = collections.Counter(t), len(t)\n        i, left, right = 0, -1, -1\n        for j, c in enumerate(s):\n            remain -= count[c] > 0\n            count[c] -= 1\n            if remain:\n                continue\n            while count[s[i]] < 0:  # greedily discard uneeds\n                count[s[i]] += 1\n                i += 1\n            if right == -1 or j-i+1 < right-left+1:\n                left, right = i, j\n        return s[left:right+1]\n\nclass Solution2(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        current_count = [0 for i in xrange(52)]\n        expected_count = [0 for i in xrange(52)]\n\n        for char in t:\n            expected_count[ord(char) - ord('a')] += 1\n\n        i, count, start, min_width, min_start = 0, 0, 0, float(\"inf\"), 0\n        while i < len(s):\n            current_count[ord(s[i]) - ord('a')] += 1\n            if current_count[ord(s[i]) - ord('a')] <= expected_count[ord(s[i]) - ord('a')]:\n                count += 1\n\n            if count == len(t):\n                while expected_count[ord(s[start]) - ord('a')] == 0 or \\\n                      current_count[ord(s[start]) - ord('a')] > expected_count[ord(s[start]) - ord('a')]:\n                    current_count[ord(s[start]) - ord('a')] -= 1\n                    start += 1\n\n                if min_width > i - start + 1:\n                    min_width = i - start + 1\n                    min_start = start\n            i += 1\n\n        if min_width == float(\"inf\"):\n            return \"\"\n\n        return s[min_start:min_start + min_width]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(k), k is the number of different characters"
    },
    {
      "title": "House Robber",
      "difficulty": "MEDIUM",
      "category": "Array, Dynamic Programming",
      "link": "https://leetcode.com/problems/house-robber",
      "slug": "house-robber",
      "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and \nit will automatically contact the police if two adjacent houses were broken into on the same night\n.\n\n\nGiven an integer array \nnums\n representing the amount of money of each house, return \nthe maximum amount of money you can rob tonight \nwithout alerting the police\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,1]\n\nOutput:\n 4\n\nExplanation:\n Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,7,9,3,1]\n\nOutput:\n 12\n\nExplanation:\n Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 400",
      "solution": "class Solution(object):\n    # @param num, a list of integer\n    # @return an integer\n    def rob(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        last, now = 0, 0\n        for i in nums:\n            last, now = now, max(last + i, now)\n        return now",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Median of Two Sorted Arrays",
      "difficulty": "HARD",
      "category": "Array, Binary Search, Divide and Conquer",
      "link": "https://leetcode.com/problems/median-of-two-sorted-arrays",
      "slug": "median-of-two-sorted-arrays",
      "description": "Given two sorted arrays \nnums1\n and \nnums2\n of size \nm\n and \nn\n respectively, return \nthe median\n of the two sorted arrays.\n\n\nThe overall run time complexity should be \nO(log (m+n))\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,3], nums2 = [2]\n\nOutput:\n 2.00000\n\nExplanation:\n merged array = [1,2,3] and median is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1,2], nums2 = [3,4]\n\nOutput:\n 2.50000\n\nExplanation:\n merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m\n\n\nnums2.length == n\n\n\n0 <= m <= 1000\n\n\n0 <= n <= 1000\n\n\n1 <= m + n <= 2000\n\n\n-10\n6\n <= nums1[i], nums2[i] <= 10\n6",
      "solution": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(A, B, k):\n            m, n = len(A), len(B)\n            if m > n:\n                m, n = n, m\n                A, B = B, A\n            i = binary_search(max(k-n, 0), min(m, k)-1, lambda i: A[i] >= B[k-1-i])\n            return max(A[i-1] if i-1 >= 0 else float(\"-inf\"), B[k-1-i] if k-1-i >= 0 else float(\"-inf\"))\n\n        len1, len2 = len(nums1), len(nums2)\n        if (len1+len2) % 2 == 1:\n            return getKth(nums1, nums2, (len1+len2)//2+1)\n        else:\n            return (getKth(nums1, nums2, (len1+len2)//2)+getKth(nums1, nums2, (len1+len2)//2+1))*0.5    \n\n\n# Generic solution.class Solution_Generic(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(arrays, k):\n            def check(num):\n                # count the number of values which are less or equal to num\n                return sum(binary_search(0, len(arr)-1, lambda x: arr[x] > num) for arr in arrays) >= k\n    \n            return binary_search(min(arr[0] for arr in arrays if arr), max(arr[-1] for arr in arrays if arr), check)\n\n        array = [nums1, nums2]\n        total = sum(len(nums) for nums in array)\n        if total % 2 == 1:\n            return getKth(array, total//2+1)\n        else:\n            return (getKth(array, total//2)+getKth(array, total//2+1))*0.5",
      "explanation": "N/A",
      "time_complexity": "O(log(max(m, n)) * log(max_val - min_val))",
      "space_complexity": "O(1)"
    },
    {
      "title": "Min Stack",
      "difficulty": "MEDIUM",
      "category": "Stack, Design",
      "link": "https://leetcode.com/problems/min-stack",
      "slug": "min-stack",
      "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\n\nImplement the \nMinStack\n class:\n\n\n\n\nMinStack()\n initializes the stack object.\n\n\nvoid push(int val)\n pushes the element \nval\n onto the stack.\n\n\nvoid pop()\n removes the element on the top of the stack.\n\n\nint top()\n gets the top element of the stack.\n\n\nint getMin()\n retrieves the minimum element in the stack.\n\n\n\n\nYou must implement a solution with \nO(1)\n time complexity for each function.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n\nOutput\n\n[null,null,null,null,-3,null,0,-2]\n\n\nExplanation\n\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= val <= 2\n31\n - 1\n\n\nMethods \npop\n, \ntop\n and \ngetMin\n operations will always be called on \nnon-empty\n stacks.\n\n\nAt most \n3 * 10\n4\n calls will be made to \npush\n, \npop\n, \ntop\n, and \ngetMin\n.",
      "solution": "class MinStack(object):\n    def __init__(self):\n        self.min = None\n        self.stack = []\n\n    # @param x, an integer\n    # @return an integer\n    def push(self, x):\n        if not self.stack:\n            self.stack.append(0)\n            self.min = x\n        else:\n            self.stack.append(x - self.min)\n            if x < self.min:\n                self.min = x\n\n    # @return nothing\n    def pop(self):\n        x = self.stack.pop()\n        if x < 0:\n            self.min = self.min - x\n\n    # @return an integer\n    def top(self):\n        x = self.stack[-1]\n        if x > 0:\n            return x + self.min\n        else:\n            return self.min\n\n    # @return an integer\n    def getMin(self):\n        return self.min\nclass MinStack2(object):\n    def __init__(self):\n        self.stack, self.minStack = [], []\n    # @param x, an integer\n    # @return an integer\n    def push(self, x):\n        self.stack.append(x)\n        if len(self.minStack):\n            if x < self.minStack[-1][0]:\n                self.minStack.append([x, 1])\n            elif x == self.minStack[-1][0]:\n                self.minStack[-1][1] += 1\n        else:\n            self.minStack.append([x, 1])\n\n    # @return nothing\n    def pop(self):\n        x = self.stack.pop()\n        if x == self.minStack[-1][0]:\n            self.minStack[-1][1] -= 1\n            if self.minStack[-1][1] == 0:\n                self.minStack.pop()\n\n    # @return an integer\n    def top(self):\n        return self.stack[-1]\n\n    # @return an integer\n    def getMin(self):\n        return self.minStack[-1][0]\n\n# time: O(1)\n# space: O(n)\nclass MinStack3(object):\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x):\n        if self.stack:\n            current_min = min(x, self.stack[-1][0])\n            self.stack.append((current_min, x))\n        else:\n            self.stack.append((x, x))\n\n    def pop(self):\n        return self.stack.pop()[1]\n\n    def top(self):\n        return self.stack[-1][1]\n\n    def getMin(self):\n        return self.stack[-1][0]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Rotate Image",
      "difficulty": "MEDIUM",
      "category": "Array, Math, Matrix",
      "link": "https://leetcode.com/problems/rotate-image",
      "slug": "rotate-image",
      "description": "You are given an \nn x n\n 2D \nmatrix\n representing an image, rotate the image by \n90\n degrees (clockwise).\n\n\nYou have to rotate the image \nin-place\n, which means you have to modify the input 2D matrix directly. \nDO NOT\n allocate another 2D matrix and do the rotation.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [[7,4,1],[8,5,2],[9,6,3]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n\nOutput:\n [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 20\n\n\n-1000 <= matrix[i][j] <= 1000",
      "solution": "class Solution(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        n = len(matrix)\n\n        # anti-diagonal mirror\n        for i in xrange(n):\n            for j in xrange(n - i):\n                matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j]\n\n        # horizontal mirror\n        for i in xrange(n / 2):\n            for j in xrange(n):\n                matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]\n\n        return matrix\nclass Solution2(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        return [list(reversed(x)) for x in zip(*matrix)]",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n^2)"
    },
    {
      "title": "Best Time to Buy and Sell Stock II",
      "difficulty": "MEDIUM",
      "category": "Array, Dynamic Programming, Greedy",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii",
      "slug": "best-time-to-buy-and-sell-stock-ii",
      "description": "You are given an integer array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold \nat most one\n share of the stock at any time. However, you can buy it then immediately sell it on the \nsame day\n.\n\n\nFind and return \nthe \nmaximum\n profit you can achieve\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 7\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [1,2,3,4,5]\n\nOutput:\n 4\n\nExplanation:\n Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n\n\n\nExample 3:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 3 * 10\n4\n\n\n0 <= prices[i] <= 10\n4",
      "solution": "class Solution:\n    def maxProfit(self, prices) -> int:\n        # intial approach \n        # buy and sell when possible \n        # profit = 0\n        # for i in range(1, len(prices)):\n        #     if prices[i] > prices[i-1]:\n        #         profit +=  prices[i] - prices[i-1]\n        # return profit \n\n        # DP\n        # 2 states, hold , not hold \n        # dp[i][0] = max profit on day i if we hold stock at the end of the day.\n        # dp[i][1] = max profit on day i if we do NOT hold stock at the end of the day. \n        dp = [[0] * 2 for _ in range(len(prices))]\n        dp[0] = [-prices[0], 0] # Base case: hold = -price, not hold = 0\n        for i in range(1, len(prices)):\n            # Case 1: holding → max of holding from yesterday or buying today\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])\n            # Case 2: not holding → max of not holding from yesterday or selling today\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])\n        # On the last day, max profit only if we are **not holding**\n        return dp[len(prices)-1][1]\n\n    # recursion\n\n    # def maxProfit(self, prices: List[int]) -> int:\n        \n    #     @lru_cache(maxsize=None)\n    #     def dfs(i, holding):\n    #         if i == len(prices):\n    #             return 0\n            \n    #         if not holding:\n    #             # Option to buy or skip\n    #             return max(\n    #                 dfs(i+1, 1) - prices[i],  # Buy\n    #                 dfs(i+1, 0)               # Skip\n    #             )\n    #         else:\n    #             # Option to sell or hold\n    #             return max(\n    #                 dfs(i+1, 0) + prices[i],  # Sell\n    #                 dfs(i+1, 1)               # Hold\n    #             )\n        \n    #     return dfs(0, 0)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Concatenated Words",
      "difficulty": "HARD",
      "category": "Array, String, Dynamic Programming, Depth-First Search, Trie",
      "link": "https://leetcode.com/problems/concatenated-words",
      "slug": "concatenated-words",
      "description": "Given an array of strings \nwords\n (\nwithout duplicates\n), return \nall the \nconcatenated words\n in the given list of\n \nwords\n.\n\n\nA \nconcatenated word\n is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct) in the given array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\n\nOutput:\n [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\n\nExplanation:\n \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; \n\"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \n\"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"cat\",\"dog\",\"catdog\"]\n\nOutput:\n [\"catdog\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 10\n4\n\n\n1 <= words[i].length <= 30\n\n\nwords[i]\n consists of only lowercase English letters.\n\n\nAll the strings of \nwords\n are \nunique\n.\n\n\n1 <= sum(words[i].length) <= 10\n5",
      "solution": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        lookup = set(words)\n        result = []\n        for word in words:\n            dp = [False] * (len(word)+1)\n            dp[0] = True\n            for i in xrange(len(word)):\n                if not dp[i]:\n                    continue\n\n                for j in xrange(i+1, len(word)+1):\n                    if j - i < len(word) and word[i:j] in lookup:\n                        dp[j] = True\n\n                if dp[len(word)]:\n                    result.append(word)\n                    break\n\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n * l^2)",
      "space_complexity": "O(n * l)"
    },
    {
      "title": "Generate Parentheses",
      "difficulty": "MEDIUM",
      "category": "String, Dynamic Programming, Backtracking",
      "link": "https://leetcode.com/problems/generate-parentheses",
      "slug": "generate-parentheses",
      "description": "Given \nn\n pairs of parentheses, write a function to \ngenerate all combinations of well-formed parentheses\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n n = 3\n\nOutput:\n [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n\nExample 2:\n\n\nInput:\n n = 1\n\nOutput:\n [\"()\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 8",
      "solution": "\n# iterative solutionclass Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result, curr = [], []\n        stk = [(1, (n, n))]\n        while stk:\n            step, args = stk.pop()\n            if step == 1:\n                left, right = args\n                if left == 0 and right == 0:\n                    result.append(\"\".join(curr))\n                if left < right:\n                    stk.append((3, tuple()))\n                    stk.append((1, (left, right-1)))\n                    stk.append((2, (')')))\n                if left > 0:\n                    stk.append((3, tuple()))\n                    stk.append((1, (left-1, right)))\n                    stk.append((2, ('(')))\n            elif step == 2:\n                curr.append(args[0])\n            elif step == 3:\n                curr.pop()\n        return result\n\n\n# recursive solutionclass Solution2(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        def generateParenthesisRecu(left, right, curr, result):\n            if left == 0 and right == 0:\n                result.append(\"\".join(curr))\n            if left > 0:\n                curr.append('(')\n                generateParenthesisRecu(left-1, right, curr, result)\n                curr.pop()\n            if left < right:\n                curr.append(')')\n                generateParenthesisRecu(left, right-1, curr, result)\n                curr.pop()\n\n        result = []\n        generateParenthesisRecu(n, n, [], result)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(4^n / n^(3/2)) ~= Catalan numbers",
      "space_complexity": "O(n)"
    },
    {
      "title": "Search a 2D Matrix",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search, Matrix",
      "link": "https://leetcode.com/problems/search-a-2d-matrix",
      "slug": "search-a-2d-matrix",
      "description": "You are given an \nm x n\n integer matrix \nmatrix\n with the following two properties:\n\n\n\n\nEach row is sorted in non-decreasing order.\n\n\nThe first integer of each row is greater than the last integer of the previous row.\n\n\n\n\nGiven an integer \ntarget\n, return \ntrue\n \nif\n \ntarget\n \nis in\n \nmatrix\n \nor\n \nfalse\n \notherwise\n.\n\n\nYou must write a solution in \nO(log(m * n))\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 100\n\n\n-10\n4\n <= matrix[i][j], target <= 10\n4",
      "solution": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not matrix:\n            return False\n\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n\n        while left < right:\n            mid = left + (right - left) / 2\n            if matrix[mid / n][mid % n] >= target:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left < m * n and matrix[left / n][left % n] == target",
      "explanation": "N/A",
      "time_complexity": "O(logm + logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Coin Change",
      "difficulty": "MEDIUM",
      "category": "Array, Dynamic Programming, Breadth-First Search",
      "link": "https://leetcode.com/problems/coin-change",
      "slug": "coin-change",
      "description": "You are given an integer array \ncoins\n representing coins of different denominations and an integer \namount\n representing a total amount of money.\n\n\nReturn \nthe fewest number of coins that you need to make up that amount\n. If that amount of money cannot be made up by any combination of the coins, return \n-1\n.\n\n\nYou may assume that you have an infinite number of each kind of coin.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n coins = [1,2,5], amount = 11\n\nOutput:\n 3\n\nExplanation:\n 11 = 5 + 5 + 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n coins = [2], amount = 3\n\nOutput:\n -1\n\n\n\nExample 3:\n\n\n\n\nInput:\n coins = [1], amount = 0\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= coins.length <= 12\n\n\n1 <= coins[i] <= 2\n31\n - 1\n\n\n0 <= amount <= 10\n4",
      "solution": "class Solution(object):\n    def coinChange(self, coins, amount):\n        \"\"\"\n        :type coins: List[int]\n        :type amount: int\n        :rtype: int\n        \"\"\"\n        INF = 0x7fffffff  # Using float(\"inf\") would be slower.\n        dp = [INF] * (amount + 1)\n        dp[0] = 0\n        for i in xrange(amount + 1):\n            if dp[i] != INF:\n                for coin in coins:\n                    if i + coin <= amount:\n                        dp[i + coin] = min(dp[i + coin], dp[i] + 1)\n        return dp[amount] if dp[amount] != INF else -1",
      "explanation": "N/A",
      "time_complexity": "O(n * k), n is the number of coins, k is the amount of money",
      "space_complexity": "O(k)"
    },
    {
      "title": "Unique Paths",
      "difficulty": "MEDIUM",
      "category": "Math, Dynamic Programming, Combinatorics",
      "link": "https://leetcode.com/problems/unique-paths",
      "slug": "unique-paths",
      "description": "There is a robot on an \nm x n\n grid. The robot is initially located at the \ntop-left corner\n (i.e., \ngrid[0][0]\n). The robot tries to move to the \nbottom-right corner\n (i.e., \ngrid[m - 1][n - 1]\n). The robot can only move either down or right at any point in time.\n\n\nGiven the two integers \nm\n and \nn\n, return \nthe number of possible unique paths that the robot can take to reach the bottom-right corner\n.\n\n\nThe test cases are generated so that the answer will be less than or equal to \n2 * 10\n9\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 3, n = 7\n\nOutput:\n 28\n\n\n\nExample 2:\n\n\n\n\nInput:\n m = 3, n = 2\n\nOutput:\n 3\n\nExplanation:\n From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m, n <= 100",
      "solution": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def nCr(n, r):  # Time: O(n), Space: O(1)\n            if n-r < r:\n                r = n-r\n            c = 1\n            for k in xrange(1, r+1):\n                c *= n-k+1\n                c //= k\n            return c\n\n        return nCr((m-1)+(n-1), n-1)\n\nclass Solution2(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if m < n:\n            m, n  = n, m\n\n        dp = [1]*n\n        for i in xrange(1, m):\n            for j in xrange(1, n):\n                dp[j] += dp[j-1]\n        return dp[n-1]",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(min(m, n))"
    },
    {
      "title": "LFU Cache",
      "difficulty": "HARD",
      "category": "Hash Table, Linked List, Design, Doubly-Linked List",
      "link": "https://leetcode.com/problems/lfu-cache",
      "slug": "lfu-cache",
      "description": "Design and implement a data structure for a \nLeast Frequently Used (LFU)\n cache.\n\n\nImplement the \nLFUCache\n class:\n\n\n\n\nLFUCache(int capacity)\n Initializes the object with the \ncapacity\n of the data structure.\n\n\nint get(int key)\n Gets the value of the \nkey\n if the \nkey\n exists in the cache. Otherwise, returns \n-1\n.\n\n\nvoid put(int key, int value)\n Update the value of the \nkey\n if present, or inserts the \nkey\n if not already present. When the cache reaches its \ncapacity\n, it should invalidate and remove the \nleast frequently used\n key before inserting a new item. For this problem, when there is a \ntie\n (i.e., two or more keys with the same frequency), the \nleast recently used\n \nkey\n would be invalidated.\n\n\n\n\nTo determine the least frequently used key, a \nuse counter\n is maintained for each key in the cache. The key with the smallest \nuse counter\n is the least frequently used key.\n\n\nWhen a key is first inserted into the cache, its \nuse counter\n is set to \n1\n (due to the \nput\n operation). The \nuse counter\n for a key in the cache is incremented either a \nget\n or \nput\n operation is called on it.\n\n\nThe functions \nget\n and \nput\n must each run in \nO(1)\n average time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\n\nOutput\n\n[null, null, null, 1, null, -1, 3, null, -1, 3, 4]\n\n\nExplanation\n\n// cnt(x) = the use counter for key x\n// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)\nLFUCache lfu = new LFUCache(2);\nlfu.put(1, 1);   // cache=[1,_], cnt(1)=1\nlfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1\nlfu.get(1);      // return 1\n                 // cache=[1,2], cnt(2)=1, cnt(1)=2\nlfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.\n                 // cache=[3,1], cnt(3)=1, cnt(1)=2\nlfu.get(2);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=[3,1], cnt(3)=2, cnt(1)=2\nlfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.\n                 // cache=[4,3], cnt(4)=1, cnt(3)=2\nlfu.get(1);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=[3,4], cnt(4)=1, cnt(3)=3\nlfu.get(4);      // return 4\n                 // cache=[4,3], cnt(4)=2, cnt(3)=3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= capacity <= 10\n4\n\n\n0 <= key <= 10\n5\n\n\n0 <= value <= 10\n9\n\n\nAt most \n2 * 10\n5\n calls will be made to \nget\n and \nput\n.",
      "solution": "\nimport collections\n\n\n# using OrderedDictclass LFUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.__capa = capacity\n        self.__size = 0\n        self.__min_freq = float(\"inf\")\n        self.__freq_to_nodes = collections.defaultdict(collections.OrderedDict)\n        self.__key_to_freq = {}\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.__key_to_freq:\n            return -1\n        value = self.__freq_to_nodes[self.__key_to_freq[key]][key]\n        self.__update(key, value)\n        return value\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: void\n        \"\"\"\n        if self.__capa <= 0:\n            return\n\n        if key not in self.__key_to_freq and self.__size == self.__capa:\n            del self.__key_to_freq[self.__freq_to_nodes[self.__min_freq].popitem(last=False)[0]]\n            if not self.__freq_to_nodes[self.__min_freq]:\n                del self.__freq_to_nodes[self.__min_freq]\n            self.__size -= 1\n        self.__update(key, value)\n        \n    def __update(self, key, value):\n        freq = 0\n        if key in self.__key_to_freq:\n            freq = self.__key_to_freq[key]\n            del self.__freq_to_nodes[freq][key]\n            if not self.__freq_to_nodes[freq]:\n                del self.__freq_to_nodes[freq]\n                if self.__min_freq == freq:\n                    self.__min_freq += 1\n            self.__size -= 1\n\n        freq += 1\n        self.__min_freq = min(self.__min_freq, freq)\n        self.__key_to_freq[key] = freq\n        self.__freq_to_nodes[freq][key] = value\n        self.__size += 1\n\n\nimport collections\n\nclass ListNode(object):\n    def __init__(self, key, value, freq):\n        self.key = key\n        self.val = value\n        self.freq = freq\n        self.next = None\n        self.prev = None\n\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def append(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\n\nclass LFUCache2(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.__capa = capacity\n        self.__size = 0\n        self.__min_freq = float(\"inf\")\n        self.__freq_to_nodes = collections.defaultdict(LinkedList)\n        self.__key_to_node = {}\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.__key_to_node:\n            return -1\n        value = self.__key_to_node[key].val\n        self.__update(key, value)\n        return value\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: void\n        \"\"\"\n        if self.__capa <= 0:\n            return\n\n        if key not in self.__key_to_node and self.__size == self.__capa:\n            del self.__key_to_node[self.__freq_to_nodes[self.__min_freq].head.key]\n            self.__freq_to_nodes[self.__min_freq].delete(self.__freq_to_nodes[self.__min_freq].head)\n            if not self.__freq_to_nodes[self.__min_freq].head:\n                del self.__freq_to_nodes[self.__min_freq]\n            self.__size -= 1\n        self.__update(key, value)\n        \n    def __update(self, key, value):\n        freq = 0\n        if key in self.__key_to_node:\n            old_node = self.__key_to_node[key]\n            freq = old_node.freq\n            self.__freq_to_nodes[freq].delete(old_node)\n            if not self.__freq_to_nodes[freq].head:\n                del self.__freq_to_nodes[freq]\n                if self.__min_freq == freq:\n                    self.__min_freq += 1\n            self.__size -= 1\n\n        freq += 1\n        self.__min_freq = min(self.__min_freq, freq)\n        self.__key_to_node[key] = ListNode(key, value, freq)\n        self.__freq_to_nodes[freq].append(self.__key_to_node[key])\n        self.__size += 1",
      "explanation": "N/A",
      "time_complexity": "O(1), per operation",
      "space_complexity": "O(k), k is the capacity of cache"
    },
    {
      "title": "Search in Rotated Sorted Array",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/search-in-rotated-sorted-array",
      "slug": "search-in-rotated-sorted-array",
      "description": "There is an integer array \nnums\n sorted in ascending order (with \ndistinct\n values).\n\n\nPrior to being passed to your function, \nnums\n is \npossibly rotated\n at an unknown pivot index \nk\n (\n1 <= k < nums.length\n) such that the resulting array is \n[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]\n (\n0-indexed\n). For example, \n[0,1,2,4,5,6,7]\n might be rotated at pivot index \n3\n and become \n[4,5,6,7,0,1,2]\n.\n\n\nGiven the array \nnums\n \nafter\n the possible rotation and an integer \ntarget\n, return \nthe index of \ntarget\n if it is in \nnums\n, or \n-1\n if it is not in \nnums\n.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [4,5,6,7,0,1,2], target = 0\n\nOutput:\n 4\n\nExample 2:\n\n\nInput:\n nums = [4,5,6,7,0,1,2], target = 3\n\nOutput:\n -1\n\nExample 3:\n\n\nInput:\n nums = [1], target = 0\n\nOutput:\n -1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 5000\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nAll values of \nnums\n are \nunique\n.\n\n\nnums\n is an ascending array that is possibly rotated.\n\n\n-10\n4\n <= target <= 10\n4",
      "solution": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) / 2\n\n            if nums[mid] == target:\n                return mid\n            elif (nums[mid] >= nums[left] and nums[left] <= target < nums[mid]) or \\\n                 (nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])):\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return -1",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Next Permutation",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers",
      "link": "https://leetcode.com/problems/next-permutation",
      "slug": "next-permutation",
      "description": "A \npermutation\n of an array of integers is an arrangement of its members into a sequence or linear order.\n\n\n\n\nFor example, for \narr = [1,2,3]\n, the following are all the permutations of \narr\n: \n[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]\n.\n\n\n\n\nThe \nnext permutation\n of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the \nnext permutation\n of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n\n\n\nFor example, the next permutation of \narr = [1,2,3]\n is \n[1,3,2]\n.\n\n\nSimilarly, the next permutation of \narr = [2,3,1]\n is \n[3,1,2]\n.\n\n\nWhile the next permutation of \narr = [3,2,1]\n is \n[1,2,3]\n because \n[3,2,1]\n does not have a lexicographical larger rearrangement.\n\n\n\n\nGiven an array of integers \nnums\n, \nfind the next permutation of\n \nnums\n.\n\n\nThe replacement must be \nin place\n and use only constant extra memory.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n [1,3,2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,1]\n\nOutput:\n [1,2,3]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,1,5]\n\nOutput:\n [1,5,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 100",
      "solution": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in reversed(xrange(len(nums)-1)):\n            if nums[i] < nums[i+1]:\n                k = i\n                break\n        else:\n            nums.reverse()\n            return\n\n        for i in reversed(xrange(k+1, len(nums))):\n            if nums[i] > nums[k]:\n                l = i\n                break\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]\n        \nclass Solution2(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in xrange(len(nums)-1):\n            if nums[i] < nums[i+1]:\n                k = i\n\n        if k == -1:\n            nums.reverse()\n            return\n\n        for i in xrange(k+1, len(nums)):\n            if nums[i] > nums[k]:\n                l = i\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Rotting Oranges",
      "difficulty": "MEDIUM",
      "category": "Array, Breadth-First Search, Matrix",
      "link": "https://leetcode.com/problems/rotting-oranges",
      "slug": "rotting-oranges",
      "description": "You are given an \nm x n\n \ngrid\n where each cell can have one of three values:\n\n\n\n\n0\n representing an empty cell,\n\n\n1\n representing a fresh orange, or\n\n\n2\n representing a rotten orange.\n\n\n\n\nEvery minute, any fresh orange that is \n4-directionally adjacent\n to a rotten orange becomes rotten.\n\n\nReturn \nthe minimum number of minutes that must elapse until no cell has a fresh orange\n. If \nthis is impossible, return\n \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[2,1,1],[1,1,0],[0,1,1]]\n\nOutput:\n 4\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[2,1,1],[0,1,1],[1,0,1]]\n\nOutput:\n -1\n\nExplanation:\n The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[0,2]]\n\nOutput:\n 0\n\nExplanation:\n Since there are already no fresh oranges at minute 0, the answer is just 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 10\n\n\ngrid[i][j]\n is \n0\n, \n1\n, or \n2\n.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def orangesRotting(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        count = 0\n        q = collections.deque()\n        for r, row in enumerate(grid):\n            for c, val in enumerate(row):\n                if val == 2:\n                    q.append((r, c, 0))\n                elif val == 1:\n                    count += 1\n\n        result = 0\n        while q:\n            r, c, result = q.popleft()\n            for d in directions:\n                nr, nc = r+d[0], c+d[1]\n                if not (0 <= nr < len(grid) and \\\n                        0 <= nc < len(grid[r])):\n                    continue\n                if grid[nr][nc] == 1:\n                    count -= 1\n                    grid[nr][nc] = 2\n                    q.append((nr, nc, result+1))\n        return result if count == 0 else -1",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Math, Design, Randomized",
      "link": "https://leetcode.com/problems/insert-delete-getrandom-o1",
      "slug": "insert-delete-getrandom-o1",
      "description": "Implement the \nRandomizedSet\n class:\n\n\n\n\nRandomizedSet()\n Initializes the \nRandomizedSet\n object.\n\n\nbool insert(int val)\n Inserts an item \nval\n into the set if not present. Returns \ntrue\n if the item was not present, \nfalse\n otherwise.\n\n\nbool remove(int val)\n Removes an item \nval\n from the set if present. Returns \ntrue\n if the item was present, \nfalse\n otherwise.\n\n\nint getRandom()\n Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the \nsame probability\n of being returned.\n\n\n\n\nYou must implement the functions of the class such that each function works in \naverage\n \nO(1)\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], [], [1], [2], []]\n\nOutput\n\n[null, true, false, true, 2, true, false, 2]\n\n\nExplanation\n\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= val <= 2\n31\n - 1\n\n\nAt most \n2 * \n10\n5\n calls will be made to \ninsert\n, \nremove\n, and \ngetRandom\n.\n\n\nThere will be \nat least one\n element in the data structure when \ngetRandom\n is called.",
      "solution": "\nfrom random import randint\nclass RandomizedSet(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__set = []\n        self.__used = {}\n\n\n    def insert(self, val):\n        \"\"\"\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        if val in self.__used:\n            return False\n\n        self.__set += val,\n        self.__used[val] = len(self.__set)-1\n\n        return True\n\n\n    def remove(self, val):\n        \"\"\"\n        Removes a value from the set. Returns true if the set contained the specified element.\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        if val not in self.__used:\n            return False\n\n        self.__used[self.__set[-1]] = self.__used[val]\n        self.__set[self.__used[val]], self.__set[-1] = self.__set[-1], self.__set[self.__used[val]]\n\n        self.__used.pop(val)\n        self.__set.pop()\n\n        return True\n\n    def getRandom(self):\n        \"\"\"\n        Get a random element from the set.\n        :rtype: int\n        \"\"\"\n        return self.__set[randint(0, len(self.__set)-1)]",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Flood Fill",
      "difficulty": "EASY",
      "category": "Array, Depth-First Search, Breadth-First Search, Matrix",
      "link": "https://leetcode.com/problems/flood-fill",
      "slug": "flood-fill",
      "description": "You are given an image represented by an \nm x n\n grid of integers \nimage\n, where \nimage[i][j]\n represents the pixel value of the image. You are also given three integers \nsr\n, \nsc\n, and \ncolor\n. Your task is to perform a \nflood fill\n on the image starting from the pixel \nimage[sr][sc]\n.\n\n\nTo perform a \nflood fill\n:\n\n\n\n\nBegin with the starting pixel and change its color to \ncolor\n.\n\n\nPerform the same process for each pixel that is \ndirectly adjacent\n (pixels that share a side with the original pixel, either horizontally or vertically) and shares the \nsame color\n as the starting pixel.\n\n\nKeep \nrepeating\n this process by checking neighboring pixels of the \nupdated\n pixels and modifying their color if it matches the original color of the starting pixel.\n\n\nThe process \nstops\n when there are \nno more\n adjacent pixels of the original color to update.\n\n\n\n\nReturn the \nmodified\n image after performing the flood fill.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nimage = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\n\n\nOutput:\n \n[[2,2,2],[2,2,0],[2,0,1]]\n\n\nExplanation:\n\n\n\n\nFrom the center of the image with position \n(sr, sc) = (1, 1)\n (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\n\n\nNote the bottom corner is \nnot\n colored 2, because it is not horizontally or vertically connected to the starting pixel.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nimage = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0\n\n\nOutput:\n \n[[0,0,0],[0,0,0]]\n\n\nExplanation:\n\n\nThe starting pixel is already colored with 0, which is the same as the target color. Therefore, no changes are made to the image.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == image.length\n\n\nn == image[i].length\n\n\n1 <= m, n <= 50\n\n\n0 <= image[i][j], color < 2\n16\n\n\n0 <= sr < m\n\n\n0 <= sc < n",
      "solution": "class Solution(object):\n    def floodFill(self, image, sr, sc, newColor):\n        \"\"\"\n        :type image: List[List[int]]\n        :type sr: int\n        :type sc: int\n        :type newColor: int\n        :rtype: List[List[int]]\n        \"\"\"\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n        def dfs(image, r, c, newColor, color):\n            if not (0 <= r < len(image) and \\\n                    0 <= c < len(image[0]) and \\\n                    image[r][c] == color):\n                return\n\n            image[r][c] = newColor\n            for d in directions:\n                dfs(image, r+d[0], c+d[1], newColor, color)\n\n        color = image[sr][sc]\n        if color == newColor: return image\n        dfs(image, sr, sc, newColor, color)\n        return image",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "Fizz Buzz",
      "difficulty": "EASY",
      "category": "Math, String, Simulation",
      "link": "https://leetcode.com/problems/fizz-buzz",
      "slug": "fizz-buzz",
      "description": "Given an integer \nn\n, return \na string array \nanswer\n (\n1-indexed\n) where\n:\n\n\n\n\nanswer[i] == \"FizzBuzz\"\n if \ni\n is divisible by \n3\n and \n5\n.\n\n\nanswer[i] == \"Fizz\"\n if \ni\n is divisible by \n3\n.\n\n\nanswer[i] == \"Buzz\"\n if \ni\n is divisible by \n5\n.\n\n\nanswer[i] == i\n (as a string) if none of the above conditions are true.\n\n\n\n\n \n\n\nExample 1:\n\n\nInput:\n n = 3\n\nOutput:\n [\"1\",\"2\",\"Fizz\"]\n\nExample 2:\n\n\nInput:\n n = 5\n\nOutput:\n [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]\n\nExample 3:\n\n\nInput:\n n = 15\n\nOutput:\n [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n4",
      "solution": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result = []\n\n        for i in xrange(1, n+1):\n            if i % 15 == 0:\n                result.append(\"FizzBuzz\")\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            else:\n                result.append(str(i))\n\n        return result\n\n    def fizzBuzz2(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        l = [str(x) for x in range(n + 1)]\n        l3 = range(0, n + 1, 3)\n        l5 = range(0, n + 1, 5)\n        for i in l3:\n            l[i] = 'Fizz'\n        for i in l5:\n            if l[i] == 'Fizz':\n                l[i] += 'Buzz'\n            else:\n                l[i] = 'Buzz'\n        return l[1:]\n\n    def fizzBuzz3(self, n):\n        return ['Fizz' * (not i % 3) + 'Buzz' * (not i % 5) or str(i) for i in range(1, n + 1)]\n\n    def fizzBuzz4(self, n):\n        return ['FizzBuzz'[i % -3 & -4:i % -5 & 8 ^ 12] or repr(i) for i in range(1, n + 1)]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Top K Frequent Words",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, String, Trie, Sorting, Heap (Priority Queue), Bucket Sort, Counting",
      "link": "https://leetcode.com/problems/top-k-frequent-words",
      "slug": "top-k-frequent-words",
      "description": "Given an array of strings \nwords\n and an integer \nk\n, return \nthe \nk\n most frequent strings\n.\n\n\nReturn the answer \nsorted\n by \nthe frequency\n from highest to lowest. Sort the words with the same frequency by their \nlexicographical order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2\n\nOutput:\n [\"i\",\"love\"]\n\nExplanation:\n \"i\" and \"love\" are the two most frequent words.\nNote that \"i\" comes before \"love\" due to a lower alphabetical order.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4\n\nOutput:\n [\"the\",\"is\",\"sunny\",\"day\"]\n\nExplanation:\n \"the\", \"is\", \"sunny\" and \"day\" are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 500\n\n\n1 <= words[i].length <= 10\n\n\nwords[i]\n consists of lowercase English letters.\n\n\nk\n is in the range \n[1, The number of \nunique\n words[i]]\n\n\n\n\n \n\n\nFollow-up:\n Could you solve it in \nO(n log(k))\n time and \nO(n)\n extra space?",
      "solution": "\nimport collections\nimport heapq\nfrom random import randint\n\nclass Solution(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counts = collections.Counter(words)\n        p = []\n        for key, val in counts.iteritems():\n            p.append((-val, key))\n        self.kthElement(p, k-1)\n\n        result = []\n        sorted_p = sorted(p[:k])\n        for i in xrange(k):\n            result.append(sorted_p[i][1])\n        return result\n\n    def kthElement(self, nums, k):  # O(n) on average\n        def PartitionAroundPivot(left, right, pivot_idx, nums):\n            pivot_value = nums[pivot_idx]\n            new_pivot_idx = left\n            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n            for i in xrange(left, right):\n                if nums[i] < pivot_value:\n                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                    new_pivot_idx += 1\n\n            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n            return new_pivot_idx\n\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k:\n                return\n            elif new_pivot_idx > k:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k.\n                left = new_pivot_idx + 1\n\n\n# Heap Solutionclass Solution2(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        class MinHeapObj(object):\n            def __init__(self,val):\n                self.val = val\n            def __lt__(self,other):\n                return self.val[1] > other.val[1] if self.val[0] == other.val[0] else \\\n                       self.val < other.val\n            def __eq__(self,other):\n                return self.val == other.val\n            def __str__(self):\n                return str(self.val)\n\n        counts = collections.Counter(words)\n        min_heap = []\n        for word, count in counts.iteritems():\n            heapq.heappush(min_heap, MinHeapObj((count, word)))\n            if len(min_heap) == k+1:\n                heapq.heappop(min_heap)\n        result = []\n        while min_heap:\n            result.append(heapq.heappop(min_heap).val[1])\n        return result[::-1]\n\n\n# Bucket Sort Solutionclass Solution3(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counts = collections.Counter(words)\n        buckets = [[] for _ in xrange(len(words)+1)]\n        for word, count in counts.iteritems():\n            buckets[count].append(word)\n        pairs = []\n        for i in reversed(xrange(len(words))):\n            for word in buckets[i]:\n                pairs.append((-i, word))\n            if len(pairs) >= k:\n                break\n        pairs.sort()\n        return [pair[1] for pair in pairs[:k]]\n\n\n# time: O(nlogn)\n# space: O(n)\n\nfrom collections import Counter\n\nclass Solution4(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counter = Counter(words)\n        candidates = counter.keys()\n        candidates.sort(key=lambda w: (-counter[w], w))\n        return candidates[:k]",
      "explanation": "N/A",
      "time_complexity": "O(n + klogk) ~ O(n + nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Integer to Roman",
      "difficulty": "MEDIUM",
      "category": "Hash Table, Math, String",
      "link": "https://leetcode.com/problems/integer-to-roman",
      "slug": "integer-to-roman",
      "description": "Seven different symbols represent Roman numerals with the following values:\n\n\n\n\n\n\n\n\nSymbol\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nI\n\n\n1\n\n\n\n\n\n\nV\n\n\n5\n\n\n\n\n\n\nX\n\n\n10\n\n\n\n\n\n\nL\n\n\n50\n\n\n\n\n\n\nC\n\n\n100\n\n\n\n\n\n\nD\n\n\n500\n\n\n\n\n\n\nM\n\n\n1000\n\n\n\n\n\n\n\n\nRoman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\n\n\n\n\nIf the value does not start with 4 or 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.\n\n\nIf the value starts with 4 or 9 use the \nsubtractive form\n representing one symbol subtracted from the following symbol, for example, 4 is 1 (\nI\n) less than 5 (\nV\n): \nIV\n and 9 is 1 (\nI\n) less than 10 (\nX\n): \nIX\n. Only the following subtractive forms are used: 4 (\nIV\n), 9 (\nIX\n), 40 (\nXL\n), 90 (\nXC\n), 400 (\nCD\n) and 900 (\nCM\n).\n\n\nOnly powers of 10 (\nI\n, \nX\n, \nC\n, \nM\n) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5 (\nV\n), 50 (\nL\n), or 500 (\nD\n) multiple times. If you need to append a symbol 4 times use the \nsubtractive form\n.\n\n\n\n\nGiven an integer, convert it to a Roman numeral.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnum = 3749\n\n\nOutput:\n \n\"MMMDCCXLIX\"\n\n\nExplanation:\n\n\n\n3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC as 500 (D) + 100 (C) + 100 (C)\n  40 = XL as 10 (X) less of 50 (L)\n   9 = IX as 1 (I) less of 10 (X)\nNote: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnum = 58\n\n\nOutput:\n \n\"LVIII\"\n\n\nExplanation:\n\n\n\n50 = L\n 8 = VIII\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnum = 1994\n\n\nOutput:\n \n\"MCMXCIV\"\n\n\nExplanation:\n\n\n\n1000 = M\n 900 = CM\n  90 = XC\n   4 = IV\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num <= 3999",
      "solution": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        numeral_map = {1: \"I\", 4: \"IV\", 5: \"V\", 9: \"IX\", \\\n                       10: \"X\", 40: \"XL\", 50: \"L\", 90: \"XC\", \\\n                       100: \"C\", 400: \"CD\", 500: \"D\", 900: \"CM\", \\\n                       1000: \"M\"}\n        keyset, result = sorted(numeral_map.keys()), []\n\n        while num > 0:\n            for key in reversed(keyset):\n                while num / key > 0:\n                    num -= key\n                    result += numeral_map[key]\n\n        return \"\".join(result)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Invert Binary Tree",
      "difficulty": "EASY",
      "category": "Tree, Depth-First Search, Breadth-First Search, Binary Tree",
      "link": "https://leetcode.com/problems/invert-binary-tree",
      "slug": "invert-binary-tree",
      "description": "Given the \nroot\n of a binary tree, invert the tree, and return \nits root\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,2,7,1,3,6,9]\n\nOutput:\n [4,7,2,9,6,3,1]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [2,1,3]\n\nOutput:\n [2,3,1]\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100",
      "solution": "\nimport collections\n\n\n# BFS solution.class Queue(object):\n    def __init__(self):\n        self.data = collections.deque()\n\n    def push(self, x):\n        self.data.append(x)\n\n    def peek(self):\n        return self.data[0]\n\n    def pop(self):\n        return self.data.popleft()\n\n    def size(self):\n        return len(self.data)\n\n    def empty(self):\n        return len(self.data) == 0\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\nclass Solution(object):\n    # @param {TreeNode} root\n    # @return {TreeNode}\n    def invertTree(self, root):\n        if root is not None:\n            nodes = Queue()\n            nodes.push(root)\n            while not nodes.empty():\n                node = nodes.pop()\n                node.left, node.right = node.right, node.left\n                if node.left is not None:\n                    nodes.push(node.left)\n                if node.right is not None:\n                    nodes.push(node.right)\n\n        return root\n\n# Stack solution.class Solution2(object):\n    # @param {TreeNode} root\n    # @return {TreeNode}\n    def invertTree(self, root):\n        if root is not None:\n            nodes = []\n            nodes.append(root)\n            while nodes:\n                node = nodes.pop()\n                node.left, node.right = node.right, node.left\n                if node.left is not None:\n                    nodes.append(node.left)\n                if node.right is not None:\n                    nodes.append(node.right)\n\n        return root\n\n# DFS, Recursive solution.class Solution3(object):\n    # @param {TreeNode} root\n    # @return {TreeNode}\n    def invertTree(self, root):\n        if root is not None:\n            root.left, root.right = self.invertTree(root.right), \\\n                                    self.invertTree(root.left)\n\n        return root",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Move Zeroes",
      "difficulty": "EASY",
      "category": "Array, Two Pointers",
      "link": "https://leetcode.com/problems/move-zeroes",
      "slug": "move-zeroes",
      "description": "Given an integer array \nnums\n, move all \n0\n's to the end of it while maintaining the relative order of the non-zero elements.\n\n\nNote\n that you must do this in-place without making a copy of the array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [0,1,0,3,12]\n\nOutput:\n [1,3,12,0,0]\n\nExample 2:\n\n\nInput:\n nums = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you minimize the total number of operations done?",
      "solution": "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i]:\n                nums[i], nums[pos] = nums[pos], nums[i]\n                pos += 1\n\n    def moveZeroes2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort(cmp=lambda a, b: 0 if b else -1)\n\nclass Solution2(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i]:\n                nums[pos] = nums[i]\n                pos += 1\n\n        for i in xrange(pos, len(nums)):\n            nums[i] = 0",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Basic Calculator",
      "difficulty": "HARD",
      "category": "Math, String, Stack, Recursion",
      "link": "https://leetcode.com/problems/basic-calculator",
      "slug": "basic-calculator",
      "description": "Given a string \ns\n representing a valid expression, implement a basic calculator to evaluate it, and return \nthe result of the evaluation\n.\n\n\nNote:\n You are \nnot\n allowed to use any built-in function which evaluates strings as mathematical expressions, such as \neval()\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"1 + 1\"\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \" 2-1 + 2 \"\n\nOutput:\n 3\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"(1+(4+5+2)-3)+(6+8)\"\n\nOutput:\n 23\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 3 * 10\n5\n\n\ns\n consists of digits, \n'+'\n, \n'-'\n, \n'('\n, \n')'\n, and \n' '\n.\n\n\ns\n represents a valid expression.\n\n\n'+'\n is \nnot\n used as a unary operation (i.e., \n\"+1\"\n and \n\"+(2 + 3)\"\n is invalid).\n\n\n'-'\n could be used as a unary operation (i.e., \n\"-1\"\n and \n\"-(2 + 3)\"\n is valid).\n\n\nThere will be no two consecutive operators in the input.\n\n\nEvery number and running calculation will fit in a signed 32-bit integer.",
      "solution": "\nimport operator\n\nclass Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def compute(operands, operators):\n            right, left = operands.pop(), operands.pop()\n            operands.append(ops[operators.pop()](left, right))\n\n        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}\n        precedence = {'+':0, '-':0, '*':1, '/':1}\n        operands, operators, operand = [], [], 0\n        for i in xrange(len(s)):\n            if s[i].isdigit():\n                operand = operand*10 + int(s[i])\n                if i == len(s)-1 or not s[i+1].isdigit():\n                    operands.append(operand)\n                    operand = 0\n            elif s[i] == '(':\n                operators.append(s[i])\n            elif s[i] == ')':\n                while operators[-1] != '(':\n                    compute(operands, operators)\n                operators.pop()\n            elif s[i] in precedence:\n                while operators and operators[-1] in precedence and \\\n                      precedence[operators[-1]] >= precedence[s[i]]:\n                    compute(operands, operators)\n                operators.append(s[i])\n        while operators:\n            compute(operands, operators)\n        return operands[-1]\n\nclass Solution2(object):\n    # @param {string} s\n    # @return {integer}\n    def calculate(self, s):\n        operands, operators = [], []\n        operand = \"\"\n        for i in reversed(xrange(len(s))):\n            if s[i].isdigit():\n                operand += s[i]\n                if i == 0 or not s[i-1].isdigit():\n                    operands.append(int(operand[::-1]))\n                    operand = \"\"\n            elif s[i] == ')' or s[i] == '+' or s[i] == '-':\n                operators.append(s[i])\n            elif s[i] == '(':\n                while operators[-1] != ')':\n                    self.compute(operands, operators)\n                operators.pop()\n\n        while operators:\n            self.compute(operands, operators)\n\n        return operands[-1]\n\n    def compute(self, operands, operators):\n        left, right = operands.pop(), operands.pop()\n        op = operators.pop()\n        if op == '+':\n            operands.append(left + right)\n        elif op == '-':\n            operands.append(left - right)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Find All Possible Recipes from Given Supplies",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, String, Graph, Topological Sort",
      "link": "https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies",
      "slug": "find-all-possible-recipes-from-given-supplies",
      "description": "You have information about \nn\n different recipes. You are given a string array \nrecipes\n and a 2D string array \ningredients\n. The \ni\nth\n recipe has the name \nrecipes[i]\n, and you can \ncreate\n it if you have \nall\n the needed ingredients from \ningredients[i]\n. A recipe can also be an ingredient for \nother \nrecipes, i.e., \ningredients[i]\n may contain a string that is in \nrecipes\n.\n\n\nYou are also given a string array \nsupplies\n containing all the ingredients that you initially have, and you have an infinite supply of all of them.\n\n\nReturn \na list of all the recipes that you can create. \nYou may return the answer in \nany order\n.\n\n\nNote that two recipes may contain each other in their ingredients.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\n\nOutput:\n [\"bread\"]\n\nExplanation:\n\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\n\nOutput:\n [\"bread\",\"sandwich\"]\n\nExplanation:\n\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\n\nOutput:\n [\"bread\",\"sandwich\",\"burger\"]\n\nExplanation:\n\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == recipes.length == ingredients.length\n\n\n1 <= n <= 100\n\n\n1 <= ingredients[i].length, supplies.length <= 100\n\n\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\n\n\nrecipes[i], ingredients[i][j]\n, and \nsupplies[k]\n consist only of lowercase English letters.\n\n\nAll the values of \nrecipes\n and \nsupplies\n combined are unique.\n\n\nEach \ningredients[i]\n does not contain any duplicate values.",
      "solution": "\nimport collections\nimport itertools\nclass Solution(object):\n    def findAllRecipes(self, recipes, ingredients, supplies):\n        \"\"\"\n        :type recipes: List[str]\n        :type ingredients: List[List[str]]\n        :type supplies: List[str]\n        :rtype: List[str]\n        \"\"\"\n        indegree = collections.defaultdict(int)\n        adj = collections.defaultdict(list)\n        for r, ingredient in itertools.izip(recipes, ingredients): \n            indegree[r] = len(ingredient)\n            for ing in ingredient:\n                adj[ing].append(r)\n        result = []\n        recipes = set(recipes)\n        q = supplies\n        while q: \n            new_q = []\n            for u in q:\n                if u in recipes:\n                    result.append(u)\n                for v in adj[u]:\n                    indegree[v] -= 1\n                    if not indegree[v]:\n                        new_q.append(v)\n            q = new_q\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(|E|)",
      "space_complexity": "O(|E|)"
    },
    {
      "title": "String to Integer (atoi)",
      "difficulty": "MEDIUM",
      "category": "String",
      "link": "https://leetcode.com/problems/string-to-integer-atoi",
      "slug": "string-to-integer-atoi",
      "description": "Implement the \nmyAtoi(string s)\n function, which converts a string to a 32-bit signed integer.\n\n\nThe algorithm for \nmyAtoi(string s)\n is as follows:\n\n\n\n\nWhitespace\n: Ignore any leading whitespace (\n\" \"\n).\n\n\nSignedness\n: Determine the sign by checking if the next character is \n'-'\n or \n'+'\n, assuming positivity if neither present.\n\n\nConversion\n: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.\n\n\nRounding\n: If the integer is out of the 32-bit signed integer range \n[-2\n31\n, 2\n31\n - 1]\n, then round the integer to remain in the range. Specifically, integers less than \n-2\n31\n should be rounded to \n-2\n31\n, and integers greater than \n2\n31\n - 1\n should be rounded to \n2\n31\n - 1\n.\n\n\n\n\nReturn the integer as the final result.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"42\"\n\n\nOutput:\n \n42\n\n\nExplanation:\n\n\n\nThe underlined characters are what is read in and the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n42\n\" (\"42\" is read in)\n           ^\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \" -042\"\n\n\nOutput:\n \n-42\n\n\nExplanation:\n\n\n\nStep 1: \"\n   \n-042\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   \n-\n042\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -\n042\n\" (\"042\" is read in, leading zeros ignored in the result)\n               ^\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"1337c0d3\"\n\n\nOutput:\n \n1337\n\n\nExplanation:\n\n\n\nStep 1: \"1337c0d3\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"1337c0d3\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n1337\nc0d3\" (\"1337\" is read in; reading stops because the next character is a non-digit)\n             ^\n\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"0-1\"\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\nStep 1: \"0-1\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"0-1\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n0\n-1\" (\"0\" is read in; reading stops because the next character is a non-digit)\n          ^\n\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"words and 987\"\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nReading stops at the first non-digit character 'w'.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 200\n\n\ns\n consists of English letters (lower-case and upper-case), digits (\n0-9\n), \n' '\n, \n'+'\n, \n'-'\n, and \n'.'\n.",
      "solution": "class Solution(object):\n    def myAtoi(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: int\n        \"\"\"\n        INT_MAX =  2147483647\n        INT_MIN = -2147483648\n        result = 0\n\n        if not str:\n            return result\n\n        i = 0\n        while i < len(str) and str[i].isspace():\n            i += 1\n\n        if len(str) == i:\n            return result\n\n        sign = 1\n        if str[i] == \"+\":\n            i += 1\n        elif str[i] == \"-\":\n            sign = -1\n            i += 1\n\n        while i < len(str) and '0' <= str[i] <= '9':\n            if result > (INT_MAX - int(str[i])) / 10:\n                return INT_MAX if sign > 0 else INT_MIN\n            result = result * 10 + int(str[i])\n            i += 1\n\n        return sign * result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Capacity To Ship Packages Within D Days",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/capacity-to-ship-packages-within-d-days",
      "slug": "capacity-to-ship-packages-within-d-days",
      "description": "A conveyor belt has packages that must be shipped from one port to another within \ndays\n days.\n\n\nThe \ni\nth\n package on the conveyor belt has a weight of \nweights[i]\n. Each day, we load the ship with packages on the conveyor belt (in the order given by \nweights\n). We may not load more weight than the maximum weight capacity of the ship.\n\n\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within \ndays\n days.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n weights = [1,2,3,4,5,6,7,8,9,10], days = 5\n\nOutput:\n 15\n\nExplanation:\n A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\n1st day: 1, 2, 3, 4, 5\n2nd day: 6, 7\n3rd day: 8\n4th day: 9\n5th day: 10\n\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.\n\n\n\nExample 2:\n\n\n\n\nInput:\n weights = [3,2,2,4,1,4], days = 3\n\nOutput:\n 6\n\nExplanation:\n A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:\n1st day: 3, 2\n2nd day: 2, 4\n3rd day: 1, 4\n\n\n\nExample 3:\n\n\n\n\nInput:\n weights = [1,2,3,1,1], days = 4\n\nOutput:\n 3\n\nExplanation:\n\n1st day: 1\n2nd day: 2\n3rd day: 3\n4th day: 1, 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= days <= weights.length <= 5 * 10\n4\n\n\n1 <= weights[i] <= 500",
      "solution": "class Solution(object):\n    def shipWithinDays(self, weights, D):\n        \"\"\"\n        :type weights: List[int]\n        :type D: int\n        :rtype: int\n        \"\"\"\n        def possible(weights, D, mid):\n            result, curr = 1, 0\n            for w in weights:\n                if curr+w > mid:\n                    result += 1\n                    curr = 0\n                curr += w\n            return result <= D\n    \n        left, right = max(weights), sum(weights)\n        while left <= right:\n            mid = left + (right-left)//2\n            if possible(weights, D, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left",
      "explanation": "N/A",
      "time_complexity": "O(nlogr)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Roman to Integer",
      "difficulty": "EASY",
      "category": "Hash Table, Math, String",
      "link": "https://leetcode.com/problems/roman-to-integer",
      "slug": "roman-to-integer",
      "description": "Roman numerals are represented by seven different symbols: \nI\n, \nV\n, \nX\n, \nL\n, \nC\n, \nD\n and \nM\n.\n\n\n\n\nSymbol\n       \nValue\n\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\n\nFor example, \n2\n is written as \nII\n in Roman numeral, just two ones added together. \n12\n is written as \nXII\n, which is simply \nX + II\n. The number \n27\n is written as \nXXVII\n, which is \nXX + V + II\n.\n\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not \nIIII\n. Instead, the number four is written as \nIV\n. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as \nIX\n. There are six instances where subtraction is used:\n\n\n\n\nI\n can be placed before \nV\n (5) and \nX\n (10) to make 4 and 9. \n\n\nX\n can be placed before \nL\n (50) and \nC\n (100) to make 40 and 90. \n\n\nC\n can be placed before \nD\n (500) and \nM\n (1000) to make 400 and 900.\n\n\n\n\nGiven a roman numeral, convert it to an integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"III\"\n\nOutput:\n 3\n\nExplanation:\n III = 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"LVIII\"\n\nOutput:\n 58\n\nExplanation:\n L = 50, V= 5, III = 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"MCMXCIV\"\n\nOutput:\n 1994\n\nExplanation:\n M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 15\n\n\ns\n contains only the characters \n('I', 'V', 'X', 'L', 'C', 'D', 'M')\n.\n\n\nIt is \nguaranteed\n that \ns\n is a valid roman numeral in the range \n[1, 3999]\n.",
      "solution": "class Solution(object):\n    # @return an integer\n    def romanToInt(self, s):\n        numeral_map = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\":100, \"D\": 500, \"M\": 1000}\n        decimal = 0\n        for i in xrange(len(s)):\n            if i > 0 and numeral_map[s[i]] > numeral_map[s[i - 1]]:\n                decimal += numeral_map[s[i]] - 2 * numeral_map[s[i - 1]]\n            else:\n                decimal += numeral_map[s[i]]\n        return decimal",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Palindrome Number",
      "difficulty": "EASY",
      "category": "Math",
      "link": "https://leetcode.com/problems/palindrome-number",
      "slug": "palindrome-number",
      "description": "Given an integer \nx\n, return \ntrue\n if \nx\n is a \npalindrome\n, and \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 121\n\nOutput:\n true\n\nExplanation:\n 121 reads as 121 from left to right and from right to left.\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = -121\n\nOutput:\n false\n\nExplanation:\n From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n\n\nExample 3:\n\n\n\n\nInput:\n x = 10\n\nOutput:\n false\n\nExplanation:\n Reads 01 from right to left. Therefore it is not a palindrome.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= x <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you solve it without converting the integer to a string?",
      "solution": "class Solution(object):\n    # @return a boolean\n    def isPalindrome(self, x):\n        if x < 0:\n            return False\n        copy, reverse = x, 0\n\n        while copy:\n            reverse *= 10\n            reverse += copy % 10\n            copy //= 10\n\n        return x == reverse",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Maximum Subarray",
      "difficulty": "MEDIUM",
      "category": "Array, Divide and Conquer, Dynamic Programming",
      "link": "https://leetcode.com/problems/maximum-subarray",
      "slug": "maximum-subarray",
      "description": "Given an integer array \nnums\n, find the \nsubarray\n with the largest sum, and return \nits sum\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-2,1,-3,4,-1,2,1,-5,4]\n\nOutput:\n 6\n\nExplanation:\n The subarray [4,-1,2,1] has the largest sum 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1]\n\nOutput:\n 1\n\nExplanation:\n The subarray [1] has the largest sum 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [5,4,-1,7,8]\n\nOutput:\n 23\n\nExplanation:\n The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n If you have figured out the \nO(n)\n solution, try coding another solution using the \ndivide and conquer\n approach, which is more subtle.",
      "solution": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, curr = float(\"-inf\"), float(\"-inf\")\n        for x in nums:\n            curr = max(curr+x, x)\n            result = max(result, curr)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Word Search",
      "difficulty": "MEDIUM",
      "category": "Array, String, Backtracking, Depth-First Search, Matrix",
      "link": "https://leetcode.com/problems/word-search",
      "slug": "word-search",
      "description": "Given an \nm x n\n grid of characters \nboard\n and a string \nword\n, return \ntrue\n \nif\n \nword\n \nexists in the grid\n.\n\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == board.length\n\n\nn = board[i].length\n\n\n1 <= m, n <= 6\n\n\n1 <= word.length <= 15\n\n\nboard\n and \nword\n consists of only lowercase and uppercase English letters.\n\n\n\n\n \n\n\nFollow up:\n Could you use search pruning to make your solution faster with a larger \nboard\n?",
      "solution": "class Solution(object):\n    # @param board, a list of lists of 1 length string\n    # @param word, a string\n    # @return a boolean\n    def exist(self, board, word):\n        visited = [[False for j in xrange(len(board[0]))] for i in xrange(len(board))]\n\n        for i in xrange(len(board)):\n            for j in xrange(len(board[0])):\n                if self.existRecu(board, word, 0, i, j, visited):\n                    return True\n\n        return False\n\n    def existRecu(self, board, word, cur, i, j, visited):\n        if cur == len(word):\n            return True\n\n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[cur]:\n            return False\n\n        visited[i][j] = True\n        result = self.existRecu(board, word, cur + 1, i + 1, j, visited) or\\\n                 self.existRecu(board, word, cur + 1, i - 1, j, visited) or\\\n                 self.existRecu(board, word, cur + 1, i, j + 1, visited) or\\\n                 self.existRecu(board, word, cur + 1, i, j - 1, visited)\n        visited[i][j] = False\n\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(m * n * 4 * 3^(l - 1)) ~= O(m * n * 3^l), l is the length of the word",
      "space_complexity": "O(l)"
    },
    {
      "title": "Edit Distance",
      "difficulty": "MEDIUM",
      "category": "String, Dynamic Programming",
      "link": "https://leetcode.com/problems/edit-distance",
      "slug": "edit-distance",
      "description": "Given two strings \nword1\n and \nword2\n, return \nthe minimum number of operations required to convert \nword1\n to \nword2\n.\n\n\nYou have the following three operations permitted on a word:\n\n\n\n\nInsert a character\n\n\nDelete a character\n\n\nReplace a character\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n word1 = \"horse\", word2 = \"ros\"\n\nOutput:\n 3\n\nExplanation:\n \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n\n\n\nExample 2:\n\n\n\n\nInput:\n word1 = \"intention\", word2 = \"execution\"\n\nOutput:\n 5\n\nExplanation:\n \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= word1.length, word2.length <= 500\n\n\nword1\n and \nword2\n consist of lowercase English letters.",
      "solution": "class Solution(object):\n    # @return an integer\n    def minDistance(self, word1, word2):\n        if len(word1) < len(word2):\n            return self.minDistance(word2, word1)\n\n        distance = [i for i in xrange(len(word2) + 1)]\n\n        for i in xrange(1, len(word1) + 1):\n            pre_distance_i_j = distance[0]\n            distance[0] = i\n            for j in xrange(1, len(word2) + 1):\n                insert = distance[j - 1] + 1\n                delete = distance[j] + 1\n                replace = pre_distance_i_j\n                if word1[i - 1] != word2[j - 1]:\n                    replace += 1\n                pre_distance_i_j = distance[j]\n                distance[j] = min(insert, delete, replace)\n\n        return distance[-1]\nclass Solution2(object):\n    # @return an integer\n    def minDistance(self, word1, word2):\n        distance = [[i] for i in xrange(len(word1) + 1)]\n        distance[0] = [j for j in xrange(len(word2) + 1)]\n\n        for i in xrange(1, len(word1) + 1):\n            for j in xrange(1, len(word2) + 1):\n                insert = distance[i][j - 1] + 1\n                delete = distance[i - 1][j] + 1\n                replace = distance[i - 1][j - 1]\n                if word1[i - 1] != word2[j - 1]:\n                    replace += 1\n                distance[i].append(min(insert, delete, replace))\n\n        return distance[-1][-1]",
      "explanation": "N/A",
      "time_complexity": "O(n * m)",
      "space_complexity": "O(n * m)"
    },
    {
      "title": "Kth Largest Element in an Array",
      "difficulty": "MEDIUM",
      "category": "Array, Divide and Conquer, Sorting, Heap (Priority Queue), Quickselect",
      "link": "https://leetcode.com/problems/kth-largest-element-in-an-array",
      "slug": "kth-largest-element-in-an-array",
      "description": "Given an integer array \nnums\n and an integer \nk\n, return \nthe\n \nk\nth\n \nlargest element in the array\n.\n\n\nNote that it is the \nk\nth\n largest element in the sorted order, not the \nk\nth\n distinct element.\n\n\nCan you solve it without sorting?\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [3,2,1,5,6,4], k = 2\n\nOutput:\n 5\n\nExample 2:\n\n\nInput:\n nums = [3,2,3,1,2,4,5,5,6], k = 4\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4",
      "solution": "\nfrom random import randint\n\n\n# optimized for duplicated numsclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        nth_element(nums, k-1, compare=lambda a, b: a > b)\n        return nums[k-1]\n\nclass Solution2(object):\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = self.PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k - 1:\n                return nums[new_pivot_idx]\n            elif new_pivot_idx > k - 1:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k - 1.\n                left = new_pivot_idx + 1\n\n    def PartitionAroundPivot(self, left, right, pivot_idx, nums):\n        pivot_value = nums[pivot_idx]\n        new_pivot_idx = left\n        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n        for i in xrange(left, right):\n            if nums[i] > pivot_value:\n                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                new_pivot_idx += 1\n\n        nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n        return new_pivot_idx",
      "explanation": "N/A",
      "time_complexity": "O(n) on average, using Median of Medians could achieve O(n) (Intro Select)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Minimum Equal Sum of Two Arrays After Replacing Zeros",
      "difficulty": "MEDIUM",
      "category": "Array, Greedy",
      "link": "https://leetcode.com/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros",
      "slug": "minimum-equal-sum-of-two-arrays-after-replacing-zeros",
      "description": "You are given two arrays \nnums1\n and \nnums2\n consisting of positive integers.\n\n\nYou have to replace \nall\n the \n0\n's in both arrays with \nstrictly\n positive integers such that the sum of elements of both arrays becomes \nequal\n.\n\n\nReturn \nthe \nminimum\n equal sum you can obtain, or \n-1\n if it is impossible\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [3,2,0,1,0], nums2 = [6,5,0]\n\nOutput:\n 12\n\nExplanation:\n We can replace 0's in the following way:\n- Replace the two 0's in nums1 with the values 2 and 4. The resulting array is nums1 = [3,2,2,1,4].\n- Replace the 0 in nums2 with the value 1. The resulting array is nums2 = [6,5,1].\nBoth arrays have an equal sum of 12. It can be shown that it is the minimum sum we can obtain.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [2,0,2,0], nums2 = [1,4]\n\nOutput:\n -1\n\nExplanation:\n It is impossible to make the sum of both arrays equal.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length, nums2.length <= 10\n5\n\n\n0 <= nums1[i], nums2[i] <= 10\n6",
      "solution": "\n# greedyclass Solution(object):\n    def minSum(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        total1 = sum(max(x, 1) for x in nums1)\n        total2 = sum(max(x, 1) for x in nums2)\n        if total1 < total2:\n            return total2 if 0 in nums1 else -1\n        if total1 > total2:\n            return total1 if 0 in nums2 else -1\n        return total1",
      "explanation": "N/A",
      "time_complexity": "O(n + m)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Majority Element",
      "difficulty": "EASY",
      "category": "Array, Hash Table, Divide and Conquer, Sorting, Counting",
      "link": "https://leetcode.com/problems/majority-element",
      "slug": "majority-element",
      "description": "Given an array \nnums\n of size \nn\n, return \nthe majority element\n.\n\n\nThe majority element is the element that appears more than \n⌊n / 2⌋\n times. You may assume that the majority element always exists in the array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [3,2,3]\n\nOutput:\n 3\n\nExample 2:\n\n\nInput:\n nums = [2,2,1,1,1,2,2]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 5 * 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n\n\n \n\n\nFollow-up:\n Could you solve the problem in linear time and in \nO(1)\n space?",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def boyer_moore_majority_vote():\n            result, cnt = None, 0\n            for x in nums:\n                if not cnt:\n                    result = x\n                if x == result:\n                    cnt += 1\n                else:\n                    cnt -= 1\n            return result\n\n        return boyer_moore_majority_vote()\n\n\nimport collections\n\nclass Solution2(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return collections.Counter(nums).most_common(1)[0][0]\n\n\nimport collections\n\nclass Solution3(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sorted(collections.Counter(nums).items(), key=lambda a: a[1], reverse=True)[0][0]",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Maximum Profit in Job Scheduling",
      "difficulty": "HARD",
      "category": "Array, Binary Search, Dynamic Programming, Sorting",
      "link": "https://leetcode.com/problems/maximum-profit-in-job-scheduling",
      "slug": "maximum-profit-in-job-scheduling",
      "description": "We have \nn\n jobs, where every job is scheduled to be done from \nstartTime[i]\n to \nendTime[i]\n, obtaining a profit of \nprofit[i]\n.\n\n\nYou're given the \nstartTime\n, \nendTime\n and \nprofit\n arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\n\n\nIf you choose a job that ends at time \nX\n you will be able to start another job that starts at time \nX\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\n\nOutput:\n 120\n\nExplanation:\n The subset chosen is the first and fourth job. \nTime range [1-3]+[3-6] , we get profit of 120 = 50 + 70.\n\n\n\nExample 2:\n\n\n \n\n\n\n\nInput:\n startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\n\nOutput:\n 150\n\nExplanation:\n The subset chosen is the first, fourth and fifth job. \nProfit obtained 150 = 20 + 70 + 60.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]\n\nOutput:\n 6\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= startTime.length == endTime.length == profit.length <= 5 * 10\n4\n\n\n1 <= startTime[i] < endTime[i] <= 10\n9\n\n\n1 <= profit[i] <= 10\n4",
      "solution": "\nimport itertools\nimport bisect\n\nclass Solution(object):\n    def jobScheduling(self, startTime, endTime, profit):\n        \"\"\"\n        :type startTime: List[int]\n        :type endTime: List[int]\n        :type profit: List[int]\n        :rtype: int\n        \"\"\"\n        jobs = sorted(itertools.izip(endTime, startTime, profit))\n        dp = [(0, 0)]\n        for e, s, p in jobs:\n            i = bisect.bisect_right(dp, (s+1, 0))-1\n            if dp[i][1]+p > dp[-1][1]:\n                dp.append((e, dp[i][1]+p))\n        return dp[-1][1]\n\n\nimport heapqclass Solution(object):\n    def jobScheduling(self, startTime, endTime, profit):\n        \"\"\"\n        :type startTime: List[int]\n        :type endTime: List[int]\n        :type profit: List[int]\n        :rtype: int\n        \"\"\"\n        min_heap = zip(startTime, endTime, profit)\n        heapq.heapify(min_heap)\n        result = 0\n        while min_heap:\n            s, e, p = heapq.heappop(min_heap)\n            if s < e:\n                heapq.heappush(min_heap, (e, s, result+p))\n            else:\n                result = max(result, p)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Contains Duplicate",
      "difficulty": "EASY",
      "category": "Array, Hash Table, Sorting",
      "link": "https://leetcode.com/problems/contains-duplicate",
      "slug": "contains-duplicate",
      "description": "Given an integer array \nnums\n, return \ntrue\n if any value appears \nat least twice\n in the array, and return \nfalse\n if every element is distinct.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,3,1]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThe element 1 occurs at the indices 0 and 3.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,2,3,4]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nAll elements are distinct.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,1,1,3,3,4,3,2,4,2]\n\n\nOutput:\n \ntrue\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9",
      "solution": "class Solution(object):\n    # @param {integer[]} nums\n    # @return {boolean}\n    def containsDuplicate(self, nums):\n        return len(nums) > len(set(nums))",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Product of Array Except Self",
      "difficulty": "MEDIUM",
      "category": "Array, Prefix Sum",
      "link": "https://leetcode.com/problems/product-of-array-except-self",
      "slug": "product-of-array-except-self",
      "description": "Given an integer array \nnums\n, return \nan array\n \nanswer\n \nsuch that\n \nanswer[i]\n \nis equal to the product of all the elements of\n \nnums\n \nexcept\n \nnums[i]\n.\n\n\nThe product of any prefix or suffix of \nnums\n is \nguaranteed\n to fit in a \n32-bit\n integer.\n\n\nYou must write an algorithm that runs in \nO(n)\n time and without using the division operation.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,2,3,4]\n\nOutput:\n [24,12,8,6]\n\nExample 2:\n\n\nInput:\n nums = [-1,1,0,-3,3]\n\nOutput:\n [0,0,9,0,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n5\n\n\n-30 <= nums[i] <= 30\n\n\nThe input is generated such that \nanswer[i]\n is \nguaranteed\n to fit in a \n32-bit\n integer.\n\n\n\n\n \n\n\nFollow up:\n Can you solve the problem in \nO(1)\n extra space complexity? (The output array \ndoes not\n count as extra space for space complexity analysis.)",
      "solution": "class Solution(object):\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def productExceptSelf(self, nums):\n        if not nums:\n            return []\n\n        left_product = [1 for _ in xrange(len(nums))]\n        for i in xrange(1, len(nums)):\n            left_product[i] = left_product[i - 1] * nums[i - 1]\n\n        right_product = 1\n        for i in xrange(len(nums) - 2, -1, -1):\n            right_product *= nums[i + 1]\n            left_product[i] = left_product[i] * right_product\n\n        return left_product",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Combination Sum",
      "difficulty": "MEDIUM",
      "category": "Array, Backtracking",
      "link": "https://leetcode.com/problems/combination-sum",
      "slug": "combination-sum",
      "description": "Given an array of \ndistinct\n integers \ncandidates\n and a target integer \ntarget\n, return \na list of all \nunique combinations\n of \ncandidates\n where the chosen numbers sum to \ntarget\n.\n You may return the combinations in \nany order\n.\n\n\nThe \nsame\n number may be chosen from \ncandidates\n an \nunlimited number of times\n. Two combinations are unique if the \nfrequency\n of at least one of the chosen numbers is different.\n\n\nThe test cases are generated such that the number of unique combinations that sum up to \ntarget\n is less than \n150\n combinations for the given input.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n candidates = [2,3,6,7], target = 7\n\nOutput:\n [[2,2,3],[7]]\n\nExplanation:\n\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n\n\n\nExample 2:\n\n\n\n\nInput:\n candidates = [2,3,5], target = 8\n\nOutput:\n [[2,2,2,2],[2,3,3],[3,5]]\n\n\n\nExample 3:\n\n\n\n\nInput:\n candidates = [2], target = 1\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= candidates.length <= 30\n\n\n2 <= candidates[i] <= 40\n\n\nAll elements of \ncandidates\n are \ndistinct\n.\n\n\n1 <= target <= 40",
      "solution": "class Solution(object):\n    # @param candidates, a list of integers\n    # @param target, integer\n    # @return a list of lists of integers\n    def combinationSum(self, candidates, target):\n        result = []\n        self.combinationSumRecu(sorted(candidates), result, 0, [], target)\n        return result\n\n    def combinationSumRecu(self, candidates, result, start, intermediate, target):\n        if target == 0:\n            result.append(list(intermediate))\n        while start < len(candidates) and candidates[start] <= target:\n            intermediate.append(candidates[start])\n            self.combinationSumRecu(candidates, result, start, intermediate, target - candidates[start])\n            intermediate.pop()\n            start += 1",
      "explanation": "N/A",
      "time_complexity": "O(k * n^k)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Container With Most Water",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers, Greedy",
      "link": "https://leetcode.com/problems/container-with-most-water",
      "slug": "container-with-most-water",
      "description": "You are given an integer array \nheight\n of length \nn\n. There are \nn\n vertical lines drawn such that the two endpoints of the \ni\nth\n line are \n(i, 0)\n and \n(i, height[i])\n.\n\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\n\nReturn \nthe maximum amount of water a container can store\n.\n\n\nNotice\n that you may not slant the container.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [1,8,6,2,5,4,8,3,7]\n\nOutput:\n 49\n\nExplanation:\n The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [1,1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= height[i] <= 10\n4",
      "solution": "class Solution(object):\n    # @return an integer\n    def maxArea(self, height):\n        max_area, i, j = 0, 0, len(height) - 1\n        while i < j:\n            max_area = max(max_area, min(height[i], height[j]) * (j - i))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return max_area",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Number of Provinces",
      "difficulty": "MEDIUM",
      "category": "Depth-First Search, Breadth-First Search, Union Find, Graph",
      "link": "https://leetcode.com/problems/number-of-provinces",
      "slug": "number-of-provinces",
      "description": "There are \nn\n cities. Some of them are connected, while some are not. If city \na\n is connected directly with city \nb\n, and city \nb\n is connected directly with city \nc\n, then city \na\n is connected indirectly with city \nc\n.\n\n\nA \nprovince\n is a group of directly or indirectly connected cities and no other cities outside of the group.\n\n\nYou are given an \nn x n\n matrix \nisConnected\n where \nisConnected[i][j] = 1\n if the \ni\nth\n city and the \nj\nth\n city are directly connected, and \nisConnected[i][j] = 0\n otherwise.\n\n\nReturn \nthe total number of \nprovinces\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 200\n\n\nn == isConnected.length\n\n\nn == isConnected[i].length\n\n\nisConnected[i][j]\n is \n1\n or \n0\n.\n\n\nisConnected[i][i] == 1\n\n\nisConnected[i][j] == isConnected[j][i]",
      "solution": "# Solution not found in kamyu104 repository",
      "explanation": "N/A",
      "time_complexity": "N/A",
      "space_complexity": "N/A"
    },
    {
      "title": "Reverse Integer",
      "difficulty": "MEDIUM",
      "category": "Math",
      "link": "https://leetcode.com/problems/reverse-integer",
      "slug": "reverse-integer",
      "description": "Given a signed 32-bit integer \nx\n, return \nx\n with its digits reversed\n. If reversing \nx\n causes the value to go outside the signed 32-bit integer range \n[-2\n31\n, 2\n31\n - 1]\n, then return \n0\n.\n\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 123\n\nOutput:\n 321\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = -123\n\nOutput:\n -321\n\n\n\nExample 3:\n\n\n\n\nInput:\n x = 120\n\nOutput:\n 21\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= x <= 2\n31\n - 1",
      "solution": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 0:\n            return -self.reverse(-x)\n\n        result = 0\n        while x:\n            result = result * 10 + x % 10\n            x //= 10\n        return result if result <= 0x7fffffff else 0  # Handle overflow.\n\n    def reverse2(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 0:\n            x = int(str(x)[::-1][-1] + str(x)[::-1][:-1])\n        else:\n            x = int(str(x)[::-1])\n        x = 0 if abs(x) > 0x7FFFFFFF else x\n        return x\n\n    def reverse3(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        s = cmp(x, 0)\n        r = int(repr(s * x)[::-1])\n        return s * r * (r < 2 ** 31)",
      "explanation": "N/A",
      "time_complexity": "O(logn) = O(1)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Single Number",
      "difficulty": "EASY",
      "category": "Array, Bit Manipulation",
      "link": "https://leetcode.com/problems/single-number",
      "slug": "single-number",
      "description": "Given a \nnon-empty\n array of integers \nnums\n, every element appears \ntwice\n except for one. Find that single one.\n\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,2,1]\n\n\nOutput:\n \n1\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [4,1,2,1,2]\n\n\nOutput:\n \n4\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1]\n\n\nOutput:\n \n1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 3 * 10\n4\n\n\n-3 * 10\n4\n <= nums[i] <= 3 * 10\n4\n\n\nEach element in the array appears twice except for one element which appears only once.",
      "solution": "\nimport operator\nfrom functools import reduce\n\nclass Solution(object):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    def singleNumber(self, A):\n        return reduce(operator.xor, A)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Pascal's Triangle",
      "difficulty": "EASY",
      "category": "Array, Dynamic Programming",
      "link": "https://leetcode.com/problems/pascals-triangle",
      "slug": "pascals-triangle",
      "description": "Given an integer \nnumRows\n, return the first numRows of \nPascal's triangle\n.\n\n\nIn \nPascal's triangle\n, each number is the sum of the two numbers directly above it as shown:\n\n\n\n\n \n\n\nExample 1:\n\n\nInput:\n numRows = 5\n\nOutput:\n [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n\nExample 2:\n\n\nInput:\n numRows = 1\n\nOutput:\n [[1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numRows <= 30",
      "solution": "class Solution(object):\n    # @return a list of lists of integers\n    def generate(self, numRows):\n        result = []\n        for i in xrange(numRows):\n            result.append([])\n            for j in xrange(i + 1):\n                if j in (0, i):\n                    result[i].append(1)\n                else:\n                    result[i].append(result[i - 1][j - 1] + result[i - 1][j])\n        return result\n\n    def generate2(self, numRows):\n        if not numRows: return []\n        res = [[1]]\n        for i in range(1, numRows):\n            res += [map(lambda x, y: x + y, res[-1] + [0], [0] + res[-1])]\n        return res[:numRows]\n\n    def generate3(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if numRows == 0: return []\n        if numRows == 1: return [[1]]\n        res = [[1], [1, 1]]\n\n        def add(nums):\n            res = nums[:1]\n            for i, j in enumerate(nums):\n                if i < len(nums) - 1:\n                    res += [nums[i] + nums[i + 1]]\n            res += nums[:1]\n            return res\n\n        while len(res) < numRows:\n            res.extend([add(res[-1])])\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Min Cost Climbing Stairs",
      "difficulty": "EASY",
      "category": "Array, Dynamic Programming",
      "link": "https://leetcode.com/problems/min-cost-climbing-stairs",
      "slug": "min-cost-climbing-stairs",
      "description": "You are given an integer array \ncost\n where \ncost[i]\n is the cost of \ni\nth\n step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\n\nYou can either start from the step with index \n0\n, or the step with index \n1\n.\n\n\nReturn \nthe minimum cost to reach the top of the floor\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n cost = [10,\n15\n,20]\n\nOutput:\n 15\n\nExplanation:\n You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n\n\nExample 2:\n\n\n\n\nInput:\n cost = [\n1\n,100,\n1\n,1,\n1\n,100,\n1\n,\n1\n,100,\n1\n]\n\nOutput:\n 6\n\nExplanation:\n You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= cost.length <= 1000\n\n\n0 <= cost[i] <= 999",
      "solution": "class Solution(object):\n    def minCostClimbingStairs(self, cost):\n        \"\"\"\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [0] * 3\n        for i in reversed(xrange(len(cost))):\n            dp[i%3] = cost[i] + min(dp[(i+1)%3], dp[(i+2)%3])\n        return min(dp[0], dp[1])",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Word Search II",
      "difficulty": "HARD",
      "category": "Array, String, Backtracking, Trie, Matrix",
      "link": "https://leetcode.com/problems/word-search-ii",
      "slug": "word-search-ii",
      "description": "Given an \nm x n\n \nboard\n of characters and a list of strings \nwords\n, return \nall words on the board\n.\n\n\nEach word must be constructed from letters of sequentially adjacent cells, where \nadjacent cells\n are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n\nOutput:\n [\"eat\",\"oath\"]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == board.length\n\n\nn == board[i].length\n\n\n1 <= m, n <= 12\n\n\nboard[i][j]\n is a lowercase English letter.\n\n\n1 <= words.length <= 3 * 10\n4\n\n\n1 <= words[i].length <= 10\n\n\nwords[i]\n consists of lowercase English letters.\n\n\nAll the strings of \nwords\n are unique.",
      "solution": "class TrieNode(object):\n    # Initialize your data structure here.\n    def __init__(self):\n        self.is_string = False\n        self.leaves = {}\n\n    # Inserts a word into the trie.\n    def insert(self, word):\n        cur = self\n        for c in word:\n            if not c in cur.leaves:\n                cur.leaves[c] = TrieNode()\n            cur = cur.leaves[c]\n        cur.is_string = True\n\nclass Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        visited = [[False for j in xrange(len(board[0]))] for i in xrange(len(board))]\n        result = {}\n        trie = TrieNode()\n        for word in words:\n            trie.insert(word)\n\n        for i in xrange(len(board)):\n            for j in xrange(len(board[0])):\n                self.findWordsRecu(board, trie, 0, i, j, visited, [], result)\n\n        return result.keys()\n\n    def findWordsRecu(self, board, trie, cur, i, j, visited, cur_word, result):\n        if not trie or i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j]:\n            return\n\n        if board[i][j] not in trie.leaves:\n            return\n\n        cur_word.append(board[i][j])\n        next_node = trie.leaves[board[i][j]]\n        if next_node.is_string:\n            result[\"\".join(cur_word)] = True\n\n        visited[i][j] = True\n        self.findWordsRecu(board, next_node, cur + 1, i + 1, j, visited, cur_word, result)\n        self.findWordsRecu(board, next_node, cur + 1, i - 1, j, visited, cur_word, result)\n        self.findWordsRecu(board, next_node, cur + 1, i, j + 1, visited, cur_word, result)\n        self.findWordsRecu(board, next_node, cur + 1, i, j - 1, visited, cur_word, result)\n        visited[i][j] = False\n        cur_word.pop()",
      "explanation": "N/A",
      "time_complexity": "O(m * n * 4 * 3^(h - 1)) ~= O(m * n * 3^h), h is the height of trie",
      "space_complexity": "O(t), t is the number of nodes in trie"
    },
    {
      "title": "Next Greater Element I",
      "difficulty": "EASY",
      "category": "Array, Hash Table, Stack, Monotonic Stack",
      "link": "https://leetcode.com/problems/next-greater-element-i",
      "slug": "next-greater-element-i",
      "description": "The \nnext greater element\n of some element \nx\n in an array is the \nfirst greater\n element that is \nto the right\n of \nx\n in the same array.\n\n\nYou are given two \ndistinct 0-indexed\n integer arrays \nnums1\n and \nnums2\n, where \nnums1\n is a subset of \nnums2\n.\n\n\nFor each \n0 <= i < nums1.length\n, find the index \nj\n such that \nnums1[i] == nums2[j]\n and determine the \nnext greater element\n of \nnums2[j]\n in \nnums2\n. If there is no next greater element, then the answer for this query is \n-1\n.\n\n\nReturn \nan array \nans\n of length \nnums1.length\n such that \nans[i]\n is the \nnext greater element\n as described above.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [4,1,2], nums2 = [1,3,4,2]\n\nOutput:\n [-1,3,-1]\n\nExplanation:\n The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,\n4\n,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [\n1\n,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,\n2\n]. There is no next greater element, so the answer is -1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [2,4], nums2 = [1,2,3,4]\n\nOutput:\n [3,-1]\n\nExplanation:\n The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,\n2\n,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,\n4\n]. There is no next greater element, so the answer is -1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length <= nums2.length <= 1000\n\n\n0 <= nums1[i], nums2[i] <= 10\n4\n\n\nAll integers in \nnums1\n and \nnums2\n are \nunique\n.\n\n\nAll the integers of \nnums1\n also appear in \nnums2\n.\n\n\n\n\n \n\n\nFollow up:\n Could you find an \nO(nums1.length + nums2.length)\n solution?",
      "solution": "class Solution(object):\n    def nextGreaterElement(self, findNums, nums):\n        \"\"\"\n        :type findNums: List[int]\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        stk, lookup = [], {}\n        for num in nums:\n            while stk and num > stk[-1]:\n                lookup[stk.pop()] = num\n            stk.append(num)\n        while stk:\n            lookup[stk.pop()] = -1\n        return map(lambda x : lookup[x], findNums)",
      "explanation": "N/A",
      "time_complexity": "O(m + n)",
      "space_complexity": "O(m + n)"
    },
    {
      "title": "Analyze User Website Visit Pattern",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Sorting",
      "link": "https://leetcode.com/problems/analyze-user-website-visit-pattern",
      "slug": "analyze-user-website-visit-pattern",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "\nimport collections\nimport itertools\n\nclass Solution(object):\n    def mostVisitedPattern(self, username, timestamp, website):\n        \"\"\"\n        :type username: List[str]\n        :type timestamp: List[int]\n        :type website: List[str]\n        :rtype: List[str]\n        \"\"\"\n        lookup = collections.defaultdict(list)\n        A = zip(timestamp, username, website)\n        A.sort()\n        for t, u, w in A:\n            lookup[u].append(w)\n        count = sum([collections.Counter(set(itertools.combinations(lookup[u], 3))) for u in lookup], collections.Counter())\n        return list(min(count, key=lambda x: (-count[x], x)))",
      "explanation": "N/A",
      "time_complexity": "O(n^3)",
      "space_complexity": "O(n^3)"
    },
    {
      "title": "Sliding Window Maximum",
      "difficulty": "HARD",
      "category": "Array, Queue, Sliding Window, Heap (Priority Queue), Monotonic Queue",
      "link": "https://leetcode.com/problems/sliding-window-maximum",
      "slug": "sliding-window-maximum",
      "description": "You are given an array of integers \nnums\n, there is a sliding window of size \nk\n which is moving from the very left of the array to the very right. You can only see the \nk\n numbers in the window. Each time the sliding window moves right by one position.\n\n\nReturn \nthe max sliding window\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,-1,-3,5,3,6,7], k = 3\n\nOutput:\n [3,3,5,5,6,7]\n\nExplanation:\n \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       \n3\n\n 1 [3  -1  -3] 5  3  6  7       \n3\n\n 1  3 [-1  -3  5] 3  6  7      \n 5\n\n 1  3  -1 [-3  5  3] 6  7       \n5\n\n 1  3  -1  -3 [5  3  6] 7       \n6\n\n 1  3  -1  -3  5 [3  6  7]      \n7\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1], k = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n1 <= k <= nums.length",
      "solution": "\nfrom collections import deque\n\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result, dq = [], deque()\n        for i in xrange(len(nums)):\n            if dq and i-dq[0] == k:\n                dq.popleft()\n            while dq and nums[dq[-1]] <= nums[i]:\n                dq.pop()\n            dq.append(i)\n            if i >= k-1:\n                result.append(nums[dq[0]])\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Word Ladder",
      "difficulty": "HARD",
      "category": "Hash Table, String, Breadth-First Search",
      "link": "https://leetcode.com/problems/word-ladder",
      "slug": "word-ladder",
      "description": "A \ntransformation sequence\n from word \nbeginWord\n to word \nendWord\n using a dictionary \nwordList\n is a sequence of words \nbeginWord -> s\n1\n -> s\n2\n -> ... -> s\nk\n such that:\n\n\n\n\nEvery adjacent pair of words differs by a single letter.\n\n\nEvery \ns\ni\n for \n1 <= i <= k\n is in \nwordList\n. Note that \nbeginWord\n does not need to be in \nwordList\n.\n\n\ns\nk\n == endWord\n\n\n\n\nGiven two words, \nbeginWord\n and \nendWord\n, and a dictionary \nwordList\n, return \nthe \nnumber of words\n in the \nshortest transformation sequence\n from\n \nbeginWord\n \nto\n \nendWord\n, or \n0\n if no such sequence exists.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\nOutput:\n 5\n\nExplanation:\n One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\n\n\n\nExample 2:\n\n\n\n\nInput:\n beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n\nOutput:\n 0\n\nExplanation:\n The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= beginWord.length <= 10\n\n\nendWord.length == beginWord.length\n\n\n1 <= wordList.length <= 5000\n\n\nwordList[i].length == beginWord.length\n\n\nbeginWord\n, \nendWord\n, and \nwordList[i]\n consist of lowercase English letters.\n\n\nbeginWord != endWord\n\n\nAll the words in \nwordList\n are \nunique\n.",
      "solution": "\nfrom string import ascii_lowercase\n\n\n# two-end bfsclass Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        words = set(wordList)\n        if endWord not in words:\n            return 0\n        left, right = {beginWord}, {endWord}\n        ladder = 2\n        while left:\n            words -= left\n            new_left = set()\n            for word in left:\n                for new_word in (word[:i]+c+word[i+1:] for i in xrange(len(beginWord)) for c in ascii_lowercase):\n                    if new_word not in words:\n                        continue\n                    if new_word in right: \n                        return ladder\n                    new_left.add(new_word)\n            left = new_left\n            ladder += 1\n            if len(left) > len(right): \n                left, right = right, left\n        return 0\n\nclass Solution2(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        lookup = set(wordList)\n        if endWord not in lookup:\n            return 0\n        ladder = 2\n        q = [beginWord]\n        while q:\n            new_q = []\n            for word in q:\n                for i in xrange(len(word)):\n                    for j in ascii_lowercase:\n                        new_word = word[:i] + j + word[i+1:]\n                        if new_word == endWord:\n                            return ladder\n                        if new_word in lookup:\n                            lookup.remove(new_word)\n                            new_q.append(new_word)\n            q = new_q\n            ladder += 1\n        return 0",
      "explanation": "N/A",
      "time_complexity": "O(b^d), b is the branch factor of bfs, d is the result depth",
      "space_complexity": "O(w * l), w is the number of words, l is the max length of words"
    },
    {
      "title": "Valid Sudoku",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Matrix",
      "link": "https://leetcode.com/problems/valid-sudoku",
      "slug": "valid-sudoku",
      "description": "Determine if a \n9 x 9\n Sudoku board is valid. Only the filled cells need to be validated \naccording to the following rules\n:\n\n\n\n\nEach row must contain the digits \n1-9\n without repetition.\n\n\nEach column must contain the digits \n1-9\n without repetition.\n\n\nEach of the nine \n3 x 3\n sub-boxes of the grid must contain the digits \n1-9\n without repetition.\n\n\n\n\nNote:\n\n\n\n\nA Sudoku board (partially filled) could be valid but is not necessarily solvable.\n\n\nOnly the filled cells need to be validated according to the mentioned rules.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\nInput:\n board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput:\n false\n\nExplanation:\n Same as Example 1, except with the \n5\n in the top left corner being modified to \n8\n. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nboard.length == 9\n\n\nboard[i].length == 9\n\n\nboard[i][j]\n is a digit \n1-9\n or \n'.'\n.",
      "solution": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        for i in xrange(9):\n            if not self.isValidList([board[i][j] for j in xrange(9)]) or \\\n               not self.isValidList([board[j][i] for j in xrange(9)]):\n                return False\n        for i in xrange(3):\n            for j in xrange(3):\n                if not self.isValidList([board[m][n] for n in xrange(3 * j, 3 * j + 3) \\\n                                                     for m in xrange(3 * i, 3 * i + 3)]):\n                    return False\n        return True\n\n    def isValidList(self, xs):\n        xs = filter(lambda x: x != '.', xs)\n        return len(set(xs)) == len(xs)",
      "explanation": "N/A",
      "time_complexity": "O(9^2)",
      "space_complexity": "O(9)"
    },
    {
      "title": "Integer to English Words",
      "difficulty": "HARD",
      "category": "Math, String, Recursion",
      "link": "https://leetcode.com/problems/integer-to-english-words",
      "slug": "integer-to-english-words",
      "description": "Convert a non-negative integer \nnum\n to its English words representation.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 123\n\nOutput:\n \"One Hundred Twenty Three\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 12345\n\nOutput:\n \"Twelve Thousand Three Hundred Forty Five\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n num = 1234567\n\nOutput:\n \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= num <= 2\n31\n - 1",
      "solution": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return \"Zero\"\n\n        lookup = {0: \"Zero\", 1:\"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", \\\n                  5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\", \\\n                  10: \"Ten\", 11: \"Eleven\", 12: \"Twelve\", 13: \"Thirteen\", 14: \"Fourteen\", \\\n                  15: \"Fifteen\", 16: \"Sixteen\", 17: \"Seventeen\", 18: \"Eighteen\", 19: \"Nineteen\", \\\n                  20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\", 50: \"Fifty\", 60: \"Sixty\", \\\n                  70: \"Seventy\", 80: \"Eighty\", 90: \"Ninety\"}\n        unit = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        res, i = [], 0\n        while num:\n            cur = num % 1000\n            if num % 1000:\n                res.append(self.threeDigits(cur, lookup, unit[i]))\n            num //= 1000\n            i += 1\n        return \" \".join(res[::-1])\n\n    def threeDigits(self, num, lookup, unit):\n        res = []\n        if num / 100:\n            res = [lookup[num / 100] + \" \" + \"Hundred\"]\n        if num % 100:\n            res.append(self.twoDigits(num % 100, lookup))\n        if unit != \"\":\n            res.append(unit)\n        return \" \".join(res)\n\n    def twoDigits(self, num, lookup):\n        if num in lookup:\n            return lookup[num]\n        return lookup[(num / 10) * 10] + \" \" + lookup[num % 10]",
      "explanation": "N/A",
      "time_complexity": "O(logn) = O(1), n is the value of the integer, which is less than 2^31 - 1",
      "space_complexity": "O(1)"
    },
    {
      "title": "Course Schedule II",
      "difficulty": "MEDIUM",
      "category": "Depth-First Search, Breadth-First Search, Graph, Topological Sort",
      "link": "https://leetcode.com/problems/course-schedule-ii",
      "slug": "course-schedule-ii",
      "description": "There are a total of \nnumCourses\n courses you have to take, labeled from \n0\n to \nnumCourses - 1\n. You are given an array \nprerequisites\n where \nprerequisites[i] = [a\ni\n, b\ni\n]\n indicates that you \nmust\n take course \nb\ni\n first if you want to take course \na\ni\n.\n\n\n\n\nFor example, the pair \n[0, 1]\n, indicates that to take course \n0\n you have to first take course \n1\n.\n\n\n\n\nReturn \nthe ordering of courses you should take to finish all courses\n. If there are many valid answers, return \nany\n of them. If it is impossible to finish all courses, return \nan empty array\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [[1,0]]\n\nOutput:\n [0,1]\n\nExplanation:\n There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n\nOutput:\n [0,2,1,3]\n\nExplanation:\n There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n\n\n\nExample 3:\n\n\n\n\nInput:\n numCourses = 1, prerequisites = []\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numCourses <= 2000\n\n\n0 <= prerequisites.length <= numCourses * (numCourses - 1)\n\n\nprerequisites[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < numCourses\n\n\na\ni\n != b\ni\n\n\nAll the pairs \n[a\ni\n, b\ni\n]\n are \ndistinct\n.",
      "solution": "\nimport collections\n\n\n# Khan's algorithm (bfs solution)class Solution(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        q = [u for u in xrange(numCourses) if u not in in_degree]\n        while q:\n            new_q = []\n            for u in q:\n                result.append(u)\n                for v in adj[u]:\n                    in_degree[v] -= 1\n                    if in_degree[v] == 0:\n                        new_q.append(v)\n            q = new_q\n        return result if len(result) == numCourses else []\n\n\nimport collections\n\n\n# dfs solutionclass Solution2(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        stk = [u for u in xrange(numCourses) if u not in in_degree]\n        while stk:\n            u = stk.pop()\n            result.append(u)\n            for v in adj[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    stk.append(v)\n        return result if len(result) == numCourses else []\n\n\nimport collections\n\n\n# dfs solutionclass Solution3(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        WHITE, GRAY, BLACK = range(3)\n        def dfs(u):\n            if lookup[u] != WHITE:\n                return lookup[u] == BLACK\n            lookup[u] = GRAY\n            if any(not dfs(v) for v in adj[u]):\n                return False\n            lookup[u] = BLACK\n            result.append(u)  # should be postorder\n            return True\n\n        result = []\n        adj = collections.defaultdict(list)\n        for u, v in prerequisites:\n            adj[u].append(v)\n        lookup = collections.defaultdict(lambda:WHITE)\n        for u in xrange(numCourses):\n            if not dfs(u):\n                return []\n        return result\n\n    \nimport collections\n\n\n# dfs solutionclass Solution4(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        WHITE, GRAY, BLACK = range(3)\n        def dfs(u):\n            if lookup[u] != WHITE:\n                return lookup[u] == BLACK\n            lookup[u] = GRAY\n            if any(not dfs(v) for v in adj[u]):\n                return False\n            lookup[u] = BLACK\n            result.append(u)  # should be postorder\n            return True\n\n        result = []\n        adj = collections.defaultdict(list)\n        for u, v in prerequisites:\n            adj[v].append(u)\n        lookup = collections.defaultdict(lambda:WHITE)\n        for u in xrange(numCourses):\n            if not dfs(u):\n                return []\n        result.reverse()\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(|V| + |E|)",
      "space_complexity": "O(|E|)"
    },
    {
      "title": "Pacific Atlantic Water Flow",
      "difficulty": "MEDIUM",
      "category": "Array, Depth-First Search, Breadth-First Search, Matrix",
      "link": "https://leetcode.com/problems/pacific-atlantic-water-flow",
      "slug": "pacific-atlantic-water-flow",
      "description": "There is an \nm x n\n rectangular island that borders both the \nPacific Ocean\n and \nAtlantic Ocean\n. The \nPacific Ocean\n touches the island's left and top edges, and the \nAtlantic Ocean\n touches the island's right and bottom edges.\n\n\nThe island is partitioned into a grid of square cells. You are given an \nm x n\n integer matrix \nheights\n where \nheights[r][c]\n represents the \nheight above sea level\n of the cell at coordinate \n(r, c)\n.\n\n\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is \nless than or equal to\n the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\n\n\nReturn \na \n2D list\n of grid coordinates \nresult\n where \nresult[i] = [r\ni\n, c\ni\n]\n denotes that rain water can flow from cell \n(r\ni\n, c\ni\n)\n to \nboth\n the Pacific and Atlantic oceans\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\n\nOutput:\n [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n\nExplanation:\n The following cells can flow to the Pacific and Atlantic oceans, as shown below:\n[0,4]: [0,4] -> Pacific Ocean \n       [0,4] -> Atlantic Ocean\n[1,3]: [1,3] -> [0,3] -> Pacific Ocean \n       [1,3] -> [1,4] -> Atlantic Ocean\n[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \n       [1,4] -> Atlantic Ocean\n[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \n       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\n[3,0]: [3,0] -> Pacific Ocean \n       [3,0] -> [4,0] -> Atlantic Ocean\n[3,1]: [3,1] -> [3,0] -> Pacific Ocean \n       [3,1] -> [4,1] -> Atlantic Ocean\n[4,0]: [4,0] -> Pacific Ocean \n       [4,0] -> Atlantic Ocean\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\n\n\n\nExample 2:\n\n\n\n\nInput:\n heights = [[1]]\n\nOutput:\n [[0,0]]\n\nExplanation:\n The water can flow from the only cell to the Pacific and Atlantic oceans.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == heights.length\n\n\nn == heights[r].length\n\n\n1 <= m, n <= 200\n\n\n0 <= heights[r][c] <= 10\n5",
      "solution": "class Solution(object):\n    def pacificAtlantic(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        PACIFIC, ATLANTIC = 1, 2\n\n        def pacificAtlanticHelper(matrix, x, y, prev_height, prev_val, visited, res):\n            if (not 0 <= x < len(matrix)) or \\\n               (not 0 <= y < len(matrix[0])) or \\\n               matrix[x][y] < prev_height or \\\n               (visited[x][y] | prev_val) == visited[x][y]:\n                return\n\n            visited[x][y] |= prev_val\n            if visited[x][y] == (PACIFIC | ATLANTIC):\n                res.append((x, y))\n\n            for d in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                pacificAtlanticHelper(matrix, x + d[0], y + d[1], matrix[x][y], visited[x][y], visited, res)\n\n        if not matrix:\n            return []\n\n        res = []\n        m, n = len(matrix),len(matrix[0])\n        visited = [[0 for _ in xrange(n)] for _ in xrange(m)]\n\n        for i in xrange(m):\n            pacificAtlanticHelper(matrix, i, 0, float(\"-inf\"), PACIFIC, visited, res)\n            pacificAtlanticHelper(matrix, i, n - 1, float(\"-inf\"), ATLANTIC, visited, res)\n        for j in xrange(n):\n            pacificAtlanticHelper(matrix, 0, j, float(\"-inf\"), PACIFIC, visited, res)\n            pacificAtlanticHelper(matrix, m - 1, j, float(\"-inf\"), ATLANTIC, visited, res)\n\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "Jump Game",
      "difficulty": "MEDIUM",
      "category": "Array, Dynamic Programming, Greedy",
      "link": "https://leetcode.com/problems/jump-game",
      "slug": "jump-game",
      "description": "You are given an integer array \nnums\n. You are initially positioned at the array's \nfirst index\n, and each element in the array represents your maximum jump length at that position.\n\n\nReturn \ntrue\n if you can reach the last index, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,3,1,1,4]\n\nOutput:\n true\n\nExplanation:\n Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,1,0,4]\n\nOutput:\n false\n\nExplanation:\n You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n0 <= nums[i] <= 10\n5",
      "solution": "class Solution(object):\n    # @param A, a list of integers\n    # @return a boolean\n    def canJump(self, A):\n        reachable = 0\n        for i, length in enumerate(A):\n            if i > reachable:\n                break\n            reachable = max(reachable, i + length)\n        return reachable >= len(A) - 1",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Validate Binary Search Tree",
      "difficulty": "MEDIUM",
      "category": "Tree, Depth-First Search, Binary Search Tree, Binary Tree",
      "link": "https://leetcode.com/problems/validate-binary-search-tree",
      "slug": "validate-binary-search-tree",
      "description": "Given the \nroot\n of a binary tree, \ndetermine if it is a valid binary search tree (BST)\n.\n\n\nA \nvalid BST\n is defined as follows:\n\n\n\n\nThe left \nsubtree\n of a node contains only nodes with keys \nstrictly less than\n the node's key.\n\n\nThe right subtree of a node contains only nodes with keys \nstrictly greater than\n the node's key.\n\n\nBoth the left and right subtrees must also be binary search trees.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [2,1,3]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,1,4,null,null,3,6]\n\nOutput:\n false\n\nExplanation:\n The root node's value is 5 but its right child's value is 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-2\n31\n <= Node.val <= 2\n31\n - 1",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# Morris Traversal Solutionclass Solution(object):\n    # @param root, a tree node\n    # @return a list of integers\n    def isValidBST(self, root):\n        prev, cur = None, root\n        while cur:\n            if cur.left is None:\n                if prev and prev.val >= cur.val:\n                    return False\n                prev = cur\n                cur = cur.right\n            else:\n                node = cur.left\n                while node.right and node.right != cur:\n                    node = node.right\n\n                if node.right is None:\n                    node.right = cur\n                    cur = cur.left\n                else:\n                    if prev and prev.val >= cur.val:\n                        return False\n                    node.right = None\n                    prev = cur\n                    cur = cur.right\n\n        return True\n\nclass Solution2(object):\n    # @param root, a tree node\n    # @return a boolean\n    def isValidBST(self, root):\n        return self.isValidBSTRecu(root, float(\"-inf\"), float(\"inf\"))\n\n    def isValidBSTRecu(self, root, low, high):\n        if root is None:\n            return True\n\n        return low < root.val and root.val < high \\\n            and self.isValidBSTRecu(root.left, low, root.val) \\\n            and self.isValidBSTRecu(root.right, root.val, high)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Sudoku Solver",
      "difficulty": "HARD",
      "category": "Array, Hash Table, Backtracking, Matrix",
      "link": "https://leetcode.com/problems/sudoku-solver",
      "slug": "sudoku-solver",
      "description": "Write a program to solve a Sudoku puzzle by filling the empty cells.\n\n\nA sudoku solution must satisfy \nall of the following rules\n:\n\n\n\n\nEach of the digits \n1-9\n must occur exactly once in each row.\n\n\nEach of the digits \n1-9\n must occur exactly once in each column.\n\n\nEach of the digits \n1-9\n must occur exactly once in each of the 9 \n3x3\n sub-boxes of the grid.\n\n\n\n\nThe \n'.'\n character indicates empty cells.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput:\n [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n\nExplanation:\n The input board is shown above and the only valid solution is shown below:\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nboard.length == 9\n\n\nboard[i].length == 9\n\n\nboard[i][j]\n is a digit or \n'.'\n.\n\n\nIt is \nguaranteed\n that the input board has only one solution.",
      "solution": "class Solution(object):\n    # @param board, a 9x9 2D array\n    # Solve the Sudoku by modifying the input board in-place.\n    # Do not return any value.\n    def solveSudoku(self, board):\n        def isValid(board, x, y):\n            for i in xrange(9):\n                if i != x and board[i][y] == board[x][y]:\n                    return False\n            for j in xrange(9):\n                if j != y and board[x][j] == board[x][y]:\n                    return False\n            i = 3 * (x / 3)\n            while i < 3 * (x / 3 + 1):\n                j = 3 * (y / 3)\n                while j < 3 * (y / 3 + 1):\n                    if (i != x or j != y) and board[i][j] == board[x][y]:\n                        return False\n                    j += 1\n                i += 1\n            return True\n\n        def solver(board):\n            for i in xrange(len(board)):\n                for j in xrange(len(board[0])):\n                    if(board[i][j] == '.'):\n                        for k in xrange(9):\n                            board[i][j] = chr(ord('1') + k)\n                            if isValid(board, i, j) and solver(board):\n                                return True\n                            board[i][j] = '.'\n                        return False\n            return True\n\n        solver(board)",
      "explanation": "N/A",
      "time_complexity": "((9!)^9)",
      "space_complexity": "(1)"
    },
    {
      "title": "Find the Duplicate Number",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers, Binary Search, Bit Manipulation",
      "link": "https://leetcode.com/problems/find-the-duplicate-number",
      "slug": "find-the-duplicate-number",
      "description": "Given an array of integers \nnums\n containing \nn + 1\n integers where each integer is in the range \n[1, n]\n inclusive.\n\n\nThere is only \none repeated number\n in \nnums\n, return \nthis repeated number\n.\n\n\nYou must solve the problem \nwithout\n modifying the array \nnums\n and using only constant extra space.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,4,2,2]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,1,3,4,2]\n\nOutput:\n 3\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,3,3,3,3]\n\nOutput:\n 3\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5\n\n\nnums.length == n + 1\n\n\n1 <= nums[i] <= n\n\n\nAll the integers in \nnums\n appear only \nonce\n except for \nprecisely one integer\n which appears \ntwo or more\n times.\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nHow can we prove that at least one duplicate number must exist in \nnums\n?\n\n\nCan you solve the problem in linear runtime complexity?",
      "solution": "class Solution(object):\n    def findDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # Treat each (key, value) pair of the array as the (pointer, next) node of the linked list,\n        # thus the duplicated number will be the begin of the cycle in the linked list.\n        # Besides, there is always a cycle in the linked list which\n        # starts from the first element of the array.\n        slow = nums[0]\n        fast = nums[nums[0]]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n\n        fast = 0\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow\n\n\n# Binary search method.class Solution2(object):\n    def findDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 1, len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) / 2\n            # Get count of num <= mid.\n            count = 0\n            for num in nums:\n                if num <= mid:\n                    count += 1\n            if count > mid:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\nclass Solution3(object):\n    def findDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        duplicate = 0\n        # Mark the value as visited by negative.\n        for num in nums:\n            if nums[abs(num) - 1] > 0:\n                nums[abs(num) - 1] *= -1\n            else:\n                duplicate = abs(num)\n                break\n        # Rollback the value.\n        for num in nums:\n            if nums[abs(num) - 1] < 0:\n                nums[abs(num) - 1] *= -1\n            else:\n                break\n        return duplicate",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "String Compression",
      "difficulty": "MEDIUM",
      "category": "Two Pointers, String",
      "link": "https://leetcode.com/problems/string-compression",
      "slug": "string-compression",
      "description": "Given an array of characters \nchars\n, compress it using the following algorithm:\n\n\nBegin with an empty string \ns\n. For each group of \nconsecutive repeating characters\n in \nchars\n:\n\n\n\n\nIf the group's length is \n1\n, append the character to \ns\n.\n\n\nOtherwise, append the character followed by the group's length.\n\n\n\n\nThe compressed string \ns\n \nshould not be returned separately\n, but instead, be stored \nin the input character array \nchars\n. Note that group lengths that are \n10\n or longer will be split into multiple characters in \nchars\n.\n\n\nAfter you are done \nmodifying the input array,\n return \nthe new length of the array\n.\n\n\nYou must write an algorithm that uses only constant extra space.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\n\nOutput:\n Return 6, and the first 6 characters of the input array should be: [\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]\n\nExplanation:\n The groups are \"aa\", \"bb\", and \"ccc\". This compresses to \"a2b2c3\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n chars = [\"a\"]\n\nOutput:\n Return 1, and the first character of the input array should be: [\"a\"]\n\nExplanation:\n The only group is \"a\", which remains uncompressed since it's a single character.\n\n\n\nExample 3:\n\n\n\n\nInput:\n chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\n\nOutput:\n Return 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"].\n\nExplanation:\n The groups are \"a\" and \"bbbbbbbbbbbb\". This compresses to \"ab12\".\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= chars.length <= 2000\n\n\nchars[i]\n is a lowercase English letter, uppercase English letter, digit, or symbol.",
      "solution": "class Solution(object):\n    def compress(self, chars):\n        \"\"\"\n        :type chars: List[str]\n        :rtype: int\n        \"\"\"\n        anchor, write = 0, 0\n        for read, c in enumerate(chars):\n            if read+1 == len(chars) or chars[read+1] != c:\n                chars[write] = chars[anchor]\n                write += 1\n                if read > anchor:\n                    n, left = read-anchor+1, write\n                    while n > 0:\n                        chars[write] = chr(n%10+ord('0'))\n                        write += 1\n                        n /= 10\n                    right = write-1\n                    while left < right:\n                        chars[left], chars[right] = chars[right], chars[left]\n                        left += 1\n                        right -= 1\n                anchor = read+1\n        return write",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Course Schedule",
      "difficulty": "MEDIUM",
      "category": "Depth-First Search, Breadth-First Search, Graph, Topological Sort",
      "link": "https://leetcode.com/problems/course-schedule",
      "slug": "course-schedule",
      "description": "There are a total of \nnumCourses\n courses you have to take, labeled from \n0\n to \nnumCourses - 1\n. You are given an array \nprerequisites\n where \nprerequisites[i] = [a\ni\n, b\ni\n]\n indicates that you \nmust\n take course \nb\ni\n first if you want to take course \na\ni\n.\n\n\n\n\nFor example, the pair \n[0, 1]\n, indicates that to take course \n0\n you have to first take course \n1\n.\n\n\n\n\nReturn \ntrue\n if you can finish all courses. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [[1,0]]\n\nOutput:\n true\n\nExplanation:\n There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\n\n\nExample 2:\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [[1,0],[0,1]]\n\nOutput:\n false\n\nExplanation:\n There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numCourses <= 2000\n\n\n0 <= prerequisites.length <= 5000\n\n\nprerequisites[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < numCourses\n\n\nAll the pairs prerequisites[i] are \nunique\n.",
      "solution": "\nimport collections\n\n\n# Khan's algorithm (bfs solution)class Solution(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        q = [u for u in xrange(numCourses) if u not in in_degree]\n        while q:\n            new_q = []\n            for u in q:\n                result.append(u)\n                for v in adj[u]:\n                    in_degree[v] -= 1\n                    if in_degree[v] == 0:\n                        new_q.append(v)\n            q = new_q\n        return len(result) == numCourses\n\n\nimport collections\n\n\n# dfs solutionclass Solution2(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        stk = [u for u in xrange(numCourses) if u not in in_degree]\n        while stk:\n            u = stk.pop()\n            result.append(u)\n            for v in adj[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    stk.append(v)\n        return len(result) == numCourses",
      "explanation": "N/A",
      "time_complexity": "O(|V| + |E|)",
      "space_complexity": "O(|E|)"
    },
    {
      "title": "Maximize Distance to Closest Person",
      "difficulty": "MEDIUM",
      "category": "Array",
      "link": "https://leetcode.com/problems/maximize-distance-to-closest-person",
      "slug": "maximize-distance-to-closest-person",
      "description": "You are given an array representing a row of \nseats\n where \nseats[i] = 1\n represents a person sitting in the \ni\nth\n seat, and \nseats[i] = 0\n represents that the \ni\nth\n seat is empty \n(0-indexed)\n.\n\n\nThere is at least one empty seat, and at least one person sitting.\n\n\nAlex wants to sit in the seat such that the distance between him and the closest person to him is maximized. \n\n\nReturn \nthat maximum distance to the closest person\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n seats = [1,0,0,0,1,0,1]\n\nOutput:\n 2\n\nExplanation: \n\nIf Alex sits in the second open seat (i.e. seats[2]), then the closest person has distance 2.\nIf Alex sits in any other open seat, the closest person has distance 1.\nThus, the maximum distance to the closest person is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n seats = [1,0,0,0]\n\nOutput:\n 3\n\nExplanation: \n\nIf Alex sits in the last seat (i.e. seats[3]), the closest person is 3 seats away.\nThis is the maximum distance possible, so the answer is 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n seats = [0,1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= seats.length <= 2 * 10\n4\n\n\nseats[i]\n is \n0\n or \n1\n.\n\n\nAt least one seat is \nempty\n.\n\n\nAt least one seat is \noccupied\n.",
      "solution": "\nclass Solution(object):\n    def maxDistToClosest(self, seats):\n        \"\"\"\n        :type seats: List[int]\n        :rtype: int\n        \"\"\"\n        prev, result = -1, 1\n        for i in xrange(len(seats)):\n            if seats[i]:\n                if prev < 0:\n                    result = i\n                else:\n                    result = max(result, (i-prev)//2)\n                prev = i\n        return max(result, len(seats)-1-prev)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Spiral Matrix",
      "difficulty": "MEDIUM",
      "category": "Array, Matrix, Simulation",
      "link": "https://leetcode.com/problems/spiral-matrix",
      "slug": "spiral-matrix",
      "description": "Given an \nm x n\n \nmatrix\n, return \nall elements of the\n \nmatrix\n \nin spiral order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [1,2,3,6,9,8,7,4,5]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n\nOutput:\n [1,2,3,4,8,12,11,10,9,5,6,7]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 10\n\n\n-100 <= matrix[i][j] <= 100",
      "solution": "class Solution(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of integers\n    def spiralOrder(self, matrix):\n        result = []\n        if matrix == []:\n            return result\n\n        left, right, top, bottom = 0, len(matrix[0]) - 1, 0, len(matrix) - 1\n\n        while left <= right and top <= bottom:\n            for j in xrange(left, right + 1):\n                result.append(matrix[top][j])\n            for i in xrange(top + 1, bottom):\n                result.append(matrix[i][right])\n            for j in reversed(xrange(left, right + 1)):\n                if top < bottom:\n                    result.append(matrix[bottom][j])\n            for i in reversed(xrange(top + 1, bottom)):\n                if left < right:\n                    result.append(matrix[i][left])\n            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1\n\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Magnetic Force Between Two Balls",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search, Sorting",
      "link": "https://leetcode.com/problems/magnetic-force-between-two-balls",
      "slug": "magnetic-force-between-two-balls",
      "description": "In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has \nn\n empty baskets, the \ni\nth\n basket is at \nposition[i]\n, Morty has \nm\n balls and needs to distribute the balls into the baskets such that the \nminimum magnetic force\n between any two balls is \nmaximum\n.\n\n\nRick stated that magnetic force between two different balls at positions \nx\n and \ny\n is \n|x - y|\n.\n\n\nGiven the integer array \nposition\n and the integer \nm\n. Return \nthe required force\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n position = [1,2,3,4,7], m = 3\n\nOutput:\n 3\n\nExplanation:\n Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n position = [5,4,3,2,1,1000000000], m = 2\n\nOutput:\n 999999999\n\nExplanation:\n We can use baskets 1 and 1000000000.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == position.length\n\n\n2 <= n <= 10\n5\n\n\n1 <= position[i] <= 10\n9\n\n\nAll integers in \nposition\n are \ndistinct\n.\n\n\n2 <= m <= position.length",
      "solution": "class Solution(object):\n    def maxDistance(self, position, m):\n        \"\"\"\n        :type position: List[int]\n        :type m: int\n        :rtype: int\n        \"\"\"\n        def check(position, m, x):\n            count, prev = 1, position[0]\n            for i in xrange(1, len(position)):\n                if position[i]-prev >= x:\n                    count += 1\n                    prev = position[i]\n            return count >= m\n        \n        position.sort()\n        left, right = 1, position[-1]-position[0]\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(position, m, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right",
      "explanation": "N/A",
      "time_complexity": "O(nlogn + nlogr), r is the range of positions",
      "space_complexity": "O(1)"
    },
    {
      "title": "Happy Number",
      "difficulty": "EASY",
      "category": "Hash Table, Math, Two Pointers",
      "link": "https://leetcode.com/problems/happy-number",
      "slug": "happy-number",
      "description": "Write an algorithm to determine if a number \nn\n is happy.\n\n\nA \nhappy number\n is a number defined by the following process:\n\n\n\n\nStarting with any positive integer, replace the number by the sum of the squares of its digits.\n\n\nRepeat the process until the number equals 1 (where it will stay), or it \nloops endlessly in a cycle\n which does not include 1.\n\n\nThose numbers for which this process \nends in 1\n are happy.\n\n\n\n\nReturn \ntrue\n \nif\n \nn\n \nis a happy number, and\n \nfalse\n \nif not\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 19\n\nOutput:\n true\n\nExplanation:\n\n1\n2\n + 9\n2\n = 82\n8\n2\n + 2\n2\n = 68\n6\n2\n + 8\n2\n = 100\n1\n2\n + 0\n2\n + 0\n2\n = 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2\n31\n - 1",
      "solution": "class Solution(object):\n    # @param {integer} n\n    # @return {boolean}\n    def isHappy(self, n):\n        lookup = {}\n        while n != 1 and n not in lookup:\n            lookup[n] = True\n            n = self.nextNumber(n)\n        return n == 1\n\n    def nextNumber(self, n):\n        new = 0\n        for char in str(n):\n            new += int(char)**2\n        return new",
      "explanation": "N/A",
      "time_complexity": "O(k), where k is the steps to be happy number",
      "space_complexity": "O(k)"
    },
    {
      "title": "Convert Sorted Array to Binary Search Tree",
      "difficulty": "EASY",
      "category": "Array, Divide and Conquer, Tree, Binary Search Tree, Binary Tree",
      "link": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree",
      "slug": "convert-sorted-array-to-binary-search-tree",
      "description": "Given an integer array \nnums\n where the elements are sorted in \nascending order\n, convert \nit to a \nheight-balanced\n \nbinary search tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [-10,-3,0,5,9]\n\nOutput:\n [0,-3,9,-10,null,5]\n\nExplanation:\n [0,-10,5,null,-3,null,9] is also accepted:\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [1,3]\n\nOutput:\n [3,1]\n\nExplanation:\n [1,null,3] and [3,1] are both height-balanced BSTs.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nnums\n is sorted in a \nstrictly increasing\n order.",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        return self.sortedArrayToBSTRecu(nums, 0, len(nums))\n\n    def sortedArrayToBSTRecu(self, nums, start, end):\n        if start == end:\n            return None\n        mid = start + self.perfect_tree_pivot(end - start)\n        node = TreeNode(nums[mid])\n        node.left = self.sortedArrayToBSTRecu(nums, start, mid)\n        node.right = self.sortedArrayToBSTRecu(nums, mid + 1, end)\n        return node\n\n    def perfect_tree_pivot(self, n):\n        \"\"\"\n        Find the point to partition n keys for a perfect binary search tree\n        \"\"\"\n        x = 1\n        # find a power of 2 <= n//2\n        # while x <= n//2:  # this loop could probably be written more elegantly :)\n        #     x *= 2\n        x = 1 << (n.bit_length() - 1)  # use the left bit shift, same as multiplying x by 2**n-1\n\n        if x // 2 - 1 <= (n - x):\n            return x - 1  # case 1: the left subtree of the root is perfect and the right subtree has less nodes\n        else:\n            return n - x // 2  # case 2 == n - (x//2 - 1) - 1 : the left subtree of the root\n                               # has more nodes and the right subtree is perfect.\nclass Solution2(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        self.iterator = iter(nums)\n        return self.helper(0, len(nums))\n    \n    def helper(self, start, end):\n        if start == end:\n            return None\n        \n        mid = (start + end) // 2\n        left = self.helper(start, mid)\n        current = TreeNode(next(self.iterator))\n        current.left = left\n        current.right = self.helper(mid+1, end)\n        return current",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(logn)"
    },
    {
      "title": "Distribute Candies Among Children II",
      "difficulty": "MEDIUM",
      "category": "Math, Combinatorics, Enumeration",
      "link": "https://leetcode.com/problems/distribute-candies-among-children-ii",
      "slug": "distribute-candies-among-children-ii",
      "description": "You are given two positive integers \nn\n and \nlimit\n.\n\n\nReturn \nthe \ntotal number\n of ways to distribute \nn\n \ncandies among \n3\n children such that no child gets more than \nlimit\n candies.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 5, limit = 2\n\nOutput:\n 3\n\nExplanation:\n There are 3 ways to distribute 5 candies such that no child gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3, limit = 3\n\nOutput:\n 10\n\nExplanation:\n There are 10 ways to distribute 3 candies such that no child gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1), (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1), (2, 1, 0) and (3, 0, 0).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n6\n\n\n1 <= limit <= 10\n6",
      "solution": "\n# stars and bars, combinatorics, principle of inclusion-exclusion class Solution(object):\n    def distributeCandies(self, n, limit):\n        \"\"\"\n        :type n: int\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        def nCr(n, r):  # Time: O(n), Space: O(1)\n            if not 0 <= r <= n:\n                return 0\n            if n-r < r:\n                r = n-r\n            c = 1\n            for k in xrange(1, r+1):\n                c *= n-k+1\n                c //= k\n            return c\n        \n        def nHr(n, r):\n            return nCr(n+(r-1), r-1)\n    \n        R = 3\n        return sum((-1 if r%2 else 1) * nCr(R, r) * nHr(n-r*(limit+1), R)for r in xrange(R+1))\n\n\n# optimized brute forceclass Solution2(object):\n    def distributeCandies(self, n, limit):\n        \"\"\"\n        :type n: int\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        return sum(min(limit, n-i)-max((n-i)-limit, 0)+1 for i in xrange(max(n-2*limit, 0), min(limit, n)+1))",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Find Eventual Safe States",
      "difficulty": "MEDIUM",
      "category": "Depth-First Search, Breadth-First Search, Graph, Topological Sort",
      "link": "https://leetcode.com/problems/find-eventual-safe-states",
      "slug": "find-eventual-safe-states",
      "description": "There is a directed graph of \nn\n nodes with each node labeled from \n0\n to \nn - 1\n. The graph is represented by a \n0-indexed\n 2D integer array \ngraph\n where \ngraph[i]\n is an integer array of nodes adjacent to node \ni\n, meaning there is an edge from node \ni\n to each node in \ngraph[i]\n.\n\n\nA node is a \nterminal node\n if there are no outgoing edges. A node is a \nsafe node\n if every possible path starting from that node leads to a \nterminal node\n (or another safe node).\n\n\nReturn \nan array containing all the \nsafe nodes\n of the graph\n. The answer should be sorted in \nascending\n order.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n graph = [[1,2],[2,3],[5],[0],[5],[],[]]\n\nOutput:\n [2,4,5,6]\n\nExplanation:\n The given graph is shown above.\nNodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.\nEvery path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.\n\n\nExample 2:\n\n\n\n\nInput:\n graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\n\nOutput:\n [4]\n\nExplanation:\n\nOnly node 4 is a terminal node, and every path starting at node 4 leads to node 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == graph.length\n\n\n1 <= n <= 10\n4\n\n\n0 <= graph[i].length <= n\n\n\n0 <= graph[i][j] <= n - 1\n\n\ngraph[i]\n is sorted in a strictly increasing order.\n\n\nThe graph may contain self-loops.\n\n\nThe number of edges in the graph will be in the range \n[1, 4 * 10\n4\n]\n.",
      "solution": "class Solution(object):\n    def eventualSafeNodes(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        WHITE, GRAY, BLACK = range(3)\n\n        def dfs(graph, node, lookup):\n            if lookup[node] != WHITE:\n                return lookup[node] == BLACK\n            lookup[node] = GRAY\n            if any(not dfs(graph, child, lookup) for child in graph[node]):\n                return False\n            lookup[node] = BLACK\n            return True\n\n        lookup = [WHITE]*len(graph)\n        return filter(lambda node: dfs(graph, node, lookup), xrange(len(graph)))",
      "explanation": "N/A",
      "time_complexity": "O(|V| + |E|)",
      "space_complexity": "O(|V|)"
    },
    {
      "title": "Combinations",
      "difficulty": "MEDIUM",
      "category": "Backtracking",
      "link": "https://leetcode.com/problems/combinations",
      "slug": "combinations",
      "description": "Given two integers \nn\n and \nk\n, return \nall possible combinations of\n \nk\n \nnumbers chosen from the range\n \n[1, n]\n.\n\n\nYou may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 4, k = 2\n\nOutput:\n [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n\nExplanation:\n There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1, k = 1\n\nOutput:\n [[1]]\n\nExplanation:\n There is 1 choose 1 = 1 total combination.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 20\n\n\n1 <= k <= n",
      "solution": "class Solution(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if k > n:\n            return []\n        nums, idxs = range(1, n+1), range(k)\n        result = [[nums[i] for i in idxs]]\n        while True:\n            for i in reversed(xrange(k)):\n                if idxs[i] != i+n-k:\n                    break\n            else:\n                break\n            idxs[i] += 1\n            for j in xrange(i+1, k):\n                idxs[j] = idxs[j-1]+1\n            result.append([nums[i] for i in idxs])\n        return result\n\nclass Solution2(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result, combination = [], []\n        i = 1\n        while True:\n            if len(combination) == k:\n                result.append(combination[:])\n            if len(combination) == k or \\\n               len(combination)+(n-i+1) < k:\n                if not combination:\n                    break\n                i = combination.pop()+1\n            else:\n                combination.append(i)\n                i += 1\n        return result\n\nclass Solution3(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def combineDFS(n, start, intermediate, k, result):\n            if k == 0:\n                result.append(intermediate[:])\n                return\n            for i in xrange(start, n):\n                intermediate.append(i+1)\n                combineDFS(n, i+1, intermediate, k-1, result)\n                intermediate.pop()\n\n        result = []\n        combineDFS(n, 0, [], k, result)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(k * C(n, k))",
      "space_complexity": "O(k)"
    },
    {
      "title": "Design Parking System",
      "difficulty": "EASY",
      "category": "Design, Simulation, Counting",
      "link": "https://leetcode.com/problems/design-parking-system",
      "slug": "design-parking-system",
      "description": "Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.\n\n\nImplement the \nParkingSystem\n class:\n\n\n\n\nParkingSystem(int big, int medium, int small)\n Initializes object of the \nParkingSystem\n class. The number of slots for each parking space are given as part of the constructor.\n\n\nbool addCar(int carType)\n Checks whether there is a parking space of \ncarType\n for the car that wants to get into the parking lot. \ncarType\n can be of three kinds: big, medium, or small, which are represented by \n1\n, \n2\n, and \n3\n respectively. \nA car can only park in a parking space of its \ncarType\n. If there is no space available, return \nfalse\n, else park the car in that size space and return \ntrue\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"]\n[[1, 1, 0], [1], [2], [3], [1]]\n\nOutput\n\n[null, true, true, false, false]\n\n\nExplanation\n\nParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\nparkingSystem.addCar(1); // return true because there is 1 available slot for a big car\nparkingSystem.addCar(2); // return true because there is 1 available slot for a medium car\nparkingSystem.addCar(3); // return false because there is no available slot for a small car\nparkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= big, medium, small <= 1000\n\n\ncarType\n is \n1\n, \n2\n, or \n3\n\n\nAt most \n1000\n calls will be made to \naddCar",
      "solution": "class ParkingSystem(object):\n\n    def __init__(self, big, medium, small):\n        \"\"\"\n        :type big: int\n        :type medium: int\n        :type small: int\n        \"\"\"\n        self.__space = [0, big, medium, small]\n\n    def addCar(self, carType):\n        \"\"\"\n        :type carType: int\n        :rtype: bool\n        \"\"\"\n        if self.__space[carType] > 0:\n            self.__space[carType] -= 1\n            return True\n        return False",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Divisible and Non-divisible Sums Difference",
      "difficulty": "EASY",
      "category": "Math",
      "link": "https://leetcode.com/problems/divisible-and-non-divisible-sums-difference",
      "slug": "divisible-and-non-divisible-sums-difference",
      "description": "You are given positive integers \nn\n and \nm\n.\n\n\nDefine two integers as follows:\n\n\n\n\nnum1\n: The sum of all integers in the range \n[1, n]\n (both \ninclusive\n) that are \nnot divisible\n by \nm\n.\n\n\nnum2\n: The sum of all integers in the range \n[1, n]\n (both \ninclusive\n) that are \ndivisible\n by \nm\n.\n\n\n\n\nReturn \nthe integer\n \nnum1 - num2\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 10, m = 3\n\nOutput:\n 19\n\nExplanation:\n In the given example:\n- Integers in the range [1, 10] that are not divisible by 3 are [1,2,4,5,7,8,10], num1 is the sum of those integers = 37.\n- Integers in the range [1, 10] that are divisible by 3 are [3,6,9], num2 is the sum of those integers = 18.\nWe return 37 - 18 = 19 as the answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 5, m = 6\n\nOutput:\n 15\n\nExplanation:\n In the given example:\n- Integers in the range [1, 5] that are not divisible by 6 are [1,2,3,4,5], num1 is the sum of those integers = 15.\n- Integers in the range [1, 5] that are divisible by 6 are [], num2 is the sum of those integers = 0.\nWe return 15 - 0 = 15 as the answer.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 5, m = 1\n\nOutput:\n -15\n\nExplanation:\n In the given example:\n- Integers in the range [1, 5] that are not divisible by 1 are [], num1 is the sum of those integers = 0.\n- Integers in the range [1, 5] that are divisible by 1 are [1,2,3,4,5], num2 is the sum of those integers = 15.\nWe return 0 - 15 = -15 as the answer.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n, m <= 1000",
      "solution": "\n# mathclass Solution(object):\n    def differenceOfSums(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        def arithmetic_progression_sum(a, d, l):\n            return (a+(a+(l-1)*d))*l//2\n    \n        return arithmetic_progression_sum(1, 1, n) - 2*arithmetic_progression_sum(m, m, n//m)\n\n\n# mathclass Solution2(object):\n    def differenceOfSums(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        return (n+1)*n//2 - 2*(((n//m+1)*(n//m)//2)*m)",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Rotate List",
      "difficulty": "MEDIUM",
      "category": "Linked List, Two Pointers",
      "link": "https://leetcode.com/problems/rotate-list",
      "slug": "rotate-list",
      "description": "Given the \nhead\n of a linked list, rotate the list to the right by \nk\n places.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 2\n\nOutput:\n [4,5,1,2,3]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [0,1,2], k = 4\n\nOutput:\n [2,0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 500]\n.\n\n\n-100 <= Node.val <= 100\n\n\n0 <= k <= 2 * 10\n9",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        n, cur = 1, head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        cur.next = head\n\n        cur, tail = head, cur\n        for _ in xrange(n - k % n):\n            tail = cur\n            cur = cur.next\n        tail.next = None\n\n        return cur",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Largest Rectangle in Histogram",
      "difficulty": "HARD",
      "category": "Array, Stack, Monotonic Stack",
      "link": "https://leetcode.com/problems/largest-rectangle-in-histogram",
      "slug": "largest-rectangle-in-histogram",
      "description": "Given an array of integers \nheights\n representing the histogram's bar height where the width of each bar is \n1\n, return \nthe area of the largest rectangle in the histogram\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [2,1,5,6,2,3]\n\nOutput:\n 10\n\nExplanation:\n The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n heights = [2,4]\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= heights.length <= 10\n5\n\n\n0 <= heights[i] <= 10\n4",
      "solution": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stk, result = [-1], 0\n        for i in xrange(len(heights)+1):\n            while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):\n                result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))\n            stk.append(i) \n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Design In-Memory File System",
      "difficulty": "HARD",
      "category": "Hash Table, String, Design, Trie, Sorting",
      "link": "https://leetcode.com/problems/design-in-memory-file-system",
      "slug": "design-in-memory-file-system",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "#        mkdir: O(l)\n#        addContentToFile: O(l + c), c is the content size\n#        readContentFromFile: O(l + c)\nclass TrieNode(object):\n\n    def __init__(self):\n        self.is_file = False\n        self.children = {}\n        self.content = \"\"\nclass FileSystem(object):\n\n    def __init__(self):\n        self.__root = TrieNode()\n\n\n    def ls(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: List[str]\n        \"\"\"\n        curr = self.__getNode(path)\n\n        if curr.is_file:\n            return [self.__split(path, '/')[-1]]\n\n        return sorted(curr.children.keys())\n\n\n    def mkdir(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: void\n        \"\"\"\n        curr = self.__putNode(path)\n        curr.is_file = False\n\n\n    def addContentToFile(self, filePath, content):\n        \"\"\"\n        :type filePath: str\n        :type content: str\n        :rtype: void\n        \"\"\"\n        curr = self.__putNode(filePath)\n        curr.is_file = True\n        curr.content += content\n\n\n    def readContentFromFile(self, filePath):\n        \"\"\"\n        :type filePath: str\n        :rtype: str\n        \"\"\"\n        return self.__getNode(filePath).content\n\n\n    def __getNode(self, path):\n        curr = self.__root\n        for s in self.__split(path, '/'):\n            curr = curr.children[s]\n        return curr\n\n\n    def __putNode(self, path):\n        curr = self.__root\n        for s in self.__split(path, '/'):\n            if s not in curr.children:\n                curr.children[s] = TrieNode()\n            curr = curr.children[s]\n        return curr\n\n\n    def __split(self, path, delim):\n        if path == '/':\n            return []\n        return path.split('/')[1:]",
      "explanation": "N/A",
      "time_complexity": "ls: O(l + klogk), l is the path length, k is the number of entries in the last level directory",
      "space_complexity": "O(n + s), n is the number of dir/file nodes, s is the total content size."
    },
    {
      "title": "Decode String",
      "difficulty": "MEDIUM",
      "category": "String, Stack, Recursion",
      "link": "https://leetcode.com/problems/decode-string",
      "slug": "decode-string",
      "description": "Given an encoded string, return its decoded string.\n\n\nThe encoding rule is: \nk[encoded_string]\n, where the \nencoded_string\n inside the square brackets is being repeated exactly \nk\n times. Note that \nk\n is guaranteed to be a positive integer.\n\n\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, \nk\n. For example, there will not be input like \n3a\n or \n2[4]\n.\n\n\nThe test cases are generated so that the length of the output will never exceed \n10\n5\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"3[a]2[bc]\"\n\nOutput:\n \"aaabcbc\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"3[a2[c]]\"\n\nOutput:\n \"accaccacc\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"2[abc]3[cd]ef\"\n\nOutput:\n \"abcabccdcdcdef\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 30\n\n\ns\n consists of lowercase English letters, digits, and square brackets \n'[]'\n.\n\n\ns\n is guaranteed to be \na valid\n input.\n\n\nAll the integers in \ns\n are in the range \n[1, 300]\n.",
      "solution": "class Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n, curr, nums, strs = 0, [], [], []\n        for c in s:\n            if c.isdigit():\n                n = n*10 + ord(c)-ord('0')\n            elif c.isalpha():\n                curr.append(c)\n            elif c == '[':\n                nums.append(n)\n                strs.append(curr)\n                n, curr = 0, []\n            elif c == ']':\n                strs[-1].extend(curr*nums.pop())\n                curr = strs.pop()\n        return \"\".join(curr)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Binary Tree Level Order Traversal",
      "difficulty": "MEDIUM",
      "category": "Tree, Breadth-First Search, Binary Tree",
      "link": "https://leetcode.com/problems/binary-tree-level-order-traversal",
      "slug": "binary-tree-level-order-traversal",
      "description": "Given the \nroot\n of a binary tree, return \nthe level order traversal of its nodes' values\n. (i.e., from left to right, level by level).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n [[3],[9,20],[15,7]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n [[1]]\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 2000]\n.\n\n\n-1000 <= Node.val <= 1000",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return a list of lists of integers\n    def levelOrder(self, root):\n        if root is None:\n            return []\n        result, current = [], [root]\n        while current:\n            next_level, vals = [], []\n            for node in current:\n                vals.append(node.val)\n                if node.left:\n                    next_level.append(node.left)\n                if node.right:\n                    next_level.append(node.right)\n            current = next_level\n            result.append(vals)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Subarray Sum Equals K",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Prefix Sum",
      "link": "https://leetcode.com/problems/subarray-sum-equals-k",
      "slug": "subarray-sum-equals-k",
      "description": "Given an array of integers \nnums\n and an integer \nk\n, return \nthe total number of subarrays whose sum equals to\n \nk\n.\n\n\nA subarray is a contiguous \nnon-empty\n sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,1,1], k = 2\n\nOutput:\n 2\n\nExample 2:\n\n\nInput:\n nums = [1,2,3], k = 3\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2 * 10\n4\n\n\n-1000 <= nums[i] <= 1000\n\n\n-10\n7\n <= k <= 10\n7",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def subarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        accumulated_sum = 0\n        lookup = collections.defaultdict(int)\n        lookup[0] += 1\n        for num in nums:\n            accumulated_sum += num\n            result += lookup[accumulated_sum - k]\n            lookup[accumulated_sum] += 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Count Zero Request Servers",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Sliding Window, Sorting",
      "link": "https://leetcode.com/problems/count-zero-request-servers",
      "slug": "count-zero-request-servers",
      "description": "You are given an integer \nn\n denoting the total number of servers and a \n2D\n \n0-indexed \ninteger array \nlogs\n, where \nlogs[i] = [server_id, time]\n denotes that the server with id \nserver_id\n received a request at time \ntime\n.\n\n\nYou are also given an integer \nx\n and a \n0-indexed\n integer array \nqueries\n.\n\n\nReturn \na \n0-indexed\n integer array\n \narr\n \nof length\n \nqueries.length\n \nwhere\n \narr[i]\n \nrepresents the number of servers that \ndid not receive\n any requests during the time interval\n \n[queries[i] - x, queries[i]]\n.\n\n\nNote that the time intervals are inclusive.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 3, logs = [[1,3],[2,6],[1,5]], x = 5, queries = [10,11]\n\nOutput:\n [1,2]\n\nExplanation:\n \nFor queries[0]: The servers with ids 1 and 2 get requests in the duration of [5, 10]. Hence, only server 3 gets zero requests.\nFor queries[1]: Only the server with id 2 gets a request in duration of [6,11]. Hence, the servers with ids 1 and 3 are the only servers that do not receive any requests during that time period.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3, logs = [[2,4],[2,1],[1,2],[3,1]], x = 2, queries = [3,4]\n\nOutput:\n [0,1]\n\nExplanation:\n \nFor queries[0]: All servers get at least one request in the duration of [1, 3].\nFor queries[1]: Only server with id 3 gets no request in the duration [2,4].\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5\n\n\n1 <= logs.length <= 10\n5\n\n\n1 <= queries.length <= 10\n5\n\n\nlogs[i].length == 2\n\n\n1 <= logs[i][0] <= n\n\n\n1 <= logs[i][1] <= 10\n6\n\n\n1 <= x <= 10\n5\n\n\nx < queries[i] <= 10\n6",
      "solution": "\n# sort, two pointersclass Solution(object):\n    def countServers(self, n, logs, x, queries):\n        \"\"\"\n        :type n: int\n        :type logs: List[List[int]]\n        :type x: int\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        logs.sort(key=lambda x:x[1])\n        result = [0]*len(queries)\n        cnt = [0]*n\n        curr = left = right = 0\n        for t, i in sorted((t, i) for i, t in enumerate(queries)):\n            while right < len(logs) and logs[right][1] <= t:\n                if cnt[logs[right][0]-1] == 0:\n                    curr += 1\n                cnt[logs[right][0]-1] += 1\n                right += 1\n            while left < right and logs[left][1] < t-x:\n                cnt[logs[left][0]-1] -= 1\n                if cnt[logs[left][0]-1] == 0:\n                    curr -= 1\n                left += 1\n            result[i] = n-curr\n        return result\n\n\n# sort, line sweepclass Solution2(object):\n    def countServers(self, n, logs, x, queries):\n        \"\"\"\n        :type n: int\n        :type logs: List[List[int]]\n        :type x: int\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        events = []\n        for sid, t in logs:\n            events.append((t, +1, sid-1))\n            events.append((t+x+1, -1, sid-1))\n        events.append((float(\"inf\"), 0, 0))\n        events.sort()\n\n        events2 = []\n        for i, t in enumerate(queries):\n            events2.append((t, i))\n        events2.sort(reverse=True)\n\n        result = [0]*len(queries)\n        cnt = [0]*n\n        curr = 0\n        for t, c, i in events:\n            while events2 and events2[-1][0] < t:                \n                result[events2.pop()[1]] += n-curr\n            if cnt[i] == 0:\n                curr += 1\n            cnt[i] += c\n            if cnt[i] == 0:\n                curr -= 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn + mlogm)",
      "space_complexity": "O(n + m)"
    },
    {
      "title": "K Closest Points to Origin",
      "difficulty": "MEDIUM",
      "category": "Array, Math, Divide and Conquer, Geometry, Sorting, Heap (Priority Queue), Quickselect",
      "link": "https://leetcode.com/problems/k-closest-points-to-origin",
      "slug": "k-closest-points-to-origin",
      "description": "Given an array of \npoints\n where \npoints[i] = [x\ni\n, y\ni\n]\n represents a point on the \nX-Y\n plane and an integer \nk\n, return the \nk\n closest points to the origin \n(0, 0)\n.\n\n\nThe distance between two points on the \nX-Y\n plane is the Euclidean distance (i.e., \n√(x\n1\n - x\n2\n)\n2\n + (y\n1\n - y\n2\n)\n2\n).\n\n\nYou may return the answer in \nany order\n. The answer is \nguaranteed\n to be \nunique\n (except for the order that it is in).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[1,3],[-2,2]], k = 1\n\nOutput:\n [[-2,2]]\n\nExplanation:\n\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[3,3],[5,-1],[-2,4]], k = 2\n\nOutput:\n [[3,3],[-2,4]]\n\nExplanation:\n The answer [[-2,4],[3,3]] would also be accepted.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= points.length <= 10\n4\n\n\n-10\n4\n <= x\ni\n, y\ni\n <= 10\n4",
      "solution": "\n# quick select solution\nfrom random import randint\n\nclass Solution(object):\n    def kClosest(self, points, K):\n        \"\"\"\n        :type points: List[List[int]]\n        :type K: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def dist(point):\n            return point[0]**2 + point[1]**2\n        \n        def kthElement(nums, k, compare):\n            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):\n                new_pivot_idx = left\n                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                for i in xrange(left, right):\n                    if compare(nums[i], nums[right]):\n                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                        new_pivot_idx += 1\n\n                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                return new_pivot_idx\n\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)\n                if new_pivot_idx == k:\n                    return\n                elif new_pivot_idx > k:\n                    right = new_pivot_idx - 1\n                else:  # new_pivot_idx < k.\n                    left = new_pivot_idx + 1\n                    \n        kthElement(points, K-1, lambda a, b: dist(a) < dist(b))\n        return points[:K]\n\n    \nimport heapq\n\nclass Solution2(object):\n    def kClosest(self, points, K):\n        \"\"\"\n        :type points: List[List[int]]\n        :type K: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def dist(point):\n            return point[0]**2 + point[1]**2\n        \n        max_heap = []\n        for point in points:\n            heapq.heappush(max_heap, (-dist(point), point))\n            if len(max_heap) > K:\n                heapq.heappop(max_heap)\n        return [heapq.heappop(max_heap)[1] for _ in xrange(len(max_heap))]",
      "explanation": "N/A",
      "time_complexity": "O(nlogk)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Evaluate Division",
      "difficulty": "MEDIUM",
      "category": "Array, String, Depth-First Search, Breadth-First Search, Union Find, Graph, Shortest Path",
      "link": "https://leetcode.com/problems/evaluate-division",
      "slug": "evaluate-division",
      "description": "You are given an array of variable pairs \nequations\n and an array of real numbers \nvalues\n, where \nequations[i] = [A\ni\n, B\ni\n]\n and \nvalues[i]\n represent the equation \nA\ni\n / B\ni\n = values[i]\n. Each \nA\ni\n or \nB\ni\n is a string that represents a single variable.\n\n\nYou are also given some \nqueries\n, where \nqueries[j] = [C\nj\n, D\nj\n]\n represents the \nj\nth\n query where you must find the answer for \nC\nj\n / D\nj\n = ?\n.\n\n\nReturn \nthe answers to all queries\n. If a single answer cannot be determined, return \n-1.0\n.\n\n\nNote:\n The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\n\n\nNote: \nThe variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n\nOutput:\n [6.00000,0.50000,-1.00000,1.00000,-1.00000]\n\nExplanation:\n \nGiven: \na / b = 2.0\n, \nb / c = 3.0\n\nqueries are: \na / c = ?\n, \nb / a = ?\n, \na / e = ?\n, \na / a = ?\n, \nx / x = ? \n\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]\nnote: x is undefined => -1.0\n\n\nExample 2:\n\n\n\n\nInput:\n equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n\nOutput:\n [3.75000,0.40000,5.00000,0.20000]\n\n\n\nExample 3:\n\n\n\n\nInput:\n equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n\nOutput:\n [0.50000,2.00000,-1.00000,-1.00000]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= equations.length <= 20\n\n\nequations[i].length == 2\n\n\n1 <= A\ni\n.length, B\ni\n.length <= 5\n\n\nvalues.length == equations.length\n\n\n0.0 < values[i] <= 20.0\n\n\n1 <= queries.length <= 20\n\n\nqueries[i].length == 2\n\n\n1 <= C\nj\n.length, D\nj\n.length <= 5\n\n\nA\ni\n, B\ni\n, C\nj\n, D\nj\n consist of lower case English letters and digits.",
      "solution": "#                                     , using  both results in α(n) ~= O(1)\n\nimport collections\nimport itertools\n\nclass UnionFind(object):\n    def __init__(self):\n        self.set = {}\n        self.rank = collections.Counter()\n\n    def find_set(self, x):\n        xp, xr = self.set.setdefault(x, (x, 1.0))\n        if x != xp:\n            pp, pr = self.find_set(xp)  # path compression.\n            self.set[x] = (pp, xr*pr)  # x/pp = xr*pr\n        return self.set[x]\n\n    def union_set(self, x, y, r):\n        (xp, xr), (yp, yr) =  map(self.find_set, (x, y))\n        if xp == yp:\n            return False\n        if self.rank[xp] < self.rank[yp]:  # union by rank\n            # to make x/yp = r*yr and merge xp into yp\n            # => since x/xp = xr, we can merge with xp/yp = r*yr/xr \n            self.set[xp] = (yp, r*yr/xr)\n        elif self.rank[xp] > self.rank[yp]:\n            # to make y/xp = 1/r*xr and merge xp into yp\n            # => since y/yp = yr, we can merge with yp/xp = 1/r*xr/yr \n            self.set[yp] = (xp, 1.0/r*xr/yr)\n        else:\n            # to make y/xp = 1/r*xr and merge xp into yp\n            # => since y/yp = yr, we can merge with yp/xp = 1/r*xr/yr \n            self.set[yp] = (xp, 1.0/r*xr/yr)\n            self.rank[xp] += 1 \n        return True\n\n    def query_set(self, x, y):\n        if x not in self.set or y not in self.set:\n            return -1.0\n        (xp, xr), (yp, yr) = map(self.find_set, (x, y))\n        return xr/yr if xp == yp else -1.0\n\nclass UnionFindPathCompressionOnly(object):\n    def __init__(self):\n        self.set = {}\n\n    def find_set(self, x):\n        xp, xr = self.set.setdefault(x, (x, 1.0))\n        if x != xp:\n            pp, pr = self.find_set(xp)  # path compression.\n            self.set[x] = (pp, xr*pr)  # x/pp = xr*pr\n        return self.set[x]\n\n    def union_set(self, x, y, r):\n        (xp, xr), (yp, yr) =  map(self.find_set, (x, y))\n        if xp == yp:\n            return False\n        # to make x/yp = r*yr and merge xp into yp\n        # => since x/xp = xr, we can merge with xp/yp = r*yr/xr \n        self.set[xp] = (yp, r*yr/xr)\n        return True\n\n    def query_set(self, x, y):\n        if x not in self.set or y not in self.set:\n            return -1.0\n        (xp, xr), (yp, yr) = map(self.find_set, (x, y))\n        return xr/yr if xp == yp else -1.0\n\nclass Solution(object):\n    def calcEquation(self, equations, values, queries):\n        \"\"\"\n        :type equations: List[List[str]]\n        :type values: List[float]\n        :type queries: List[List[str]]\n        :rtype: List[float]\n        \"\"\"\n        union_find = UnionFind()\n        for (a, b), k in itertools.izip(equations, values):\n            union_find.union_set(a, b, k)\n        return [union_find.query_set(a, b) for a, b in queries]\n\n\n# bfs solution\nimport collections\nimport itertools\n\nclass Solution2(object):\n    def calcEquation(self, equations, values, queries):\n        \"\"\"\n        :type equations: List[List[str]]\n        :type values: List[float]\n        :type queries: List[List[str]]\n        :rtype: List[float]\n        \"\"\"\n        adj = collections.defaultdict(dict)\n        for (a, b), k in itertools.izip(equations, values):\n            adj[a][b] = k\n            adj[b][a] = 1.0/k\n\n        def bfs(adj, a, b, lookup):\n            if a not in adj or b not in adj:\n                return -1.0\n            if (a, b) in lookup:\n                return lookup[a, b]\n            visited = {a}\n            q = collections.deque([(a, 1.0)])\n            while q:\n                u, val = q.popleft()\n                if u == b:\n                    lookup[a, b] = val\n                    return val\n                for v, k in adj[u].iteritems():\n                    if v in visited:\n                        continue                    \n                    visited.add(v)\n                    q.append((v, val*k))\n            lookup[a, b] = -1.0\n            return -1.0\n\n        lookup = {}\n        return [bfs(adj, a, b, lookup) for a, b in queries]\n\n\nimport collections\nimport itertools\n\n\n# variant of floyd–warshall algorithm solutionclass Solution3(object):\n    def calcEquation(self, equations, values, queries):\n        \"\"\"\n        :type equations: List[List[str]]\n        :type values: List[float]\n        :type queries: List[List[str]]\n        :rtype: List[float]\n        \"\"\"\n        adj = collections.defaultdict(dict)\n        for (a, b), k in itertools.izip(equations, values):\n            adj[a][a] = adj[b][b] = 1.0\n            adj[a][b] = k\n            adj[b][a] = 1.0/k\n        for k in adj:\n            for i in adj[k]:\n                for j in adj[k]:\n                    adj[i][j] = adj[i][k]*adj[k][j]\n        return [adj[a].get(b, -1.0) for a, b in queries]\n\n    \nimport collections\n\nclass Solution4(object):\n    def calcEquation(self, equations, values, query):\n        \"\"\"\n        :type equations: List[List[str]]\n        :type values: List[float]\n        :type query: List[List[str]]\n        :rtype: List[float]\n        \"\"\"\n        def check(up, down, lookup, visited):\n            if up in lookup and down in lookup[up]:\n                return (True, lookup[up][down])\n            for k, v in lookup[up].iteritems():\n                if k not in visited:\n                    visited.add(k)\n                    tmp = check(k, down, lookup, visited)\n                    if tmp[0]:\n                        return (True, v * tmp[1])\n            return (False, 0)\n\n        lookup = collections.defaultdict(dict)\n        for i, e in enumerate(equations):\n            lookup[e[0]][e[1]] = values[i]\n            if values[i]:\n                lookup[e[1]][e[0]] = 1.0 / values[i]\n\n        result = []\n        for q in query:\n            visited = set()\n            tmp = check(q[0], q[1], lookup, visited)\n            result.append(tmp[1] if tmp[0] else -1)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(e + q * n), at most O(n^3 + q)",
      "space_complexity": "O(e)"
    }
  ],
  "Microsoft": [
    {
      "title": "Two Sum",
      "difficulty": "EASY",
      "category": "Array, Hash Table",
      "link": "https://leetcode.com/problems/two-sum",
      "slug": "two-sum",
      "description": "Given an array of integers \nnums\n and an integer \ntarget\n, return \nindices of the two numbers such that they add up to \ntarget\n.\n\n\nYou may assume that each input would have \nexactly\n one solution\n, and you may not use the \nsame\n element twice.\n\n\nYou can return the answer in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,7,11,15], target = 9\n\nOutput:\n [0,1]\n\nExplanation:\n Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,4], target = 6\n\nOutput:\n [1,2]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,3], target = 6\n\nOutput:\n [0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n-10\n9\n <= target <= 10\n9\n\n\nOnly one valid answer exists.\n\n\n\n\n \n\n\nFollow-up: \nCan you come up with an algorithm that is less than \nO(n\n2\n)\n \ntime complexity?",
      "solution": "from typing import List\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n\n        for idx in range(len(nums)):\n            val = target - nums[idx]\n            if val in seen:\n                return [idx, seen[val]]\n            else:\n                seen[nums[idx]] = idx",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Longest Substring Without Repeating Characters",
      "difficulty": "MEDIUM",
      "category": "Hash Table, String, Sliding Window",
      "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters",
      "slug": "longest-substring-without-repeating-characters",
      "description": "Given a string \ns\n, find the length of the \nlongest\n \nsubstring\n without duplicate characters.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abcabcbb\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"abc\", with the length of 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"bbbbb\"\n\nOutput:\n 1\n\nExplanation:\n The answer is \"b\", with the length of 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"pwwkew\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 5 * 10\n4\n\n\ns\n consists of English letters, digits, symbols and spaces.",
      "solution": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, left = 0, 0\n        lookup = {}\n        for right in xrange(len(s)):\n            if s[right] in lookup:\n                left = max(left, lookup[s[right]]+1)\n            lookup[s[right]] = right\n            result = max(result, right-left+1)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Longest Palindromic Substring",
      "difficulty": "MEDIUM",
      "category": "Two Pointers, String, Dynamic Programming",
      "link": "https://leetcode.com/problems/longest-palindromic-substring",
      "slug": "longest-palindromic-substring",
      "description": "Given a string \ns\n, return \nthe longest\n \npalindromic\n \nsubstring\n in \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"babad\"\n\nOutput:\n \"bab\"\n\nExplanation:\n \"aba\" is also a valid answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"cbbd\"\n\nOutput:\n \"bb\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consist of only digits and English letters.",
      "solution": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def preProcess(s):\n            if not s:\n                return ['^', '$']\n            T = ['^']\n            for c in s:\n                T +=  ['#', c]\n            T += ['#', '$']\n            return T\n\n        T = preProcess(s)\n        P = [0] * len(T)\n        center, right = 0, 0\n        for i in xrange(1, len(T) - 1):\n            i_mirror = 2 * center - i\n            if right > i:\n                P[i] = min(right - i, P[i_mirror])\n            else:\n                P[i] = 0\n\n            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:\n                P[i] += 1\n\n            if i + P[i] > right:\n                center, right = i, i + P[i]\n\n        max_i = 0\n        for i in xrange(1, len(T) - 1):\n            if P[i] > P[max_i]:\n                max_i = i\n        start = (max_i - 1 - P[max_i]) // 2\n        return s[start : start + P[max_i]]\n\nclass Solution2(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return (right-left+1)-2\n        \n        left, right = -1, -2\n        for i in xrange(len(s)):\n            l = max(expand(s, i, i), expand(s, i, i+1))\n            if l > right-left+1:\n                right = i+l//2\n                left = right-l+1\n        return s[left:right+1] if left >= 0 else \"\"",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Median of Two Sorted Arrays",
      "difficulty": "HARD",
      "category": "Array, Binary Search, Divide and Conquer",
      "link": "https://leetcode.com/problems/median-of-two-sorted-arrays",
      "slug": "median-of-two-sorted-arrays",
      "description": "Given two sorted arrays \nnums1\n and \nnums2\n of size \nm\n and \nn\n respectively, return \nthe median\n of the two sorted arrays.\n\n\nThe overall run time complexity should be \nO(log (m+n))\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,3], nums2 = [2]\n\nOutput:\n 2.00000\n\nExplanation:\n merged array = [1,2,3] and median is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1,2], nums2 = [3,4]\n\nOutput:\n 2.50000\n\nExplanation:\n merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m\n\n\nnums2.length == n\n\n\n0 <= m <= 1000\n\n\n0 <= n <= 1000\n\n\n1 <= m + n <= 2000\n\n\n-10\n6\n <= nums1[i], nums2[i] <= 10\n6",
      "solution": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(A, B, k):\n            m, n = len(A), len(B)\n            if m > n:\n                m, n = n, m\n                A, B = B, A\n            i = binary_search(max(k-n, 0), min(m, k)-1, lambda i: A[i] >= B[k-1-i])\n            return max(A[i-1] if i-1 >= 0 else float(\"-inf\"), B[k-1-i] if k-1-i >= 0 else float(\"-inf\"))\n\n        len1, len2 = len(nums1), len(nums2)\n        if (len1+len2) % 2 == 1:\n            return getKth(nums1, nums2, (len1+len2)//2+1)\n        else:\n            return (getKth(nums1, nums2, (len1+len2)//2)+getKth(nums1, nums2, (len1+len2)//2+1))*0.5    \n\n\n# Generic solution.class Solution_Generic(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(arrays, k):\n            def check(num):\n                # count the number of values which are less or equal to num\n                return sum(binary_search(0, len(arr)-1, lambda x: arr[x] > num) for arr in arrays) >= k\n    \n            return binary_search(min(arr[0] for arr in arrays if arr), max(arr[-1] for arr in arrays if arr), check)\n\n        array = [nums1, nums2]\n        total = sum(len(nums) for nums in array)\n        if total % 2 == 1:\n            return getKth(array, total//2+1)\n        else:\n            return (getKth(array, total//2)+getKth(array, total//2+1))*0.5",
      "explanation": "N/A",
      "time_complexity": "O(log(max(m, n)) * log(max_val - min_val))",
      "space_complexity": "O(1)"
    },
    {
      "title": "Search in Rotated Sorted Array",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/search-in-rotated-sorted-array",
      "slug": "search-in-rotated-sorted-array",
      "description": "There is an integer array \nnums\n sorted in ascending order (with \ndistinct\n values).\n\n\nPrior to being passed to your function, \nnums\n is \npossibly rotated\n at an unknown pivot index \nk\n (\n1 <= k < nums.length\n) such that the resulting array is \n[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]\n (\n0-indexed\n). For example, \n[0,1,2,4,5,6,7]\n might be rotated at pivot index \n3\n and become \n[4,5,6,7,0,1,2]\n.\n\n\nGiven the array \nnums\n \nafter\n the possible rotation and an integer \ntarget\n, return \nthe index of \ntarget\n if it is in \nnums\n, or \n-1\n if it is not in \nnums\n.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [4,5,6,7,0,1,2], target = 0\n\nOutput:\n 4\n\nExample 2:\n\n\nInput:\n nums = [4,5,6,7,0,1,2], target = 3\n\nOutput:\n -1\n\nExample 3:\n\n\nInput:\n nums = [1], target = 0\n\nOutput:\n -1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 5000\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nAll values of \nnums\n are \nunique\n.\n\n\nnums\n is an ascending array that is possibly rotated.\n\n\n-10\n4\n <= target <= 10\n4",
      "solution": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) / 2\n\n            if nums[mid] == target:\n                return mid\n            elif (nums[mid] >= nums[left] and nums[left] <= target < nums[mid]) or \\\n                 (nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])):\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return -1",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Container With Most Water",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers, Greedy",
      "link": "https://leetcode.com/problems/container-with-most-water",
      "slug": "container-with-most-water",
      "description": "You are given an integer array \nheight\n of length \nn\n. There are \nn\n vertical lines drawn such that the two endpoints of the \ni\nth\n line are \n(i, 0)\n and \n(i, height[i])\n.\n\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\n\nReturn \nthe maximum amount of water a container can store\n.\n\n\nNotice\n that you may not slant the container.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [1,8,6,2,5,4,8,3,7]\n\nOutput:\n 49\n\nExplanation:\n The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [1,1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= height[i] <= 10\n4",
      "solution": "class Solution(object):\n    # @return an integer\n    def maxArea(self, height):\n        max_area, i, j = 0, 0, len(height) - 1\n        while i < j:\n            max_area = max(max_area, min(height[i], height[j]) * (j - i))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return max_area",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Group Anagrams",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, String, Sorting",
      "link": "https://leetcode.com/problems/group-anagrams",
      "slug": "group-anagrams",
      "description": "Given an array of strings \nstrs\n, group the \nanagrams\n together. You can return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nstrs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n\n\nOutput:\n \n[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\n\nExplanation:\n\n\n\n\nThere is no string in strs that can be rearranged to form \n\"bat\"\n.\n\n\nThe strings \n\"nat\"\n and \n\"tan\"\n are anagrams as they can be rearranged to form each other.\n\n\nThe strings \n\"ate\"\n, \n\"eat\"\n, and \n\"tea\"\n are anagrams as they can be rearranged to form each other.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nstrs = [\"\"]\n\n\nOutput:\n \n[[\"\"]]\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nstrs = [\"a\"]\n\n\nOutput:\n \n[[\"a\"]]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 10\n4\n\n\n0 <= strs[i].length <= 100\n\n\nstrs[i]\n consists of lowercase English letters.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagrams_map, result = collections.defaultdict(list), []\n        for s in strs:\n            sorted_str = (\"\").join(sorted(s))\n            anagrams_map[sorted_str].append(s)\n        for anagram in anagrams_map.values():\n            anagram.sort()\n            result.append(anagram)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n * glogg), g is the max size of groups.",
      "space_complexity": "O(n)"
    },
    {
      "title": "Minimum Edge Reversals So Every Node Is Reachable",
      "difficulty": "HARD",
      "category": "Dynamic Programming, Depth-First Search, Breadth-First Search, Graph",
      "link": "https://leetcode.com/problems/minimum-edge-reversals-so-every-node-is-reachable",
      "slug": "minimum-edge-reversals-so-every-node-is-reachable",
      "description": "There is a \nsimple directed graph\n with \nn\n nodes labeled from \n0\n to \nn - 1\n. The graph would form a \ntree\n if its edges were bi-directional.\n\n\nYou are given an integer \nn\n and a \n2D\n integer array \nedges\n, where \nedges[i] = [u\ni\n, v\ni\n]\n represents a \ndirected edge\n going from node \nu\ni\n to node \nv\ni\n.\n\n\nAn \nedge reversal\n changes the direction of an edge, i.e., a directed edge going from node \nu\ni\n to node \nv\ni\n becomes a directed edge going from node \nv\ni\n to node \nu\ni\n.\n\n\nFor every node \ni\n in the range \n[0, n - 1]\n, your task is to \nindependently\n calculate the \nminimum\n number of \nedge reversals\n required so it is possible to reach any other node starting from node \ni\n through a \nsequence\n of \ndirected edges\n.\n\n\nReturn \nan integer array \nanswer\n, where \nanswer[i]\n is the\n \n \nminimum\n number of \nedge reversals\n required so it is possible to reach any other node starting from node \ni\n through a \nsequence\n of \ndirected edges\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[2,0],[2,1],[1,3]]\n\nOutput:\n [1,1,0,2]\n\nExplanation:\n The image above shows the graph formed by the edges.\nFor node 0: after reversing the edge [2,0], it is possible to reach any other node starting from node 0.\nSo, answer[0] = 1.\nFor node 1: after reversing the edge [2,1], it is possible to reach any other node starting from node 1.\nSo, answer[1] = 1.\nFor node 2: it is already possible to reach any other node starting from node 2.\nSo, answer[2] = 0.\nFor node 3: after reversing the edges [1,3] and [2,1], it is possible to reach any other node starting from node 3.\nSo, answer[3] = 2.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 3, edges = [[1,2],[2,0]]\n\nOutput:\n [2,0,1]\n\nExplanation:\n The image above shows the graph formed by the edges.\nFor node 0: after reversing the edges [2,0] and [1,2], it is possible to reach any other node starting from node 0.\nSo, answer[0] = 2.\nFor node 1: it is already possible to reach any other node starting from node 1.\nSo, answer[1] = 0.\nFor node 2: after reversing the edge [1, 2], it is possible to reach any other node starting from node 2.\nSo, answer[2] = 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= u\ni\n == edges[i][0] < n\n\n\n0 <= v\ni\n == edges[i][1] < n\n\n\nu\ni\n != v\ni\n\n\nThe input is generated such that if the edges were bi-directional, the graph would be a tree.",
      "solution": "\n# iterative dfs, tree dpclass Solution(object):\n    def minEdgeReversals(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def iter_dfs1():\n            result = 0\n            stk = [(0, -1)]\n            while stk:\n                u, p = stk.pop()\n                for v in adj[u].iterkeys():\n                    if v == p:\n                        continue\n                    result += adj[u][v]\n                    stk.append((v, u))\n            return result\n\n        def iter_dfs2(curr):\n            result = [-1]*n\n            stk = [(0, curr)]\n            while stk:\n                u, curr = stk.pop()\n                result[u] = curr\n                for v in adj[u].iterkeys():\n                    if result[v] == -1:\n                        stk.append((v, curr-adj[u][v]+adj[v][u]))\n            return result\n    \n        adj = collections.defaultdict(dict)\n        for u, v in edges:\n            adj[u][v] = 0\n            adj[v][u] = 1\n        return iter_dfs2(iter_dfs1())\n        \n\n# dfs, tree dpclass Solution2(object):\n    def minEdgeReversals(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def dfs1(u, p):\n            return sum(adj[u][v]+dfs1(v, u) for v in adj[u] if v != p)\n\n        def dfs2(u, curr):\n            result[u] = curr\n            for v in adj[u]:\n                if result[v] == -1:\n                    dfs2(v, curr-adj[u][v]+adj[v][u])\n    \n        adj = collections.defaultdict(dict)\n        for u, v in edges:\n            adj[u][v] = 0\n            adj[v][u] = 1\n        result = [-1]*n\n        dfs2(0, dfs1(0, -1))\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Roman to Integer",
      "difficulty": "EASY",
      "category": "Hash Table, Math, String",
      "link": "https://leetcode.com/problems/roman-to-integer",
      "slug": "roman-to-integer",
      "description": "Roman numerals are represented by seven different symbols: \nI\n, \nV\n, \nX\n, \nL\n, \nC\n, \nD\n and \nM\n.\n\n\n\n\nSymbol\n       \nValue\n\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\n\nFor example, \n2\n is written as \nII\n in Roman numeral, just two ones added together. \n12\n is written as \nXII\n, which is simply \nX + II\n. The number \n27\n is written as \nXXVII\n, which is \nXX + V + II\n.\n\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not \nIIII\n. Instead, the number four is written as \nIV\n. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as \nIX\n. There are six instances where subtraction is used:\n\n\n\n\nI\n can be placed before \nV\n (5) and \nX\n (10) to make 4 and 9. \n\n\nX\n can be placed before \nL\n (50) and \nC\n (100) to make 40 and 90. \n\n\nC\n can be placed before \nD\n (500) and \nM\n (1000) to make 400 and 900.\n\n\n\n\nGiven a roman numeral, convert it to an integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"III\"\n\nOutput:\n 3\n\nExplanation:\n III = 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"LVIII\"\n\nOutput:\n 58\n\nExplanation:\n L = 50, V= 5, III = 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"MCMXCIV\"\n\nOutput:\n 1994\n\nExplanation:\n M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 15\n\n\ns\n contains only the characters \n('I', 'V', 'X', 'L', 'C', 'D', 'M')\n.\n\n\nIt is \nguaranteed\n that \ns\n is a valid roman numeral in the range \n[1, 3999]\n.",
      "solution": "class Solution(object):\n    # @return an integer\n    def romanToInt(self, s):\n        numeral_map = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\":100, \"D\": 500, \"M\": 1000}\n        decimal = 0\n        for i in xrange(len(s)):\n            if i > 0 and numeral_map[s[i]] > numeral_map[s[i - 1]]:\n                decimal += numeral_map[s[i]] - 2 * numeral_map[s[i - 1]]\n            else:\n                decimal += numeral_map[s[i]]\n        return decimal",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Find Peak Element",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/find-peak-element",
      "slug": "find-peak-element",
      "description": "A peak element is an element that is strictly greater than its neighbors.\n\n\nGiven a \n0-indexed\n integer array \nnums\n, find a peak element, and return its index. If the array contains multiple peaks, return the index to \nany of the peaks\n.\n\n\nYou may imagine that \nnums[-1] = nums[n] = -∞\n. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\n\nYou must write an algorithm that runs in \nO(log n)\n time.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,1]\n\nOutput:\n 2\n\nExplanation:\n 3 is a peak element and your function should return the index number 2.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,1,3,5,6,4]\n\nOutput:\n 5\n\nExplanation:\n Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\nnums[i] != nums[i + 1]\n for all valid \ni\n.",
      "solution": "class Solution(object):\n    def findPeakElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            mid = left + (right - left) / 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Climbing Stairs",
      "difficulty": "EASY",
      "category": "Math, Dynamic Programming, Memoization",
      "link": "https://leetcode.com/problems/climbing-stairs",
      "slug": "climbing-stairs",
      "description": "You are climbing a staircase. It takes \nn\n steps to reach the top.\n\n\nEach time you can either climb \n1\n or \n2\n steps. In how many distinct ways can you climb to the top?\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 2\n\nExplanation:\n There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 3\n\nExplanation:\n There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 45",
      "solution": "\nimport itertools\n\nclass Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def matrix_expo(A, K):\n            result = [[int(i==j) for j in xrange(len(A))] \\\n                      for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b for a, b in itertools.izip(row, col)) \\\n                     for col in ZB] for row in A]\n\n        T = [[1, 1],\n             [1, 0]]\n        return matrix_mult([[1,  0]], matrix_expo(T, n))[0][0]  # [a0, a(-1)] * T^n\n\nclass Solution2(object):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    def climbStairs(self, n):\n        prev, current = 0, 1\n        for i in xrange(n):\n            prev, current = current, prev + current,\n        return current",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Best Time to Buy and Sell Stock",
      "difficulty": "EASY",
      "category": "Array, Dynamic Programming",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
      "slug": "best-time-to-buy-and-sell-stock",
      "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nYou want to maximize your profit by choosing a \nsingle day\n to buy one stock and choosing a \ndifferent day in the future\n to sell that stock.\n\n\nReturn \nthe maximum profit you can achieve from this transaction\n. If you cannot achieve any profit, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 5\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transactions are done and the max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n4",
      "solution": "class Solution:\n    def maxProfit(self, prices) -> int:\n        profit = 0\n        buy = prices[0]\n\n        for price in range(1, len(prices)):\n            profit = max(profit, prices[price] - buy)\n            buy = min(prices[price], buy)\n\n        return profit",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Move Zeroes",
      "difficulty": "EASY",
      "category": "Array, Two Pointers",
      "link": "https://leetcode.com/problems/move-zeroes",
      "slug": "move-zeroes",
      "description": "Given an integer array \nnums\n, move all \n0\n's to the end of it while maintaining the relative order of the non-zero elements.\n\n\nNote\n that you must do this in-place without making a copy of the array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [0,1,0,3,12]\n\nOutput:\n [1,3,12,0,0]\n\nExample 2:\n\n\nInput:\n nums = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you minimize the total number of operations done?",
      "solution": "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i]:\n                nums[i], nums[pos] = nums[pos], nums[i]\n                pos += 1\n\n    def moveZeroes2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort(cmp=lambda a, b: 0 if b else -1)\n\nclass Solution2(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i]:\n                nums[pos] = nums[i]\n                pos += 1\n\n        for i in xrange(pos, len(nums)):\n            nums[i] = 0",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Largest Rectangle in Histogram",
      "difficulty": "HARD",
      "category": "Array, Stack, Monotonic Stack",
      "link": "https://leetcode.com/problems/largest-rectangle-in-histogram",
      "slug": "largest-rectangle-in-histogram",
      "description": "Given an array of integers \nheights\n representing the histogram's bar height where the width of each bar is \n1\n, return \nthe area of the largest rectangle in the histogram\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [2,1,5,6,2,3]\n\nOutput:\n 10\n\nExplanation:\n The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n heights = [2,4]\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= heights.length <= 10\n5\n\n\n0 <= heights[i] <= 10\n4",
      "solution": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stk, result = [-1], 0\n        for i in xrange(len(heights)+1):\n            while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):\n                result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))\n            stk.append(i) \n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "K-th Smallest in Lexicographical Order",
      "difficulty": "HARD",
      "category": "Trie",
      "link": "https://leetcode.com/problems/k-th-smallest-in-lexicographical-order",
      "slug": "k-th-smallest-in-lexicographical-order",
      "description": "Given two integers \nn\n and \nk\n, return \nthe\n \nk\nth\n \nlexicographically smallest integer in the range\n \n[1, n]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 13, k = 2\n\nOutput:\n 10\n\nExplanation:\n The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1, k = 1\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= n <= 10\n9",
      "solution": "class Solution(object):\n    def findKthNumber(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n\n        cnts = [0] * 10\n        for i in xrange(1, 10):\n            cnts[i] = cnts[i - 1] * 10 + 1\n\n        nums = []\n        i = n\n        while i:\n            nums.append(i % 10)\n            i /= 10\n\n        total, target = n, 0\n        i = len(nums) - 1\n        while i >= 0 and k > 0:\n            target = target*10 + nums[i]\n            start = int(i == len(nums)-1)\n            for j in xrange(start, 10):\n                candidate = result*10 + j\n                if candidate < target:\n                    num = cnts[i+1]\n                elif candidate > target:\n                    num = cnts[i]\n                else:\n                    num = total - cnts[i + 1]*(j-start) - cnts[i]*(9-j)\n                if k > num:\n                    k -= num\n                else:\n                    result = candidate\n                    k -= 1\n                    total = num-1\n                    break\n            i -= 1\n\n        return result\n\nclass Solution2(object):\n    def findKthNumber(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def count(n, prefix):\n            result, number = 0, 1\n            while prefix <= n:\n                result += number\n                prefix *= 10\n                number *= 10\n            result -= max(number/10 - (n - prefix/10 + 1), 0)\n            return result\n\n        def findKthNumberHelper(n, k, cur, index):\n            if cur:\n                index += 1\n                if index == k:\n                    return (cur, index)\n\n            i = int(cur == 0)\n            while i <= 9:\n                cur = cur * 10 + i\n                cnt = count(n, cur)\n                if k > cnt + index:\n                    index += cnt\n                elif cur <= n:\n                    result = findKthNumberHelper(n, k, cur, index)\n                    if result[0]:\n                        return result\n                i += 1\n                cur /= 10\n            return (0, index)\n\n        return findKthNumberHelper(n, k, 0, 0)[0]",
      "explanation": "N/A",
      "time_complexity": "O(logn * logn)",
      "space_complexity": "O(logn)"
    },
    {
      "title": "Jump Game II",
      "difficulty": "MEDIUM",
      "category": "Array, Dynamic Programming, Greedy",
      "link": "https://leetcode.com/problems/jump-game-ii",
      "slug": "jump-game-ii",
      "description": "You are given a \n0-indexed\n array of integers \nnums\n of length \nn\n. You are initially positioned at \nnums[0]\n.\n\n\nEach element \nnums[i]\n represents the maximum length of a forward jump from index \ni\n. In other words, if you are at \nnums[i]\n, you can jump to any \nnums[i + j]\n where:\n\n\n\n\n0 <= j <= nums[i]\n and\n\n\ni + j < n\n\n\n\n\nReturn \nthe minimum number of jumps to reach \nnums[n - 1]\n. The test cases are generated such that you can reach \nnums[n - 1]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,3,1,1,4]\n\nOutput:\n 2\n\nExplanation:\n The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,3,0,1,4]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n0 <= nums[i] <= 1000\n\n\nIt's guaranteed that you can reach \nnums[n - 1]\n.",
      "solution": "class Solution(object):\n    # @param A, a list of integers\n    # @return an integer\n    def jump(self, A):\n        jump_count = 0\n        reachable = 0\n        curr_reachable = 0\n        for i, length in enumerate(A):\n            if i > reachable:\n                return -1\n            if i > curr_reachable:\n                curr_reachable = reachable\n                jump_count += 1\n            reachable = max(reachable, i + length)\n        return jump_count",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Max Consecutive Ones",
      "difficulty": "EASY",
      "category": "Array",
      "link": "https://leetcode.com/problems/max-consecutive-ones",
      "slug": "max-consecutive-ones",
      "description": "Given a binary array \nnums\n, return \nthe maximum number of consecutive \n1\n's in the array\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,0,1,1,1]\n\nOutput:\n 3\n\nExplanation:\n The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,0,1,1,0,1]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\nnums[i]\n is either \n0\n or \n1\n.",
      "solution": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, local_max = 0, 0\n        for n in nums:\n            local_max = (local_max + 1 if n else 0)\n            result = max(result, local_max)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Minimum Size Subarray Sum",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search, Sliding Window, Prefix Sum",
      "link": "https://leetcode.com/problems/minimum-size-subarray-sum",
      "slug": "minimum-size-subarray-sum",
      "description": "Given an array of positive integers \nnums\n and a positive integer \ntarget\n, return \nthe \nminimal length\n of a \nsubarray\n whose sum is greater than or equal to\n \ntarget\n. If there is no such subarray, return \n0\n instead.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n target = 7, nums = [2,3,1,2,4,3]\n\nOutput:\n 2\n\nExplanation:\n The subarray [4,3] has the minimal length under the problem constraint.\n\n\n\nExample 2:\n\n\n\n\nInput:\n target = 4, nums = [1,4,4]\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\nInput:\n target = 11, nums = [1,1,1,1,1,1,1,1]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= target <= 10\n9\n\n\n1 <= nums.length <= 10\n5\n\n\n1 <= nums[i] <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n If you have figured out the \nO(n)\n solution, try coding another solution of which the time complexity is \nO(n log(n))\n.",
      "solution": "class Solution(object):\n    # @param {integer} s\n    # @param {integer[]} nums\n    # @return {integer}\n    def minSubArrayLen(self, s, nums):\n        start = 0\n        sum = 0\n        min_size = float(\"inf\")\n        for i in xrange(len(nums)):\n            sum += nums[i]\n            while sum >= s:\n                min_size = min(min_size, i - start + 1)\n                sum -= nums[start]\n                start += 1\n\n        return min_size if min_size != float(\"inf\") else 0\n\n# Binary search solution.class Solution2(object):\n    # @param {integer} s\n    # @param {integer[]} nums\n    # @return {integer}\n    def minSubArrayLen(self, s, nums):\n        min_size = float(\"inf\")\n        sum_from_start = [n for n in nums]\n        for i in xrange(len(sum_from_start) - 1):\n            sum_from_start[i + 1] += sum_from_start[i]\n        for i in xrange(len(sum_from_start)):\n            end = self.binarySearch(lambda x, y: x <= y, sum_from_start, \\\n                                    i, len(sum_from_start), \\\n                                    sum_from_start[i] - nums[i] + s)\n            if end < len(sum_from_start):\n                min_size = min(min_size, end - i + 1)\n\n        return min_size if min_size != float(\"inf\") else 0\n\n    def binarySearch(self, compare, A, start, end, target):\n        while start < end:\n            mid = start + (end - start) / 2\n            if compare(target, A[mid]):\n                end = mid\n            else:\n                start = mid + 1\n        return start",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Gas Station",
      "difficulty": "MEDIUM",
      "category": "Array, Greedy",
      "link": "https://leetcode.com/problems/gas-station",
      "slug": "gas-station",
      "description": "There are \nn\n gas stations along a circular route, where the amount of gas at the \ni\nth\n station is \ngas[i]\n.\n\n\nYou have a car with an unlimited gas tank and it costs \ncost[i]\n of gas to travel from the \ni\nth\n station to its next \n(i + 1)\nth\n station. You begin the journey with an empty tank at one of the gas stations.\n\n\nGiven two integer arrays \ngas\n and \ncost\n, return \nthe starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return\n \n-1\n. If there exists a solution, it is \nguaranteed\n to be \nunique\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n\nOutput:\n 3\n\nExplanation:\n\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n\n\n\nExample 2:\n\n\n\n\nInput:\n gas = [2,3,4], cost = [3,4,3]\n\nOutput:\n -1\n\nExplanation:\n\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == gas.length == cost.length\n\n\n1 <= n <= 10\n5\n\n\n0 <= gas[i], cost[i] <= 10\n4\n\n\nThe input is generated such that the answer is unique.",
      "solution": "class Solution(object):\n    # @param gas, a list of integers\n    # @param cost, a list of integers\n    # @return an integer\n    def canCompleteCircuit(self, gas, cost):\n        start, total_sum, current_sum = 0, 0, 0\n        for i in xrange(len(gas)):\n            diff = gas[i] - cost[i]\n            current_sum += diff\n            total_sum += diff\n            if current_sum < 0:\n                start = i + 1\n                current_sum = 0\n        if total_sum >= 0:\n            return start\n\n        return -1",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Split Array Largest Sum",
      "difficulty": "HARD",
      "category": "Array, Binary Search, Dynamic Programming, Greedy, Prefix Sum",
      "link": "https://leetcode.com/problems/split-array-largest-sum",
      "slug": "split-array-largest-sum",
      "description": "Given an integer array \nnums\n and an integer \nk\n, split \nnums\n into \nk\n non-empty subarrays such that the largest sum of any subarray is \nminimized\n.\n\n\nReturn \nthe minimized largest sum of the split\n.\n\n\nA \nsubarray\n is a contiguous part of the array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [7,2,5,10,8], k = 2\n\nOutput:\n 18\n\nExplanation:\n There are four ways to split nums into two subarrays.\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,3,4,5], k = 2\n\nOutput:\n 9\n\nExplanation:\n There are four ways to split nums into two subarrays.\nThe best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n0 <= nums[i] <= 10\n6\n\n\n1 <= k <= min(50, nums.length)",
      "solution": "class Solution(object):\n    def splitArray(self, nums, m):\n        \"\"\"\n        :type nums: List[int]\n        :type m: int\n        :rtype: int\n        \"\"\"\n        def check(nums, m, s):\n            cnt, curr_sum = 1, 0\n            for num in nums:\n                curr_sum += num\n                if curr_sum > s:\n                    curr_sum = num\n                    cnt += 1\n            return cnt <= m\n\n        left, right = max(nums), sum(nums)\n        while left <= right:\n            mid = left + (right - left) // 2\n            if check(nums, m, mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left",
      "explanation": "N/A",
      "time_complexity": "O(nlogs), s is the sum of nums",
      "space_complexity": "O(1)"
    },
    {
      "title": "Subarray Sum Equals K",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Prefix Sum",
      "link": "https://leetcode.com/problems/subarray-sum-equals-k",
      "slug": "subarray-sum-equals-k",
      "description": "Given an array of integers \nnums\n and an integer \nk\n, return \nthe total number of subarrays whose sum equals to\n \nk\n.\n\n\nA subarray is a contiguous \nnon-empty\n sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,1,1], k = 2\n\nOutput:\n 2\n\nExample 2:\n\n\nInput:\n nums = [1,2,3], k = 3\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2 * 10\n4\n\n\n-1000 <= nums[i] <= 1000\n\n\n-10\n7\n <= k <= 10\n7",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def subarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        accumulated_sum = 0\n        lookup = collections.defaultdict(int)\n        lookup[0] += 1\n        for num in nums:\n            accumulated_sum += num\n            result += lookup[accumulated_sum - k]\n            lookup[accumulated_sum] += 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Contains Duplicate",
      "difficulty": "EASY",
      "category": "Array, Hash Table, Sorting",
      "link": "https://leetcode.com/problems/contains-duplicate",
      "slug": "contains-duplicate",
      "description": "Given an integer array \nnums\n, return \ntrue\n if any value appears \nat least twice\n in the array, and return \nfalse\n if every element is distinct.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,3,1]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThe element 1 occurs at the indices 0 and 3.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,2,3,4]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nAll elements are distinct.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,1,1,3,3,4,3,2,4,2]\n\n\nOutput:\n \ntrue\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9",
      "solution": "class Solution(object):\n    # @param {integer[]} nums\n    # @return {boolean}\n    def containsDuplicate(self, nums):\n        return len(nums) > len(set(nums))",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Minimum Operations to Reduce an Integer to 0",
      "difficulty": "MEDIUM",
      "category": "Dynamic Programming, Greedy, Bit Manipulation",
      "link": "https://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0",
      "slug": "minimum-operations-to-reduce-an-integer-to-0",
      "description": "You are given a positive integer \nn\n, you can do the following operation \nany\n number of times:\n\n\n\n\nAdd or subtract a \npower\n of \n2\n from \nn\n.\n\n\n\n\nReturn \nthe \nminimum\n number of operations to make \nn\n equal to \n0\n.\n\n\nA number \nx\n is power of \n2\n if \nx == 2\ni\n where \ni >= 0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 39\n\nOutput:\n 3\n\nExplanation:\n We can do the following operations:\n- Add 2\n0\n = 1 to n, so now n = 40.\n- Subtract 2\n3\n = 8 from n, so now n = 32.\n- Subtract 2\n5\n = 32 from n, so now n = 0.\nIt can be shown that 3 is the minimum number of operations we need to make n equal to 0.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 54\n\nOutput:\n 3\n\nExplanation:\n We can do the following operations:\n- Add 2\n1\n = 2 to n, so now n = 56.\n- Add 2\n3\n = 8 to n, so now n = 64.\n- Subtract 2\n6\n = 64 from n, so now n = 0.\nSo the minimum number of operations is 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5",
      "solution": "\n# greedy, trick\n# reference: https://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3203994/java-c-python-1-line-solution/class Solution(object):\n    def minOperations(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def popcount(x):\n            return bin(x)[2:].count('1')\n\n        return popcount(n^(n*0b11))\n\n\n# greedyclass Solution2(object):\n    def minOperations(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while n:\n            if n&1:\n                n >>= 1\n                n += n&1\n                result += 1\n            n >>= 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Frequency of the Most Frequent Element",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search, Greedy, Sliding Window, Sorting, Prefix Sum",
      "link": "https://leetcode.com/problems/frequency-of-the-most-frequent-element",
      "slug": "frequency-of-the-most-frequent-element",
      "description": "The \nfrequency\n of an element is the number of times it occurs in an array.\n\n\nYou are given an integer array \nnums\n and an integer \nk\n. In one operation, you can choose an index of \nnums\n and increment the element at that index by \n1\n.\n\n\nReturn \nthe \nmaximum possible frequency\n of an element after performing \nat most\n \nk\n operations\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,4], k = 5\n\nOutput:\n 3\n\nExplanation:\n Increment the first element three times and the second element two times to make nums = [4,4,4].\n4 has a frequency of 3.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,4,8,13], k = 5\n\nOutput:\n 2\n\nExplanation:\n There are multiple optimal solutions:\n- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.\n- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.\n- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,9,6], k = 2\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n1 <= nums[i] <= 10\n5\n\n\n1 <= k <= 10\n5",
      "solution": "class Solution(object):\n    def maxFrequency(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        left = 0\n        nums.sort()\n        for right in xrange(len(nums)):\n            k += nums[right]\n            if k < nums[right]*(right-left+1):\n                k -= nums[left]\n                left += 1\n        return right-left+1",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Reverse Nodes in k-Group",
      "difficulty": "HARD",
      "category": "Linked List, Recursion",
      "link": "https://leetcode.com/problems/reverse-nodes-in-k-group",
      "slug": "reverse-nodes-in-k-group",
      "description": "Given the \nhead\n of a linked list, reverse the nodes of the list \nk\n at a time, and return \nthe modified list\n.\n\n\nk\n is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of \nk\n then left-out nodes, in the end, should remain as it is.\n\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 2\n\nOutput:\n [2,1,4,3,5]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 3\n\nOutput:\n [3,2,1,4,5]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is \nn\n.\n\n\n1 <= k <= n <= 5000\n\n\n0 <= Node.val <= 1000\n\n\n\n\n \n\n\nFollow-up:\n Can you solve the problem in \nO(1)\n extra memory space?",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\nclass Solution(object):\n    # @param head, a ListNode\n    # @param k, an integer\n    # @return a ListNode\n    def reverseKGroup(self, head, k):\n        dummy = ListNode(-1)\n        dummy.next = head\n\n        cur, cur_dummy = head, dummy\n        length = 0\n\n        while cur:\n            next_cur = cur.next\n            length = (length + 1) % k\n\n            if length == 0:\n                next_dummy = cur_dummy.next\n                self.reverse(cur_dummy, cur.next)\n                cur_dummy = next_dummy\n\n            cur = next_cur\n\n        return dummy.next\n\n    def reverse(self, begin, end):\n            first = begin.next\n            cur = first.next\n\n            while cur != end:\n                first.next = cur.next\n                cur.next = begin.next\n                begin.next = cur\n                cur = first.next",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Intersection of Two Linked Lists",
      "difficulty": "EASY",
      "category": "Hash Table, Linked List, Two Pointers",
      "link": "https://leetcode.com/problems/intersection-of-two-linked-lists",
      "slug": "intersection-of-two-linked-lists",
      "description": "Given the heads of two singly linked-lists \nheadA\n and \nheadB\n, return \nthe node at which the two lists intersect\n. If the two linked lists have no intersection at all, return \nnull\n.\n\n\nFor example, the following two linked lists begin to intersect at node \nc1\n:\n\n\n\n\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\n\n\nNote\n that the linked lists must \nretain their original structure\n after the function returns.\n\n\nCustom Judge:\n\n\nThe inputs to the \njudge\n are given as follows (your program is \nnot\n given these inputs):\n\n\n\n\nintersectVal\n - The value of the node where the intersection occurs. This is \n0\n if there is no intersected node.\n\n\nlistA\n - The first linked list.\n\n\nlistB\n - The second linked list.\n\n\nskipA\n - The number of nodes to skip ahead in \nlistA\n (starting from the head) to get to the intersected node.\n\n\nskipB\n - The number of nodes to skip ahead in \nlistB\n (starting from the head) to get to the intersected node.\n\n\n\n\nThe judge will then create the linked structure based on these inputs and pass the two heads, \nheadA\n and \nheadB\n to your program. If you correctly return the intersected node, then your solution will be \naccepted\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n\nOutput:\n Intersected at '8'\n\nExplanation:\n The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2\nnd\n node in A and 3\nrd\n node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3\nrd\n node in A and 4\nth\n node in B) point to the same location in memory.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n\nOutput:\n Intersected at '2'\n\nExplanation:\n The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n\nOutput:\n No intersection\n\nExplanation:\n From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes of \nlistA\n is in the \nm\n.\n\n\nThe number of nodes of \nlistB\n is in the \nn\n.\n\n\n1 <= m, n <= 3 * 10\n4\n\n\n1 <= Node.val <= 10\n5\n\n\n0 <= skipA <= m\n\n\n0 <= skipB <= n\n\n\nintersectVal\n is \n0\n if \nlistA\n and \nlistB\n do not intersect.\n\n\nintersectVal == listA[skipA] == listB[skipB]\n if \nlistA\n and \nlistB\n intersect.\n\n\n\n\n \n\n\nFollow up:\n Could you write a solution that runs in \nO(m + n)\n time and use only \nO(1)\n memory?",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\nclass Solution(object):\n    # @param two ListNodes\n    # @return the intersected ListNode\n    def getIntersectionNode(self, headA, headB):\n        curA, curB = headA, headB\n        while curA != curB:\n            curA = curA.next if curA else headB\n            curB = curB.next if curB else headA\n        return curA",
      "explanation": "N/A",
      "time_complexity": "O(m + n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Rotate Image",
      "difficulty": "MEDIUM",
      "category": "Array, Math, Matrix",
      "link": "https://leetcode.com/problems/rotate-image",
      "slug": "rotate-image",
      "description": "You are given an \nn x n\n 2D \nmatrix\n representing an image, rotate the image by \n90\n degrees (clockwise).\n\n\nYou have to rotate the image \nin-place\n, which means you have to modify the input 2D matrix directly. \nDO NOT\n allocate another 2D matrix and do the rotation.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [[7,4,1],[8,5,2],[9,6,3]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n\nOutput:\n [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 20\n\n\n-1000 <= matrix[i][j] <= 1000",
      "solution": "class Solution(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        n = len(matrix)\n\n        # anti-diagonal mirror\n        for i in xrange(n):\n            for j in xrange(n - i):\n                matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j]\n\n        # horizontal mirror\n        for i in xrange(n / 2):\n            for j in xrange(n):\n                matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]\n\n        return matrix\nclass Solution2(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        return [list(reversed(x)) for x in zip(*matrix)]",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n^2)"
    },
    {
      "title": "Sliding Window Maximum",
      "difficulty": "HARD",
      "category": "Array, Queue, Sliding Window, Heap (Priority Queue), Monotonic Queue",
      "link": "https://leetcode.com/problems/sliding-window-maximum",
      "slug": "sliding-window-maximum",
      "description": "You are given an array of integers \nnums\n, there is a sliding window of size \nk\n which is moving from the very left of the array to the very right. You can only see the \nk\n numbers in the window. Each time the sliding window moves right by one position.\n\n\nReturn \nthe max sliding window\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,-1,-3,5,3,6,7], k = 3\n\nOutput:\n [3,3,5,5,6,7]\n\nExplanation:\n \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       \n3\n\n 1 [3  -1  -3] 5  3  6  7       \n3\n\n 1  3 [-1  -3  5] 3  6  7      \n 5\n\n 1  3  -1 [-3  5  3] 6  7       \n5\n\n 1  3  -1  -3 [5  3  6] 7       \n6\n\n 1  3  -1  -3  5 [3  6  7]      \n7\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1], k = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n1 <= k <= nums.length",
      "solution": "\nfrom collections import deque\n\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result, dq = [], deque()\n        for i in xrange(len(nums)):\n            if dq and i-dq[0] == k:\n                dq.popleft()\n            while dq and nums[dq[-1]] <= nums[i]:\n                dq.pop()\n            dq.append(i)\n            if i >= k-1:\n                result.append(nums[dq[0]])\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Find Minimum in Rotated Sorted Array",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array",
      "slug": "find-minimum-in-rotated-sorted-array",
      "description": "Suppose an array of length \nn\n sorted in ascending order is \nrotated\n between \n1\n and \nn\n times. For example, the array \nnums = [0,1,2,4,5,6,7]\n might become:\n\n\n\n\n[4,5,6,7,0,1,2]\n if it was rotated \n4\n times.\n\n\n[0,1,2,4,5,6,7]\n if it was rotated \n7\n times.\n\n\n\n\nNotice that \nrotating\n an array \n[a[0], a[1], a[2], ..., a[n-1]]\n 1 time results in the array \n[a[n-1], a[0], a[1], a[2], ..., a[n-2]]\n.\n\n\nGiven the sorted rotated array \nnums\n of \nunique\n elements, return \nthe minimum element of this array\n.\n\n\nYou must write an algorithm that runs in \nO(log n) time\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,4,5,1,2]\n\nOutput:\n 1\n\nExplanation:\n The original array was [1,2,3,4,5] rotated 3 times.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [4,5,6,7,0,1,2]\n\nOutput:\n 0\n\nExplanation:\n The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [11,13,15,17]\n\nOutput:\n 11\n\nExplanation:\n The original array was [11,13,15,17] and it was rotated 4 times. \n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 5000\n\n\n-5000 <= nums[i] <= 5000\n\n\nAll the integers of \nnums\n are \nunique\n.\n\n\nnums\n is sorted and rotated between \n1\n and \nn\n times.",
      "solution": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums)\n        target = nums[-1]\n\n        while left < right:\n            mid = left + (right - left) / 2\n\n            if nums[mid] <= target:\n                right = mid\n            else:\n                left = mid + 1\n\n        return nums[left]\n\nclass Solution2(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] >= nums[right]:\n            mid = left + (right - left) / 2\n\n            if nums[mid] < nums[left]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return nums[left]",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Recover Binary Search Tree",
      "difficulty": "MEDIUM",
      "category": "Tree, Depth-First Search, Binary Search Tree, Binary Tree",
      "link": "https://leetcode.com/problems/recover-binary-search-tree",
      "slug": "recover-binary-search-tree",
      "description": "You are given the \nroot\n of a binary search tree (BST), where the values of \nexactly\n two nodes of the tree were swapped by mistake. \nRecover the tree without changing its structure\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,3,null,null,2]\n\nOutput:\n [3,1,null,null,2]\n\nExplanation:\n 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,1,4,null,null,2]\n\nOutput:\n [2,1,4,null,null,3]\n\nExplanation:\n 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 1000]\n.\n\n\n-2\n31\n <= Node.val <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n A solution using \nO(n)\n space is pretty straight-forward. Could you devise a constant \nO(1)\n space solution?",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        if self:\n            serial = []\n            queue = [self]\n\n            while queue:\n                cur = queue[0]\n\n                if cur:\n                    serial.append(cur.val)\n                    queue.append(cur.left)\n                    queue.append(cur.right)\n                else:\n                    serial.append(\"#\")\n\n                queue = queue[1:]\n\n            while serial[-1] == \"#\":\n                serial.pop()\n\n            return repr(serial)\n\n        else:\n            return None\nclass Solution(object):\n    # @param root, a tree node\n    # @return a tree node\n    def recoverTree(self, root):\n        return self.MorrisTraversal(root)\n\n    def MorrisTraversal(self, root):\n        if root is None:\n            return\n        broken = [None, None]\n        pre, cur = None, root\n\n        while cur:\n            if cur.left is None:\n                self.detectBroken(broken, pre, cur)\n                pre = cur\n                cur = cur.right\n            else:\n                node = cur.left\n                while node.right and node.right != cur:\n                    node = node.right\n\n                if node.right is None:\n                    node.right =cur\n                    cur = cur.left\n                else:\n                    self.detectBroken(broken, pre, cur)\n                    node.right = None\n                    pre = cur\n                    cur = cur.right\n\n        broken[0].val, broken[1].val = broken[1].val, broken[0].val\n\n        return root\n\n    def detectBroken(self, broken, pre, cur):\n        if pre and pre.val > cur.val:\n            if broken[0] is None:\n                broken[0] = pre\n            broken[1] = cur",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Valid Parentheses",
      "difficulty": "EASY",
      "category": "String, Stack",
      "link": "https://leetcode.com/problems/valid-parentheses",
      "slug": "valid-parentheses",
      "description": "Given a string \ns\n containing just the characters \n'('\n, \n')'\n, \n'{'\n, \n'}'\n, \n'['\n and \n']'\n, determine if the input string is valid.\n\n\nAn input string is valid if:\n\n\n\n\nOpen brackets must be closed by the same type of brackets.\n\n\nOpen brackets must be closed in the correct order.\n\n\nEvery close bracket has a corresponding open bracket of the same type.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"()\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"()[]{}\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"(]\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"([])\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"([)]\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of parentheses only \n'()[]{}'\n.",
      "solution": "class Solution(object):\n    # @return a boolean\n    def isValid(self, s):\n        stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        for parenthese in s:\n            if parenthese in lookup:\n                stack.append(parenthese)\n            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:\n                return False\n        return len(stack) == 0",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Longest Substring with At Most K Distinct Characters",
      "difficulty": "MEDIUM",
      "category": "Hash Table, String, Sliding Window",
      "link": "https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters",
      "slug": "longest-substring-with-at-most-k-distinct-characters",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "class Solution(object):\n    def lengthOfLongestSubstringKDistinct(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in xrange(256)]\n        for i, char in enumerate(s):\n            if visited[ord(char)] == 0:\n                distinct_count += 1\n            visited[ord(char)] += 1\n            while distinct_count > k:\n                visited[ord(s[start])] -= 1\n                if visited[ord(s[start])] == 0:\n                    distinct_count -= 1\n                start += 1\n            longest = max(longest, i - start + 1)\n        return longest\n\n\nfrom collections import Counter\n\nclass Solution2(object):\n    def lengthOfLongestSubstringKDistinct(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        counter = Counter()\n        left, max_length = 0, 0\n        for right, char in enumerate(s):\n            counter[char] += 1\n            while len(counter) > k:\n                counter[s[left]] -= 1\n                if counter[s[left]] == 0:\n                    del counter[s[left]]\n                left += 1\n            max_length = max(max_length, right-left+1)\n        return max_length",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Longest Consecutive Sequence",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Union Find",
      "link": "https://leetcode.com/problems/longest-consecutive-sequence",
      "slug": "longest-consecutive-sequence",
      "description": "Given an unsorted array of integers \nnums\n, return \nthe length of the longest consecutive elements sequence.\n\n\nYou must write an algorithm that runs in \nO(n)\n time.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [100,4,200,1,3,2]\n\nOutput:\n 4\n\nExplanation:\n The longest consecutive elements sequence is \n[1, 2, 3, 4]\n. Therefore its length is 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,3,7,2,5,8,4,6,0,1]\n\nOutput:\n 9\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,0,1,2]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9",
      "solution": "class Solution(object):\n    # @param num, a list of integer\n    # @return an integer\n    def longestConsecutive(self, num):\n        result, lengths = 1, {key: 0 for key in num}\n        for i in num:\n            if lengths[i] == 0:\n                lengths[i] = 1\n                left, right = lengths.get(i - 1, 0), lengths.get(i + 1, 0)\n                length = 1 + left + right\n                result, lengths[i - left], lengths[i + right] = max(result, length), length, length\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Zero Array Transformation III",
      "difficulty": "MEDIUM",
      "category": "Array, Greedy, Sorting, Heap (Priority Queue), Prefix Sum",
      "link": "https://leetcode.com/problems/zero-array-transformation-iii",
      "slug": "zero-array-transformation-iii",
      "description": "You are given an integer array \nnums\n of length \nn\n and a 2D array \nqueries\n where \nqueries[i] = [l\ni\n, r\ni\n]\n.\n\n\nEach \nqueries[i]\n represents the following action on \nnums\n:\n\n\n\n\nDecrement the value at each index in the range \n[l\ni\n, r\ni\n]\n in \nnums\n by \nat most\n \n1.\n\n\nThe amount by which the value is decremented can be chosen \nindependently\n for each index.\n\n\n\n\nA \nZero Array\n is an array with all its elements equal to 0.\n\n\nReturn the \nmaximum \nnumber of elements that can be removed from \nqueries\n, such that \nnums\n can still be converted to a \nzero array\n using the \nremaining\n queries. If it is not possible to convert \nnums\n to a \nzero array\n, return -1.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,0,2], queries = [[0,2],[0,2],[1,1]]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nAfter removing \nqueries[2]\n, \nnums\n can still be converted to a zero array.\n\n\n\n\nUsing \nqueries[0]\n, decrement \nnums[0]\n and \nnums[2]\n by 1 and \nnums[1]\n by 0.\n\n\nUsing \nqueries[1]\n, decrement \nnums[0]\n and \nnums[2]\n by 1 and \nnums[1]\n by 0.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,1,1,1], queries = [[1,3],[0,2],[1,3],[1,2]]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nWe can remove \nqueries[2]\n and \nqueries[3]\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,2,3,4], queries = [[0,3]]\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\nnums\n cannot be converted to a zero array even after using all the queries.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n0 <= nums[i] <= 10\n5\n\n\n1 <= queries.length <= 10\n5\n\n\nqueries[i].length == 2\n\n\n0 <= l\ni\n <= r\ni\n < nums.length",
      "solution": "\nimport heapq\n\n\n# sort, heap, greedyclass Solution(object):\n    def maxRemoval(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        queries.sort(reverse=True)\n        max_heap, min_heap = [], []\n        for i in xrange(len(nums)):\n            while queries and queries[-1][0] <= i:\n                heapq.heappush(max_heap, -queries.pop()[1])\n            while min_heap and min_heap[0] < i:\n                heapq.heappop(min_heap)\n            while len(min_heap) < nums[i]:\n                if not max_heap or -max_heap[0] < i:\n                    return -1\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        return len(max_heap)",
      "explanation": "N/A",
      "time_complexity": "O(n + qlogq)",
      "space_complexity": "O(q)"
    },
    {
      "title": "Combination Sum II",
      "difficulty": "MEDIUM",
      "category": "Array, Backtracking",
      "link": "https://leetcode.com/problems/combination-sum-ii",
      "slug": "combination-sum-ii",
      "description": "Given a collection of candidate numbers (\ncandidates\n) and a target number (\ntarget\n), find all unique combinations in \ncandidates\n where the candidate numbers sum to \ntarget\n.\n\n\nEach number in \ncandidates\n may only be used \nonce\n in the combination.\n\n\nNote:\n The solution set must not contain duplicate combinations.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n candidates = [10,1,2,7,6,1,5], target = 8\n\nOutput:\n \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\n\n\nExample 2:\n\n\n\n\nInput:\n candidates = [2,5,2,1,2], target = 5\n\nOutput:\n \n[\n[1,2,2],\n[5]\n]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= candidates.length <= 100\n\n\n1 <= candidates[i] <= 50\n\n\n1 <= target <= 30",
      "solution": "class Solution(object):\n    # @param candidates, a list of integers\n    # @param target, integer\n    # @return a list of lists of integers\n    def combinationSum2(self, candidates, target):\n        result = []\n        self.combinationSumRecu(sorted(candidates), result, 0, [], target)\n        return result\n\n    def combinationSumRecu(self, candidates, result, start, intermediate, target):\n        if target == 0:\n            result.append(list(intermediate))\n        prev = 0\n        while start < len(candidates) and candidates[start] <= target:\n            if prev != candidates[start]:\n                intermediate.append(candidates[start])\n                self.combinationSumRecu(candidates, result, start + 1, intermediate, target - candidates[start])\n                intermediate.pop()\n                prev = candidates[start]\n            start += 1",
      "explanation": "N/A",
      "time_complexity": "O(k * C(n, k))",
      "space_complexity": "O(k)"
    },
    {
      "title": "Maximum Difference Between Even and Odd Frequency II",
      "difficulty": "HARD",
      "category": "String, Sliding Window, Enumeration, Prefix Sum",
      "link": "https://leetcode.com/problems/maximum-difference-between-even-and-odd-frequency-ii",
      "slug": "maximum-difference-between-even-and-odd-frequency-ii",
      "description": "You are given a string \ns\n and an integer \nk\n. Your task is to find the \nmaximum\n difference between the frequency of \ntwo\n characters, \nfreq[a] - freq[b]\n, in a \nsubstring\n \nsubs\n of \ns\n, such that:\n\n\n\n\nsubs\n has a size of \nat least\n \nk\n.\n\n\nCharacter \na\n has an \nodd frequency\n in \nsubs\n.\n\n\nCharacter \nb\n has a \nnon-zero\n \neven frequency\n in \nsubs\n.\n\n\n\n\nReturn the \nmaximum\n difference.\n\n\nNote\n that \nsubs\n can contain more than 2 \ndistinct\n characters.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"12233\", k = 4\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\nFor the substring \n\"12233\"\n, the frequency of \n'1'\n is 1 and the frequency of \n'3'\n is 2. The difference is \n1 - 2 = -1\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"1122211\", k = 3\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nFor the substring \n\"11222\"\n, the frequency of \n'2'\n is 3 and the frequency of \n'1'\n is 2. The difference is \n3 - 2 = 1\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"110\", k = 3\n\n\nOutput:\n \n-1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= s.length <= 3 * 10\n4\n\n\ns\n consists only of digits \n'0'\n to \n'4'\n.\n\n\nThe input is generated that at least one substring has a character with an even frequency and a character with an odd frequency.\n\n\n1 <= k <= s.length",
      "solution": "\n# prefix sum, two pointers, sliding windowclass Solution(object):\n    def maxDifference(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def diff(x, y):\n            prefix1, prefix2, prefix = [0]*(len(s)+1), [0]*(len(s)+1), [0]*(len(s)+1)\n            for i in xrange(len(s)):\n                prefix1[i+1] = prefix1[i]+int(s[i] == x)\n                prefix2[i+1] = prefix2[i]+int(s[i] == y)\n                prefix[i+1] = prefix[i]+(int(s[i] == x)-int(s[i] == y))\n            result = float(\"-inf\")\n            mn = [[float(\"inf\")]*2 for _ in xrange(2)]\n            left = 0\n            for right in xrange(k-1, len(s)):\n                while k <= right-left+1 and prefix1[right+1]-prefix1[left] and prefix2[right+1]-prefix2[left]:\n                    i, j = prefix1[left]%2, prefix2[left]%2\n                    mn[i][j] = min(mn[i][j], prefix[left])\n                    left += 1\n                i, j = prefix1[right+1]%2, prefix2[right+1]%2\n                result = max(result, prefix[right+1]-mn[i^1][j])\n            return result\n        \n        lookup = set(s)\n        return max(diff(x, y) for x in lookup for y in lookup if x != y)",
      "explanation": "N/A",
      "time_complexity": "O(d^2 * n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Next Greater Element I",
      "difficulty": "EASY",
      "category": "Array, Hash Table, Stack, Monotonic Stack",
      "link": "https://leetcode.com/problems/next-greater-element-i",
      "slug": "next-greater-element-i",
      "description": "The \nnext greater element\n of some element \nx\n in an array is the \nfirst greater\n element that is \nto the right\n of \nx\n in the same array.\n\n\nYou are given two \ndistinct 0-indexed\n integer arrays \nnums1\n and \nnums2\n, where \nnums1\n is a subset of \nnums2\n.\n\n\nFor each \n0 <= i < nums1.length\n, find the index \nj\n such that \nnums1[i] == nums2[j]\n and determine the \nnext greater element\n of \nnums2[j]\n in \nnums2\n. If there is no next greater element, then the answer for this query is \n-1\n.\n\n\nReturn \nan array \nans\n of length \nnums1.length\n such that \nans[i]\n is the \nnext greater element\n as described above.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [4,1,2], nums2 = [1,3,4,2]\n\nOutput:\n [-1,3,-1]\n\nExplanation:\n The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,\n4\n,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [\n1\n,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,\n2\n]. There is no next greater element, so the answer is -1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [2,4], nums2 = [1,2,3,4]\n\nOutput:\n [3,-1]\n\nExplanation:\n The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,\n2\n,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,\n4\n]. There is no next greater element, so the answer is -1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length <= nums2.length <= 1000\n\n\n0 <= nums1[i], nums2[i] <= 10\n4\n\n\nAll integers in \nnums1\n and \nnums2\n are \nunique\n.\n\n\nAll the integers of \nnums1\n also appear in \nnums2\n.\n\n\n\n\n \n\n\nFollow up:\n Could you find an \nO(nums1.length + nums2.length)\n solution?",
      "solution": "class Solution(object):\n    def nextGreaterElement(self, findNums, nums):\n        \"\"\"\n        :type findNums: List[int]\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        stk, lookup = [], {}\n        for num in nums:\n            while stk and num > stk[-1]:\n                lookup[stk.pop()] = num\n            stk.append(num)\n        while stk:\n            lookup[stk.pop()] = -1\n        return map(lambda x : lookup[x], findNums)",
      "explanation": "N/A",
      "time_complexity": "O(m + n)",
      "space_complexity": "O(m + n)"
    },
    {
      "title": "Add Strings",
      "difficulty": "EASY",
      "category": "Math, String, Simulation",
      "link": "https://leetcode.com/problems/add-strings",
      "slug": "add-strings",
      "description": "Given two non-negative integers, \nnum1\n and \nnum2\n represented as string, return \nthe sum of\n \nnum1\n \nand\n \nnum2\n \nas a string\n.\n\n\nYou must solve the problem without using any built-in library for handling large integers (such as \nBigInteger\n). You must also not convert the inputs to integers directly.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num1 = \"11\", num2 = \"123\"\n\nOutput:\n \"134\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n num1 = \"456\", num2 = \"77\"\n\nOutput:\n \"533\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n num1 = \"0\", num2 = \"0\"\n\nOutput:\n \"0\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num1.length, num2.length <= 10\n4\n\n\nnum1\n and \nnum2\n consist of only digits.\n\n\nnum1\n and \nnum2\n don't have any leading zeros except for the zero itself.",
      "solution": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        result = []\n        i, j, carry = len(num1) - 1, len(num2) - 1, 0\n\n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += ord(num1[i]) - ord('0')\n                i -= 1\n            if j >= 0:\n                carry += ord(num2[j]) - ord('0')\n                j -= 1\n            result.append(str(carry % 10))\n            carry /= 10\n        result.reverse()\n\n        return \"\".join(result)\n\n    def addStrings2(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        length = max(len(num1), len(num2))\n        num1 = num1.zfill(length)[::-1]\n        num2 = num2.zfill(length)[::-1]\n        res, plus = '', 0\n        for index, num in enumerate(num1):\n            tmp = str(int(num) + int(num2[index]) + plus)\n            res += tmp[-1]\n            if int(tmp) > 9:\n                plus = 1\n            else:\n                plus = 0\n        if plus:\n            res += '1'\n        return res[::-1]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Maximal Rectangle",
      "difficulty": "HARD",
      "category": "Array, Dynamic Programming, Stack, Matrix, Monotonic Stack",
      "link": "https://leetcode.com/problems/maximal-rectangle",
      "slug": "maximal-rectangle",
      "description": "Given a \nrows x cols\n binary \nmatrix\n filled with \n0\n's and \n1\n's, find the largest rectangle containing only \n1\n's and return \nits area\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\n\nOutput:\n 6\n\nExplanation:\n The maximal rectangle is shown in the above picture.\n\n\n\nExample 2:\n\n\n\n\nInput:\n matrix = [[\"0\"]]\n\nOutput:\n 0\n\n\n\nExample 3:\n\n\n\n\nInput:\n matrix = [[\"1\"]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nrows == matrix.length\n\n\ncols == matrix[i].length\n\n\n1 <= row, cols <= 200\n\n\nmatrix[i][j]\n is \n'0'\n or \n'1'\n.",
      "solution": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        def largestRectangleArea(heights):\n            stk, result, i = [-1], 0, 0\n            for i in xrange(len(heights)+1):\n                while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):\n                    result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))\n                stk.append(i) \n            return result\n\n        if not matrix:\n            return 0\n        result = 0\n        heights = [0]*len(matrix[0])\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[0])):\n                heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0\n            result = max(result, largestRectangleArea(heights))\n        return result\n\n\n# DP solution.class Solution2(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        if not matrix:\n            return 0\n\n        result = 0\n        m = len(matrix)\n        n = len(matrix[0])\n        L = [0 for _ in xrange(n)]\n        H = [0 for _ in xrange(n)]\n        R = [n for _ in xrange(n)]\n\n        for i in xrange(m):\n            left = 0\n            for j in xrange(n):\n                if matrix[i][j] == '1':\n                    L[j] = max(L[j], left)\n                    H[j] += 1\n                else:\n                    L[j] = 0\n                    H[j] = 0\n                    R[j] = n\n                    left = j + 1\n\n            right = n\n            for j in reversed(xrange(n)):\n                if matrix[i][j] == '1':\n                    R[j] = min(R[j], right)\n                    result = max(result, H[j] * (R[j] - L[j]))\n                else:\n                    right = j\n\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n)"
    },
    {
      "title": "3Sum",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers, Sorting",
      "link": "https://leetcode.com/problems/3sum",
      "slug": "3sum",
      "description": "Given an integer array nums, return all the triplets \n[nums[i], nums[j], nums[k]]\n such that \ni != j\n, \ni != k\n, and \nj != k\n, and \nnums[i] + nums[j] + nums[k] == 0\n.\n\n\nNotice that the solution set must not contain duplicate triplets.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-1,0,1,2,-1,-4]\n\nOutput:\n [[-1,-1,2],[-1,0,1]]\n\nExplanation:\n \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,1,1]\n\nOutput:\n []\n\nExplanation:\n The only possible triplet does not sum up to 0.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [0,0,0]\n\nOutput:\n [[0,0,0]]\n\nExplanation:\n The only possible triplet sums up to 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= nums.length <= 3000\n\n\n-10\n5\n <= nums[i] <= 10\n5",
      "solution": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        nums.sort()\n        for i in reversed(xrange(2, len(nums))):\n            if i+1 < len(nums) and nums[i] == nums[i+1]:\n                continue\n            target = -nums[i]\n            left, right = 0, i-1\n            while left < right:\n                if nums[left]+nums[right] < target:\n                    left += 1\n                elif nums[left]+nums[right] > target:\n                    right -= 1\n                else:\n                    result.append([nums[left], nums[right], nums[i]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left-1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right+1]:\n                        right -= 1\n        return result\n\nclass Solution2(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, i = sorted(nums), [], 0\n        while i < len(nums) - 2:\n            if i == 0 or nums[i] != nums[i - 1]:\n                j, k = i + 1, len(nums) - 1\n                while j < k:\n                    if nums[i] + nums[j] + nums[k] < 0:\n                        j += 1\n                    elif nums[i] + nums[j] + nums[k] > 0:\n                        k -= 1\n                    else:\n                        result.append([nums[i], nums[j], nums[k]])\n                        j, k = j + 1, k - 1\n                        while j < k and nums[j] == nums[j - 1]:\n                            j += 1\n                        while j < k and nums[k] == nums[k + 1]:\n                            k -= 1\n            i += 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Maximum Difference Between Even and Odd Frequency I",
      "difficulty": "EASY",
      "category": "Hash Table, String, Counting",
      "link": "https://leetcode.com/problems/maximum-difference-between-even-and-odd-frequency-i",
      "slug": "maximum-difference-between-even-and-odd-frequency-i",
      "description": "You are given a string \ns\n consisting of lowercase English letters.\n\n\nYour task is to find the \nmaximum\n difference \ndiff = freq(a\n1\n) - freq(a\n2\n)\n between the frequency of characters \na\n1\n and \na\n2\n in the string such that:\n\n\n\n\na\n1\n has an \nodd frequency\n in the string.\n\n\na\n2\n has an \neven frequency\n in the string.\n\n\n\n\nReturn this \nmaximum\n difference.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"aaaaabbc\"\n\n\nOutput:\n 3\n\n\nExplanation:\n\n\n\n\nThe character \n'a'\n has an \nodd frequency\n of \n5\n,\n and \n'b'\n has an \neven frequency\n of \n2\n.\n\n\nThe maximum difference is \n5 - 2 = 3\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"abcabcab\"\n\n\nOutput:\n 1\n\n\nExplanation:\n\n\n\n\nThe character \n'a'\n has an \nodd frequency\n of \n3\n,\n and \n'c'\n has an \neven frequency\n of \n2\n.\n\n\nThe maximum difference is \n3 - 2 = 1\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= s.length <= 100\n\n\ns\n consists only of lowercase English letters.\n\n\ns\n contains at least one character with an odd frequency and one with an even frequency.",
      "solution": "\n# freq tableclass Solution(object):\n    def maxDifference(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        cnt = [0]*26\n        for x in s:\n            cnt[ord(x)-ord('a')] += 1\n        mn, mx = float(\"inf\"), 0\n        for x in cnt:\n            if not x:\n                continue\n            if x%2 == 0:\n                mn = min(mn, x)\n            else:\n                mx = max(mx, x)\n        return mx-mn",
      "explanation": "N/A",
      "time_complexity": "O(n + 26)",
      "space_complexity": "O(26)"
    },
    {
      "title": "Search Insert Position",
      "difficulty": "EASY",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/search-insert-position",
      "slug": "search-insert-position",
      "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 5\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 2\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 7\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nnums\n contains \ndistinct\n values sorted in \nascending\n order.\n\n\n-10\n4\n <= target <= 10\n4",
      "solution": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if nums[mid] >= target:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return left",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Trapping Rain Water",
      "difficulty": "HARD",
      "category": "Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack",
      "link": "https://leetcode.com/problems/trapping-rain-water",
      "slug": "trapping-rain-water",
      "description": "Given \nn\n non-negative integers representing an elevation map where the width of each bar is \n1\n, compute how much water it can trap after raining.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [0,1,0,2,1,0,1,3,2,1,2,1]\n\nOutput:\n 6\n\nExplanation:\n The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [4,2,0,3,2,5]\n\nOutput:\n 9\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n1 <= n <= 2 * 10\n4\n\n\n0 <= height[i] <= 10\n5",
      "solution": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result, left, right, level = 0, 0, len(height)-1, 0\n        while left < right:\n            if height[left] < height[right]:\n                lower = height[left]\n                left += 1\n            else:\n                lower = height[right]\n                right -= 1\n            level = max(level, lower)\n            result += level-lower\n        return result\n\nclass Solution2(object):\n    # @param A, a list of integers\n    # @return an integer\n    def trap(self, A):\n        result = 0\n        top = 0\n        for i in xrange(len(A)):\n            if A[top] < A[i]:\n                top = i\n\n        second_top = 0\n        for i in xrange(top):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        second_top = len(A) - 1\n        for i in reversed(xrange(top, len(A))):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        return result\n\nclass Solution3(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        right = [0]*len(height)\n        mx = 0\n        for i in reversed(xrange(len(height))):\n            right[i] = mx\n            mx = max(mx, height[i])\n        result = left = 0\n        for i in xrange(len(height)):\n            left = max(left, height[i])\n            result += max(min(left, right[i])-height[i], 0)\n        return result\n\nclass Solution4(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        stk = []\n        for i in xrange(len(height)):\n            prev = 0\n            while stk and height[stk[-1]] <= height[i]:\n                j = stk.pop()\n                result += (height[j] - prev) * (i - j - 1)\n                prev = height[j]\n            if stk:\n                result += (height[i] - prev) * (i - stk[-1] - 1)\n            stk.append(i)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Binary Tree Level Order Traversal",
      "difficulty": "MEDIUM",
      "category": "Tree, Breadth-First Search, Binary Tree",
      "link": "https://leetcode.com/problems/binary-tree-level-order-traversal",
      "slug": "binary-tree-level-order-traversal",
      "description": "Given the \nroot\n of a binary tree, return \nthe level order traversal of its nodes' values\n. (i.e., from left to right, level by level).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n [[3],[9,20],[15,7]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n [[1]]\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 2000]\n.\n\n\n-1000 <= Node.val <= 1000",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return a list of lists of integers\n    def levelOrder(self, root):\n        if root is None:\n            return []\n        result, current = [], [root]\n        while current:\n            next_level, vals = [], []\n            for node in current:\n                vals.append(node.val)\n                if node.left:\n                    next_level.append(node.left)\n                if node.right:\n                    next_level.append(node.right)\n            current = next_level\n            result.append(vals)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Transform Array to All Equal Elements",
      "difficulty": "MEDIUM",
      "category": "Array, Greedy",
      "link": "https://leetcode.com/problems/transform-array-to-all-equal-elements",
      "slug": "transform-array-to-all-equal-elements",
      "description": "You are given an integer array \nnums\n of size \nn\n containing only \n1\n and \n-1\n, and an integer \nk\n.\n\n\nYou can perform the following operation at most \nk\n times:\n\n\n\n\n\n\nChoose an index \ni\n (\n0 <= i < n - 1\n), and \nmultiply\n both \nnums[i]\n and \nnums[i + 1]\n by \n-1\n.\n\n\n\n\n\n\nNote\n that you can choose the same index \ni\n more than once in \ndifferent\n operations.\n\n\nReturn \ntrue\n if it is possible to make all elements of the array \nequal\n after at most \nk\n operations, and \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,-1,1,-1,1], k = 3\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nWe can make all elements in the array equal in 2 operations as follows:\n\n\n\n\nChoose index \ni = 1\n, and multiply both \nnums[1]\n and \nnums[2]\n by -1. Now \nnums = [1,1,-1,-1,1]\n.\n\n\nChoose index \ni = 2\n, and multiply both \nnums[2]\n and \nnums[3]\n by -1. Now \nnums = [1,1,1,1,1]\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [-1,-1,-1,1,1,1], k = 5\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nIt is not possible to make all array elements equal in at most 5 operations.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == nums.length <= 10\n5\n\n\nnums[i]\n is either -1 or 1.\n\n\n1 <= k <= n",
      "solution": "\n# greedyclass Solution(object):\n    def canMakeEqual(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        def check(target):\n            cnt = 0\n            sign = 1\n            for i in xrange(len(nums)):\n                if nums[i]*sign == target:\n                    sign = 1\n                    continue\n                cnt += 1\n                if i+1 == len(nums) or cnt > k:\n                    return False\n                sign = -1\n            return True\n\n        return check(1) or check(-1)\n\n\n# greedyclass Solution2(object):\n    def canMakeEqual(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        def check(target):\n            parity = cnt = 0\n            for i in xrange(len(nums)):\n                if nums[i] == target:\n                    continue\n                cnt += i if parity else -i\n                if cnt > k:\n                    return False\n                parity ^= 1\n            return parity == 0\n\n        return check(1) or check(-1)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "LRU Cache",
      "difficulty": "MEDIUM",
      "category": "Hash Table, Linked List, Design, Doubly-Linked List",
      "link": "https://leetcode.com/problems/lru-cache",
      "slug": "lru-cache",
      "description": "Design a data structure that follows the constraints of a \nLeast Recently Used (LRU) cache\n.\n\n\nImplement the \nLRUCache\n class:\n\n\n\n\nLRUCache(int capacity)\n Initialize the LRU cache with \npositive\n size \ncapacity\n.\n\n\nint get(int key)\n Return the value of the \nkey\n if the key exists, otherwise return \n-1\n.\n\n\nvoid put(int key, int value)\n Update the value of the \nkey\n if the \nkey\n exists. Otherwise, add the \nkey-value\n pair to the cache. If the number of keys exceeds the \ncapacity\n from this operation, \nevict\n the least recently used key.\n\n\n\n\nThe functions \nget\n and \nput\n must each run in \nO(1)\n average time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n\nOutput\n\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n\nExplanation\n\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= capacity <= 3000\n\n\n0 <= key <= 10\n4\n\n\n0 <= value <= 10\n5\n\n\nAt most \n2 * 10\n5\n calls will be made to \nget\n and \nput\n.",
      "solution": "\nimport collections\n\n\n# using OrderedDictclass LRUCache(object):\n    def __init__(self, capacity):\n        self.cache = collections.OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        val = self.cache[key]\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.cache and len(self.cache) == self.capacity:\n            self.cache.popitem(last=False)\n        self.__update(key, val)\n    \n    def __update(self, key, val):\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = val\n\n\n\nclass ListNode(object):\n    def __init__(self, key, val):\n        self.val = val\n        self.key = key\n        self.next = None\n        self.prev = None\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\nclass LRUCache2(object):\n\n    def __init__(self, capacity):\n        self.list = LinkedList()\n        self.dict = {}\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.dict:\n            return -1\n        val = self.dict[key].val\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.dict and len(self.dict) == self.capacity:\n            del self.dict[self.list.head.key]\n            self.list.delete(self.list.head)\n        self.__update(key, val)\n\n    def __update(self, key, val):\n        if key in self.dict:\n            self.list.delete(self.dict[key])\n        node = ListNode(key, val)\n        self.list.insert(node)\n        self.dict[key] = node",
      "explanation": "N/A",
      "time_complexity": "O(1), per operation.",
      "space_complexity": "O(k), k is the capacity of cache."
    },
    {
      "title": "Next Permutation",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers",
      "link": "https://leetcode.com/problems/next-permutation",
      "slug": "next-permutation",
      "description": "A \npermutation\n of an array of integers is an arrangement of its members into a sequence or linear order.\n\n\n\n\nFor example, for \narr = [1,2,3]\n, the following are all the permutations of \narr\n: \n[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]\n.\n\n\n\n\nThe \nnext permutation\n of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the \nnext permutation\n of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n\n\n\nFor example, the next permutation of \narr = [1,2,3]\n is \n[1,3,2]\n.\n\n\nSimilarly, the next permutation of \narr = [2,3,1]\n is \n[3,1,2]\n.\n\n\nWhile the next permutation of \narr = [3,2,1]\n is \n[1,2,3]\n because \n[3,2,1]\n does not have a lexicographical larger rearrangement.\n\n\n\n\nGiven an array of integers \nnums\n, \nfind the next permutation of\n \nnums\n.\n\n\nThe replacement must be \nin place\n and use only constant extra memory.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n [1,3,2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,1]\n\nOutput:\n [1,2,3]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,1,5]\n\nOutput:\n [1,5,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 100",
      "solution": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in reversed(xrange(len(nums)-1)):\n            if nums[i] < nums[i+1]:\n                k = i\n                break\n        else:\n            nums.reverse()\n            return\n\n        for i in reversed(xrange(k+1, len(nums))):\n            if nums[i] > nums[k]:\n                l = i\n                break\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]\n        \nclass Solution2(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in xrange(len(nums)-1):\n            if nums[i] < nums[i+1]:\n                k = i\n\n        if k == -1:\n            nums.reverse()\n            return\n\n        for i in xrange(k+1, len(nums)):\n            if nums[i] > nums[k]:\n                l = i\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    }
  ],
  "Meta": [
    {
      "title": "Minimum Remove to Make Valid Parentheses",
      "difficulty": "MEDIUM",
      "category": "String, Stack",
      "link": "https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses",
      "slug": "minimum-remove-to-make-valid-parentheses",
      "description": "Given a string \ns\n of \n'('\n , \n')'\n and lowercase English characters.\n\n\nYour task is to remove the minimum number of parentheses ( \n'('\n or \n')'\n, in any positions ) so that the resulting \nparentheses string\n is valid and return \nany\n valid string.\n\n\nFormally, a \nparentheses string\n is valid if and only if:\n\n\n\n\nIt is the empty string, contains only lowercase characters, or\n\n\nIt can be written as \nAB\n (\nA\n concatenated with \nB\n), where \nA\n and \nB\n are valid strings, or\n\n\nIt can be written as \n(A)\n, where \nA\n is a valid string.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"lee(t(c)o)de)\"\n\nOutput:\n \"lee(t(c)o)de\"\n\nExplanation:\n \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"a)b(c)d\"\n\nOutput:\n \"ab(c)d\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"))((\"\n\nOutput:\n \"\"\n\nExplanation:\n An empty string is also valid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns[i]\n is either \n'('\n , \n')'\n, or lowercase English letter.",
      "solution": "class Solution(object):\n    def minRemoveToMakeValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        result = list(s)\n        count = 0\n        for i, v in enumerate(result):\n            if v == '(':\n                count += 1\n            elif v == ')':\n                if count:\n                    count -= 1\n                else:\n                    result[i] = \"\"\n        if count:\n            for i in reversed(xrange(len(result))):\n                if result[i] == '(':\n                    result[i] = \"\"\n                    count -= 1\n                    if not count:\n                        break\n        return \"\".join(result)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Valid Word Abbreviation",
      "difficulty": "EASY",
      "category": "Two Pointers, String",
      "link": "https://leetcode.com/problems/valid-word-abbreviation",
      "slug": "valid-word-abbreviation",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "class Solution(object):\n    def validWordAbbreviation(self, word, abbr):\n        \"\"\"\n        :type word: str\n        :type abbr: str\n        :rtype: bool\n        \"\"\"\n        i , digit = 0, 0\n        for c in abbr:\n            if c.isdigit():\n                if digit == 0 and c == '0':\n                    return False\n                digit *= 10\n                digit += int(c)\n            else:\n                if digit:\n                    i += digit\n                    digit = 0\n                if i >= len(word) or word[i] != c:\n                    return False\n                i += 1\n        if digit:\n            i += digit\n\n        return i == len(word)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Binary Tree Vertical Order Traversal",
      "difficulty": "MEDIUM",
      "category": "Hash Table, Tree, Depth-First Search, Breadth-First Search, Sorting, Binary Tree",
      "link": "https://leetcode.com/problems/binary-tree-vertical-order-traversal",
      "slug": "binary-tree-vertical-order-traversal",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "\nimport collections\n\n\n# BFS + hash solution.class Solution(object):\n    def verticalOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        cols = collections.defaultdict(list)\n        queue = [(root, 0)]\n        for node, i in queue:\n            if node:\n                cols[i].append(node.val)\n                queue += (node.left, i - 1), (node.right, i + 1)\n        return [cols[i] for i in xrange(min(cols.keys()),\n                                        max(cols.keys()) + 1)] if cols else []",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Valid Palindrome II",
      "difficulty": "EASY",
      "category": "Two Pointers, String, Greedy",
      "link": "https://leetcode.com/problems/valid-palindrome-ii",
      "slug": "valid-palindrome-ii",
      "description": "Given a string \ns\n, return \ntrue\n \nif the \ns\n can be palindrome after deleting \nat most one\n character from it\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"aba\"\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abca\"\n\nOutput:\n true\n\nExplanation:\n You could delete the character 'c'.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"abc\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns\n consists of lowercase English letters.",
      "solution": "class Solution(object):\n    def validPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        def validPalindrome(s, left, right):\n            while left < right:\n                if s[left] != s[right]:\n                    return False\n                left, right = left+1, right-1\n            return True\n\n        left, right = 0, len(s)-1\n        while left < right:\n            if s[left] != s[right]:\n                return validPalindrome(s, left, right-1) or validPalindrome(s, left+1, right)\n            left, right = left+1, right-1\n        return True",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Lowest Common Ancestor of a Binary Tree III",
      "difficulty": "MEDIUM",
      "category": "Hash Table, Two Pointers, Tree, Binary Tree",
      "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii",
      "slug": "lowest-common-ancestor-of-a-binary-tree-iii",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "\n# Definition for a Node.class Node:\n    def __init__(self, val):\n        pass\nclass Solution(object):\n    def lowestCommonAncestor(self, p, q):\n        \"\"\"\n        :type node: Node\n        :rtype: Node\n        \"\"\"\n        a, b = p, q\n        while a != b:\n            a = a.parent if a else q\n            b = b.parent if b else p\n        return a\n\nclass Solution2(object):\n    def lowestCommonAncestor(self, p, q):\n        \"\"\"\n        :type node: Node\n        :rtype: Node\n        \"\"\"\n        def depth(node):\n            d = 0\n            while node:\n                node = node.parent\n                d += 1\n            return d\n        \n        p_d, q_d = depth(p), depth(q)\n        while p_d > q_d:\n            p = p.parent\n            p_d -= 1\n        while p_d < q_d:\n            q = q.parent\n            q_d -= 1\n        while p != q:\n            p = p.parent\n            q = q.parent\n        return p",
      "explanation": "N/A",
      "time_complexity": "O(h)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Kth Largest Element in an Array",
      "difficulty": "MEDIUM",
      "category": "Array, Divide and Conquer, Sorting, Heap (Priority Queue), Quickselect",
      "link": "https://leetcode.com/problems/kth-largest-element-in-an-array",
      "slug": "kth-largest-element-in-an-array",
      "description": "Given an integer array \nnums\n and an integer \nk\n, return \nthe\n \nk\nth\n \nlargest element in the array\n.\n\n\nNote that it is the \nk\nth\n largest element in the sorted order, not the \nk\nth\n distinct element.\n\n\nCan you solve it without sorting?\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [3,2,1,5,6,4], k = 2\n\nOutput:\n 5\n\nExample 2:\n\n\nInput:\n nums = [3,2,3,1,2,4,5,5,6], k = 4\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4",
      "solution": "\nfrom random import randint\n\n\n# optimized for duplicated numsclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        nth_element(nums, k-1, compare=lambda a, b: a > b)\n        return nums[k-1]\n\nclass Solution2(object):\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = self.PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k - 1:\n                return nums[new_pivot_idx]\n            elif new_pivot_idx > k - 1:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k - 1.\n                left = new_pivot_idx + 1\n\n    def PartitionAroundPivot(self, left, right, pivot_idx, nums):\n        pivot_value = nums[pivot_idx]\n        new_pivot_idx = left\n        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n        for i in xrange(left, right):\n            if nums[i] > pivot_value:\n                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                new_pivot_idx += 1\n\n        nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n        return new_pivot_idx",
      "explanation": "N/A",
      "time_complexity": "O(n) on average, using Median of Medians could achieve O(n) (Intro Select)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Binary Tree Right Side View",
      "difficulty": "MEDIUM",
      "category": "Tree, Depth-First Search, Breadth-First Search, Binary Tree",
      "link": "https://leetcode.com/problems/binary-tree-right-side-view",
      "slug": "binary-tree-right-side-view",
      "description": "Given the \nroot\n of a binary tree, imagine yourself standing on the \nright side\n of it, return \nthe values of the nodes you can see ordered from top to bottom\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nroot = [1,2,3,null,5,null,4]\n\n\nOutput:\n \n[1,3,4]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nroot = [1,2,3,4,null,null,null,5]\n\n\nOutput:\n \n[1,3,4,5]\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nroot = [1,null,3]\n\n\nOutput:\n \n[1,3]\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nroot = []\n\n\nOutput:\n \n[]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return a list of integers\n    def rightSideView(self, root):\n        result = []\n        self.rightSideViewDFS(root, 1, result)\n        return result\n\n    def rightSideViewDFS(self, node, depth, result):\n        if not node:\n            return\n\n        if depth > len(result):\n            result.append(node.val)\n\n        self.rightSideViewDFS(node.right, depth+1, result)\n        self.rightSideViewDFS(node.left, depth+1, result)\n\n\n# BFS solutionclass Solution2(object):\n    # @param root, a tree node\n    # @return a list of integers\n    def rightSideView(self, root):\n        if root is None:\n            return []\n\n        result, current = [], [root]\n        while current:\n            next_level = []\n            for node in current:\n                if node.left:\n                    next_level.append(node.left)\n                if node.right:\n                    next_level.append(node.right)                \n            result.append(node.val)\n            current = next_level\n\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Basic Calculator II",
      "difficulty": "MEDIUM",
      "category": "Math, String, Stack",
      "link": "https://leetcode.com/problems/basic-calculator-ii",
      "slug": "basic-calculator-ii",
      "description": "Given a string \ns\n which represents an expression, \nevaluate this expression and return its value\n. \n\n\nThe integer division should truncate toward zero.\n\n\nYou may assume that the given expression is always valid. All intermediate results will be in the range of \n[-2\n31\n, 2\n31\n - 1]\n.\n\n\nNote:\n You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as \neval()\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"3+2*2\"\n\nOutput:\n 7\n\nExample 2:\n\n\nInput:\n s = \" 3/2 \"\n\nOutput:\n 1\n\nExample 3:\n\n\nInput:\n s = \" 3+5 / 2 \"\n\nOutput:\n 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 3 * 10\n5\n\n\ns\n consists of integers and operators \n('+', '-', '*', '/')\n separated by some number of spaces.\n\n\ns\n represents \na valid expression\n.\n\n\nAll the integers in the expression are non-negative integers in the range \n[0, 2\n31\n - 1]\n.\n\n\nThe answer is \nguaranteed\n to fit in a \n32-bit integer\n.",
      "solution": "\nimport operator\n\nclass Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def compute(operands, operators):\n            right, left = operands.pop(), operands.pop()\n            operands.append(ops[operators.pop()](left, right))\n\n        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}\n        precedence = {'+':0, '-':0, '*':1, '/':1}\n        operands, operators, operand = [], [], 0\n        for i in xrange(len(s)):\n            if s[i].isdigit():\n                operand = operand*10 + int(s[i])\n                if i == len(s)-1 or not s[i+1].isdigit():\n                    operands.append(operand)\n                    operand = 0\n            elif s[i] == '(':\n                operators.append(s[i])\n            elif s[i] == ')':\n                while operators[-1] != '(':\n                    compute(operands, operators)\n                operators.pop()\n            elif s[i] in precedence:\n                while operators and operators[-1] in precedence and \\\n                      precedence[operators[-1]] >= precedence[s[i]]:\n                    compute(operands, operators)\n                operators.append(s[i])\n        while operators:\n            compute(operands, operators)\n        return operands[-1]\n\nclass Solution2(object):\n    # @param {string} s\n    # @return {integer}\n    def calculate(self, s):\n        operands, operators = [], []\n        operand = \"\"\n        for i in reversed(xrange(len(s))):\n            if s[i].isdigit():\n                operand += s[i]\n                if i == 0 or not s[i-1].isdigit():\n                    operands.append(int(operand[::-1]))\n                    operand = \"\"\n            elif s[i] == ')' or s[i] == '*' or s[i] == '/':\n                operators.append(s[i])\n            elif s[i] == '+' or s[i] == '-':\n                while operators and \\\n                      (operators[-1] == '*' or operators[-1] == '/'):\n                    self.compute(operands, operators)\n                operators.append(s[i])\n            elif s[i] == '(':\n                while operators[-1] != ')':\n                    self.compute(operands, operators)\n                operators.pop()\n\n        while operators:\n            self.compute(operands, operators)\n\n        return operands[-1]\n\n    def compute(self, operands, operators):\n        left, right = operands.pop(), operands.pop()\n        op = operators.pop()\n        if op == '+':\n            operands.append(left + right)\n        elif op == '-':\n            operands.append(left - right)\n        elif op == '*':\n            operands.append(left * right)\n        elif op == '/':\n            operands.append(left / right)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Lowest Common Ancestor of a Binary Tree",
      "difficulty": "MEDIUM",
      "category": "Tree, Depth-First Search, Binary Tree",
      "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree",
      "slug": "lowest-common-ancestor-of-a-binary-tree",
      "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\n\nAccording to the \ndefinition of LCA on Wikipedia\n: “The lowest common ancestor is defined between two nodes \np\n and \nq\n as the lowest node in \nT\n that has both \np\n and \nq\n as descendants (where we allow \na node to be a descendant of itself\n).”\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n\nOutput:\n 3\n\nExplanation:\n The LCA of nodes 5 and 1 is 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n\nOutput:\n 5\n\nExplanation:\n The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [1,2], p = 1, q = 2\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 10\n5\n]\n.\n\n\n-10\n9\n <= Node.val <= 10\n9\n\n\nAll \nNode.val\n are \nunique\n.\n\n\np != q\n\n\np\n and \nq\n will exist in the tree.",
      "solution": "class Solution(object):\n    # @param {TreeNode} root\n    # @param {TreeNode} p\n    # @param {TreeNode} q\n    # @return {TreeNode}\n    def lowestCommonAncestor(self, root, p, q):\n        if root in (None, p, q):\n            return root\n\n        left, right = [self.lowestCommonAncestor(child, p, q) \\\n                         for child in (root.left, root.right)]\n        # 1. If the current subtree contains both p and q,\n        #    return their LCA.\n        # 2. If only one of them is in that subtree,\n        #    return that one of them.\n        # 3. If neither of them is in that subtree,\n        #    return the node of that subtree.\n        return root if left and right else left or right",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Find Peak Element",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/find-peak-element",
      "slug": "find-peak-element",
      "description": "A peak element is an element that is strictly greater than its neighbors.\n\n\nGiven a \n0-indexed\n integer array \nnums\n, find a peak element, and return its index. If the array contains multiple peaks, return the index to \nany of the peaks\n.\n\n\nYou may imagine that \nnums[-1] = nums[n] = -∞\n. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\n\nYou must write an algorithm that runs in \nO(log n)\n time.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,1]\n\nOutput:\n 2\n\nExplanation:\n 3 is a peak element and your function should return the index number 2.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,1,3,5,6,4]\n\nOutput:\n 5\n\nExplanation:\n Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\nnums[i] != nums[i + 1]\n for all valid \ni\n.",
      "solution": "class Solution(object):\n    def findPeakElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            mid = left + (right - left) / 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Nested List Weight Sum",
      "difficulty": "MEDIUM",
      "category": "Depth-First Search, Breadth-First Search",
      "link": "https://leetcode.com/problems/nested-list-weight-sum",
      "slug": "nested-list-weight-sum",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "class Solution(object):\n    def depthSum(self, nestedList):\n        \"\"\"\n        :type nestedList: List[NestedInteger]\n        :rtype: int\n        \"\"\"\n        def depthSumHelper(nestedList, depth):\n            res = 0\n            for l in nestedList:\n                if l.isInteger():\n                    res += l.getInteger() * depth\n                else:\n                    res += depthSumHelper(l.getList(), depth + 1)\n            return res\n        return depthSumHelper(nestedList, 1)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Random Pick with Weight",
      "difficulty": "MEDIUM",
      "category": "Array, Math, Binary Search, Prefix Sum, Randomized",
      "link": "https://leetcode.com/problems/random-pick-with-weight",
      "slug": "random-pick-with-weight",
      "description": "You are given a \n0-indexed\n array of positive integers \nw\n where \nw[i]\n describes the \nweight\n of the \ni\nth\n index.\n\n\nYou need to implement the function \npickIndex()\n, which \nrandomly\n picks an index in the range \n[0, w.length - 1]\n (\ninclusive\n) and returns it. The \nprobability\n of picking an index \ni\n is \nw[i] / sum(w)\n.\n\n\n\n\nFor example, if \nw = [1, 3]\n, the probability of picking index \n0\n is \n1 / (1 + 3) = 0.25\n (i.e., \n25%\n), and the probability of picking index \n1\n is \n3 / (1 + 3) = 0.75\n (i.e., \n75%\n).\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"Solution\",\"pickIndex\"]\n[[[1]],[]]\n\nOutput\n\n[null,0]\n\n\nExplanation\n\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.\n\n\n\nExample 2:\n\n\n\n\nInput\n\n[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]\n[[[1,3]],[],[],[],[],[]]\n\nOutput\n\n[null,1,1,1,1,0]\n\n\nExplanation\n\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.\n\nSince this is a randomization problem, multiple answers are allowed.\nAll of the following outputs can be considered correct:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\nand so on.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= w.length <= 10\n4\n\n\n1 <= w[i] <= 10\n5\n\n\npickIndex\n will be called at most \n10\n4\n times.",
      "solution": "#        pickIndex: O(logn)\n\nimport random\nimport bisect\n\nclass Solution(object):\n\n    def __init__(self, w):\n        \"\"\"\n        :type w: List[int]\n        \"\"\"\n        self.__prefix_sum = list(w)\n        for i in xrange(1, len(w)):\n            self.__prefix_sum[i] += self.__prefix_sum[i-1]\n\n    def pickIndex(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        target = random.randint(0, self.__prefix_sum[-1]-1)\n        return bisect.bisect_right(self.__prefix_sum, target)",
      "explanation": "N/A",
      "time_complexity": "ctor: O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Sum Root to Leaf Numbers",
      "difficulty": "MEDIUM",
      "category": "Tree, Depth-First Search, Binary Tree",
      "link": "https://leetcode.com/problems/sum-root-to-leaf-numbers",
      "slug": "sum-root-to-leaf-numbers",
      "description": "You are given the \nroot\n of a binary tree containing digits from \n0\n to \n9\n only.\n\n\nEach root-to-leaf path in the tree represents a number.\n\n\n\n\nFor example, the root-to-leaf path \n1 -> 2 -> 3\n represents the number \n123\n.\n\n\n\n\nReturn \nthe total sum of all root-to-leaf numbers\n. Test cases are generated so that the answer will fit in a \n32-bit\n integer.\n\n\nA \nleaf\n node is a node with no children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3]\n\nOutput:\n 25\n\nExplanation:\n\nThe root-to-leaf path \n1->2\n represents the number \n12\n.\nThe root-to-leaf path \n1->3\n represents the number \n13\n.\nTherefore, sum = 12 + 13 = \n25\n.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [4,9,0,5,1]\n\nOutput:\n 1026\n\nExplanation:\n\nThe root-to-leaf path \n4->9->5\n represents the number 495.\nThe root-to-leaf path \n4->9->1\n represents the number 491.\nThe root-to-leaf path \n4->0\n represents the number 40.\nTherefore, sum = 495 + 491 + 40 = \n1026\n.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\n0 <= Node.val <= 9\n\n\nThe depth of the tree will not exceed \n10\n.",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\nclass Solution(object):\n    # @param root, a tree node\n    # @return an integer\n    def sumNumbers(self, root):\n        return self.sumNumbersRecu(root, 0)\n\n    def sumNumbersRecu(self, root, num):\n        if root is None:\n            return 0\n\n        if root.left is None and root.right is None:\n            return num * 10 + root.val\n\n        return self.sumNumbersRecu(root.left, num * 10 + root.val) + self.sumNumbersRecu(root.right, num * 10 + root.val)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h), h is height of binary tree"
    },
    {
      "title": "Diameter of Binary Tree",
      "difficulty": "EASY",
      "category": "Tree, Depth-First Search, Binary Tree",
      "link": "https://leetcode.com/problems/diameter-of-binary-tree",
      "slug": "diameter-of-binary-tree",
      "description": "Given the \nroot\n of a binary tree, return \nthe length of the \ndiameter\n of the tree\n.\n\n\nThe \ndiameter\n of a binary tree is the \nlength\n of the longest path between any two nodes in a tree. This path may or may not pass through the \nroot\n.\n\n\nThe \nlength\n of a path between two nodes is represented by the number of edges between them.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5]\n\nOutput:\n 3\n\nExplanation:\n 3 is the length of the path [4,2,1,3] or [5,2,1,3].\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1,2]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-100 <= Node.val <= 100",
      "solution": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def diameterOfBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def iter_dfs(node):\n            result = 0\n            stk = [(1, [node, [0]])]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, ret = params\n                    if not node:\n                        continue\n                    ret1, ret2 = [0], [0]\n                    stk.append((2, [node, ret1, ret2, ret]))\n                    stk.append((1, [node.right, ret2]))\n                    stk.append((1, [node.left, ret1]))\n                elif step == 2:\n                    node, ret1, ret2, ret = params\n                    result = max(result, ret1[0]+ret2[0])\n                    ret[0] = 1+max(ret1[0], ret2[0])\n            return result\n        \n        return iter_dfs(root)\n\nclass Solution2(object):\n    def diameterOfBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(root):\n            if not root: \n                return 0, 0\n            left_d, left_h = dfs(root.left)\n            right_d, right_h = dfs(root.right)\n            return max(left_d, right_d, left_h+right_h), 1+max(left_h, right_h)\n \n        return dfs(root)[0]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Top K Frequent Elements",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Divide and Conquer, Sorting, Heap (Priority Queue), Bucket Sort, Counting, Quickselect",
      "link": "https://leetcode.com/problems/top-k-frequent-elements",
      "slug": "top-k-frequent-elements",
      "description": "Given an integer array \nnums\n and an integer \nk\n, return \nthe\n \nk\n \nmost frequent elements\n. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,1,1,2,2,3], k = 2\n\nOutput:\n [1,2]\n\nExample 2:\n\n\nInput:\n nums = [1], k = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nk\n is in the range \n[1, the number of unique elements in the array]\n.\n\n\nIt is \nguaranteed\n that the answer is \nunique\n.\n\n\n\n\n \n\n\nFollow up:\n Your algorithm's time complexity must be better than \nO(n log n)\n, where n is the array's size.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        counts = collections.Counter(nums)\n        buckets = [[] for _ in xrange(len(nums)+1)]\n        for i, count in counts.iteritems():\n            buckets[count].append(i)\n\n        result = []\n        for i in reversed(xrange(len(buckets))):\n            for j in xrange(len(buckets[i])):\n                result.append(buckets[i][j])\n                if len(result) == k:\n                    return result\n        return result\n\n\n# Quick Select Solution\nfrom random import randintclass Solution2(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        counts = collections.Counter(nums)\n        p = []\n        for key, val in counts.iteritems():\n            p.append((-val, key))\n        self.kthElement(p, k-1)\n\n        result = []\n        for i in xrange(k):\n            result.append(p[i][1])\n        return result\n\n    def kthElement(self, nums, k):\n        def PartitionAroundPivot(left, right, pivot_idx, nums):\n            pivot_value = nums[pivot_idx]\n            new_pivot_idx = left\n            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n            for i in xrange(left, right):\n                if nums[i] < pivot_value:\n                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                    new_pivot_idx += 1\n\n            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n            return new_pivot_idx\n\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k:\n                return\n            elif new_pivot_idx > k:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k.\n                left = new_pivot_idx + 1\n\nclass Solution3(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        return [key for key, _ in collections.Counter(nums).most_common(k)]",
      "explanation": "N/A",
      "time_complexity": "O(nlogk)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Merge Intervals",
      "difficulty": "MEDIUM",
      "category": "Array, Sorting",
      "link": "https://leetcode.com/problems/merge-intervals",
      "slug": "merge-intervals",
      "description": "Given an array of \nintervals\n where \nintervals[i] = [start\ni\n, end\ni\n]\n, merge all overlapping intervals, and return \nan array of the non-overlapping intervals that cover all the intervals in the input\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n intervals = [[1,3],[2,6],[8,10],[15,18]]\n\nOutput:\n [[1,6],[8,10],[15,18]]\n\nExplanation:\n Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\n\n\nExample 2:\n\n\n\n\nInput:\n intervals = [[1,4],[4,5]]\n\nOutput:\n [[1,5]]\n\nExplanation:\n Intervals [1,4] and [4,5] are considered overlapping.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= intervals.length <= 10\n4\n\n\nintervals[i].length == 2\n\n\n0 <= start\ni\n <= end\ni\n <= 10\n4",
      "solution": "class Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        intervals.sort()\n        result = []\n        for interval in intervals:\n            if not result or interval[0] > result[-1][1]:\n                result.append(interval)\n            else:\n                result[-1][1] = max(result[-1][1], interval[1])\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Two Sum",
      "difficulty": "EASY",
      "category": "Array, Hash Table",
      "link": "https://leetcode.com/problems/two-sum",
      "slug": "two-sum",
      "description": "Given an array of integers \nnums\n and an integer \ntarget\n, return \nindices of the two numbers such that they add up to \ntarget\n.\n\n\nYou may assume that each input would have \nexactly\n one solution\n, and you may not use the \nsame\n element twice.\n\n\nYou can return the answer in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,7,11,15], target = 9\n\nOutput:\n [0,1]\n\nExplanation:\n Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,4], target = 6\n\nOutput:\n [1,2]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,3], target = 6\n\nOutput:\n [0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n-10\n9\n <= target <= 10\n9\n\n\nOnly one valid answer exists.\n\n\n\n\n \n\n\nFollow-up: \nCan you come up with an algorithm that is less than \nO(n\n2\n)\n \ntime complexity?",
      "solution": "from typing import List\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n\n        for idx in range(len(nums)):\n            val = target - nums[idx]\n            if val in seen:\n                return [idx, seen[val]]\n            else:\n                seen[nums[idx]] = idx",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Best Time to Buy and Sell Stock",
      "difficulty": "EASY",
      "category": "Array, Dynamic Programming",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
      "slug": "best-time-to-buy-and-sell-stock",
      "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nYou want to maximize your profit by choosing a \nsingle day\n to buy one stock and choosing a \ndifferent day in the future\n to sell that stock.\n\n\nReturn \nthe maximum profit you can achieve from this transaction\n. If you cannot achieve any profit, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 5\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transactions are done and the max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n4",
      "solution": "class Solution:\n    def maxProfit(self, prices) -> int:\n        profit = 0\n        buy = prices[0]\n\n        for price in range(1, len(prices)):\n            profit = max(profit, prices[price] - buy)\n            buy = min(prices[price], buy)\n\n        return profit",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Merge k Sorted Lists",
      "difficulty": "HARD",
      "category": "Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort",
      "link": "https://leetcode.com/problems/merge-k-sorted-lists",
      "slug": "merge-k-sorted-lists",
      "description": "You are given an array of \nk\n linked-lists \nlists\n, each linked-list is sorted in ascending order.\n\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n lists = [[1,4,5],[1,3,4],[2,6]]\n\nOutput:\n [1,1,2,3,4,4,5,6]\n\nExplanation:\n The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted linked list:\n1->1->2->3->4->4->5->6\n\n\n\nExample 2:\n\n\n\n\nInput:\n lists = []\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n lists = [[]]\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nk == lists.length\n\n\n0 <= k <= 10\n4\n\n\n0 <= lists[i].length <= 500\n\n\n-10\n4\n <= lists[i][j] <= 10\n4\n\n\nlists[i]\n is sorted in \nascending order\n.\n\n\nThe sum of \nlists[i].length\n will not exceed \n10\n4\n.",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\t\t\n        if self:\t\t\n            return \"{} -> {}\".format(self.val, self.next)\n\n\n# Merge two by two solution.class Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        if not lists:\n            return None\n        left, right = 0, len(lists) - 1\n        while right > 0:\n            lists[left] = mergeTwoLists(lists[left], lists[right])\n            left += 1\n            right -= 1\n            if left >= right:\n                left = 0\n        return lists[0]\n\n\n# Divide and Conquer solution.class Solution2(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        def mergeKListsHelper(lists, begin, end):\n            if begin > end:\n                return None\n            if begin == end:\n                return lists[begin]\n            return mergeTwoLists(mergeKListsHelper(lists, begin, (begin + end) / 2), \\\n                                 mergeKListsHelper(lists, (begin + end) / 2 + 1, end))\n\n        return mergeKListsHelper(lists, 0, len(lists) - 1)\n\n\n# Heap solution.\nimport heapqclass Solution3(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        dummy = ListNode(0)\n        current = dummy\n\n        heap = []\n        for sorted_list in lists:\n            if sorted_list:\n                heapq.heappush(heap, (sorted_list.val, sorted_list))\n\n        while heap:\n            smallest = heapq.heappop(heap)[1]\n            current.next = smallest\n            current = current.next\n            if smallest.next:\n                heapq.heappush(heap, (smallest.next.val, smallest.next))\n\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(nlogk)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Valid Parentheses",
      "difficulty": "EASY",
      "category": "String, Stack",
      "link": "https://leetcode.com/problems/valid-parentheses",
      "slug": "valid-parentheses",
      "description": "Given a string \ns\n containing just the characters \n'('\n, \n')'\n, \n'{'\n, \n'}'\n, \n'['\n and \n']'\n, determine if the input string is valid.\n\n\nAn input string is valid if:\n\n\n\n\nOpen brackets must be closed by the same type of brackets.\n\n\nOpen brackets must be closed in the correct order.\n\n\nEvery close bracket has a corresponding open bracket of the same type.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"()\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"()[]{}\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"(]\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"([])\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"([)]\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of parentheses only \n'()[]{}'\n.",
      "solution": "class Solution(object):\n    # @return a boolean\n    def isValid(self, s):\n        stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        for parenthese in s:\n            if parenthese in lookup:\n                stack.append(parenthese)\n            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:\n                return False\n        return len(stack) == 0",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Pow(x, n)",
      "difficulty": "MEDIUM",
      "category": "Math, Recursion",
      "link": "https://leetcode.com/problems/powx-n",
      "slug": "powx-n",
      "description": "Implement \npow(x, n)\n, which calculates \nx\n raised to the power \nn\n (i.e., \nx\nn\n).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 2.00000, n = 10\n\nOutput:\n 1024.00000\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = 2.10000, n = 3\n\nOutput:\n 9.26100\n\n\n\nExample 3:\n\n\n\n\nInput:\n x = 2.00000, n = -2\n\nOutput:\n 0.25000\n\nExplanation:\n 2\n-2\n = 1/2\n2\n = 1/4 = 0.25\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-100.0 < x < 100.0\n\n\n-2\n31\n <= n <= 2\n31\n-1\n\n\nn\n is an integer.\n\n\nEither \nx\n is not zero or \nn > 0\n.\n\n\n-10\n4\n <= x\nn\n <= 10\n4",
      "solution": "class Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        result = 1\n        abs_n = abs(n)\n        while abs_n:\n            if abs_n & 1:\n                result *= x\n            abs_n >>= 1\n            x *= x\n\n        return 1 / result if n < 0 else result\n\n\n# Recursive solution.class Solution2(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        if n < 0 and n != -n:\n            return 1.0 / self.myPow(x, -n)\n        if n == 0:\n            return 1\n        v = self.myPow(x, n / 2)\n        if n % 2 == 0:\n            return v * v\n        else:\n            return v * v * x",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(logn)"
    },
    {
      "title": "Buildings With an Ocean View",
      "difficulty": "MEDIUM",
      "category": "Array, Stack, Monotonic Stack",
      "link": "https://leetcode.com/problems/buildings-with-an-ocean-view",
      "slug": "buildings-with-an-ocean-view",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "class Solution(object):\n    def findBuildings(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i, h in enumerate(heights):\n            while result and heights[result[-1]] <= h:\n                result.pop()\n            result.append(i)\n        return result\n\nclass Solution2(object):\n    def findBuildings(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i in reversed(xrange(len(heights))):\n            if not result or heights[result[-1]] < heights[i]:\n                result.append(i)\n        result.reverse()\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Custom Sort String",
      "difficulty": "MEDIUM",
      "category": "Hash Table, String, Sorting",
      "link": "https://leetcode.com/problems/custom-sort-string",
      "slug": "custom-sort-string",
      "description": "You are given two strings \norder\n and \ns\n. All the characters of \norder\n are \nunique\n and were sorted in some custom order previously.\n\n\nPermute the characters of \ns\n so that they match the order that \norder\n was sorted. More specifically, if a character \nx\n occurs before a character \ny\n in \norder\n, then \nx\n should occur before \ny\n in the permuted string.\n\n\nReturn \nany permutation of \ns\n that satisfies this property\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput: \n \n order = \"cba\", s = \"abcd\" \n\n\nOutput: \n \n \"cbad\" \n\n\nExplanation: \n \n\"a\"\n, \n\"b\"\n, \n\"c\"\n appear in order, so the order of \n\"a\"\n, \n\"b\"\n, \n\"c\"\n should be \n\"c\"\n, \n\"b\"\n, and \n\"a\"\n.\n\n\nSince \n\"d\"\n does not appear in \norder\n, it can be at any position in the returned string. \n\"dcba\"\n, \n\"cdba\"\n, \n\"cbda\"\n are also valid outputs.\n\n\n\n\nExample 2:\n\n\n\n\nInput: \n \n order = \"bcafg\", s = \"abcd\" \n\n\nOutput: \n \n \"bcad\" \n\n\nExplanation: \n The characters \n\"b\"\n, \n\"c\"\n, and \n\"a\"\n from \norder\n dictate the order for the characters in \ns\n. The character \n\"d\"\n in \ns\n does not appear in \norder\n, so its position is flexible.\n\n\nFollowing the order of appearance in \norder\n, \n\"b\"\n, \n\"c\"\n, and \n\"a\"\n from \ns\n should be arranged as \n\"b\"\n, \n\"c\"\n, \n\"a\"\n. \n\"d\"\n can be placed at any position since it's not in order. The output \n\"bcad\"\n correctly follows this rule. Other arrangements like \n\"dbca\"\n or \n\"bcda\"\n would also be valid, as long as \n\"b\"\n, \n\"c\"\n, \n\"a\"\n maintain their order.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= order.length <= 26\n\n\n1 <= s.length <= 200\n\n\norder\n and \ns\n consist of lowercase English letters.\n\n\nAll the characters of \norder\n are \nunique\n.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def customSortString(self, S, T):\n        \"\"\"\n        :type S: str\n        :type T: str\n        :rtype: str\n        \"\"\"\n        counter, s = collections.Counter(T), set(S)\n        result = [c*counter[c] for c in S]\n        result.extend([c*counter for c, counter in counter.iteritems() if c not in s])\n        return \"\".join(result)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "K Closest Points to Origin",
      "difficulty": "MEDIUM",
      "category": "Array, Math, Divide and Conquer, Geometry, Sorting, Heap (Priority Queue), Quickselect",
      "link": "https://leetcode.com/problems/k-closest-points-to-origin",
      "slug": "k-closest-points-to-origin",
      "description": "Given an array of \npoints\n where \npoints[i] = [x\ni\n, y\ni\n]\n represents a point on the \nX-Y\n plane and an integer \nk\n, return the \nk\n closest points to the origin \n(0, 0)\n.\n\n\nThe distance between two points on the \nX-Y\n plane is the Euclidean distance (i.e., \n√(x\n1\n - x\n2\n)\n2\n + (y\n1\n - y\n2\n)\n2\n).\n\n\nYou may return the answer in \nany order\n. The answer is \nguaranteed\n to be \nunique\n (except for the order that it is in).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[1,3],[-2,2]], k = 1\n\nOutput:\n [[-2,2]]\n\nExplanation:\n\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[3,3],[5,-1],[-2,4]], k = 2\n\nOutput:\n [[3,3],[-2,4]]\n\nExplanation:\n The answer [[-2,4],[3,3]] would also be accepted.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= points.length <= 10\n4\n\n\n-10\n4\n <= x\ni\n, y\ni\n <= 10\n4",
      "solution": "\n# quick select solution\nfrom random import randint\n\nclass Solution(object):\n    def kClosest(self, points, K):\n        \"\"\"\n        :type points: List[List[int]]\n        :type K: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def dist(point):\n            return point[0]**2 + point[1]**2\n        \n        def kthElement(nums, k, compare):\n            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):\n                new_pivot_idx = left\n                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                for i in xrange(left, right):\n                    if compare(nums[i], nums[right]):\n                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                        new_pivot_idx += 1\n\n                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                return new_pivot_idx\n\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)\n                if new_pivot_idx == k:\n                    return\n                elif new_pivot_idx > k:\n                    right = new_pivot_idx - 1\n                else:  # new_pivot_idx < k.\n                    left = new_pivot_idx + 1\n                    \n        kthElement(points, K-1, lambda a, b: dist(a) < dist(b))\n        return points[:K]\n\n    \nimport heapq\n\nclass Solution2(object):\n    def kClosest(self, points, K):\n        \"\"\"\n        :type points: List[List[int]]\n        :type K: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def dist(point):\n            return point[0]**2 + point[1]**2\n        \n        max_heap = []\n        for point in points:\n            heapq.heappush(max_heap, (-dist(point), point))\n            if len(max_heap) > K:\n                heapq.heappop(max_heap)\n        return [heapq.heappop(max_heap)[1] for _ in xrange(len(max_heap))]",
      "explanation": "N/A",
      "time_complexity": "O(nlogk)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Clone Graph",
      "difficulty": "MEDIUM",
      "category": "Hash Table, Depth-First Search, Breadth-First Search, Graph",
      "link": "https://leetcode.com/problems/clone-graph",
      "slug": "clone-graph",
      "description": "Given a reference of a node in a \nconnected\n undirected graph.\n\n\nReturn a \ndeep copy\n (clone) of the graph.\n\n\nEach node in the graph contains a value (\nint\n) and a list (\nList[Node]\n) of its neighbors.\n\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n\n\n\n \n\n\nTest case format:\n\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with \nval == 1\n, the second node with \nval == 2\n, and so on. The graph is represented in the test case using an adjacency list.\n\n\nAn adjacency list\n is a collection of unordered \nlists\n used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\n\nThe given node will always be the first node with \nval = 1\n. You must return the \ncopy of the given node\n as a reference to the cloned graph.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n adjList = [[2,4],[1,3],[2,4],[1,3]]\n\nOutput:\n [[2,4],[1,3],[2,4],[1,3]]\n\nExplanation:\n There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n adjList = [[]]\n\nOutput:\n [[]]\n\nExplanation:\n Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n\n\n\nExample 3:\n\n\n\n\nInput:\n adjList = []\n\nOutput:\n []\n\nExplanation:\n This an empty graph, it does not have any nodes.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the graph is in the range \n[0, 100]\n.\n\n\n1 <= Node.val <= 100\n\n\nNode.val\n is unique for each node.\n\n\nThere are no repeated edges and no self-loops in the graph.\n\n\nThe Graph is connected and all nodes can be visited starting from the given node.",
      "solution": "class UndirectedGraphNode(object):\n    def __init__(self, x):\n        self.label = x\n        self.neighbors = []\nclass Solution(object):\n    # @param node, a undirected graph node\n    # @return a undirected graph node\n    def cloneGraph(self, node):\n        if node is None:\n            return None\n        cloned_node = UndirectedGraphNode(node.label)\n        cloned, queue = {node:cloned_node}, [node]\n\n        while queue:\n            current = queue.pop()\n            for neighbor in current.neighbors:\n                if neighbor not in cloned:\n                    queue.append(neighbor)\n                    cloned_neighbor = UndirectedGraphNode(neighbor.label)\n                    cloned[neighbor] = cloned_neighbor\n                cloned[current].neighbors.append(cloned[neighbor])\n        return cloned[node]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Subarray Sum Equals K",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Prefix Sum",
      "link": "https://leetcode.com/problems/subarray-sum-equals-k",
      "slug": "subarray-sum-equals-k",
      "description": "Given an array of integers \nnums\n and an integer \nk\n, return \nthe total number of subarrays whose sum equals to\n \nk\n.\n\n\nA subarray is a contiguous \nnon-empty\n sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,1,1], k = 2\n\nOutput:\n 2\n\nExample 2:\n\n\nInput:\n nums = [1,2,3], k = 3\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2 * 10\n4\n\n\n-1000 <= nums[i] <= 1000\n\n\n-10\n7\n <= k <= 10\n7",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def subarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        accumulated_sum = 0\n        lookup = collections.defaultdict(int)\n        lookup[0] += 1\n        for num in nums:\n            accumulated_sum += num\n            result += lookup[accumulated_sum - k]\n            lookup[accumulated_sum] += 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Range Sum of BST",
      "difficulty": "EASY",
      "category": "Tree, Depth-First Search, Binary Search Tree, Binary Tree",
      "link": "https://leetcode.com/problems/range-sum-of-bst",
      "slug": "range-sum-of-bst",
      "description": "Given the \nroot\n node of a binary search tree and two integers \nlow\n and \nhigh\n, return \nthe sum of values of all nodes with a value in the \ninclusive\n range \n[low, high]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [10,5,15,3,7,null,18], low = 7, high = 15\n\nOutput:\n 32\n\nExplanation:\n Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\n\nOutput:\n 23\n\nExplanation:\n Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 2 * 10\n4\n]\n.\n\n\n1 <= Node.val <= 10\n5\n\n\n1 <= low <= high <= 10\n5\n\n\nAll \nNode.val\n are \nunique\n.",
      "solution": "\n# Definition for a binary tree node.class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def rangeSumBST(self, root, L, R):\n        \"\"\"\n        :type root: TreeNode\n        :type L: int\n        :type R: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        s = [root]\n        while s:\n            node = s.pop()\n            if node:\n                if L <= node.val <= R:\n                    result += node.val\n                if L < node.val:\n                    s.append(node.left)\n                if node.val < R:\n                    s.append(node.right)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Dot Product of Two Sparse Vectors",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Two Pointers, Design",
      "link": "https://leetcode.com/problems/dot-product-of-two-sparse-vectors",
      "slug": "dot-product-of-two-sparse-vectors",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "#        dot_product: O(min(n, m))\nclass SparseVector:\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        self.lookup = {i:v for i, v in enumerate(nums) if v}\n\n    def dotProduct(self, vec):\n        \"\"\"\n        :type vec: 'SparseVector'\n        :rtype: int\n        \"\"\"\n        if len(self.lookup) > len(vec.lookup):\n            self, vec = vec, self\n        return sum(v*vec.lookup[i] for i, v in self.lookup.iteritems() if i in vec.lookup)",
      "explanation": "N/A",
      "time_complexity": "ctor: O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Valid Palindrome",
      "difficulty": "EASY",
      "category": "Two Pointers, String",
      "link": "https://leetcode.com/problems/valid-palindrome",
      "slug": "valid-palindrome",
      "description": "A phrase is a \npalindrome\n if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\n\nGiven a string \ns\n, return \ntrue\n if it is a \npalindrome\n, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"A man, a plan, a canal: Panama\"\n\nOutput:\n true\n\nExplanation:\n \"amanaplanacanalpanama\" is a palindrome.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"race a car\"\n\nOutput:\n false\n\nExplanation:\n \"raceacar\" is not a palindrome.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \" \"\n\nOutput:\n true\n\nExplanation:\n s is an empty string \"\" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 2 * 10\n5\n\n\ns\n consists only of printable ASCII characters.",
      "solution": "class Solution(object):\n    # @param s, a string\n    # @return a boolean\n    def isPalindrome(self, s):\n        i, j = 0, len(s) - 1\n        while i < j:\n            while i < j and not s[i].isalnum():\n                i += 1\n            while i < j and not s[j].isalnum():\n                j -= 1\n            if s[i].lower() != s[j].lower():\n                return False\n            i, j = i + 1, j - 1\n        return True",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Next Permutation",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers",
      "link": "https://leetcode.com/problems/next-permutation",
      "slug": "next-permutation",
      "description": "A \npermutation\n of an array of integers is an arrangement of its members into a sequence or linear order.\n\n\n\n\nFor example, for \narr = [1,2,3]\n, the following are all the permutations of \narr\n: \n[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]\n.\n\n\n\n\nThe \nnext permutation\n of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the \nnext permutation\n of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n\n\n\nFor example, the next permutation of \narr = [1,2,3]\n is \n[1,3,2]\n.\n\n\nSimilarly, the next permutation of \narr = [2,3,1]\n is \n[3,1,2]\n.\n\n\nWhile the next permutation of \narr = [3,2,1]\n is \n[1,2,3]\n because \n[3,2,1]\n does not have a lexicographical larger rearrangement.\n\n\n\n\nGiven an array of integers \nnums\n, \nfind the next permutation of\n \nnums\n.\n\n\nThe replacement must be \nin place\n and use only constant extra memory.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n [1,3,2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,1]\n\nOutput:\n [1,2,3]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,1,5]\n\nOutput:\n [1,5,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 100",
      "solution": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in reversed(xrange(len(nums)-1)):\n            if nums[i] < nums[i+1]:\n                k = i\n                break\n        else:\n            nums.reverse()\n            return\n\n        for i in reversed(xrange(k+1, len(nums))):\n            if nums[i] > nums[k]:\n                l = i\n                break\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]\n        \nclass Solution2(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in xrange(len(nums)-1):\n            if nums[i] < nums[i+1]:\n                k = i\n\n        if k == -1:\n            nums.reverse()\n            return\n\n        for i in xrange(k+1, len(nums)):\n            if nums[i] > nums[k]:\n                l = i\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Shortest Path in Binary Matrix",
      "difficulty": "MEDIUM",
      "category": "Array, Breadth-First Search, Matrix",
      "link": "https://leetcode.com/problems/shortest-path-in-binary-matrix",
      "slug": "shortest-path-in-binary-matrix",
      "description": "Given an \nn x n\n binary matrix \ngrid\n, return \nthe length of the shortest \nclear path\n in the matrix\n. If there is no clear path, return \n-1\n.\n\n\nA \nclear path\n in a binary matrix is a path from the \ntop-left\n cell (i.e., \n(0, 0)\n) to the \nbottom-right\n cell (i.e., \n(n - 1, n - 1)\n) such that:\n\n\n\n\nAll the visited cells of the path are \n0\n.\n\n\nAll the adjacent cells of the path are \n8-directionally\n connected (i.e., they are different and they share an edge or a corner).\n\n\n\n\nThe \nlength of a clear path\n is the number of visited cells of this path.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,1],[1,0]]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,0,0],[1,1,0],[1,1,0]]\n\nOutput:\n 4\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[1,0,0],[1,1,0],[1,1,0]]\n\nOutput:\n -1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\nn == grid[i].length\n\n\n1 <= n <= 100\n\n\ngrid[i][j] is 0 or 1",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def shortestPathBinaryMatrix(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(-1, -1), (-1, 0), (-1, 1), \\\n                      ( 0, -1), ( 0, 1), \\\n                      ( 1, -1), ( 1, 0), ( 1, 1)]\n        result = 0\n        q = collections.deque([(0, 0)])\n        while q:\n            result += 1\n            next_depth = collections.deque()\n            while q:\n                i, j = q.popleft()\n                if 0 <= i < len(grid) and \\\n                   0 <= j < len(grid[0]) and \\\n                    not grid[i][j]:\n                    grid[i][j] = 1\n                    if i == len(grid)-1 and j == len(grid)-1:\n                        return result\n                    for d in directions:\n                        next_depth.append((i+d[0], j+d[1]))\n            q = next_depth\n        return -1",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Copy List with Random Pointer",
      "difficulty": "MEDIUM",
      "category": "Hash Table, Linked List",
      "link": "https://leetcode.com/problems/copy-list-with-random-pointer",
      "slug": "copy-list-with-random-pointer",
      "description": "A linked list of length \nn\n is given such that each node contains an additional random pointer, which could point to any node in the list, or \nnull\n.\n\n\nConstruct a \ndeep copy\n of the list. The deep copy should consist of exactly \nn\n \nbrand new\n nodes, where each new node has its value set to the value of its corresponding original node. Both the \nnext\n and \nrandom\n pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. \nNone of the pointers in the new list should point to nodes in the original list\n.\n\n\nFor example, if there are two nodes \nX\n and \nY\n in the original list, where \nX.random --> Y\n, then for the corresponding two nodes \nx\n and \ny\n in the copied list, \nx.random --> y\n.\n\n\nReturn \nthe head of the copied linked list\n.\n\n\nThe linked list is represented in the input/output as a list of \nn\n nodes. Each node is represented as a pair of \n[val, random_index]\n where:\n\n\n\n\nval\n: an integer representing \nNode.val\n\n\nrandom_index\n: the index of the node (range from \n0\n to \nn-1\n) that the \nrandom\n pointer points to, or \nnull\n if it does not point to any node.\n\n\n\n\nYour code will \nonly\n be given the \nhead\n of the original linked list.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n\nOutput:\n [[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [[1,1],[2,1]]\n\nOutput:\n [[1,1],[2,1]]\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n head = [[3,null],[3,0],[3,null]]\n\nOutput:\n [[3,null],[3,0],[3,null]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 1000\n\n\n-10\n4\n <= Node.val <= 10\n4\n\n\nNode.random\n is \nnull\n or is pointing to some node in the linked list.",
      "solution": "class Node(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n        self.random = None\nclass Solution(object):\n    # @param head, a RandomListNode\n    # @return a RandomListNode\n    def copyRandomList(self, head):\n        # copy and combine copied list with original list\n        current = head\n        while current:\n            copied = Node(current.val)\n            copied.next = current.next\n            current.next = copied\n            current = copied.next\n\n        # update random node in copied list\n        current = head\n        while current:\n            if current.random:\n                current.next.random = current.random.next\n            current = current.next.next\n\n        # split copied list from combined one\n        dummy = Node(0)\n        copied_current, current = dummy, head\n        while current:\n            copied_current.next = current.next\n            current.next = current.next.next\n            copied_current, current = copied_current.next, current.next\n        return dummy.next\nclass Solution2(object):\n    # @param head, a RandomListNode\n    # @return a RandomListNode\n    def copyRandomList(self, head):\n        dummy = Node(0)\n        current, prev, copies = head, dummy, {}\n\n        while current:\n            copied = Node(current.val)\n            copies[current] = copied\n            prev.next = copied\n            prev, current = prev.next, current.next\n\n        current = head\n        while current:\n            if current.random:\n                copies[current].random = copies[current.random]\n            current = current.next\n\n        return dummy.next\n\n# time: O(n)\n# space: O(n)\nfrom collections import defaultdict\n\nclass Solution3(object):\n    def copyRandomList(self, head):\n        \"\"\"\n        :type head: RandomListNode\n        :rtype: RandomListNode\n        \"\"\"\n        clone = defaultdict(lambda: Node(0))\n        clone[None] = None\n        cur = head\n\n        while cur:\n            clone[cur].val = cur.val\n            clone[cur].next = clone[cur.next]\n            clone[cur].random = clone[cur.random]\n            cur = cur.next\n\n        return clone[head]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Merge Sorted Array",
      "difficulty": "EASY",
      "category": "Array, Two Pointers, Sorting",
      "link": "https://leetcode.com/problems/merge-sorted-array",
      "slug": "merge-sorted-array",
      "description": "You are given two integer arrays \nnums1\n and \nnums2\n, sorted in \nnon-decreasing order\n, and two integers \nm\n and \nn\n, representing the number of elements in \nnums1\n and \nnums2\n respectively.\n\n\nMerge\n \nnums1\n and \nnums2\n into a single array sorted in \nnon-decreasing order\n.\n\n\nThe final sorted array should not be returned by the function, but instead be \nstored inside the array \nnums1\n. To accommodate this, \nnums1\n has a length of \nm + n\n, where the first \nm\n elements denote the elements that should be merged, and the last \nn\n elements are set to \n0\n and should be ignored. \nnums2\n has a length of \nn\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n\nOutput:\n [1,2,2,3,5,6]\n\nExplanation:\n The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [\n1\n,\n2\n,2,\n3\n,5,6] with the underlined elements coming from nums1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1], m = 1, nums2 = [], n = 0\n\nOutput:\n [1]\n\nExplanation:\n The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums1 = [0], m = 0, nums2 = [1], n = 1\n\nOutput:\n [1]\n\nExplanation:\n The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m + n\n\n\nnums2.length == n\n\n\n0 <= m, n <= 200\n\n\n1 <= m + n <= 200\n\n\n-10\n9\n <= nums1[i], nums2[j] <= 10\n9\n\n\n\n\n \n\n\nFollow up: \nCan you come up with an algorithm that runs in \nO(m + n)\n time?",
      "solution": "class Solution(object):\n    # @param A  a list of integers\n    # @param m  an integer, length of A\n    # @param B  a list of integers\n    # @param n  an integer, length of B\n    # @return nothing\n    def merge(self, A, m, B, n):\n        last, i, j = m + n - 1, m - 1, n - 1\n\n        while i >= 0 and j >= 0:\n            if A[i] > B[j]:\n                A[last] = A[i]\n                last, i = last - 1, i - 1\n            else:\n                A[last] = B[j]\n                last, j = last - 1, j - 1\n\n        while j >= 0:\n                A[last] = B[j]\n                last, j = last - 1, j - 1",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Sliding Window Median",
      "difficulty": "HARD",
      "category": "Array, Hash Table, Sliding Window, Heap (Priority Queue)",
      "link": "https://leetcode.com/problems/sliding-window-median",
      "slug": "sliding-window-median",
      "description": "The \nmedian\n is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\n\n\n\nFor examples, if \narr = [2,\n3\n,4]\n, the median is \n3\n.\n\n\nFor examples, if \narr = [1,\n2,3\n,4]\n, the median is \n(2 + 3) / 2 = 2.5\n.\n\n\n\n\nYou are given an integer array \nnums\n and an integer \nk\n. There is a sliding window of size \nk\n which is moving from the very left of the array to the very right. You can only see the \nk\n numbers in the window. Each time the sliding window moves right by one position.\n\n\nReturn \nthe median array for each window in the original array\n. Answers within \n10\n-5\n of the actual value will be accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,-1,-3,5,3,6,7], k = 3\n\nOutput:\n [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\n\nExplanation:\n \nWindow position                Median\n---------------                -----\n[\n1  3  -1\n] -3  5  3  6  7        1\n 1 [\n3  -1  -3\n] 5  3  6  7       -1\n 1  3 [\n-1  -3  5\n] 3  6  7       -1\n 1  3  -1 [\n-3  5  3\n] 6  7        3\n 1  3  -1  -3 [\n5  3  6\n] 7        5\n 1  3  -1  -3  5 [\n3  6  7\n]       6\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,3,4,2,3,1,4,2], k = 3\n\nOutput:\n [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= nums.length <= 10\n5\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1",
      "solution": "\nfrom sortedcontainers import SortedList\n\nclass Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        sl = SortedList(float(nums[i])for i in xrange(k))\n        result = [(sl[k//2]+sl[k//2-(1-k%2)])/2]\n        for i in xrange(k, len(nums)):\n            sl.add(float(nums[i]))\n            sl.remove(nums[i-k])\n            result.append((sl[k//2]+sl[k//2-(1-k%2)])/2)\n        return result\n\n\nimport collections\nimport heapq\n\nclass Solution2(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        def lazy_delete(heap, to_remove, sign):\n            while heap and sign*heap[0] in to_remove:\n                to_remove[sign*heap[0]] -= 1\n                if not to_remove[sign*heap[0]]:\n                    del to_remove[sign*heap[0]]\n                heapq.heappop(heap)\n\n        def full_delete(heap, to_remove, sign):  # Time: O(k), Space: O(k)\n            result = []\n            for x in heap:\n                if sign*x not in to_remove:\n                    result.append(x)\n                    continue\n                to_remove[sign*x] -= 1\n                if not to_remove[sign*x]:\n                    del to_remove[sign*x]\n            heap[:] = result\n            heapq.heapify(heap)\n\n        min_heap, max_heap = [], []\n        for i in xrange(k):\n            if i%2 == 0:\n                heapq.heappush(min_heap, -heapq.heappushpop(max_heap, -nums[i]))\n            else:\n                heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))\n        result = [float(min_heap[0])] if k%2 else [(min_heap[0]-max_heap[0])/2.0]\n        to_remove = collections.defaultdict(int)\n        for i in xrange(k, len(nums)):\n            heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))\n            if nums[i-k] > -max_heap[0]:\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n            to_remove[nums[i-k]] += 1\n            lazy_delete(max_heap, to_remove, -1)\n            lazy_delete(min_heap, to_remove, 1)\n            if len(min_heap)+len(max_heap) > 2*k:\n                full_delete(max_heap, to_remove, -1)\n                full_delete(min_heap, to_remove, 1)\n            result.append(float(min_heap[0]) if k%2 else (min_heap[0]-max_heap[0])/2.0)\n        return result\n\n\nimport collections\nimport heapq\n\nclass Solution3(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        def lazy_delete(heap, to_remove, sign):\n            while heap and sign*heap[0] in to_remove:\n                to_remove[sign*heap[0]] -= 1\n                if not to_remove[sign*heap[0]]:\n                    del to_remove[sign*heap[0]]\n                heapq.heappop(heap)\n\n        min_heap, max_heap = [], []\n        for i in xrange(k):\n            if i%2 == 0:\n                heapq.heappush(min_heap, -heapq.heappushpop(max_heap, -nums[i]))\n            else:\n                heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))\n        result = [float(min_heap[0])] if k%2 else [(min_heap[0]-max_heap[0])/2.0]\n        to_remove = collections.defaultdict(int)\n        for i in xrange(k, len(nums)):\n            heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))\n            if nums[i-k] > -max_heap[0]:\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n            to_remove[nums[i-k]] += 1\n            lazy_delete(max_heap, to_remove, -1)\n            lazy_delete(min_heap, to_remove, 1)\n            result.append(float(min_heap[0]) if k%2 else (min_heap[0]-max_heap[0])/2.0)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn) due to lazy delete",
      "space_complexity": "O(n)"
    },
    {
      "title": "Simplify Path",
      "difficulty": "MEDIUM",
      "category": "String, Stack",
      "link": "https://leetcode.com/problems/simplify-path",
      "slug": "simplify-path",
      "description": "You are given an \nabsolute\n path for a Unix-style file system, which always begins with a slash \n'/'\n. Your task is to transform this absolute path into its \nsimplified canonical path\n.\n\n\nThe \nrules\n of a Unix-style file system are as follows:\n\n\n\n\nA single period \n'.'\n represents the current directory.\n\n\nA double period \n'..'\n represents the previous/parent directory.\n\n\nMultiple consecutive slashes such as \n'//'\n and \n'///'\n are treated as a single slash \n'/'\n.\n\n\nAny sequence of periods that does \nnot match\n the rules above should be treated as a \nvalid directory or\n \nfile \nname\n. For example, \n'...' \nand \n'....'\n are valid directory or file names.\n\n\n\n\nThe simplified canonical path should follow these \nrules\n:\n\n\n\n\nThe path must start with a single slash \n'/'\n.\n\n\nDirectories within the path must be separated by exactly one slash \n'/'\n.\n\n\nThe path must not end with a slash \n'/'\n, unless it is the root directory.\n\n\nThe path must not have any single or double periods (\n'.'\n and \n'..'\n) used to denote current or parent directories.\n\n\n\n\nReturn the \nsimplified canonical path\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \npath = \"/home/\"\n\n\nOutput:\n \n\"/home\"\n\n\nExplanation:\n\n\nThe trailing slash should be removed.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \npath = \"/home//foo/\"\n\n\nOutput:\n \n\"/home/foo\"\n\n\nExplanation:\n\n\nMultiple consecutive slashes are replaced by a single one.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \npath = \"/home/user/Documents/../Pictures\"\n\n\nOutput:\n \n\"/home/user/Pictures\"\n\n\nExplanation:\n\n\nA double period \n\"..\"\n refers to the directory up a level (the parent directory).\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \npath = \"/../\"\n\n\nOutput:\n \n\"/\"\n\n\nExplanation:\n\n\nGoing one level up from the root directory is not possible.\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \npath = \"/.../a/../b/c/../d/./\"\n\n\nOutput:\n \n\"/.../b/d\"\n\n\nExplanation:\n\n\n\"...\"\n is a valid name for a directory in this problem.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= path.length <= 3000\n\n\npath\n consists of English letters, digits, period \n'.'\n, slash \n'/'\n or \n'_'\n.\n\n\npath\n is a valid absolute Unix path.",
      "solution": "class Solution(object):\n    # @param path, a string\n    # @return a string\n    def simplifyPath(self, path):\n        stack, tokens = [], path.split(\"/\")\n        for token in tokens:\n            if token == \"..\" and stack:\n                stack.pop()\n            elif token != \"..\" and token != \".\" and token:\n                stack.append(token)\n        return \"/\" + \"/\".join(stack)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Making A Large Island",
      "difficulty": "HARD",
      "category": "Array, Depth-First Search, Breadth-First Search, Union Find, Matrix",
      "link": "https://leetcode.com/problems/making-a-large-island",
      "slug": "making-a-large-island",
      "description": "You are given an \nn x n\n binary matrix \ngrid\n. You are allowed to change \nat most one\n \n0\n to be \n1\n.\n\n\nReturn \nthe size of the largest \nisland\n in\n \ngrid\n \nafter applying this operation\n.\n\n\nAn \nisland\n is a 4-directionally connected group of \n1\ns.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n grid = [[1,0],[0,1]]\n\nOutput:\n 3\n\nExplanation:\n Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[1,1],[1,0]]\n\nOutput:\n 4\n\nExplanation: \nChange the 0 to 1 and make the island bigger, only one island with area = 4.\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[1,1],[1,1]]\n\nOutput:\n 4\n\nExplanation:\n Can't change any 0 to 1, only one island with area = 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\nn == grid[i].length\n\n\n1 <= n <= 500\n\n\ngrid[i][j]\n is either \n0\n or \n1\n.",
      "solution": "\nclass Solution(object):\n    def largestIsland(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n        def dfs(r, c, index, grid):\n            if not (0 <= r < len(grid) and\n                    0 <= c < len(grid[0]) and\n                    grid[r][c] == 1):\n                return 0\n            result = 1\n            grid[r][c] = index\n            for d in directions:\n                result += dfs(r+d[0], c+d[1], index, grid)\n            return result\n\n        area = {}\n        index = 2\n        for r in xrange(len(grid)):\n            for c in xrange(len(grid[r])):\n                if grid[r][c] == 1:\n                    area[index] = dfs(r, c, index, grid)\n                    index += 1\n\n        result = max(area.values() or [0])\n        for r in xrange(len(grid)):\n            for c in xrange(len(grid[r])):\n                if grid[r][c] == 0:\n                    seen = set()\n                    for d in directions:\n                        nr, nc = r+d[0], c+d[1]\n                        if not (0 <= nr < len(grid) and\n                                0 <= nc < len(grid[0]) and\n                                grid[nr][nc] > 1):\n                            continue\n                        seen.add(grid[nr][nc])\n                    result = max(result, 1 + sum(area[i] for i in seen))\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n^2)"
    },
    {
      "title": "Minimum Window Substring",
      "difficulty": "HARD",
      "category": "Hash Table, String, Sliding Window",
      "link": "https://leetcode.com/problems/minimum-window-substring",
      "slug": "minimum-window-substring",
      "description": "Given two strings \ns\n and \nt\n of lengths \nm\n and \nn\n respectively, return \nthe \nminimum window\n \nsubstring\n of \ns\n such that every character in \nt\n (\nincluding duplicates\n) is included in the window\n. If there is no such substring, return \nthe empty string \n\"\"\n.\n\n\nThe testcases will be generated such that the answer is \nunique\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"ADOBECODEBANC\", t = \"ABC\"\n\nOutput:\n \"BANC\"\n\nExplanation:\n The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"a\", t = \"a\"\n\nOutput:\n \"a\"\n\nExplanation:\n The entire string s is the minimum window.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"a\", t = \"aa\"\n\nOutput:\n \"\"\n\nExplanation:\n Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == s.length\n\n\nn == t.length\n\n\n1 <= m, n <= 10\n5\n\n\ns\n and \nt\n consist of uppercase and lowercase English letters.\n\n\n\n\n \n\n\nFollow up:\n Could you find an algorithm that runs in \nO(m + n)\n time?",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        count, remain = collections.Counter(t), len(t)\n        i, left, right = 0, -1, -1\n        for j, c in enumerate(s):\n            remain -= count[c] > 0\n            count[c] -= 1\n            if remain:\n                continue\n            while count[s[i]] < 0:  # greedily discard uneeds\n                count[s[i]] += 1\n                i += 1\n            if right == -1 or j-i+1 < right-left+1:\n                left, right = i, j\n        return s[left:right+1]\n\nclass Solution2(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        current_count = [0 for i in xrange(52)]\n        expected_count = [0 for i in xrange(52)]\n\n        for char in t:\n            expected_count[ord(char) - ord('a')] += 1\n\n        i, count, start, min_width, min_start = 0, 0, 0, float(\"inf\"), 0\n        while i < len(s):\n            current_count[ord(s[i]) - ord('a')] += 1\n            if current_count[ord(s[i]) - ord('a')] <= expected_count[ord(s[i]) - ord('a')]:\n                count += 1\n\n            if count == len(t):\n                while expected_count[ord(s[start]) - ord('a')] == 0 or \\\n                      current_count[ord(s[start]) - ord('a')] > expected_count[ord(s[start]) - ord('a')]:\n                    current_count[ord(s[start]) - ord('a')] -= 1\n                    start += 1\n\n                if min_width > i - start + 1:\n                    min_width = i - start + 1\n                    min_start = start\n            i += 1\n\n        if min_width == float(\"inf\"):\n            return \"\"\n\n        return s[min_start:min_start + min_width]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(k), k is the number of different characters"
    },
    {
      "title": "Accounts Merge",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, String, Depth-First Search, Breadth-First Search, Union Find, Sorting",
      "link": "https://leetcode.com/problems/accounts-merge",
      "slug": "accounts-merge",
      "description": "Given a list of \naccounts\n where each element \naccounts[i]\n is a list of strings, where the first element \naccounts[i][0]\n is a name, and the rest of the elements are \nemails\n representing emails of the account.\n\n\nNow, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\n\n\nAfter merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails \nin sorted order\n. The accounts themselves can be returned in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\n\nOutput:\n [[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\n\nExplanation:\n\nThe first and second John's are the same person as they have the common email \"johnsmith@mail.com\".\nThe third John and Mary are different people as none of their email addresses are used by other accounts.\nWe could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], \n['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.\n\n\n\nExample 2:\n\n\n\n\nInput:\n accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]\n\nOutput:\n [[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= accounts.length <= 1000\n\n\n2 <= accounts[i].length <= 10\n\n\n1 <= accounts[i][j].length <= 30\n\n\naccounts[i][0]\n consists of English letters.\n\n\naccounts[i][j] (for j > 0)\n is a valid email.",
      "solution": "#                  and the max length ofemail is 320, p.s. {64}@{255}\n\nimport collections\n\nclass UnionFind(object):\n    def __init__(self):\n        self.set = []\n\n    def get_id(self):\n        self.set.append(len(self.set))\n        return len(self.set)-1\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root != y_root:\n            self.set[min(x_root, y_root)] = max(x_root, y_root)\n\nclass Solution(object):\n    def accountsMerge(self, accounts):\n        \"\"\"\n        :type accounts: List[List[str]]\n        :rtype: List[List[str]]\n        \"\"\"\n        union_find = UnionFind()\n        email_to_name = {}\n        email_to_id = {}\n        for account in accounts:\n            name = account[0]\n            for i in xrange(1, len(account)):\n                if account[i] not in email_to_id:\n                    email_to_name[account[i]] = name\n                    email_to_id[account[i]] = union_find.get_id()\n                union_find.union_set(email_to_id[account[1]],\n                                     email_to_id[account[i]])\n\n        result = collections.defaultdict(list)\n        for email in email_to_name.keys():\n            result[union_find.find_set(email_to_id[email])].append(email)\n        for emails in result.values():\n            emails.sort()\n        return [[email_to_name[emails[0]]] + emails\n                for emails in result.values()]",
      "explanation": "N/A",
      "time_complexity": "O(nlogn), n is the number of total emails,",
      "space_complexity": "O(n)"
    },
    {
      "title": "LRU Cache",
      "difficulty": "MEDIUM",
      "category": "Hash Table, Linked List, Design, Doubly-Linked List",
      "link": "https://leetcode.com/problems/lru-cache",
      "slug": "lru-cache",
      "description": "Design a data structure that follows the constraints of a \nLeast Recently Used (LRU) cache\n.\n\n\nImplement the \nLRUCache\n class:\n\n\n\n\nLRUCache(int capacity)\n Initialize the LRU cache with \npositive\n size \ncapacity\n.\n\n\nint get(int key)\n Return the value of the \nkey\n if the key exists, otherwise return \n-1\n.\n\n\nvoid put(int key, int value)\n Update the value of the \nkey\n if the \nkey\n exists. Otherwise, add the \nkey-value\n pair to the cache. If the number of keys exceeds the \ncapacity\n from this operation, \nevict\n the least recently used key.\n\n\n\n\nThe functions \nget\n and \nput\n must each run in \nO(1)\n average time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n\nOutput\n\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n\nExplanation\n\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= capacity <= 3000\n\n\n0 <= key <= 10\n4\n\n\n0 <= value <= 10\n5\n\n\nAt most \n2 * 10\n5\n calls will be made to \nget\n and \nput\n.",
      "solution": "\nimport collections\n\n\n# using OrderedDictclass LRUCache(object):\n    def __init__(self, capacity):\n        self.cache = collections.OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        val = self.cache[key]\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.cache and len(self.cache) == self.capacity:\n            self.cache.popitem(last=False)\n        self.__update(key, val)\n    \n    def __update(self, key, val):\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = val\n\n\n\nclass ListNode(object):\n    def __init__(self, key, val):\n        self.val = val\n        self.key = key\n        self.next = None\n        self.prev = None\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\nclass LRUCache2(object):\n\n    def __init__(self, capacity):\n        self.list = LinkedList()\n        self.dict = {}\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.dict:\n            return -1\n        val = self.dict[key].val\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.dict and len(self.dict) == self.capacity:\n            del self.dict[self.list.head.key]\n            self.list.delete(self.list.head)\n        self.__update(key, val)\n\n    def __update(self, key, val):\n        if key in self.dict:\n            self.list.delete(self.dict[key])\n        node = ListNode(key, val)\n        self.list.insert(node)\n        self.dict[key] = node",
      "explanation": "N/A",
      "time_complexity": "O(1), per operation.",
      "space_complexity": "O(k), k is the capacity of cache."
    },
    {
      "title": "Max Consecutive Ones III",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search, Sliding Window, Prefix Sum",
      "link": "https://leetcode.com/problems/max-consecutive-ones-iii",
      "slug": "max-consecutive-ones-iii",
      "description": "Given a binary array \nnums\n and an integer \nk\n, return \nthe maximum number of consecutive \n1\n's in the array if you can flip at most\n \nk\n \n0\n's.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\n\nOutput:\n 6\n\nExplanation:\n [1,1,1,0,0,\n1\n,1,1,1,1,\n1\n]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\n\nOutput:\n 10\n\nExplanation:\n [0,0,\n1,1,\n1\n,\n1\n,1,1,1,\n1\n,1,1\n,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\nnums[i]\n is either \n0\n or \n1\n.\n\n\n0 <= k <= nums.length",
      "solution": "class Solution(object):\n    def longestOnes(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        result, i = 0, 0\n        for j in xrange(len(A)):\n            K -= int(A[j] == 0)\n            while K < 0:\n                K += int(A[i] == 0)\n                i += 1\n            result = max(result, j-i+1)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Kth Missing Positive Number",
      "difficulty": "EASY",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/kth-missing-positive-number",
      "slug": "kth-missing-positive-number",
      "description": "Given an array \narr\n of positive integers sorted in a \nstrictly increasing order\n, and an integer \nk\n.\n\n\nReturn \nthe\n \nk\nth\n \npositive\n integer that is \nmissing\n from this array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [2,3,4,7,11], k = 5\n\nOutput:\n 9\n\nExplanation: \nThe missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5\nth\n missing positive integer is 9.\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [1,2,3,4], k = 2\n\nOutput:\n 6\n\nExplanation: \nThe missing positive integers are [5,6,7,...]. The 2\nnd\n missing positive integer is 6.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr.length <= 1000\n\n\n1 <= arr[i] <= 1000\n\n\n1 <= k <= 1000\n\n\narr[i] < arr[j]\n for \n1 <= i < j <= arr.length\n\n\n\n\n \n\n\nFollow up:\n\n\nCould you solve this problem in less than O(n) complexity?",
      "solution": "class Solution(object):\n    def findKthPositive(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def check(arr, k, x):\n            return arr[x]-(x+1) < k\n\n        left, right = 0, len(arr)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(arr, k, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right+1+k  # arr[right] + (k-(arr[right]-(right+1))) if right >= 0 else k",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Find First and Last Position of Element in Sorted Array",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array",
      "slug": "find-first-and-last-position-of-element-in-sorted-array",
      "description": "Given an array of integers \nnums\n sorted in non-decreasing order, find the starting and ending position of a given \ntarget\n value.\n\n\nIf \ntarget\n is not found in the array, return \n[-1, -1]\n.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [5,7,7,8,8,10], target = 8\n\nOutput:\n [3,4]\n\nExample 2:\n\n\nInput:\n nums = [5,7,7,8,8,10], target = 6\n\nOutput:\n [-1,-1]\n\nExample 3:\n\n\nInput:\n nums = [], target = 0\n\nOutput:\n [-1,-1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\nnums\n is a non-decreasing array.\n\n\n-10\n9\n <= target <= 10\n9",
      "solution": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        def binarySearch(n, check):  # usually use\n            left, right = 0, n-1  # search in [0, n-1], return n if not found\n            while left <= right:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left  # or return right+1\n\n        def binarySearch2(n, check):  # frequently use\n            left, right = 0, n  # search in [0, n), return n if not found\n            while left < right:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid\n                else:\n                    left = mid+1\n            return left  # or return right\n\n        def binarySearch3(n, check):  # never use\n            left, right = -1, n-1  # search in (-1, n-1], return n if not found\n            while left < right:\n                mid = right - (right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid\n            return left+1  # or return right+1\n\n        def binarySearch4(n, check):  # sometimes use\n            left, right = -1, n  # search in (-1, n), return n if not found\n            while right-left >= 2:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid\n                else:\n                    left = mid\n            return left+1  # or return right\n\n        # Find the first idx where nums[idx] >= target\n        left = binarySearch(len(nums), lambda i: nums[i] >= target)\n        if left == len(nums) or nums[left] != target:\n            return [-1, -1]\n        # Find the first idx where nums[idx] > target\n        right = binarySearch(len(nums), lambda i: nums[i] > target)\n        return [left, right-1]",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Longest Common Prefix",
      "difficulty": "EASY",
      "category": "String, Trie",
      "link": "https://leetcode.com/problems/longest-common-prefix",
      "slug": "longest-common-prefix",
      "description": "Write a function to find the longest common prefix string amongst an array of strings.\n\n\nIf there is no common prefix, return an empty string \n\"\"\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n strs = [\"flower\",\"flow\",\"flight\"]\n\nOutput:\n \"fl\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n strs = [\"dog\",\"racecar\",\"car\"]\n\nOutput:\n \"\"\n\nExplanation:\n There is no common prefix among the input strings.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 200\n\n\n0 <= strs[i].length <= 200\n\n\nstrs[i]\n consists of only lowercase English letters if it is non-empty.",
      "solution": "class Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n\n        for i in xrange(len(strs[0])):\n            for string in strs[1:]:\n                if i >= len(string) or string[i] != strs[0][i]:\n                    return strs[0][:i]\n        return strs[0]\n\nclass Solution2(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        prefix = \"\"\n        \n        for chars in zip(*strs):\n            if all(c == chars[0] for c in chars):\n                prefix += chars[0]\n            else:\n                return prefix\n            \n        return prefix",
      "explanation": "N/A",
      "time_complexity": "O(n * k), k is the length of the common prefix",
      "space_complexity": "O(k)"
    },
    {
      "title": "Squares of a Sorted Array",
      "difficulty": "EASY",
      "category": "Array, Two Pointers, Sorting",
      "link": "https://leetcode.com/problems/squares-of-a-sorted-array",
      "slug": "squares-of-a-sorted-array",
      "description": "Given an integer array \nnums\n sorted in \nnon-decreasing\n order, return \nan array of \nthe squares of each number\n sorted in non-decreasing order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-4,-1,0,3,10]\n\nOutput:\n [0,1,9,16,100]\n\nExplanation:\n After squaring, the array becomes [16,1,0,9,100].\nAfter sorting, it becomes [0,1,9,16,100].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-7,-3,2,3,11]\n\nOutput:\n [4,9,9,49,121]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= \n10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nnums\n is sorted in \nnon-decreasing\n order.\n\n\n\n\n \n\n\nFollow up:\n Squaring each element and sorting the new array is very trivial, could you find an \nO(n)\n solution using a different approach?",
      "solution": "\nimport bisect\n\nclass Solution(object):\n    def sortedSquares(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        right = bisect.bisect_left(A, 0)\n        left = right-1\n        result = []\n        while 0 <= left or right < len(A):\n            if right == len(A) or \\\n               (0 <= left and A[left]**2 < A[right]**2):\n                result.append(A[left]**2)\n                left -= 1\n            else:\n                result.append(A[right]**2)\n                right += 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Remove Nth Node From End of List",
      "difficulty": "MEDIUM",
      "category": "Linked List, Two Pointers",
      "link": "https://leetcode.com/problems/remove-nth-node-from-end-of-list",
      "slug": "remove-nth-node-from-end-of-list",
      "description": "Given the \nhead\n of a linked list, remove the \nn\nth\n node from the end of the list and return its head.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], n = 2\n\nOutput:\n [1,2,3,5]\n\n\n\nExample 2:\n\n\n\n\nInput:\n head = [1], n = 1\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = [1,2], n = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is \nsz\n.\n\n\n1 <= sz <= 30\n\n\n0 <= Node.val <= 100\n\n\n1 <= n <= sz\n\n\n\n\n \n\n\nFollow up:\n Could you do this in one pass?",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self is None:\n            return \"Nil\"\n        else:\n            return \"{} -> {}\".format(self.val, repr(self.next))\nclass Solution(object):\n    # @return a ListNode\n    def removeNthFromEnd(self, head, n):\n        dummy = ListNode(-1)\n        dummy.next = head\n        slow, fast = dummy, dummy\n\n        for i in xrange(n):\n            fast = fast.next\n\n        while fast.next:\n            slow, fast = slow.next, fast.next\n\n        slow.next = slow.next.next\n\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Diagonal Traverse",
      "difficulty": "MEDIUM",
      "category": "Array, Matrix, Simulation",
      "link": "https://leetcode.com/problems/diagonal-traverse",
      "slug": "diagonal-traverse",
      "description": "Given an \nm x n\n matrix \nmat\n, return \nan array of all the elements of the array in a diagonal order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [1,2,4,7,5,3,6,8,9]\n\n\n\nExample 2:\n\n\n\n\nInput:\n mat = [[1,2],[3,4]]\n\nOutput:\n [1,2,3,4]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n1 <= m, n <= 10\n4\n\n\n1 <= m * n <= 10\n4\n\n\n-10\n5\n <= mat[i][j] <= 10\n5",
      "solution": "class Solution(object):\n    def findDiagonalOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return []\n\n        result = []\n        row, col, d = 0, 0, 0\n        dirs = [(-1, 1), (1, -1)]\n\n        for i in xrange(len(matrix) * len(matrix[0])):\n            result.append(matrix[row][col])\n            row += dirs[d][0]\n            col += dirs[d][1]\n\n            if row >= len(matrix):\n                row = len(matrix) - 1\n                col += 2\n                d = 1 - d\n            elif col >= len(matrix[0]):\n                col = len(matrix[0]) - 1\n                row += 2\n                d = 1 - d\n            elif row < 0:\n                row = 0\n                d = 1 - d\n            elif col < 0:\n                col = 0\n                d = 1 - d\n\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Missing Ranges",
      "difficulty": "EASY",
      "category": "Array",
      "link": "https://leetcode.com/problems/missing-ranges",
      "slug": "missing-ranges",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "class Solution(object):\n    def findMissingRanges(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: List[str]\n        \"\"\"\n        def getRange(lower, upper):\n            if lower == upper:\n                return \"{}\".format(lower)\n            else:\n                return \"{}->{}\".format(lower, upper)\n        ranges = []\n        pre = lower - 1\n\n        for i in xrange(len(nums) + 1):\n            if i == len(nums):\n                cur = upper + 1\n            else:\n                cur = nums[i]\n            if cur - pre >= 2:\n                ranges.append(getRange(pre + 1, cur - 1))\n\n            pre = cur\n\n        return ranges",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Moving Average from Data Stream",
      "difficulty": "EASY",
      "category": "Array, Design, Queue, Data Stream",
      "link": "https://leetcode.com/problems/moving-average-from-data-stream",
      "slug": "moving-average-from-data-stream",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "\nfrom collections import deque\nclass MovingAverage(object):\n\n    def __init__(self, size):\n        \"\"\"\n        Initialize your data structure here.\n        :type size: int\n        \"\"\"\n        self.__size = size\n        self.__sum = 0\n        self.__q = deque()\n\n    def next(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: float\n        \"\"\"\n        if len(self.__q) == self.__size:\n            self.__sum -= self.__q.popleft()\n        self.__sum += val\n        self.__q.append(val)\n        return 1.0 * self.__sum / len(self.__q)",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(w)"
    },
    {
      "title": "Exclusive Time of Functions",
      "difficulty": "MEDIUM",
      "category": "Array, Stack",
      "link": "https://leetcode.com/problems/exclusive-time-of-functions",
      "slug": "exclusive-time-of-functions",
      "description": "On a \nsingle-threaded\n CPU, we execute a program containing \nn\n functions. Each function has a unique ID between \n0\n and \nn-1\n.\n\n\nFunction calls are \nstored in a \ncall stack\n: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is \nthe current function being executed\n. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.\n\n\nYou are given a list \nlogs\n, where \nlogs[i]\n represents the \ni\nth\n log message formatted as a string \n\"{function_id}:{\"start\" | \"end\"}:{timestamp}\"\n. For example, \n\"0:start:3\"\n means a function call with function ID \n0\n \nstarted at the beginning\n of timestamp \n3\n, and \n\"1:end:2\"\n means a function call with function ID \n1\n \nended at the end\n of timestamp \n2\n. Note that a function can be called \nmultiple times, possibly recursively\n.\n\n\nA function's \nexclusive time\n is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for \n2\n time units and another call executing for \n1\n time unit, the \nexclusive time\n is \n2 + 1 = 3\n.\n\n\nReturn \nthe \nexclusive time\n of each function in an array, where the value at the \ni\nth\n index represents the exclusive time for the function with ID \ni\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 2, logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]\n\nOutput:\n [3,4]\n\nExplanation:\n\nFunction 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.\nFunction 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.\nFunction 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.\nSo function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"]\n\nOutput:\n [8]\n\nExplanation:\n\nFunction 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\nFunction 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\nFunction 0 (initial call) resumes execution then immediately calls itself again.\nFunction 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.\nFunction 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.\nSo function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:6\",\"1:end:6\",\"0:end:7\"]\n\nOutput:\n [7,1]\n\nExplanation:\n\nFunction 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\nFunction 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\nFunction 0 (initial call) resumes execution then immediately calls function 1.\nFunction 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6.\nFunction 0 resumes execution at the beginning of time 6 and executes for 2 units of time.\nSo function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100\n\n\n2 <= logs.length <= 500\n\n\n0 <= function_id < n\n\n\n0 <= timestamp <= 10\n9\n\n\nNo two start events will happen at the same timestamp.\n\n\nNo two end events will happen at the same timestamp.\n\n\nEach function has an \n\"end\"\n log for each \n\"start\"\n log.",
      "solution": "class Solution(object):\n    def exclusiveTime(self, n, logs):\n        \"\"\"\n        :type n: int\n        :type logs: List[str]\n        :rtype: List[int]\n        \"\"\"\n        result = [0] * n\n        stk, prev = [], 0\n        for log in logs:\n            tokens = log.split(\":\")\n            if tokens[1] == \"start\":\n                if stk:\n                    result[stk[-1]] += int(tokens[2]) - prev\n                stk.append(int(tokens[0]))\n                prev = int(tokens[2])\n            else:\n                result[stk.pop()] += int(tokens[2]) - prev + 1\n                prev = int(tokens[2]) + 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Add Strings",
      "difficulty": "EASY",
      "category": "Math, String, Simulation",
      "link": "https://leetcode.com/problems/add-strings",
      "slug": "add-strings",
      "description": "Given two non-negative integers, \nnum1\n and \nnum2\n represented as string, return \nthe sum of\n \nnum1\n \nand\n \nnum2\n \nas a string\n.\n\n\nYou must solve the problem without using any built-in library for handling large integers (such as \nBigInteger\n). You must also not convert the inputs to integers directly.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num1 = \"11\", num2 = \"123\"\n\nOutput:\n \"134\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n num1 = \"456\", num2 = \"77\"\n\nOutput:\n \"533\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n num1 = \"0\", num2 = \"0\"\n\nOutput:\n \"0\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num1.length, num2.length <= 10\n4\n\n\nnum1\n and \nnum2\n consist of only digits.\n\n\nnum1\n and \nnum2\n don't have any leading zeros except for the zero itself.",
      "solution": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        result = []\n        i, j, carry = len(num1) - 1, len(num2) - 1, 0\n\n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += ord(num1[i]) - ord('0')\n                i -= 1\n            if j >= 0:\n                carry += ord(num2[j]) - ord('0')\n                j -= 1\n            result.append(str(carry % 10))\n            carry /= 10\n        result.reverse()\n\n        return \"\".join(result)\n\n    def addStrings2(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        length = max(len(num1), len(num2))\n        num1 = num1.zfill(length)[::-1]\n        num2 = num2.zfill(length)[::-1]\n        res, plus = '', 0\n        for index, num in enumerate(num1):\n            tmp = str(int(num) + int(num2[index]) + plus)\n            res += tmp[-1]\n            if int(tmp) > 9:\n                plus = 1\n            else:\n                plus = 0\n        if plus:\n            res += '1'\n        return res[::-1]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Binary Search Tree Iterator",
      "difficulty": "MEDIUM",
      "category": "Stack, Tree, Design, Binary Search Tree, Binary Tree, Iterator",
      "link": "https://leetcode.com/problems/binary-search-tree-iterator",
      "slug": "binary-search-tree-iterator",
      "description": "Implement the \nBSTIterator\n class that represents an iterator over the \nin-order traversal\n of a binary search tree (BST):\n\n\n\n\nBSTIterator(TreeNode root)\n Initializes an object of the \nBSTIterator\n class. The \nroot\n of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\n\n\nboolean hasNext()\n Returns \ntrue\n if there exists a number in the traversal to the right of the pointer, otherwise returns \nfalse\n.\n\n\nint next()\n Moves the pointer to the right, then returns the number at the pointer.\n\n\n\n\nNotice that by initializing the pointer to a non-existent smallest number, the first call to \nnext()\n will return the smallest element in the BST.\n\n\nYou may assume that \nnext()\n calls will always be valid. That is, there will be at least a next number in the in-order traversal when \nnext()\n is called.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput\n\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n\nOutput\n\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n\nExplanation\n\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n5\n]\n.\n\n\n0 <= Node.val <= 10\n6\n\n\nAt most \n10\n5\n calls will be made to \nhasNext\n, and \nnext\n.\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nCould you implement \nnext()\n and \nhasNext()\n to run in average \nO(1)\n time and use \nO(h)\n memory, where \nh\n is the height of the tree?",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass BSTIterator(object):\n    # @param root, a binary search tree's root node\n    def __init__(self, root):\n        self.__stk = []\n        self.__traversalLeft(root)\n\n    # @return a boolean, whether we have a next smallest number\n    def hasNext(self):\n        return self.__stk\n\n    # @return an integer, the next smallest number\n    def next(self):\n        node = self.__stk.pop()\n        self.__traversalLeft(node.right)\n        return node.val\n    \n    def __traversalLeft(self, node):\n        while node is not None:\n            self.__stk.append(node)\n            node = node.left",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(h), h is height of binary tree"
    },
    {
      "title": "Minimum Add to Make Parentheses Valid",
      "difficulty": "MEDIUM",
      "category": "String, Stack, Greedy",
      "link": "https://leetcode.com/problems/minimum-add-to-make-parentheses-valid",
      "slug": "minimum-add-to-make-parentheses-valid",
      "description": "A parentheses string is valid if and only if:\n\n\n\n\nIt is the empty string,\n\n\nIt can be written as \nAB\n (\nA\n concatenated with \nB\n), where \nA\n and \nB\n are valid strings, or\n\n\nIt can be written as \n(A)\n, where \nA\n is a valid string.\n\n\n\n\nYou are given a parentheses string \ns\n. In one move, you can insert a parenthesis at any position of the string.\n\n\n\n\nFor example, if \ns = \"()))\"\n, you can insert an opening parenthesis to be \n\"(\n(\n)))\"\n or a closing parenthesis to be \n\"())\n)\n)\"\n.\n\n\n\n\nReturn \nthe minimum number of moves required to make \ns\n valid\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"())\"\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"(((\"\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns[i]\n is either \n'('\n or \n')'\n.",
      "solution": "class Solution(object):\n    def minAddToMakeValid(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: int\n        \"\"\"\n        add, bal, = 0, 0\n        for c in S:\n            bal += 1 if c == '(' else -1\n            if bal == -1:\n                add += 1\n                bal += 1\n        return add + bal",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Robot Room Cleaner",
      "difficulty": "HARD",
      "category": "Backtracking, Interactive",
      "link": "https://leetcode.com/problems/robot-room-cleaner",
      "slug": "robot-room-cleaner",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "class Solution(object):\n    def cleanRoom(self, robot):\n        \"\"\"\n        :type robot: Robot\n        :rtype: None\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        def goBack(robot):\n            robot.turnLeft()\n            robot.turnLeft()\n            robot.move()\n            robot.turnRight()\n            robot.turnRight()\n\n        def dfs(pos, robot, d, lookup):\n            robot.clean()\n            for _ in directions:\n                new_pos = (pos[0]+directions[d][0],\n                           pos[1]+directions[d][1])\n                if new_pos not in lookup:\n                    lookup.add(new_pos)\n                    if robot.move():\n                        dfs(new_pos, robot, d, lookup)\n                        goBack(robot)\n                robot.turnRight()\n                d = (d+1) % len(directions)\n        \n        dfs((0, 0), robot, 0, set())",
      "explanation": "N/A",
      "time_complexity": "O(n), n is the number of cells",
      "space_complexity": "O(n)"
    },
    {
      "title": "Add Two Numbers",
      "difficulty": "MEDIUM",
      "category": "Linked List, Math, Recursion",
      "link": "https://leetcode.com/problems/add-two-numbers",
      "slug": "add-two-numbers",
      "description": "You are given two \nnon-empty\n linked lists representing two non-negative integers. The digits are stored in \nreverse order\n, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n l1 = [2,4,3], l2 = [5,6,4]\n\nOutput:\n [7,0,8]\n\nExplanation:\n 342 + 465 = 807.\n\n\n\nExample 2:\n\n\n\n\nInput:\n l1 = [0], l2 = [0]\n\nOutput:\n [0]\n\n\n\nExample 3:\n\n\n\n\nInput:\n l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n\nOutput:\n [8,9,9,9,0,0,0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in each linked list is in the range \n[1, 100]\n.\n\n\n0 <= Node.val <= 9\n\n\nIt is guaranteed that the list represents a number that does not have leading zeros.",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        current, carry = dummy, 0\n\n        while l1 or l2:\n            val = carry\n            if l1:\n                val += l1.val\n                l1 = l1.next\n            if l2:\n                val += l2.val\n                l2 = l2.next\n            carry, val = divmod(val, 10)\n            current.next = ListNode(val)\n            current = current.next\n\n        if carry == 1:\n            current.next = ListNode(1)\n\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Subsets",
      "difficulty": "MEDIUM",
      "category": "Array, Backtracking, Bit Manipulation",
      "link": "https://leetcode.com/problems/subsets",
      "slug": "subsets",
      "description": "Given an integer array \nnums\n of \nunique\n elements, return \nall possible\n \nsubsets\n \n(the power set)\n.\n\n\nThe solution set \nmust not\n contain duplicate subsets. Return the solution in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0]\n\nOutput:\n [[],[0]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n\n\n-10 <= nums[i] <= 10\n\n\nAll the numbers of \nnums\n are \nunique\n.",
      "solution": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        result = [[]]\n        for i in xrange(len(nums)):\n            size = len(result)\n            for j in xrange(size):\n                result.append(list(result[j]))\n                result[-1].append(nums[i])\n        return result\n\nclass Solution2(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i, count = 0, 1 << len(nums)\n        nums.sort()\n\n        while i < count:\n            cur = []\n            for j in xrange(len(nums)):\n                if i & 1 << j:\n                    cur.append(nums[j])\n            result.append(cur)\n            i += 1\n\n        return result\n\nclass Solution3(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        return self.subsetsRecu([], sorted(nums))\n\n    def subsetsRecu(self, cur, nums):\n        if not nums:\n            return [cur]\n\n        return self.subsetsRecu(cur, nums[1:]) + self.subsetsRecu(cur + [nums[0]], nums[1:])",
      "explanation": "N/A",
      "time_complexity": "O(n * 2^n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Remove Invalid Parentheses",
      "difficulty": "HARD",
      "category": "String, Backtracking, Breadth-First Search",
      "link": "https://leetcode.com/problems/remove-invalid-parentheses",
      "slug": "remove-invalid-parentheses",
      "description": "Given a string \ns\n that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\n\n\nReturn \na list of \nunique strings\n that are valid with the minimum number of removals\n. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"()())()\"\n\nOutput:\n [\"(())()\",\"()()()\"]\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"(a)())()\"\n\nOutput:\n [\"(a())()\",\"(a)()()\"]\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \")(\"\n\nOutput:\n [\"\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 25\n\n\ns\n consists of lowercase English letters and parentheses \n'('\n and \n')'\n.\n\n\nThere will be at most \n20\n parentheses in \ns\n.",
      "solution": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        # Calculate the minimum left and right parantheses to remove\n        def findMinRemove(s):\n            left_removed, right_removed = 0, 0\n            for c in s:\n                if c == '(':\n                    left_removed += 1\n                elif c == ')':\n                    if not left_removed:\n                        right_removed += 1\n                    else:\n                        left_removed -= 1\n            return (left_removed, right_removed)\n\n        # Check whether s is valid or not.\n        def isValid(s):\n            sum = 0\n            for c in s:\n                if c == '(':\n                    sum += 1\n                elif c == ')':\n                    sum -= 1\n                if sum < 0:\n                    return False\n            return sum == 0\n\n        def removeInvalidParenthesesHelper(start, left_removed, right_removed):\n            if left_removed == 0 and right_removed == 0:\n                tmp = \"\"\n                for i, c in enumerate(s):\n                    if i not in removed:\n                        tmp += c\n                if isValid(tmp):\n                    res.append(tmp)\n                return\n\n            for i in xrange(start, len(s)):\n                if right_removed == 0 and left_removed > 0 and s[i] == '(':\n                    if i == start or s[i] != s[i - 1]:  # Skip duplicated.\n                        removed[i] = True\n                        removeInvalidParenthesesHelper(i + 1, left_removed - 1, right_removed)\n                        del removed[i]\n                elif right_removed > 0 and s[i] == ')':\n                    if i == start or s[i] != s[i - 1]:  # Skip duplicated.\n                        removed[i] = True\n                        removeInvalidParenthesesHelper(i + 1, left_removed, right_removed - 1)\n                        del removed[i]\n\n        res, removed = [], {}\n        (left_removed, right_removed) = findMinRemove(s)\n        removeInvalidParenthesesHelper(0, left_removed, right_removed)\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(C(n, c)), try out all possible substrings with the minimum c deletion.",
      "space_complexity": "O(c), the depth is at most c, and it costs n at each depth"
    },
    {
      "title": "Palindromic Substrings",
      "difficulty": "MEDIUM",
      "category": "Two Pointers, String, Dynamic Programming",
      "link": "https://leetcode.com/problems/palindromic-substrings",
      "slug": "palindromic-substrings",
      "description": "Given a string \ns\n, return \nthe number of \npalindromic substrings\n in it\n.\n\n\nA string is a \npalindrome\n when it reads the same backward as forward.\n\n\nA \nsubstring\n is a contiguous sequence of characters within the string.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abc\"\n\nOutput:\n 3\n\nExplanation:\n Three palindromic strings: \"a\", \"b\", \"c\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"aaa\"\n\nOutput:\n 6\n\nExplanation:\n Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consists of lowercase English letters.",
      "solution": "class Solution(object):\n    def countSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def manacher(s):\n            s = '^#' + '#'.join(s) + '#$'\n            P = [0] * len(s)\n            C, R = 0, 0\n            for i in xrange(1, len(s) - 1):\n                i_mirror = 2*C-i\n                if R > i:\n                    P[i] = min(R-i, P[i_mirror])\n                while s[i+1+P[i]] == s[i-1-P[i]]:\n                    P[i] += 1\n                if i+P[i] > R:\n                    C, R = i, i+P[i]\n            return P\n        return sum((max_len+1)//2 for max_len in manacher(s))",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Valid Number",
      "difficulty": "HARD",
      "category": "String",
      "link": "https://leetcode.com/problems/valid-number",
      "slug": "valid-number",
      "description": "Given a string \ns\n, return whether \ns\n is a \nvalid number\n.\n\n\n\nFor example, all the following are valid numbers: \n\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"\n, while the following are not valid numbers: \n\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"\n.\n\n\nFormally, a \nvalid number\n is defined using one of the following definitions:\n\n\n\n\nAn \ninteger number\n followed by an \noptional exponent\n.\n\n\nA \ndecimal number\n followed by an \noptional exponent\n.\n\n\n\n\nAn \ninteger number\n is defined with an \noptional sign\n \n'-'\n or \n'+'\n followed by \ndigits\n.\n\n\nA \ndecimal number\n is defined with an \noptional sign\n \n'-'\n or \n'+'\n followed by one of the following definitions:\n\n\n\n\nDigits\n followed by a \ndot\n \n'.'\n.\n\n\nDigits\n followed by a \ndot\n \n'.'\n followed by \ndigits\n.\n\n\nA \ndot\n \n'.'\n followed by \ndigits\n.\n\n\n\n\nAn \nexponent\n is defined with an \nexponent notation\n \n'e'\n or \n'E'\n followed by an \ninteger number\n.\n\n\nThe \ndigits\n are defined as one or more digits.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"0\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"e\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \".\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 20\n\n\ns\n consists of only English letters (both uppercase and lowercase), digits (\n0-9\n), plus \n'+'\n, minus \n'-'\n, or dot \n'.'\n.",
      "solution": "class InputType(object):\n    INVALID    = 0\n    SPACE      = 1\n    SIGN       = 2\n    DIGIT      = 3\n    DOT        = 4\n    EXPONENT   = 5\n\n\n# regular expression: \"^\\s*[\\+-]?((\\d+(\\.\\d*)?)|\\.\\d+)([eE][\\+-]?\\d+)?\\s*$\"\n# automata: http://images.cnitblog.com/i/627993/201405/012016243309923.pngclass Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        transition_table = [[-1,  0,  3,  1,  2, -1],     # next states for state 0\n                            [-1,  8, -1,  1,  4,  5],     # next states for state 1\n                            [-1, -1, -1,  4, -1, -1],     # next states for state 2\n                            [-1, -1, -1,  1,  2, -1],     # next states for state 3\n                            [-1,  8, -1,  4, -1,  5],     # next states for state 4\n                            [-1, -1,  6,  7, -1, -1],     # next states for state 5\n                            [-1, -1, -1,  7, -1, -1],     # next states for state 6\n                            [-1,  8, -1,  7, -1, -1],     # next states for state 7\n                            [-1,  8, -1, -1, -1, -1]]     # next states for state 8\n\n        state = 0\n        for char in s:\n            inputType = InputType.INVALID\n            if char.isspace():\n                inputType = InputType.SPACE\n            elif char == '+' or char == '-':\n                inputType = InputType.SIGN\n            elif char.isdigit():\n                inputType = InputType.DIGIT\n            elif char == '.':\n                inputType = InputType.DOT\n            elif char == 'e' or char == 'E':\n                inputType = InputType.EXPONENT\n\n            state = transition_table[state][inputType]\n\n            if state == -1:\n                return False\n\n        return state == 1 or state == 4 or state == 7 or state == 8\n\nclass Solution2(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        import re\n        return bool(re.match(\"^\\s*[\\+-]?((\\d+(\\.\\d*)?)|\\.\\d+)([eE][\\+-]?\\d+)?\\s*$\", s))",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Continuous Subarray Sum",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Math, Prefix Sum",
      "link": "https://leetcode.com/problems/continuous-subarray-sum",
      "slug": "continuous-subarray-sum",
      "description": "Given an integer array nums and an integer k, return \ntrue\n \nif \nnums\n has a \ngood subarray\n or \nfalse\n otherwise\n.\n\n\nA \ngood subarray\n is a subarray where:\n\n\n\n\nits length is \nat least two\n, and\n\n\nthe sum of the elements of the subarray is a multiple of \nk\n.\n\n\n\n\nNote\n that:\n\n\n\n\nA \nsubarray\n is a contiguous part of the array.\n\n\nAn integer \nx\n is a multiple of \nk\n if there exists an integer \nn\n such that \nx = n * k\n. \n0\n is \nalways\n a multiple of \nk\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [23,\n2,4\n,6,7], k = 6\n\nOutput:\n true\n\nExplanation:\n [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [\n23,2,6,4,7\n], k = 6\n\nOutput:\n true\n\nExplanation:\n [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.\n42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [23,2,6,4,7], k = 13\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n0 <= nums[i] <= 10\n9\n\n\n0 <= sum(nums[i]) <= 2\n31\n - 1\n\n\n1 <= k <= 2\n31\n - 1",
      "solution": "class Solution(object):\n    def checkSubarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        count = 0\n        lookup = {0: -1}\n        for i, num in enumerate(nums):\n            count += num\n            if k:\n                count %= k\n            if count in lookup:\n                if i - lookup[count] > 1:\n                    return True\n            else:\n                lookup[count] = i\n\n        return False",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Closest Binary Search Tree Value",
      "difficulty": "EASY",
      "category": "Binary Search, Tree, Depth-First Search, Binary Search Tree, Binary Tree",
      "link": "https://leetcode.com/problems/closest-binary-search-tree-value",
      "slug": "closest-binary-search-tree-value",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "class Solution(object):\n    def closestValue(self, root, target):\n        \"\"\"\n        :type root: TreeNode\n        :type target: float\n        :rtype: int\n        \"\"\"\n        gap = float(\"inf\")\n        closest = float(\"inf\")\n        while root:\n            if abs(root.val - target) < gap:\n                gap = abs(root.val - target)\n                closest = root.val\n            if target == root.val:\n                break\n            elif target < root.val:\n                root = root.left\n            else:\n                root = root.right\n        return closest",
      "explanation": "N/A",
      "time_complexity": "O(h)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Vertical Order Traversal of a Binary Tree",
      "difficulty": "HARD",
      "category": "Hash Table, Tree, Depth-First Search, Breadth-First Search, Sorting, Binary Tree",
      "link": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree",
      "slug": "vertical-order-traversal-of-a-binary-tree",
      "description": "Given the \nroot\n of a binary tree, calculate the \nvertical order traversal\n of the binary tree.\n\n\nFor each node at position \n(row, col)\n, its left and right children will be at positions \n(row + 1, col - 1)\n and \n(row + 1, col + 1)\n respectively. The root of the tree is at \n(0, 0)\n.\n\n\nThe \nvertical order traversal\n of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.\n\n\nReturn \nthe \nvertical order traversal\n of the binary tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n [[9],[3,15],[20],[7]]\n\nExplanation:\n\nColumn -1: Only node 9 is in this column.\nColumn 0: Nodes 3 and 15 are in this column in that order from top to bottom.\nColumn 1: Only node 20 is in this column.\nColumn 2: Only node 7 is in this column.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,6,7]\n\nOutput:\n [[4],[2],[1,5,6],[3],[7]]\n\nExplanation:\n\nColumn -2: Only node 4 is in this column.\nColumn -1: Only node 2 is in this column.\nColumn 0: Nodes 1, 5, and 6 are in this column.\n          1 is at the top, so it comes first.\n          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.\nColumn 1: Only node 3 is in this column.\nColumn 2: Only node 7 is in this column.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,6,5,7]\n\nOutput:\n [[4],[2],[1,5,6],[3],[7]]\n\nExplanation:\n\nThis case is the exact same as example 2, but with nodes 5 and 6 swapped.\nNote that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\n0 <= Node.val <= 1000",
      "solution": "\nimport collections\n\n\n# Definition for a binary tree node.class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def verticalTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        def dfs(node, lookup, x, y):\n            if not node:\n                return\n            lookup[x][y].append(node)\n            dfs(node.left, lookup, x-1, y+1)\n            dfs(node.right, lookup, x+1, y+1)\n                \n        lookup = collections.defaultdict(lambda: collections.defaultdict(list))\n        dfs(root, lookup, 0, 0)\n\n        result = []\n        for x in sorted(lookup):\n            report = []\n            for y in sorted(lookup[x]):\n                report.extend(sorted(node.val for node in lookup[x][y]))\n            result.append(report)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Group Shifted Strings",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, String",
      "link": "https://leetcode.com/problems/group-shifted-strings",
      "slug": "group-shifted-strings",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    # @param {string[]} strings\n    # @return {string[][]}\n    def groupStrings(self, strings):\n        groups = collections.defaultdict(list)\n        for s in strings:  # Grouping.\n            groups[self.hashStr(s)].append(s)\n\n        result = []\n        for key, val in groups.iteritems():\n            result.append(sorted(val))\n\n        return result\n\n    def hashStr(self, s):\n        base = ord(s[0])\n        hashcode = \"\"\n        for i in xrange(len(s)):\n            if ord(s[i]) - base >= 0:\n                hashcode += unichr(ord('a') + ord(s[i]) - base)\n            else:\n                hashcode += unichr(ord('a') + ord(s[i]) - base + 26)\n        return hashcode",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Course Schedule",
      "difficulty": "MEDIUM",
      "category": "Depth-First Search, Breadth-First Search, Graph, Topological Sort",
      "link": "https://leetcode.com/problems/course-schedule",
      "slug": "course-schedule",
      "description": "There are a total of \nnumCourses\n courses you have to take, labeled from \n0\n to \nnumCourses - 1\n. You are given an array \nprerequisites\n where \nprerequisites[i] = [a\ni\n, b\ni\n]\n indicates that you \nmust\n take course \nb\ni\n first if you want to take course \na\ni\n.\n\n\n\n\nFor example, the pair \n[0, 1]\n, indicates that to take course \n0\n you have to first take course \n1\n.\n\n\n\n\nReturn \ntrue\n if you can finish all courses. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [[1,0]]\n\nOutput:\n true\n\nExplanation:\n There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\n\n\nExample 2:\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [[1,0],[0,1]]\n\nOutput:\n false\n\nExplanation:\n There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numCourses <= 2000\n\n\n0 <= prerequisites.length <= 5000\n\n\nprerequisites[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < numCourses\n\n\nAll the pairs prerequisites[i] are \nunique\n.",
      "solution": "\nimport collections\n\n\n# Khan's algorithm (bfs solution)class Solution(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        q = [u for u in xrange(numCourses) if u not in in_degree]\n        while q:\n            new_q = []\n            for u in q:\n                result.append(u)\n                for v in adj[u]:\n                    in_degree[v] -= 1\n                    if in_degree[v] == 0:\n                        new_q.append(v)\n            q = new_q\n        return len(result) == numCourses\n\n\nimport collections\n\n\n# dfs solutionclass Solution2(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        stk = [u for u in xrange(numCourses) if u not in in_degree]\n        while stk:\n            u = stk.pop()\n            result.append(u)\n            for v in adj[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    stk.append(v)\n        return len(result) == numCourses",
      "explanation": "N/A",
      "time_complexity": "O(|V| + |E|)",
      "space_complexity": "O(|E|)"
    },
    {
      "title": "Insert into a Sorted Circular Linked List",
      "difficulty": "MEDIUM",
      "category": "Linked List",
      "link": "https://leetcode.com/problems/insert-into-a-sorted-circular-linked-list",
      "slug": "insert-into-a-sorted-circular-linked-list",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "class Node(object):\n    def __init__(self, val, next):\n        self.val = val\n        self.next = next\n\nclass Solution(object):\n    def insert(self, head, insertVal):\n        \"\"\"\n        :type head: Node\n        :type insertVal: int\n        :rtype: Node\n        \"\"\"\n        def insertAfter(node, val):\n            node.next = Node(val, node.next)\n        \n        if not head:\n            node = Node(insertVal, None)\n            node.next = node\n            return node\n\n        curr = head\n        while True:\n            if curr.val < curr.next.val:\n                if curr.val <= insertVal and \\\n                   insertVal <= curr.next.val:\n                    insertAfter(curr, insertVal)\n                    break\n            elif curr.val > curr.next.val:\n                if curr.val <= insertVal or \\\n                   insertVal <= curr.next.val:\n                    insertAfter(curr, insertVal)\n                    break\n            else:\n                if curr.next == head:\n                    insertAfter(curr, insertVal)\n                    break\n            curr = curr.next\n        return head",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "3Sum",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers, Sorting",
      "link": "https://leetcode.com/problems/3sum",
      "slug": "3sum",
      "description": "Given an integer array nums, return all the triplets \n[nums[i], nums[j], nums[k]]\n such that \ni != j\n, \ni != k\n, and \nj != k\n, and \nnums[i] + nums[j] + nums[k] == 0\n.\n\n\nNotice that the solution set must not contain duplicate triplets.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-1,0,1,2,-1,-4]\n\nOutput:\n [[-1,-1,2],[-1,0,1]]\n\nExplanation:\n \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,1,1]\n\nOutput:\n []\n\nExplanation:\n The only possible triplet does not sum up to 0.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [0,0,0]\n\nOutput:\n [[0,0,0]]\n\nExplanation:\n The only possible triplet sums up to 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= nums.length <= 3000\n\n\n-10\n5\n <= nums[i] <= 10\n5",
      "solution": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        nums.sort()\n        for i in reversed(xrange(2, len(nums))):\n            if i+1 < len(nums) and nums[i] == nums[i+1]:\n                continue\n            target = -nums[i]\n            left, right = 0, i-1\n            while left < right:\n                if nums[left]+nums[right] < target:\n                    left += 1\n                elif nums[left]+nums[right] > target:\n                    right -= 1\n                else:\n                    result.append([nums[left], nums[right], nums[i]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left-1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right+1]:\n                        right -= 1\n        return result\n\nclass Solution2(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, i = sorted(nums), [], 0\n        while i < len(nums) - 2:\n            if i == 0 or nums[i] != nums[i - 1]:\n                j, k = i + 1, len(nums) - 1\n                while j < k:\n                    if nums[i] + nums[j] + nums[k] < 0:\n                        j += 1\n                    elif nums[i] + nums[j] + nums[k] > 0:\n                        k -= 1\n                    else:\n                        result.append([nums[i], nums[j], nums[k]])\n                        j, k = j + 1, k - 1\n                        while j < k and nums[j] == nums[j - 1]:\n                            j += 1\n                        while j < k and nums[k] == nums[k + 1]:\n                            k -= 1\n            i += 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)"
    },
    {
      "title": "All Nodes Distance K in Binary Tree",
      "difficulty": "MEDIUM",
      "category": "Hash Table, Tree, Depth-First Search, Breadth-First Search, Binary Tree",
      "link": "https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree",
      "slug": "all-nodes-distance-k-in-binary-tree",
      "description": "Given the \nroot\n of a binary tree, the value of a target node \ntarget\n, and an integer \nk\n, return \nan array of the values of all nodes that have a distance \nk\n from the target node.\n\n\nYou can return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2\n\nOutput:\n [7,4,1]\nExplanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1], target = 1, k = 3\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 500]\n.\n\n\n0 <= Node.val <= 500\n\n\nAll the values \nNode.val\n are \nunique\n.\n\n\ntarget\n is the value of one of the nodes in the tree.\n\n\n0 <= k <= 1000",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def distanceK(self, root, target, K):\n        \"\"\"\n        :type root: TreeNode\n        :type target: TreeNode\n        :type K: int\n        :rtype: List[int]\n        \"\"\"\n        def dfs(parent, child, neighbors):\n            if not child:\n                return\n            if parent:\n                neighbors[parent.val].append(child.val)\n                neighbors[child.val].append(parent.val)\n            dfs(child, child.left, neighbors)\n            dfs(child, child.right, neighbors)\n\n        neighbors = collections.defaultdict(list)\n        dfs(None, root, neighbors)\n        bfs = [target.val]\n        lookup = set(bfs)\n        for _ in xrange(K):\n            bfs = [nei for node in bfs\n                   for nei in neighbors[node]\n                   if nei not in lookup]\n            lookup |= set(bfs)\n        return bfs",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "String to Integer (atoi)",
      "difficulty": "MEDIUM",
      "category": "String",
      "link": "https://leetcode.com/problems/string-to-integer-atoi",
      "slug": "string-to-integer-atoi",
      "description": "Implement the \nmyAtoi(string s)\n function, which converts a string to a 32-bit signed integer.\n\n\nThe algorithm for \nmyAtoi(string s)\n is as follows:\n\n\n\n\nWhitespace\n: Ignore any leading whitespace (\n\" \"\n).\n\n\nSignedness\n: Determine the sign by checking if the next character is \n'-'\n or \n'+'\n, assuming positivity if neither present.\n\n\nConversion\n: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.\n\n\nRounding\n: If the integer is out of the 32-bit signed integer range \n[-2\n31\n, 2\n31\n - 1]\n, then round the integer to remain in the range. Specifically, integers less than \n-2\n31\n should be rounded to \n-2\n31\n, and integers greater than \n2\n31\n - 1\n should be rounded to \n2\n31\n - 1\n.\n\n\n\n\nReturn the integer as the final result.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"42\"\n\n\nOutput:\n \n42\n\n\nExplanation:\n\n\n\nThe underlined characters are what is read in and the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n42\n\" (\"42\" is read in)\n           ^\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \" -042\"\n\n\nOutput:\n \n-42\n\n\nExplanation:\n\n\n\nStep 1: \"\n   \n-042\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   \n-\n042\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -\n042\n\" (\"042\" is read in, leading zeros ignored in the result)\n               ^\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"1337c0d3\"\n\n\nOutput:\n \n1337\n\n\nExplanation:\n\n\n\nStep 1: \"1337c0d3\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"1337c0d3\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n1337\nc0d3\" (\"1337\" is read in; reading stops because the next character is a non-digit)\n             ^\n\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"0-1\"\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\nStep 1: \"0-1\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"0-1\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n0\n-1\" (\"0\" is read in; reading stops because the next character is a non-digit)\n          ^\n\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"words and 987\"\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nReading stops at the first non-digit character 'w'.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 200\n\n\ns\n consists of English letters (lower-case and upper-case), digits (\n0-9\n), \n' '\n, \n'+'\n, \n'-'\n, and \n'.'\n.",
      "solution": "class Solution(object):\n    def myAtoi(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: int\n        \"\"\"\n        INT_MAX =  2147483647\n        INT_MIN = -2147483648\n        result = 0\n\n        if not str:\n            return result\n\n        i = 0\n        while i < len(str) and str[i].isspace():\n            i += 1\n\n        if len(str) == i:\n            return result\n\n        sign = 1\n        if str[i] == \"+\":\n            i += 1\n        elif str[i] == \"-\":\n            sign = -1\n            i += 1\n\n        while i < len(str) and '0' <= str[i] <= '9':\n            if result > (INT_MAX - int(str[i])) / 10:\n                return INT_MAX if sign > 0 else INT_MIN\n            result = result * 10 + int(str[i])\n            i += 1\n\n        return sign * result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Contains Duplicate II",
      "difficulty": "EASY",
      "category": "Array, Hash Table, Sliding Window",
      "link": "https://leetcode.com/problems/contains-duplicate-ii",
      "slug": "contains-duplicate-ii",
      "description": "Given an integer array \nnums\n and an integer \nk\n, return \ntrue\n \nif there are two \ndistinct indices\n \ni\n and \nj\n in the array such that \nnums[i] == nums[j]\n and \nabs(i - j) <= k\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,1], k = 3\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,0,1,1], k = 1\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,2,3,1,2,3], k = 2\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n0 <= k <= 10\n5",
      "solution": "class Solution(object):\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {boolean}\n    def containsNearbyDuplicate(self, nums, k):\n        lookup = {}\n        for i, num in enumerate(nums):\n            if num not in lookup:\n                lookup[num] = i\n            else:\n                # If the value occurs before, check the difference.\n                if i - lookup[num] <= k:\n                    return True\n                # Update the index of the value.\n                lookup[num] = i\n        return False",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Zero Array Transformation III",
      "difficulty": "MEDIUM",
      "category": "Array, Greedy, Sorting, Heap (Priority Queue), Prefix Sum",
      "link": "https://leetcode.com/problems/zero-array-transformation-iii",
      "slug": "zero-array-transformation-iii",
      "description": "You are given an integer array \nnums\n of length \nn\n and a 2D array \nqueries\n where \nqueries[i] = [l\ni\n, r\ni\n]\n.\n\n\nEach \nqueries[i]\n represents the following action on \nnums\n:\n\n\n\n\nDecrement the value at each index in the range \n[l\ni\n, r\ni\n]\n in \nnums\n by \nat most\n \n1.\n\n\nThe amount by which the value is decremented can be chosen \nindependently\n for each index.\n\n\n\n\nA \nZero Array\n is an array with all its elements equal to 0.\n\n\nReturn the \nmaximum \nnumber of elements that can be removed from \nqueries\n, such that \nnums\n can still be converted to a \nzero array\n using the \nremaining\n queries. If it is not possible to convert \nnums\n to a \nzero array\n, return -1.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,0,2], queries = [[0,2],[0,2],[1,1]]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nAfter removing \nqueries[2]\n, \nnums\n can still be converted to a zero array.\n\n\n\n\nUsing \nqueries[0]\n, decrement \nnums[0]\n and \nnums[2]\n by 1 and \nnums[1]\n by 0.\n\n\nUsing \nqueries[1]\n, decrement \nnums[0]\n and \nnums[2]\n by 1 and \nnums[1]\n by 0.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,1,1,1], queries = [[1,3],[0,2],[1,3],[1,2]]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nWe can remove \nqueries[2]\n and \nqueries[3]\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,2,3,4], queries = [[0,3]]\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\nnums\n cannot be converted to a zero array even after using all the queries.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n0 <= nums[i] <= 10\n5\n\n\n1 <= queries.length <= 10\n5\n\n\nqueries[i].length == 2\n\n\n0 <= l\ni\n <= r\ni\n < nums.length",
      "solution": "\nimport heapq\n\n\n# sort, heap, greedyclass Solution(object):\n    def maxRemoval(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        queries.sort(reverse=True)\n        max_heap, min_heap = [], []\n        for i in xrange(len(nums)):\n            while queries and queries[-1][0] <= i:\n                heapq.heappush(max_heap, -queries.pop()[1])\n            while min_heap and min_heap[0] < i:\n                heapq.heappop(min_heap)\n            while len(min_heap) < nums[i]:\n                if not max_heap or -max_heap[0] < i:\n                    return -1\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        return len(max_heap)",
      "explanation": "N/A",
      "time_complexity": "O(n + qlogq)",
      "space_complexity": "O(q)"
    },
    {
      "title": "Swim in Rising Water",
      "difficulty": "HARD",
      "category": "Array, Binary Search, Depth-First Search, Breadth-First Search, Union Find, Heap (Priority Queue), Matrix",
      "link": "https://leetcode.com/problems/swim-in-rising-water",
      "slug": "swim-in-rising-water",
      "description": "You are given an \nn x n\n integer matrix \ngrid\n where each value \ngrid[i][j]\n represents the elevation at that point \n(i, j)\n.\n\n\nIt starts raining, and water gradually rises over time. At time \nt\n, the water level is \nt\n, meaning \nany\n cell with elevation less than equal to \nt\n is submerged or reachable.\n\n\nYou can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most \nt\n. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n\n\nReturn \nthe minimum time until you can reach the bottom right square \n(n - 1, n - 1)\n if you start at the top left square \n(0, 0)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,2],[1,3]]\n\nOutput:\n 3\nExplanation:\nAt time 0, you are in grid location (0, 0).\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\n\nOutput:\n 16\n\nExplanation:\n The final route is shown.\nWe need to wait until time 16 so that (0, 0) and (4, 4) are connected.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\nn == grid[i].length\n\n\n1 <= n <= 50\n\n\n0 <= grid[i][j] < n\n2\n\n\nEach value \ngrid[i][j]\n is \nunique\n.",
      "solution": "class UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        return True\n\nclass Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        positions = [None] * (n**2)\n        for i in xrange(n):\n            for j in xrange(n):\n                positions[grid[i][j]] = (i, j)\n        directions = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n        union_find = UnionFind(n**2)\n        for elevation in xrange(n**2):\n            i, j = positions[elevation]\n            for direction in directions:\n                x, y = i+direction[0], j+direction[1]\n                if 0 <= x < n and 0 <= y < n and grid[x][y] <= elevation:\n                    union_find.union_set(i*n+j, x*n+y)\n                    if union_find.find_set(0) == union_find.find_set(n**2-1):\n                        return elevation\n        return n**2-1",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n^2)"
    },
    {
      "title": "Managers with at Least 5 Direct Reports",
      "difficulty": "MEDIUM",
      "category": "Database",
      "link": "https://leetcode.com/problems/managers-with-at-least-5-direct-reports",
      "slug": "managers-with-at-least-5-direct-reports",
      "description": "Table: \nEmployee\n\n\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| department  | varchar |\n| managerId   | int     |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the name of an employee, their department, and the id of their manager.\nIf managerId is null, then the employee does not have a manager.\nNo employee will be the manager of themself.\n\n\n\n \n\n\nWrite a solution to find managers with at least \nfive direct reports\n.\n\n\nReturn the result table in \nany order\n.\n\n\nThe result format is in the following example.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nEmployee table:\n+-----+-------+------------+-----------+\n| id  | name  | department | managerId |\n+-----+-------+------------+-----------+\n| 101 | John  | A          | null      |\n| 102 | Dan   | A          | 101       |\n| 103 | James | A          | 101       |\n| 104 | Amy   | A          | 101       |\n| 105 | Anne  | A          | 101       |\n| 106 | Ron   | B          | 101       |\n+-----+-------+------------+-----------+\n\nOutput:\n \n+------+\n| name |\n+------+\n| John |\n+------+",
      "solution": "# Solution not found in kamyu104 repository",
      "explanation": "N/A",
      "time_complexity": "N/A",
      "space_complexity": "N/A"
    },
    {
      "title": "Maximum Swap",
      "difficulty": "MEDIUM",
      "category": "Math, Greedy",
      "link": "https://leetcode.com/problems/maximum-swap",
      "slug": "maximum-swap",
      "description": "You are given an integer \nnum\n. You can swap two digits at most once to get the maximum valued number.\n\n\nReturn \nthe maximum valued number you can get\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 2736\n\nOutput:\n 7236\n\nExplanation:\n Swap the number 2 and the number 7.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 9973\n\nOutput:\n 9973\n\nExplanation:\n No swap.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= num <= 10\n8",
      "solution": "class Solution(object):\n    def maximumSwap(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        digits = list(str(num))\n        left, right = 0, 0\n        max_idx = len(digits)-1\n        for i in reversed(xrange(len(digits))):\n            if digits[i] > digits[max_idx]:\n                max_idx = i\n            elif digits[max_idx] > digits[i]:\n                left, right = i, max_idx\n        digits[left], digits[right] = digits[right], digits[left]\n        return int(\"\".join(digits))",
      "explanation": "N/A",
      "time_complexity": "O(logn), logn is the length of the number string",
      "space_complexity": "O(logn)"
    },
    {
      "title": "Container With Most Water",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers, Greedy",
      "link": "https://leetcode.com/problems/container-with-most-water",
      "slug": "container-with-most-water",
      "description": "You are given an integer array \nheight\n of length \nn\n. There are \nn\n vertical lines drawn such that the two endpoints of the \ni\nth\n line are \n(i, 0)\n and \n(i, height[i])\n.\n\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\n\nReturn \nthe maximum amount of water a container can store\n.\n\n\nNotice\n that you may not slant the container.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [1,8,6,2,5,4,8,3,7]\n\nOutput:\n 49\n\nExplanation:\n The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [1,1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= height[i] <= 10\n4",
      "solution": "class Solution(object):\n    # @return an integer\n    def maxArea(self, height):\n        max_area, i, j = 0, 0, len(height) - 1\n        while i < j:\n            max_area = max(max_area, min(height[i], height[j]) * (j - i))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return max_area",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Cutting Ribbons",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/cutting-ribbons",
      "slug": "cutting-ribbons",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "class Solution(object):\n    def maxLength(self, ribbons, k):\n        \"\"\"\n        :type ribbons: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def check(ribbons, k, s):\n            return reduce(lambda total,x: total+x//s, ribbons, 0) >= k\n\n        left, right = 1, sum(ribbons)//k\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(ribbons, k, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right",
      "explanation": "N/A",
      "time_complexity": "O(nlogr), r is sum(ribbons)/k",
      "space_complexity": "O(1)"
    },
    {
      "title": "Word Break",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, String, Dynamic Programming, Trie, Memoization",
      "link": "https://leetcode.com/problems/word-break",
      "slug": "word-break",
      "description": "Given a string \ns\n and a dictionary of strings \nwordDict\n, return \ntrue\n if \ns\n can be segmented into a space-separated sequence of one or more dictionary words.\n\n\nNote\n that the same word in the dictionary may be reused multiple times in the segmentation.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"leetcode\", wordDict = [\"leet\",\"code\"]\n\nOutput:\n true\n\nExplanation:\n Return true because \"leetcode\" can be segmented as \"leet code\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\n\nOutput:\n true\n\nExplanation:\n Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\nNote that you are allowed to reuse a dictionary word.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 300\n\n\n1 <= wordDict.length <= 1000\n\n\n1 <= wordDict[i].length <= 20\n\n\ns\n and \nwordDict[i]\n consist of only lowercase English letters.\n\n\nAll the strings of \nwordDict\n are \nunique\n.",
      "solution": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: Set[str]\n        :rtype: bool\n        \"\"\"\n        n = len(s)\n\n        max_len = 0\n        for string in wordDict:\n            max_len = max(max_len, len(string))\n\n        can_break = [False for _ in xrange(n + 1)]\n        can_break[0] = True\n        for i in xrange(1, n + 1):\n            for l in xrange(1, min(i, max_len) + 1):\n                if can_break[i-l] and s[i-l:i] in wordDict:\n                    can_break[i] = True\n                    break\n\n        return can_break[-1]",
      "explanation": "N/A",
      "time_complexity": "O(n * l^2)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Binary Tree Maximum Path Sum",
      "difficulty": "HARD",
      "category": "Dynamic Programming, Tree, Depth-First Search, Binary Tree",
      "link": "https://leetcode.com/problems/binary-tree-maximum-path-sum",
      "slug": "binary-tree-maximum-path-sum",
      "description": "A \npath\n in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence \nat most once\n. Note that the path does not need to pass through the root.\n\n\nThe \npath sum\n of a path is the sum of the node's values in the path.\n\n\nGiven the \nroot\n of a binary tree, return \nthe maximum \npath sum\n of any \nnon-empty\n path\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3]\n\nOutput:\n 6\n\nExplanation:\n The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [-10,9,20,null,null,15,7]\n\nOutput:\n 42\n\nExplanation:\n The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 3 * 10\n4\n]\n.\n\n\n-1000 <= Node.val <= 1000",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return an integer\n    def maxPathSum(self, root):\n        def iter_dfs(node):\n            result = float(\"-inf\")\n            max_sum = [0]\n            stk = [(1, [node, max_sum])]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, ret = params\n                    if not node:\n                        continue\n                    ret1, ret2 = [0], [0]\n                    stk.append((2, [node, ret1, ret2, ret]))\n                    stk.append((1, [node.right, ret2]))\n                    stk.append((1, [node.left, ret1]))\n                elif step == 2:\n                    node, ret1, ret2, ret = params\n                    result = max(result, node.val+max(ret1[0], 0)+max(ret2[0], 0))\n                    ret[0] = node.val+max(ret1[0], ret2[0], 0)\n            return result\n        \n        return iter_dfs(root)\n\nclass Solution2(object):\n    # @param root, a tree node\n    # @return an integer\n    def maxPathSum(self, root):\n        def dfs(node):\n            if not node:\n                return (float(\"-inf\"), 0)\n            max_left, curr_left = dfs(node.left)\n            max_right, curr_right = dfs(node.right)\n            return (max(max_left, max_right, node.val+max(curr_left, 0)+max(curr_right, 0)),\n                    node.val+max(curr_left, curr_right, 0))\n        \n        return dfs(root)[0]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h), h is height of binary tree"
    },
    {
      "title": "Car Pooling",
      "difficulty": "MEDIUM",
      "category": "Array, Sorting, Heap (Priority Queue), Simulation, Prefix Sum",
      "link": "https://leetcode.com/problems/car-pooling",
      "slug": "car-pooling",
      "description": "There is a car with \ncapacity\n empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west).\n\n\nYou are given the integer \ncapacity\n and an array \ntrips\n where \ntrips[i] = [numPassengers\ni\n, from\ni\n, to\ni\n]\n indicates that the \ni\nth\n trip has \nnumPassengers\ni\n passengers and the locations to pick them up and drop them off are \nfrom\ni\n and \nto\ni\n respectively. The locations are given as the number of kilometers due east from the car's initial location.\n\n\nReturn \ntrue\n if it is possible to pick up and drop off all passengers for all the given trips, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n trips = [[2,1,5],[3,3,7]], capacity = 4\n\nOutput:\n false\n\n\n\nExample 2:\n\n\n\n\nInput:\n trips = [[2,1,5],[3,3,7]], capacity = 5\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= trips.length <= 1000\n\n\ntrips[i].length == 3\n\n\n1 <= numPassengers\ni\n <= 100\n\n\n0 <= from\ni\n < to\ni\n <= 1000\n\n\n1 <= capacity <= 10\n5",
      "solution": "class Solution(object):\n    def carPooling(self, trips, capacity):\n        \"\"\"\n        :type trips: List[List[int]]\n        :type capacity: int\n        :rtype: bool\n        \"\"\"\n        line = [x for num, start, end in trips for x in [[start, num], [end, -num]]]\n        line.sort()\n        for _, num in line:\n            capacity -= num\n            if capacity < 0:\n                return False\n        return True",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Strobogrammatic Number",
      "difficulty": "EASY",
      "category": "Hash Table, Two Pointers, String",
      "link": "https://leetcode.com/problems/strobogrammatic-number",
      "slug": "strobogrammatic-number",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "class Solution(object):\n    lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'}\n\n    # @param {string} num\n    # @return {boolean}\n    def isStrobogrammatic(self, num):\n        n = len(num)\n        for i in xrange((n+1) / 2):\n            if num[n-1-i] not in self.lookup or \\\n               num[i] != self.lookup[num[n-1-i]]:\n                return False\n        return True",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Capacity To Ship Packages Within D Days",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/capacity-to-ship-packages-within-d-days",
      "slug": "capacity-to-ship-packages-within-d-days",
      "description": "A conveyor belt has packages that must be shipped from one port to another within \ndays\n days.\n\n\nThe \ni\nth\n package on the conveyor belt has a weight of \nweights[i]\n. Each day, we load the ship with packages on the conveyor belt (in the order given by \nweights\n). We may not load more weight than the maximum weight capacity of the ship.\n\n\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within \ndays\n days.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n weights = [1,2,3,4,5,6,7,8,9,10], days = 5\n\nOutput:\n 15\n\nExplanation:\n A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\n1st day: 1, 2, 3, 4, 5\n2nd day: 6, 7\n3rd day: 8\n4th day: 9\n5th day: 10\n\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.\n\n\n\nExample 2:\n\n\n\n\nInput:\n weights = [3,2,2,4,1,4], days = 3\n\nOutput:\n 6\n\nExplanation:\n A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:\n1st day: 3, 2\n2nd day: 2, 4\n3rd day: 1, 4\n\n\n\nExample 3:\n\n\n\n\nInput:\n weights = [1,2,3,1,1], days = 4\n\nOutput:\n 3\n\nExplanation:\n\n1st day: 1\n2nd day: 2\n3rd day: 3\n4th day: 1, 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= days <= weights.length <= 5 * 10\n4\n\n\n1 <= weights[i] <= 500",
      "solution": "class Solution(object):\n    def shipWithinDays(self, weights, D):\n        \"\"\"\n        :type weights: List[int]\n        :type D: int\n        :rtype: int\n        \"\"\"\n        def possible(weights, D, mid):\n            result, curr = 1, 0\n            for w in weights:\n                if curr+w > mid:\n                    result += 1\n                    curr = 0\n                curr += w\n            return result <= D\n    \n        left, right = max(weights), sum(weights)\n        while left <= right:\n            mid = left + (right-left)//2\n            if possible(weights, D, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left",
      "explanation": "N/A",
      "time_complexity": "O(nlogr)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Longest Substring Without Repeating Characters",
      "difficulty": "MEDIUM",
      "category": "Hash Table, String, Sliding Window",
      "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters",
      "slug": "longest-substring-without-repeating-characters",
      "description": "Given a string \ns\n, find the length of the \nlongest\n \nsubstring\n without duplicate characters.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abcabcbb\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"abc\", with the length of 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"bbbbb\"\n\nOutput:\n 1\n\nExplanation:\n The answer is \"b\", with the length of 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"pwwkew\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 5 * 10\n4\n\n\ns\n consists of English letters, digits, symbols and spaces.",
      "solution": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, left = 0, 0\n        lookup = {}\n        for right in xrange(len(s)):\n            if s[right] in lookup:\n                left = max(left, lookup[s[right]]+1)\n            lookup[s[right]] = right\n            result = max(result, right-left+1)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Word Ladder",
      "difficulty": "HARD",
      "category": "Hash Table, String, Breadth-First Search",
      "link": "https://leetcode.com/problems/word-ladder",
      "slug": "word-ladder",
      "description": "A \ntransformation sequence\n from word \nbeginWord\n to word \nendWord\n using a dictionary \nwordList\n is a sequence of words \nbeginWord -> s\n1\n -> s\n2\n -> ... -> s\nk\n such that:\n\n\n\n\nEvery adjacent pair of words differs by a single letter.\n\n\nEvery \ns\ni\n for \n1 <= i <= k\n is in \nwordList\n. Note that \nbeginWord\n does not need to be in \nwordList\n.\n\n\ns\nk\n == endWord\n\n\n\n\nGiven two words, \nbeginWord\n and \nendWord\n, and a dictionary \nwordList\n, return \nthe \nnumber of words\n in the \nshortest transformation sequence\n from\n \nbeginWord\n \nto\n \nendWord\n, or \n0\n if no such sequence exists.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\nOutput:\n 5\n\nExplanation:\n One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\n\n\n\nExample 2:\n\n\n\n\nInput:\n beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n\nOutput:\n 0\n\nExplanation:\n The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= beginWord.length <= 10\n\n\nendWord.length == beginWord.length\n\n\n1 <= wordList.length <= 5000\n\n\nwordList[i].length == beginWord.length\n\n\nbeginWord\n, \nendWord\n, and \nwordList[i]\n consist of lowercase English letters.\n\n\nbeginWord != endWord\n\n\nAll the words in \nwordList\n are \nunique\n.",
      "solution": "\nfrom string import ascii_lowercase\n\n\n# two-end bfsclass Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        words = set(wordList)\n        if endWord not in words:\n            return 0\n        left, right = {beginWord}, {endWord}\n        ladder = 2\n        while left:\n            words -= left\n            new_left = set()\n            for word in left:\n                for new_word in (word[:i]+c+word[i+1:] for i in xrange(len(beginWord)) for c in ascii_lowercase):\n                    if new_word not in words:\n                        continue\n                    if new_word in right: \n                        return ladder\n                    new_left.add(new_word)\n            left = new_left\n            ladder += 1\n            if len(left) > len(right): \n                left, right = right, left\n        return 0\n\nclass Solution2(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        lookup = set(wordList)\n        if endWord not in lookup:\n            return 0\n        ladder = 2\n        q = [beginWord]\n        while q:\n            new_q = []\n            for word in q:\n                for i in xrange(len(word)):\n                    for j in ascii_lowercase:\n                        new_word = word[:i] + j + word[i+1:]\n                        if new_word == endWord:\n                            return ladder\n                        if new_word in lookup:\n                            lookup.remove(new_word)\n                            new_q.append(new_word)\n            q = new_q\n            ladder += 1\n        return 0",
      "explanation": "N/A",
      "time_complexity": "O(b^d), b is the branch factor of bfs, d is the result depth",
      "space_complexity": "O(w * l), w is the number of words, l is the max length of words"
    },
    {
      "title": "Find Median from Data Stream",
      "difficulty": "HARD",
      "category": "Two Pointers, Design, Sorting, Heap (Priority Queue), Data Stream",
      "link": "https://leetcode.com/problems/find-median-from-data-stream",
      "slug": "find-median-from-data-stream",
      "description": "The \nmedian\n is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\n\n\n\nFor example, for \narr = [2,3,4]\n, the median is \n3\n.\n\n\nFor example, for \narr = [2,3]\n, the median is \n(2 + 3) / 2 = 2.5\n.\n\n\n\n\nImplement the MedianFinder class:\n\n\n\n\nMedianFinder()\n initializes the \nMedianFinder\n object.\n\n\nvoid addNum(int num)\n adds the integer \nnum\n from the data stream to the data structure.\n\n\ndouble findMedian()\n returns the median of all elements so far. Answers within \n10\n-5\n of the actual answer will be accepted.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\n\nOutput\n\n[null, null, null, 1.5, null, 2.0]\n\n\nExplanation\n\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-10\n5\n <= num <= 10\n5\n\n\nThere will be at least one element in the data structure before calling \nfindMedian\n.\n\n\nAt most \n5 * 10\n4\n calls will be made to \naddNum\n and \nfindMedian\n.\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nIf all integer numbers from the stream are in the range \n[0, 100]\n, how would you optimize your solution?\n\n\nIf \n99%\n of all integer numbers from the stream are in the range \n[0, 100]\n, how would you optimize your solution?",
      "solution": "\nfrom heapq import heappush, heappop\nclass MedianFinder(object):\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__max_heap = []\n        self.__min_heap = []\n\n    def addNum(self, num):\n        \"\"\"\n        Adds a num into the data structure.\n        :type num: int\n        :rtype: void\n        \"\"\"\n        # Balance smaller half and larger half.\n        if not self.__max_heap or num > -self.__max_heap[0]:\n            heappush(self.__min_heap, num)\n            if len(self.__min_heap) > len(self.__max_heap) + 1:\n                heappush(self.__max_heap, -heappop(self.__min_heap))\n        else:\n            heappush(self.__max_heap, -num)\n            if len(self.__max_heap) > len(self.__min_heap):\n                heappush(self.__min_heap, -heappop(self.__max_heap))\n\n    def findMedian(self):\n        \"\"\"\n        Returns the median of current data stream\n        :rtype: float\n        \"\"\"\n        return (-self.__max_heap[0] + self.__min_heap[0]) / 2.0 \\\n               if len(self.__min_heap) == len(self.__max_heap) \\\n               else self.__min_heap[0]",
      "explanation": "N/A",
      "time_complexity": "O(nlogn) for total n addNums, O(logn) per addNum, O(1) per findMedian.",
      "space_complexity": "O(n), total space"
    },
    {
      "title": "Valid Palindrome III",
      "difficulty": "HARD",
      "category": "String, Dynamic Programming",
      "link": "https://leetcode.com/problems/valid-palindrome-iii",
      "slug": "valid-palindrome-iii",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "class Solution(object):\n    def isValidPalindrome(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        if s == s[::-1]:  # optional, to optimize special case\n            return True\n\n        dp = [[1] * len(s) for _ in xrange(2)]\n        for i in reversed(xrange(len(s))):\n            for j in xrange(i+1, len(s)):\n                if s[i] == s[j]:\n                    dp[i%2][j] = 2 + dp[(i+1)%2][j-1] if i+1 <= j-1 else 2\n                else:\n                    dp[i%2][j] = max(dp[(i+1)%2][j], dp[i%2][j-1])\n        return len(s) <= k + dp[0][-1]",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Kth Smallest Element in a Sorted Matrix",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search, Sorting, Heap (Priority Queue), Matrix",
      "link": "https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix",
      "slug": "kth-smallest-element-in-a-sorted-matrix",
      "description": "Given an \nn x n\n \nmatrix\n where each of the rows and columns is sorted in ascending order, return \nthe\n \nk\nth\n \nsmallest element in the matrix\n.\n\n\nNote that it is the \nk\nth\n smallest element \nin the sorted order\n, not the \nk\nth\n \ndistinct\n element.\n\n\nYou must find a solution with a memory complexity better than \nO(n\n2\n)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n\nOutput:\n 13\n\nExplanation:\n The elements in the matrix are [1,5,9,10,11,12,13,\n13\n,15], and the 8\nth\n smallest number is 13\n\n\n\nExample 2:\n\n\n\n\nInput:\n matrix = [[-5]], k = 1\n\nOutput:\n -5\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 300\n\n\n-10\n9\n <= matrix[i][j] <= 10\n9\n\n\nAll the rows and columns of \nmatrix\n are \nguaranteed\n to be sorted in \nnon-decreasing order\n.\n\n\n1 <= k <= n\n2\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nCould you solve the problem with a constant memory (i.e., \nO(1)\n memory complexity)?\n\n\nCould you solve the problem in \nO(n)\n time complexity? The solution may be too advanced for an interview but you may find reading \nthis paper\n fun.",
      "solution": "\nfrom heapq import heappush, heappop\nclass Solution(object):\n    def kthSmallest(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        kth_smallest = 0\n        min_heap = []\n\n        def push(i, j):\n            if len(matrix) > len(matrix[0]):\n                if i < len(matrix[0]) and j < len(matrix):\n                    heappush(min_heap, [matrix[j][i], i, j])\n            else:\n                if i < len(matrix) and j < len(matrix[0]):\n                    heappush(min_heap, [matrix[i][j], i, j])\n\n        push(0, 0)\n        while min_heap and k > 0:\n            kth_smallest, i, j = heappop(min_heap)\n            push(i, j + 1)\n            if j == 0:\n                push(i + 1, 0)\n            k -= 1\n\n        return kth_smallest",
      "explanation": "N/A",
      "time_complexity": "O(k * log(min(n, m, k))), with n x m matrix",
      "space_complexity": "O(min(n, m, k))"
    },
    {
      "title": "Add Two Integers",
      "difficulty": "EASY",
      "category": "Math",
      "link": "https://leetcode.com/problems/add-two-integers",
      "slug": "add-two-integers",
      "description": "Given two integers \nnum1\n and \nnum2\n, return \nthe \nsum\n of the two integers\n.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num1 = 12, num2 = 5\n\nOutput:\n 17\n\nExplanation:\n num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is returned.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num1 = -10, num2 = 4\n\nOutput:\n -6\n\nExplanation:\n num1 + num2 = -6, so -6 is returned.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-100 <= num1, num2 <= 100",
      "solution": "\n# mathclass Solution(object):\n    def sum(self, num1, num2):\n        \"\"\"\n        :type num1: int\n        :type num2: int\n        :rtype: int\n        \"\"\"\n        return num1+num2",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Shortest Path in a Hidden Grid",
      "difficulty": "MEDIUM",
      "category": "Array, Depth-First Search, Breadth-First Search, Matrix, Interactive",
      "link": "https://leetcode.com/problems/shortest-path-in-a-hidden-grid",
      "slug": "shortest-path-in-a-hidden-grid",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "class GridMaster(object):\n    def canMove(self, direction):\n        pass\n\n    def move(self, direction):\n        pass\n\n    def isTarget(self):\n        pass\n\n\nimport collections\n\nclass Solution(object):\n    def findShortestPath(self, master):\n        \"\"\"\n        :type master: GridMaster\n        :rtype: int\n        \"\"\"\n        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        rollback = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}\n\n        def dfs(pos, target, master, lookup, adj):\n            if target[0] is None and master.isTarget():\n                target[0] = pos\n            lookup.add(pos)\n            for d, (di, dj) in directions.iteritems():\n                if not master.canMove(d):\n                    continue\n                nei = (pos[0]+di, pos[1]+dj)\n                adj[pos].add(nei)\n                adj[nei].add(pos)\n                if nei in lookup:\n                    continue\n                master.move(d)\n                dfs(nei, target, master, lookup, adj)\n                master.move(rollback[d])\n                        \n        def bi_bfs(adj, start, target):\n            left, right = {start}, {target}\n            lookup = set()\n            steps = 0\n            while left:\n                for pos in left:\n                    lookup.add(pos)\n                new_left = set()\n                for pos in left:\n                    if pos in right: \n                        return steps\n                    for nei in adj[pos]:\n                        if nei in lookup:\n                            continue\n                        new_left.add(nei)\n                left = new_left\n                steps += 1\n                if len(left) > len(right): \n                    left, right = right, left\n            return -1         \n        \n        start = (0, 0)\n        target = [None]\n        adj = collections.defaultdict(set)\n        dfs(start, target, master, set(), adj)\n        if not target[0]:\n            return -1\n        return bi_bfs(adj, start, target[0])\n\nclass Solution2(object):\n    def findShortestPath(self, master):\n        \"\"\"\n        :type master: GridMaster\n        :rtype: int\n        \"\"\"\n        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        rollback = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}\n\n        def dfs(pos, target, master, lookup, adj):\n            if target[0] is None and master.isTarget():\n                target[0] = pos\n            lookup.add(pos)\n            for d, (di, dj) in directions.iteritems():\n                if not master.canMove(d):\n                    continue\n                nei = (pos[0]+di, pos[1]+dj)\n                adj[pos].add(nei)\n                adj[nei].add(pos)\n                if nei in lookup:\n                    continue\n                master.move(d)\n                dfs(nei, target, master, lookup, adj)\n                master.move(rollback[d])\n                        \n        def bfs(adj, start, target):\n            q = [start]\n            lookup = set(q)\n            steps = 0\n            while q:\n                new_q = []\n                for pos in q:\n                    if pos == target:\n                        return steps\n                    for nei in adj[pos]:\n                        if nei in lookup:\n                            continue\n                        lookup.add(nei)\n                        new_q.append(nei)\n                q = new_q\n                steps += 1\n            return -1  \n        \n        start = (0, 0)\n        target = [None]\n        adj = collections.defaultdict(set)\n        dfs(start, target, master, set(), adj)\n        if not target[0]:\n            return -1\n        return bfs(adj, start, target[0])",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "Maximum Subarray",
      "difficulty": "MEDIUM",
      "category": "Array, Divide and Conquer, Dynamic Programming",
      "link": "https://leetcode.com/problems/maximum-subarray",
      "slug": "maximum-subarray",
      "description": "Given an integer array \nnums\n, find the \nsubarray\n with the largest sum, and return \nits sum\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-2,1,-3,4,-1,2,1,-5,4]\n\nOutput:\n 6\n\nExplanation:\n The subarray [4,-1,2,1] has the largest sum 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1]\n\nOutput:\n 1\n\nExplanation:\n The subarray [1] has the largest sum 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [5,4,-1,7,8]\n\nOutput:\n 23\n\nExplanation:\n The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n If you have figured out the \nO(n)\n solution, try coding another solution using the \ndivide and conquer\n approach, which is more subtle.",
      "solution": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, curr = float(\"-inf\"), float(\"-inf\")\n        for x in nums:\n            curr = max(curr+x, x)\n            result = max(result, curr)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Interval List Intersections",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers, Line Sweep",
      "link": "https://leetcode.com/problems/interval-list-intersections",
      "slug": "interval-list-intersections",
      "description": "You are given two lists of closed intervals, \nfirstList\n and \nsecondList\n, where \nfirstList[i] = [start\ni\n, end\ni\n]\n and \nsecondList[j] = [start\nj\n, end\nj\n]\n. Each list of intervals is pairwise \ndisjoint\n and in \nsorted order\n.\n\n\nReturn \nthe intersection of these two interval lists\n.\n\n\nA \nclosed interval\n \n[a, b]\n (with \na <= b\n) denotes the set of real numbers \nx\n with \na <= x <= b\n.\n\n\nThe \nintersection\n of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of \n[1, 3]\n and \n[2, 4]\n is \n[2, 3]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]\n\nOutput:\n [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n firstList = [[1,3],[5,9]], secondList = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= firstList.length, secondList.length <= 1000\n\n\nfirstList.length + secondList.length >= 1\n\n\n0 <= start\ni\n < end\ni\n <= 10\n9\n\n\nend\ni\n < start\ni+1\n\n\n0 <= start\nj\n < end\nj\n <= 10\n9\n \n\n\nend\nj\n < start\nj+1",
      "solution": "\n# Definition for an interval.class Interval(object):\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\nclass Solution(object):\n    def intervalIntersection(self, A, B):\n        \"\"\"\n        :type A: List[Interval]\n        :type B: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        result = []\n        i, j = 0, 0\n        while i < len(A) and j < len(B):\n            left = max(A[i].start, B[j].start)\n            right = min(A[i].end, B[j].end)\n            if left <= right:\n                result.append(Interval(left, right))\n            if A[i].end < B[j].end:\n                i += 1\n            else:\n                j += 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(m + n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Range Sum Query - Immutable",
      "difficulty": "EASY",
      "category": "Array, Design, Prefix Sum",
      "link": "https://leetcode.com/problems/range-sum-query-immutable",
      "slug": "range-sum-query-immutable",
      "description": "Given an integer array \nnums\n, handle multiple queries of the following type:\n\n\n\n\nCalculate the \nsum\n of the elements of \nnums\n between indices \nleft\n and \nright\n \ninclusive\n where \nleft <= right\n.\n\n\n\n\nImplement the \nNumArray\n class:\n\n\n\n\nNumArray(int[] nums)\n Initializes the object with the integer array \nnums\n.\n\n\nint sumRange(int left, int right)\n Returns the \nsum\n of the elements of \nnums\n between indices \nleft\n and \nright\n \ninclusive\n (i.e. \nnums[left] + nums[left + 1] + ... + nums[right]\n).\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n\nOutput\n\n[null, 1, -1, -3]\n\n\nExplanation\n\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n5\n <= nums[i] <= 10\n5\n\n\n0 <= left <= right < nums.length\n\n\nAt most \n10\n4\n calls will be made to \nsumRange\n.",
      "solution": "#        lookup: O(1)\nclass NumArray(object):\n    def __init__(self, nums):\n        \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n        self.accu = [0]\n        for num in nums:\n            self.accu.append(self.accu[-1] + num),\n\n    def sumRange(self, i, j):\n        \"\"\"\n        sum of elements nums[i..j], inclusive.\n        :type i: int\n        :type j: int\n        :rtype: int\n        \"\"\"\n        return self.accu[j + 1] - self.accu[i]",
      "explanation": "N/A",
      "time_complexity": "ctor:   O(n),",
      "space_complexity": "O(n)"
    },
    {
      "title": "Frequency of the Most Frequent Element",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search, Greedy, Sliding Window, Sorting, Prefix Sum",
      "link": "https://leetcode.com/problems/frequency-of-the-most-frequent-element",
      "slug": "frequency-of-the-most-frequent-element",
      "description": "The \nfrequency\n of an element is the number of times it occurs in an array.\n\n\nYou are given an integer array \nnums\n and an integer \nk\n. In one operation, you can choose an index of \nnums\n and increment the element at that index by \n1\n.\n\n\nReturn \nthe \nmaximum possible frequency\n of an element after performing \nat most\n \nk\n operations\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,4], k = 5\n\nOutput:\n 3\n\nExplanation:\n Increment the first element three times and the second element two times to make nums = [4,4,4].\n4 has a frequency of 3.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,4,8,13], k = 5\n\nOutput:\n 2\n\nExplanation:\n There are multiple optimal solutions:\n- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.\n- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.\n- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,9,6], k = 2\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n1 <= nums[i] <= 10\n5\n\n\n1 <= k <= 10\n5",
      "solution": "class Solution(object):\n    def maxFrequency(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        left = 0\n        nums.sort()\n        for right in xrange(len(nums)):\n            k += nums[right]\n            if k < nums[right]*(right-left+1):\n                k -= nums[left]\n                left += 1\n        return right-left+1",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Random Pick Index",
      "difficulty": "MEDIUM",
      "category": "Hash Table, Math, Reservoir Sampling, Randomized",
      "link": "https://leetcode.com/problems/random-pick-index",
      "slug": "random-pick-index",
      "description": "Given an integer array \nnums\n with possible \nduplicates\n, randomly output the index of a given \ntarget\n number. You can assume that the given target number must exist in the array.\n\n\nImplement the \nSolution\n class:\n\n\n\n\nSolution(int[] nums)\n Initializes the object with the array \nnums\n.\n\n\nint pick(int target)\n Picks a random index \ni\n from \nnums\n where \nnums[i] == target\n. If there are multiple valid i's, then each index should have an equal probability of returning.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"Solution\", \"pick\", \"pick\", \"pick\"]\n[[[1, 2, 3, 3, 3]], [3], [1], [3]]\n\nOutput\n\n[null, 4, 0, 2]\n\n\nExplanation\n\nSolution solution = new Solution([1, 2, 3, 3, 3]);\nsolution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\nsolution.pick(1); // It should return 0. Since in the array only nums[0] is equal to 1.\nsolution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2 * 10\n4\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\ntarget\n is an integer from \nnums\n.\n\n\nAt most \n10\n4\n calls will be made to \npick\n.",
      "solution": "#        pick: O(1)\n\nfrom random import randint\nimport collections\n\nclass Solution(object):\n\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        self.__lookup = collections.defaultdict(list)\n        for i, x in enumerate(nums):\n            self.__lookup[x].append(i)\n\n    def pick(self, target):\n        \"\"\"\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.__lookup[target][randint(0, len(self.__lookup[target])-1)]\n\n\n#        pick: O(n)\nfrom random import randint\n\nclass Solution_TLE(object):\n\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        self.__nums = nums\n\n    def pick(self, target):\n        \"\"\"\n        :type target: int\n        :rtype: int\n        \"\"\"\n        reservoir = -1\n        n = 0\n        for i in xrange(len(self.__nums)):\n            if self.__nums[i] != target:\n                continue\n            reservoir = i if randint(1, n+1) == 1 else reservoir\n            n += 1\n        return reservoir",
      "explanation": "N/A",
      "time_complexity": "ctor: O(1)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Kth Smallest Element in a BST",
      "difficulty": "MEDIUM",
      "category": "Tree, Depth-First Search, Binary Search Tree, Binary Tree",
      "link": "https://leetcode.com/problems/kth-smallest-element-in-a-bst",
      "slug": "kth-smallest-element-in-a-bst",
      "description": "Given the \nroot\n of a binary search tree, and an integer \nk\n, return \nthe\n \nk\nth\n \nsmallest value (\n1-indexed\n) of all the values of the nodes in the tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,1,4,null,2], k = 1\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,3,6,2,4,null,null,1], k = 3\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is \nn\n.\n\n\n1 <= k <= n <= 10\n4\n\n\n0 <= Node.val <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?",
      "solution": "class Solution(object):\n    # @param {TreeNode} root\n    # @param {integer} k\n    # @return {integer}\n    def kthSmallest(self, root, k):\n        s, cur, rank = [], root, 0\n\n        while s or cur:\n            if cur:\n                s.append(cur)\n                cur = cur.left\n            else:\n                cur = s.pop()\n                rank += 1\n                if rank == k:\n                    return cur.val\n                cur = cur.right\n\n        return float(\"-inf\")\n\n\n# time: O(max(h, k))\n# space: O(h)\n\nfrom itertools import islice\n\nclass Solution2(object):\n    def kthSmallest(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def gen_inorder(root):\n            if root:\n                for n in gen_inorder(root.left):\n                    yield n\n\n                yield root.val\n\n                for n in gen_inorder(root.right):\n                    yield n\n\n        return next(islice(gen_inorder(root), k-1, k))",
      "explanation": "N/A",
      "time_complexity": "O(max(h, k))",
      "space_complexity": "O(h)"
    },
    {
      "title": "Decode String",
      "difficulty": "MEDIUM",
      "category": "String, Stack, Recursion",
      "link": "https://leetcode.com/problems/decode-string",
      "slug": "decode-string",
      "description": "Given an encoded string, return its decoded string.\n\n\nThe encoding rule is: \nk[encoded_string]\n, where the \nencoded_string\n inside the square brackets is being repeated exactly \nk\n times. Note that \nk\n is guaranteed to be a positive integer.\n\n\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, \nk\n. For example, there will not be input like \n3a\n or \n2[4]\n.\n\n\nThe test cases are generated so that the length of the output will never exceed \n10\n5\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"3[a]2[bc]\"\n\nOutput:\n \"aaabcbc\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"3[a2[c]]\"\n\nOutput:\n \"accaccacc\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"2[abc]3[cd]ef\"\n\nOutput:\n \"abcabccdcdcdef\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 30\n\n\ns\n consists of lowercase English letters, digits, and square brackets \n'[]'\n.\n\n\ns\n is guaranteed to be \na valid\n input.\n\n\nAll the integers in \ns\n are in the range \n[1, 300]\n.",
      "solution": "class Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n, curr, nums, strs = 0, [], [], []\n        for c in s:\n            if c.isdigit():\n                n = n*10 + ord(c)-ord('0')\n            elif c.isalpha():\n                curr.append(c)\n            elif c == '[':\n                nums.append(n)\n                strs.append(curr)\n                n, curr = 0, []\n            elif c == ']':\n                strs[-1].extend(curr*nums.pop())\n                curr = strs.pop()\n        return \"\".join(curr)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Koko Eating Bananas",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/koko-eating-bananas",
      "slug": "koko-eating-bananas",
      "description": "Koko loves to eat bananas. There are \nn\n piles of bananas, the \ni\nth\n pile has \npiles[i]\n bananas. The guards have gone and will come back in \nh\n hours.\n\n\nKoko can decide her bananas-per-hour eating speed of \nk\n. Each hour, she chooses some pile of bananas and eats \nk\n bananas from that pile. If the pile has less than \nk\n bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\n\nReturn \nthe minimum integer\n \nk\n \nsuch that she can eat all the bananas within\n \nh\n \nhours\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n piles = [3,6,7,11], h = 8\n\nOutput:\n 4\n\n\n\nExample 2:\n\n\n\n\nInput:\n piles = [30,11,23,4,20], h = 5\n\nOutput:\n 30\n\n\n\nExample 3:\n\n\n\n\nInput:\n piles = [30,11,23,4,20], h = 6\n\nOutput:\n 23\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= piles.length <= 10\n4\n\n\npiles.length <= h <= 10\n9\n\n\n1 <= piles[i] <= 10\n9",
      "solution": "class Solution(object):\n    def minEatingSpeed(self, piles, H):\n        \"\"\"\n        :type piles: List[int]\n        :type H: int\n        :rtype: int\n        \"\"\"\n        def possible(piles, H, K):\n            return sum((pile-1)//K+1 for pile in piles) <= H\n\n        left, right = 1, max(piles)\n        while left <= right:\n            mid = left + (right-left)//2\n            if possible(piles, H, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left",
      "explanation": "N/A",
      "time_complexity": "O(nlogr)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Goat Latin",
      "difficulty": "EASY",
      "category": "String",
      "link": "https://leetcode.com/problems/goat-latin",
      "slug": "goat-latin",
      "description": "You are given a string \nsentence\n that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\n\n\nWe would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n\n\n\n\nIf a word begins with a vowel (\n'a'\n, \n'e'\n, \n'i'\n, \n'o'\n, or \n'u'\n), append \n\"ma\"\n to the end of the word.\n\n\t\n\n\nFor example, the word \n\"apple\"\n becomes \n\"applema\"\n.\n\n\n\n\n\n\nIf a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add \n\"ma\"\n.\n\t\n\n\nFor example, the word \n\"goat\"\n becomes \n\"oatgma\"\n.\n\n\n\n\n\n\nAdd one letter \n'a'\n to the end of each word per its word index in the sentence, starting with \n1\n.\n\t\n\n\nFor example, the first word gets \n\"a\"\n added to the end, the second word gets \n\"aa\"\n added to the end, and so on.\n\n\n\n\n\n\n\n\nReturn\n the final sentence representing the conversion from sentence to Goat Latin\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n sentence = \"I speak Goat Latin\"\n\nOutput:\n \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"\n\nExample 2:\n\n\nInput:\n sentence = \"The quick brown fox jumped over the lazy dog\"\n\nOutput:\n \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= sentence.length <= 150\n\n\nsentence\n consists of English letters and spaces.\n\n\nsentence\n has no leading or trailing spaces.\n\n\nAll the words in \nsentence\n are separated by a single space.",
      "solution": "#                    n is the length of S,\n#                    w is the number of word,\n#                    l is the average length of word\nclass Solution(object):\n    def toGoatLatin(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n        def convert(S):\n            vowel = set('aeiouAEIOU')\n            for i, word in enumerate(S.split(), 1):\n                if word[0] not in vowel:\n                    word = word[1:] + word[:1]\n                yield word + 'ma' + 'a'*i\n        return \" \".join(convert(S))",
      "explanation": "N/A",
      "time_complexity": "O(n + w^2), n = w * l,",
      "space_complexity": "O(n)"
    },
    {
      "title": "Longest Palindromic Substring",
      "difficulty": "MEDIUM",
      "category": "Two Pointers, String, Dynamic Programming",
      "link": "https://leetcode.com/problems/longest-palindromic-substring",
      "slug": "longest-palindromic-substring",
      "description": "Given a string \ns\n, return \nthe longest\n \npalindromic\n \nsubstring\n in \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"babad\"\n\nOutput:\n \"bab\"\n\nExplanation:\n \"aba\" is also a valid answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"cbbd\"\n\nOutput:\n \"bb\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consist of only digits and English letters.",
      "solution": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def preProcess(s):\n            if not s:\n                return ['^', '$']\n            T = ['^']\n            for c in s:\n                T +=  ['#', c]\n            T += ['#', '$']\n            return T\n\n        T = preProcess(s)\n        P = [0] * len(T)\n        center, right = 0, 0\n        for i in xrange(1, len(T) - 1):\n            i_mirror = 2 * center - i\n            if right > i:\n                P[i] = min(right - i, P[i_mirror])\n            else:\n                P[i] = 0\n\n            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:\n                P[i] += 1\n\n            if i + P[i] > right:\n                center, right = i, i + P[i]\n\n        max_i = 0\n        for i in xrange(1, len(T) - 1):\n            if P[i] > P[max_i]:\n                max_i = i\n        start = (max_i - 1 - P[max_i]) // 2\n        return s[start : start + P[max_i]]\n\nclass Solution2(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return (right-left+1)-2\n        \n        left, right = -1, -2\n        for i in xrange(len(s)):\n            l = max(expand(s, i, i), expand(s, i, i+1))\n            if l > right-left+1:\n                right = i+l//2\n                left = right-l+1\n        return s[left:right+1] if left >= 0 else \"\"",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Text Justification",
      "difficulty": "HARD",
      "category": "Array, String, Simulation",
      "link": "https://leetcode.com/problems/text-justification",
      "slug": "text-justification",
      "description": "Given an array of strings \nwords\n and a width \nmaxWidth\n, format the text such that each line has exactly \nmaxWidth\n characters and is fully (left and right) justified.\n\n\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces \n' '\n when necessary so that each line has exactly \nmaxWidth\n characters.\n\n\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n\n\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\n\n\nNote:\n\n\n\n\nA word is defined as a character sequence consisting of non-space characters only.\n\n\nEach word's length is guaranteed to be greater than \n0\n and not exceed \nmaxWidth\n.\n\n\nThe input array \nwords\n contains at least one word.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n\nOutput:\n\n[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n\nOutput:\n\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\n\nExplanation:\n Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n\nOutput:\n\n[\n  \"Science  is  what we\",\n  \"understand      well\",\n  \"enough to explain to\",\n  \"a  computer.  Art is\",\n  \"everything  else  we\",\n  \"do                  \"\n]\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 300\n\n\n1 <= words[i].length <= 20\n\n\nwords[i]\n consists of only English letters and symbols.\n\n\n1 <= maxWidth <= 100\n\n\nwords[i].length <= maxWidth",
      "solution": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        def addSpaces(i, spaceCnt, maxWidth, is_last):\n            if i < spaceCnt:\n                # For the last line of text, it should be left justified,\n                # and no extra space is inserted between words.\n                return 1 if is_last else (maxWidth // spaceCnt) + int(i < maxWidth % spaceCnt)\n            return 0\n\n        def connect(words, maxWidth, begin, end, length, is_last):\n            s = []  # The extra space O(k) is spent here.\n            n = end - begin\n            for i in xrange(n):\n                s += words[begin + i],\n                s += ' ' * addSpaces(i, n - 1, maxWidth - length, is_last),\n            # For only one word in a line.\n            line = \"\".join(s)\n            if len(line) < maxWidth:\n                line += ' ' * (maxWidth - len(line))\n            return line\n\n        res = []\n        begin, length = 0, 0\n        for i in xrange(len(words)):\n            if length + len(words[i]) + (i - begin) > maxWidth:\n                res += connect(words, maxWidth, begin, i, length, False),\n                begin, length = i, 0\n            length += len(words[i])\n\n        # Last line.\n        res += connect(words, maxWidth, begin, len(words), length, True),\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(k), k is maxWidth."
    },
    {
      "title": "Remove All Adjacent Duplicates in String II",
      "difficulty": "MEDIUM",
      "category": "String, Stack",
      "link": "https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii",
      "slug": "remove-all-adjacent-duplicates-in-string-ii",
      "description": "You are given a string \ns\n and an integer \nk\n, a \nk\n \nduplicate removal\n consists of choosing \nk\n adjacent and equal letters from \ns\n and removing them, causing the left and the right side of the deleted substring to concatenate together.\n\n\nWe repeatedly make \nk\n \nduplicate removals\n on \ns\n until we no longer can.\n\n\nReturn \nthe final string after all such duplicate removals have been made\n. It is guaranteed that the answer is \nunique\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abcd\", k = 2\n\nOutput:\n \"abcd\"\n\nExplanation: \nThere's nothing to delete.\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"deeedbbcccbdaa\", k = 3\n\nOutput:\n \"aa\"\n\nExplanation: \n\nFirst delete \"eee\" and \"ccc\", get \"ddbbbdaa\"\nThen delete \"bbb\", get \"dddaa\"\nFinally delete \"ddd\", get \"aa\"\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"pbbcggttciiippooaais\", k = 2\n\nOutput:\n \"ps\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\n2 <= k <= 10\n4\n\n\ns\n only contains lowercase English letters.",
      "solution": "class Solution(object):\n    def removeDuplicates(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        stk = [['^', 0]]\n        for c in s:\n            if stk[-1][0] == c:\n                stk[-1][1] += 1\n                if stk[-1][1] == k:\n                    stk.pop()\n            else:\n                stk.append([c, 1])\n        return \"\".join(c*k for c, k in stk)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Best Time to Buy and Sell Stock III",
      "difficulty": "HARD",
      "category": "Array, Dynamic Programming",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii",
      "slug": "best-time-to-buy-and-sell-stock-iii",
      "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nFind the maximum profit you can achieve. You may complete \nat most two transactions\n.\n\n\nNote:\n You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [3,3,5,0,0,3,1,4]\n\nOutput:\n 6\n\nExplanation:\n Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [1,2,3,4,5]\n\nOutput:\n 4\n\nExplanation:\n Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n\n\n\nExample 3:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transaction is done, i.e. max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n5",
      "solution": "from typing import List\n\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        max_txn = k\n        n = len(prices)\n        # dp[t][d] = max profit with at most t transactions by day d\n        # t ∈ [0..2] (number of transactions)\n        # d ∈ [0..n-1] (days)\n        dp = [[0] * n for _ in range(max_txn + 1)]\n\n        for t in range(1, max_txn+1):\n            max_profit_so_far = -prices[0]\n            for d in range(1, n):\n                # Option 1: don't sell today, carry forward previous max\n                # Option 2: sell today, and find best buy day using max_so_far\n                dp[t][d] = max(dp[t][d-1], prices[d] + max_profit_so_far)\n                # Update max_so_far for future days\n                max_profit_so_far = max(max_profit_so_far, dp[t-1][d] - prices[d])\n        # last day upto max_txn \n        return dp[max_txn][n-1]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Median of Two Sorted Arrays",
      "difficulty": "HARD",
      "category": "Array, Binary Search, Divide and Conquer",
      "link": "https://leetcode.com/problems/median-of-two-sorted-arrays",
      "slug": "median-of-two-sorted-arrays",
      "description": "Given two sorted arrays \nnums1\n and \nnums2\n of size \nm\n and \nn\n respectively, return \nthe median\n of the two sorted arrays.\n\n\nThe overall run time complexity should be \nO(log (m+n))\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,3], nums2 = [2]\n\nOutput:\n 2.00000\n\nExplanation:\n merged array = [1,2,3] and median is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1,2], nums2 = [3,4]\n\nOutput:\n 2.50000\n\nExplanation:\n merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m\n\n\nnums2.length == n\n\n\n0 <= m <= 1000\n\n\n0 <= n <= 1000\n\n\n1 <= m + n <= 2000\n\n\n-10\n6\n <= nums1[i], nums2[i] <= 10\n6",
      "solution": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(A, B, k):\n            m, n = len(A), len(B)\n            if m > n:\n                m, n = n, m\n                A, B = B, A\n            i = binary_search(max(k-n, 0), min(m, k)-1, lambda i: A[i] >= B[k-1-i])\n            return max(A[i-1] if i-1 >= 0 else float(\"-inf\"), B[k-1-i] if k-1-i >= 0 else float(\"-inf\"))\n\n        len1, len2 = len(nums1), len(nums2)\n        if (len1+len2) % 2 == 1:\n            return getKth(nums1, nums2, (len1+len2)//2+1)\n        else:\n            return (getKth(nums1, nums2, (len1+len2)//2)+getKth(nums1, nums2, (len1+len2)//2+1))*0.5    \n\n\n# Generic solution.class Solution_Generic(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(arrays, k):\n            def check(num):\n                # count the number of values which are less or equal to num\n                return sum(binary_search(0, len(arr)-1, lambda x: arr[x] > num) for arr in arrays) >= k\n    \n            return binary_search(min(arr[0] for arr in arrays if arr), max(arr[-1] for arr in arrays if arr), check)\n\n        array = [nums1, nums2]\n        total = sum(len(nums) for nums in array)\n        if total % 2 == 1:\n            return getKth(array, total//2+1)\n        else:\n            return (getKth(array, total//2)+getKth(array, total//2+1))*0.5",
      "explanation": "N/A",
      "time_complexity": "O(log(max(m, n)) * log(max_val - min_val))",
      "space_complexity": "O(1)"
    }
  ],
  "Google": [
    {
      "title": "Two Sum",
      "difficulty": "EASY",
      "category": "Array, Hash Table",
      "link": "https://leetcode.com/problems/two-sum",
      "slug": "two-sum",
      "description": "Given an array of integers \nnums\n and an integer \ntarget\n, return \nindices of the two numbers such that they add up to \ntarget\n.\n\n\nYou may assume that each input would have \nexactly\n one solution\n, and you may not use the \nsame\n element twice.\n\n\nYou can return the answer in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,7,11,15], target = 9\n\nOutput:\n [0,1]\n\nExplanation:\n Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,4], target = 6\n\nOutput:\n [1,2]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,3], target = 6\n\nOutput:\n [0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n-10\n9\n <= target <= 10\n9\n\n\nOnly one valid answer exists.\n\n\n\n\n \n\n\nFollow-up: \nCan you come up with an algorithm that is less than \nO(n\n2\n)\n \ntime complexity?",
      "solution": "from typing import List\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n\n        for idx in range(len(nums)):\n            val = target - nums[idx]\n            if val in seen:\n                return [idx, seen[val]]\n            else:\n                seen[nums[idx]] = idx",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Palindrome Number",
      "difficulty": "EASY",
      "category": "Math",
      "link": "https://leetcode.com/problems/palindrome-number",
      "slug": "palindrome-number",
      "description": "Given an integer \nx\n, return \ntrue\n if \nx\n is a \npalindrome\n, and \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 121\n\nOutput:\n true\n\nExplanation:\n 121 reads as 121 from left to right and from right to left.\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = -121\n\nOutput:\n false\n\nExplanation:\n From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n\n\nExample 3:\n\n\n\n\nInput:\n x = 10\n\nOutput:\n false\n\nExplanation:\n Reads 01 from right to left. Therefore it is not a palindrome.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= x <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you solve it without converting the integer to a string?",
      "solution": "class Solution(object):\n    # @return a boolean\n    def isPalindrome(self, x):\n        if x < 0:\n            return False\n        copy, reverse = x, 0\n\n        while copy:\n            reverse *= 10\n            reverse += copy % 10\n            copy //= 10\n\n        return x == reverse",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Add Two Numbers",
      "difficulty": "MEDIUM",
      "category": "Linked List, Math, Recursion",
      "link": "https://leetcode.com/problems/add-two-numbers",
      "slug": "add-two-numbers",
      "description": "You are given two \nnon-empty\n linked lists representing two non-negative integers. The digits are stored in \nreverse order\n, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n l1 = [2,4,3], l2 = [5,6,4]\n\nOutput:\n [7,0,8]\n\nExplanation:\n 342 + 465 = 807.\n\n\n\nExample 2:\n\n\n\n\nInput:\n l1 = [0], l2 = [0]\n\nOutput:\n [0]\n\n\n\nExample 3:\n\n\n\n\nInput:\n l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n\nOutput:\n [8,9,9,9,0,0,0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in each linked list is in the range \n[1, 100]\n.\n\n\n0 <= Node.val <= 9\n\n\nIt is guaranteed that the list represents a number that does not have leading zeros.",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        current, carry = dummy, 0\n\n        while l1 or l2:\n            val = carry\n            if l1:\n                val += l1.val\n                l1 = l1.next\n            if l2:\n                val += l2.val\n                l2 = l2.next\n            carry, val = divmod(val, 10)\n            current.next = ListNode(val)\n            current = current.next\n\n        if carry == 1:\n            current.next = ListNode(1)\n\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Best Time to Buy and Sell Stock",
      "difficulty": "EASY",
      "category": "Array, Dynamic Programming",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
      "slug": "best-time-to-buy-and-sell-stock",
      "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nYou want to maximize your profit by choosing a \nsingle day\n to buy one stock and choosing a \ndifferent day in the future\n to sell that stock.\n\n\nReturn \nthe maximum profit you can achieve from this transaction\n. If you cannot achieve any profit, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 5\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transactions are done and the max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n4",
      "solution": "class Solution:\n    def maxProfit(self, prices) -> int:\n        profit = 0\n        buy = prices[0]\n\n        for price in range(1, len(prices)):\n            profit = max(profit, prices[price] - buy)\n            buy = min(prices[price], buy)\n\n        return profit",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Longest Common Prefix",
      "difficulty": "EASY",
      "category": "String, Trie",
      "link": "https://leetcode.com/problems/longest-common-prefix",
      "slug": "longest-common-prefix",
      "description": "Write a function to find the longest common prefix string amongst an array of strings.\n\n\nIf there is no common prefix, return an empty string \n\"\"\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n strs = [\"flower\",\"flow\",\"flight\"]\n\nOutput:\n \"fl\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n strs = [\"dog\",\"racecar\",\"car\"]\n\nOutput:\n \"\"\n\nExplanation:\n There is no common prefix among the input strings.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 200\n\n\n0 <= strs[i].length <= 200\n\n\nstrs[i]\n consists of only lowercase English letters if it is non-empty.",
      "solution": "class Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n\n        for i in xrange(len(strs[0])):\n            for string in strs[1:]:\n                if i >= len(string) or string[i] != strs[0][i]:\n                    return strs[0][:i]\n        return strs[0]\n\nclass Solution2(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        prefix = \"\"\n        \n        for chars in zip(*strs):\n            if all(c == chars[0] for c in chars):\n                prefix += chars[0]\n            else:\n                return prefix\n            \n        return prefix",
      "explanation": "N/A",
      "time_complexity": "O(n * k), k is the length of the common prefix",
      "space_complexity": "O(k)"
    },
    {
      "title": "Longest Consecutive Sequence",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Union Find",
      "link": "https://leetcode.com/problems/longest-consecutive-sequence",
      "slug": "longest-consecutive-sequence",
      "description": "Given an unsorted array of integers \nnums\n, return \nthe length of the longest consecutive elements sequence.\n\n\nYou must write an algorithm that runs in \nO(n)\n time.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [100,4,200,1,3,2]\n\nOutput:\n 4\n\nExplanation:\n The longest consecutive elements sequence is \n[1, 2, 3, 4]\n. Therefore its length is 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,3,7,2,5,8,4,6,0,1]\n\nOutput:\n 9\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,0,1,2]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9",
      "solution": "class Solution(object):\n    # @param num, a list of integer\n    # @return an integer\n    def longestConsecutive(self, num):\n        result, lengths = 1, {key: 0 for key in num}\n        for i in num:\n            if lengths[i] == 0:\n                lengths[i] = 1\n                left, right = lengths.get(i - 1, 0), lengths.get(i + 1, 0)\n                length = 1 + left + right\n                result, lengths[i - left], lengths[i + right] = max(result, length), length, length\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Trapping Rain Water",
      "difficulty": "HARD",
      "category": "Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack",
      "link": "https://leetcode.com/problems/trapping-rain-water",
      "slug": "trapping-rain-water",
      "description": "Given \nn\n non-negative integers representing an elevation map where the width of each bar is \n1\n, compute how much water it can trap after raining.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [0,1,0,2,1,0,1,3,2,1,2,1]\n\nOutput:\n 6\n\nExplanation:\n The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [4,2,0,3,2,5]\n\nOutput:\n 9\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n1 <= n <= 2 * 10\n4\n\n\n0 <= height[i] <= 10\n5",
      "solution": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result, left, right, level = 0, 0, len(height)-1, 0\n        while left < right:\n            if height[left] < height[right]:\n                lower = height[left]\n                left += 1\n            else:\n                lower = height[right]\n                right -= 1\n            level = max(level, lower)\n            result += level-lower\n        return result\n\nclass Solution2(object):\n    # @param A, a list of integers\n    # @return an integer\n    def trap(self, A):\n        result = 0\n        top = 0\n        for i in xrange(len(A)):\n            if A[top] < A[i]:\n                top = i\n\n        second_top = 0\n        for i in xrange(top):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        second_top = len(A) - 1\n        for i in reversed(xrange(top, len(A))):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        return result\n\nclass Solution3(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        right = [0]*len(height)\n        mx = 0\n        for i in reversed(xrange(len(height))):\n            right[i] = mx\n            mx = max(mx, height[i])\n        result = left = 0\n        for i in xrange(len(height)):\n            left = max(left, height[i])\n            result += max(min(left, right[i])-height[i], 0)\n        return result\n\nclass Solution4(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        stk = []\n        for i in xrange(len(height)):\n            prev = 0\n            while stk and height[stk[-1]] <= height[i]:\n                j = stk.pop()\n                result += (height[j] - prev) * (i - j - 1)\n                prev = height[j]\n            if stk:\n                result += (height[i] - prev) * (i - stk[-1] - 1)\n            stk.append(i)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Longest Substring Without Repeating Characters",
      "difficulty": "MEDIUM",
      "category": "Hash Table, String, Sliding Window",
      "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters",
      "slug": "longest-substring-without-repeating-characters",
      "description": "Given a string \ns\n, find the length of the \nlongest\n \nsubstring\n without duplicate characters.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abcabcbb\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"abc\", with the length of 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"bbbbb\"\n\nOutput:\n 1\n\nExplanation:\n The answer is \"b\", with the length of 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"pwwkew\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 5 * 10\n4\n\n\ns\n consists of English letters, digits, symbols and spaces.",
      "solution": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, left = 0, 0\n        lookup = {}\n        for right in xrange(len(s)):\n            if s[right] in lookup:\n                left = max(left, lookup[s[right]]+1)\n            lookup[s[right]] = right\n            result = max(result, right-left+1)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Roman to Integer",
      "difficulty": "EASY",
      "category": "Hash Table, Math, String",
      "link": "https://leetcode.com/problems/roman-to-integer",
      "slug": "roman-to-integer",
      "description": "Roman numerals are represented by seven different symbols: \nI\n, \nV\n, \nX\n, \nL\n, \nC\n, \nD\n and \nM\n.\n\n\n\n\nSymbol\n       \nValue\n\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\n\nFor example, \n2\n is written as \nII\n in Roman numeral, just two ones added together. \n12\n is written as \nXII\n, which is simply \nX + II\n. The number \n27\n is written as \nXXVII\n, which is \nXX + V + II\n.\n\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not \nIIII\n. Instead, the number four is written as \nIV\n. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as \nIX\n. There are six instances where subtraction is used:\n\n\n\n\nI\n can be placed before \nV\n (5) and \nX\n (10) to make 4 and 9. \n\n\nX\n can be placed before \nL\n (50) and \nC\n (100) to make 40 and 90. \n\n\nC\n can be placed before \nD\n (500) and \nM\n (1000) to make 400 and 900.\n\n\n\n\nGiven a roman numeral, convert it to an integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"III\"\n\nOutput:\n 3\n\nExplanation:\n III = 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"LVIII\"\n\nOutput:\n 58\n\nExplanation:\n L = 50, V= 5, III = 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"MCMXCIV\"\n\nOutput:\n 1994\n\nExplanation:\n M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 15\n\n\ns\n contains only the characters \n('I', 'V', 'X', 'L', 'C', 'D', 'M')\n.\n\n\nIt is \nguaranteed\n that \ns\n is a valid roman numeral in the range \n[1, 3999]\n.",
      "solution": "class Solution(object):\n    # @return an integer\n    def romanToInt(self, s):\n        numeral_map = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\":100, \"D\": 500, \"M\": 1000}\n        decimal = 0\n        for i in xrange(len(s)):\n            if i > 0 and numeral_map[s[i]] > numeral_map[s[i - 1]]:\n                decimal += numeral_map[s[i]] - 2 * numeral_map[s[i - 1]]\n            else:\n                decimal += numeral_map[s[i]]\n        return decimal",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Median of Two Sorted Arrays",
      "difficulty": "HARD",
      "category": "Array, Binary Search, Divide and Conquer",
      "link": "https://leetcode.com/problems/median-of-two-sorted-arrays",
      "slug": "median-of-two-sorted-arrays",
      "description": "Given two sorted arrays \nnums1\n and \nnums2\n of size \nm\n and \nn\n respectively, return \nthe median\n of the two sorted arrays.\n\n\nThe overall run time complexity should be \nO(log (m+n))\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,3], nums2 = [2]\n\nOutput:\n 2.00000\n\nExplanation:\n merged array = [1,2,3] and median is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1,2], nums2 = [3,4]\n\nOutput:\n 2.50000\n\nExplanation:\n merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m\n\n\nnums2.length == n\n\n\n0 <= m <= 1000\n\n\n0 <= n <= 1000\n\n\n1 <= m + n <= 2000\n\n\n-10\n6\n <= nums1[i], nums2[i] <= 10\n6",
      "solution": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(A, B, k):\n            m, n = len(A), len(B)\n            if m > n:\n                m, n = n, m\n                A, B = B, A\n            i = binary_search(max(k-n, 0), min(m, k)-1, lambda i: A[i] >= B[k-1-i])\n            return max(A[i-1] if i-1 >= 0 else float(\"-inf\"), B[k-1-i] if k-1-i >= 0 else float(\"-inf\"))\n\n        len1, len2 = len(nums1), len(nums2)\n        if (len1+len2) % 2 == 1:\n            return getKth(nums1, nums2, (len1+len2)//2+1)\n        else:\n            return (getKth(nums1, nums2, (len1+len2)//2)+getKth(nums1, nums2, (len1+len2)//2+1))*0.5    \n\n\n# Generic solution.class Solution_Generic(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(arrays, k):\n            def check(num):\n                # count the number of values which are less or equal to num\n                return sum(binary_search(0, len(arr)-1, lambda x: arr[x] > num) for arr in arrays) >= k\n    \n            return binary_search(min(arr[0] for arr in arrays if arr), max(arr[-1] for arr in arrays if arr), check)\n\n        array = [nums1, nums2]\n        total = sum(len(nums) for nums in array)\n        if total % 2 == 1:\n            return getKth(array, total//2+1)\n        else:\n            return (getKth(array, total//2)+getKth(array, total//2+1))*0.5",
      "explanation": "N/A",
      "time_complexity": "O(log(max(m, n)) * log(max_val - min_val))",
      "space_complexity": "O(1)"
    },
    {
      "title": "Merge Intervals",
      "difficulty": "MEDIUM",
      "category": "Array, Sorting",
      "link": "https://leetcode.com/problems/merge-intervals",
      "slug": "merge-intervals",
      "description": "Given an array of \nintervals\n where \nintervals[i] = [start\ni\n, end\ni\n]\n, merge all overlapping intervals, and return \nan array of the non-overlapping intervals that cover all the intervals in the input\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n intervals = [[1,3],[2,6],[8,10],[15,18]]\n\nOutput:\n [[1,6],[8,10],[15,18]]\n\nExplanation:\n Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\n\n\nExample 2:\n\n\n\n\nInput:\n intervals = [[1,4],[4,5]]\n\nOutput:\n [[1,5]]\n\nExplanation:\n Intervals [1,4] and [4,5] are considered overlapping.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= intervals.length <= 10\n4\n\n\nintervals[i].length == 2\n\n\n0 <= start\ni\n <= end\ni\n <= 10\n4",
      "solution": "class Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        intervals.sort()\n        result = []\n        for interval in intervals:\n            if not result or interval[0] > result[-1][1]:\n                result.append(interval)\n            else:\n                result[-1][1] = max(result[-1][1], interval[1])\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "3Sum",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers, Sorting",
      "link": "https://leetcode.com/problems/3sum",
      "slug": "3sum",
      "description": "Given an integer array nums, return all the triplets \n[nums[i], nums[j], nums[k]]\n such that \ni != j\n, \ni != k\n, and \nj != k\n, and \nnums[i] + nums[j] + nums[k] == 0\n.\n\n\nNotice that the solution set must not contain duplicate triplets.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-1,0,1,2,-1,-4]\n\nOutput:\n [[-1,-1,2],[-1,0,1]]\n\nExplanation:\n \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,1,1]\n\nOutput:\n []\n\nExplanation:\n The only possible triplet does not sum up to 0.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [0,0,0]\n\nOutput:\n [[0,0,0]]\n\nExplanation:\n The only possible triplet sums up to 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= nums.length <= 3000\n\n\n-10\n5\n <= nums[i] <= 10\n5",
      "solution": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        nums.sort()\n        for i in reversed(xrange(2, len(nums))):\n            if i+1 < len(nums) and nums[i] == nums[i+1]:\n                continue\n            target = -nums[i]\n            left, right = 0, i-1\n            while left < right:\n                if nums[left]+nums[right] < target:\n                    left += 1\n                elif nums[left]+nums[right] > target:\n                    right -= 1\n                else:\n                    result.append([nums[left], nums[right], nums[i]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left-1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right+1]:\n                        right -= 1\n        return result\n\nclass Solution2(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, i = sorted(nums), [], 0\n        while i < len(nums) - 2:\n            if i == 0 or nums[i] != nums[i - 1]:\n                j, k = i + 1, len(nums) - 1\n                while j < k:\n                    if nums[i] + nums[j] + nums[k] < 0:\n                        j += 1\n                    elif nums[i] + nums[j] + nums[k] > 0:\n                        k -= 1\n                    else:\n                        result.append([nums[i], nums[j], nums[k]])\n                        j, k = j + 1, k - 1\n                        while j < k and nums[j] == nums[j - 1]:\n                            j += 1\n                        while j < k and nums[k] == nums[k + 1]:\n                            k -= 1\n            i += 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)"
    },
    {
      "title": "4Sum",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers, Sorting",
      "link": "https://leetcode.com/problems/4sum",
      "slug": "4sum",
      "description": "Given an array \nnums\n of \nn\n integers, return \nan array of all the \nunique\n quadruplets\n \n[nums[a], nums[b], nums[c], nums[d]]\n such that:\n\n\n\n\n0 <= a, b, c, d < n\n\n\na\n, \nb\n, \nc\n, and \nd\n are \ndistinct\n.\n\n\nnums[a] + nums[b] + nums[c] + nums[d] == target\n\n\n\n\nYou may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,0,-1,0,-2,2], target = 0\n\nOutput:\n [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,2,2,2,2], target = 8\n\nOutput:\n [[2,2,2,2]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 200\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n-10\n9\n <= target <= 10\n9",
      "solution": "\nimport collections\n\n\n# Two pointer solution. (1356ms)class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        result = []\n        for i in xrange(len(nums) - 3):\n            if i and nums[i] == nums[i - 1]:\n                continue\n            for j in xrange(i + 1, len(nums) - 2):\n                if j != i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                total = target - nums[i] - nums[j]\n                left, right = j + 1, len(nums) - 1\n                while left < right:\n                    if nums[left] + nums[right] == total:\n                        result.append([nums[i], nums[j], nums[left], nums[right]])\n                        right -= 1\n                        left += 1\n                        while left < right and nums[left] == nums[left - 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right + 1]:\n                            right -= 1\n                    elif nums[left] + nums[right] > total:\n                        right -= 1\n                    else:\n                        left += 1\n        return result\n\n\n# Hash solution. (224ms)class Solution2(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, lookup = sorted(nums), [], collections.defaultdict(list)\n        for i in xrange(0, len(nums) - 1):\n            for j in xrange(i + 1, len(nums)):\n                is_duplicated = False\n                for [x, y] in lookup[nums[i] + nums[j]]:\n                    if nums[x] == nums[i]:\n                        is_duplicated = True\n                        break\n                if not is_duplicated:\n                    lookup[nums[i] + nums[j]].append([i, j])\n        ans = {}\n        for c in xrange(2, len(nums)):\n            for d in xrange(c+1, len(nums)):\n                if target - nums[c] - nums[d] in lookup:\n                    for [a, b] in lookup[target - nums[c] - nums[d]]:\n                        if b < c:\n                            quad = [nums[a], nums[b], nums[c], nums[d]]\n                            quad_hash = \" \".join(str(quad))\n                            if quad_hash not in ans:\n                                ans[quad_hash] = True\n                                result.append(quad)\n        return result\n\nclass Solution3(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, lookup = sorted(nums), [], collections.defaultdict(list)\n        for i in xrange(0, len(nums) - 1):\n            for j in xrange(i + 1, len(nums)):\n                lookup[nums[i] + nums[j]].append([i, j])\n\n        for i in lookup.keys():\n            if target - i in lookup:\n                for x in lookup[i]:\n                    for y in lookup[target - i]:\n                        [a, b], [c, d] = x, y\n                        if a is not c and a is not d and \\\n                           b is not c and b is not d:\n                            quad = sorted([nums[a], nums[b], nums[c], nums[d]])\n                            if quad not in result:\n                                result.append(quad)\n        return sorted(result)",
      "explanation": "N/A",
      "time_complexity": "O(n^2 * p) ~ O(n^4)",
      "space_complexity": "O(n^2)"
    },
    {
      "title": "Zigzag Conversion",
      "difficulty": "MEDIUM",
      "category": "String",
      "link": "https://leetcode.com/problems/zigzag-conversion",
      "slug": "zigzag-conversion",
      "description": "The string \n\"PAYPALISHIRING\"\n is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\n\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\n\n\nAnd then read line by line: \n\"PAHNAPLSIIGYIR\"\n\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\n\n\nstring convert(string s, int numRows);\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"PAYPALISHIRING\", numRows = 3\n\nOutput:\n \"PAHNAPLSIIGYIR\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"PAYPALISHIRING\", numRows = 4\n\nOutput:\n \"PINALSIGYAHRPI\"\n\nExplanation:\n\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"A\", numRows = 1\n\nOutput:\n \"A\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consists of English letters (lower-case and upper-case), \n','\n and \n'.'\n.\n\n\n1 <= numRows <= 1000",
      "solution": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        if numRows == 1:\n            return s\n        step, zigzag = 2 * numRows - 2, \"\"\n        for i in xrange(numRows):\n            for j in xrange(i, len(s), step):\n                zigzag += s[j]\n                if 0 < i < numRows - 1 and j + step - 2 * i < len(s):\n                    zigzag += s[j + step - 2 * i]\n        return zigzag",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Valid Parentheses",
      "difficulty": "EASY",
      "category": "String, Stack",
      "link": "https://leetcode.com/problems/valid-parentheses",
      "slug": "valid-parentheses",
      "description": "Given a string \ns\n containing just the characters \n'('\n, \n')'\n, \n'{'\n, \n'}'\n, \n'['\n and \n']'\n, determine if the input string is valid.\n\n\nAn input string is valid if:\n\n\n\n\nOpen brackets must be closed by the same type of brackets.\n\n\nOpen brackets must be closed in the correct order.\n\n\nEvery close bracket has a corresponding open bracket of the same type.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"()\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"()[]{}\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"(]\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"([])\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"([)]\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of parentheses only \n'()[]{}'\n.",
      "solution": "class Solution(object):\n    # @return a boolean\n    def isValid(self, s):\n        stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        for parenthese in s:\n            if parenthese in lookup:\n                stack.append(parenthese)\n            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:\n                return False\n        return len(stack) == 0",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Top K Frequent Words",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, String, Trie, Sorting, Heap (Priority Queue), Bucket Sort, Counting",
      "link": "https://leetcode.com/problems/top-k-frequent-words",
      "slug": "top-k-frequent-words",
      "description": "Given an array of strings \nwords\n and an integer \nk\n, return \nthe \nk\n most frequent strings\n.\n\n\nReturn the answer \nsorted\n by \nthe frequency\n from highest to lowest. Sort the words with the same frequency by their \nlexicographical order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2\n\nOutput:\n [\"i\",\"love\"]\n\nExplanation:\n \"i\" and \"love\" are the two most frequent words.\nNote that \"i\" comes before \"love\" due to a lower alphabetical order.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4\n\nOutput:\n [\"the\",\"is\",\"sunny\",\"day\"]\n\nExplanation:\n \"the\", \"is\", \"sunny\" and \"day\" are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 500\n\n\n1 <= words[i].length <= 10\n\n\nwords[i]\n consists of lowercase English letters.\n\n\nk\n is in the range \n[1, The number of \nunique\n words[i]]\n\n\n\n\n \n\n\nFollow-up:\n Could you solve it in \nO(n log(k))\n time and \nO(n)\n extra space?",
      "solution": "\nimport collections\nimport heapq\nfrom random import randint\n\nclass Solution(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counts = collections.Counter(words)\n        p = []\n        for key, val in counts.iteritems():\n            p.append((-val, key))\n        self.kthElement(p, k-1)\n\n        result = []\n        sorted_p = sorted(p[:k])\n        for i in xrange(k):\n            result.append(sorted_p[i][1])\n        return result\n\n    def kthElement(self, nums, k):  # O(n) on average\n        def PartitionAroundPivot(left, right, pivot_idx, nums):\n            pivot_value = nums[pivot_idx]\n            new_pivot_idx = left\n            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n            for i in xrange(left, right):\n                if nums[i] < pivot_value:\n                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                    new_pivot_idx += 1\n\n            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n            return new_pivot_idx\n\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k:\n                return\n            elif new_pivot_idx > k:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k.\n                left = new_pivot_idx + 1\n\n\n# Heap Solutionclass Solution2(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        class MinHeapObj(object):\n            def __init__(self,val):\n                self.val = val\n            def __lt__(self,other):\n                return self.val[1] > other.val[1] if self.val[0] == other.val[0] else \\\n                       self.val < other.val\n            def __eq__(self,other):\n                return self.val == other.val\n            def __str__(self):\n                return str(self.val)\n\n        counts = collections.Counter(words)\n        min_heap = []\n        for word, count in counts.iteritems():\n            heapq.heappush(min_heap, MinHeapObj((count, word)))\n            if len(min_heap) == k+1:\n                heapq.heappop(min_heap)\n        result = []\n        while min_heap:\n            result.append(heapq.heappop(min_heap).val[1])\n        return result[::-1]\n\n\n# Bucket Sort Solutionclass Solution3(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counts = collections.Counter(words)\n        buckets = [[] for _ in xrange(len(words)+1)]\n        for word, count in counts.iteritems():\n            buckets[count].append(word)\n        pairs = []\n        for i in reversed(xrange(len(words))):\n            for word in buckets[i]:\n                pairs.append((-i, word))\n            if len(pairs) >= k:\n                break\n        pairs.sort()\n        return [pair[1] for pair in pairs[:k]]\n\n\n# time: O(nlogn)\n# space: O(n)\n\nfrom collections import Counter\n\nclass Solution4(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counter = Counter(words)\n        candidates = counter.keys()\n        candidates.sort(key=lambda w: (-counter[w], w))\n        return candidates[:k]",
      "explanation": "N/A",
      "time_complexity": "O(n + klogk) ~ O(n + nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Single Number",
      "difficulty": "EASY",
      "category": "Array, Bit Manipulation",
      "link": "https://leetcode.com/problems/single-number",
      "slug": "single-number",
      "description": "Given a \nnon-empty\n array of integers \nnums\n, every element appears \ntwice\n except for one. Find that single one.\n\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,2,1]\n\n\nOutput:\n \n1\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [4,1,2,1,2]\n\n\nOutput:\n \n4\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1]\n\n\nOutput:\n \n1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 3 * 10\n4\n\n\n-3 * 10\n4\n <= nums[i] <= 3 * 10\n4\n\n\nEach element in the array appears twice except for one element which appears only once.",
      "solution": "\nimport operator\nfrom functools import reduce\n\nclass Solution(object):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    def singleNumber(self, A):\n        return reduce(operator.xor, A)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Container With Most Water",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers, Greedy",
      "link": "https://leetcode.com/problems/container-with-most-water",
      "slug": "container-with-most-water",
      "description": "You are given an integer array \nheight\n of length \nn\n. There are \nn\n vertical lines drawn such that the two endpoints of the \ni\nth\n line are \n(i, 0)\n and \n(i, height[i])\n.\n\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\n\nReturn \nthe maximum amount of water a container can store\n.\n\n\nNotice\n that you may not slant the container.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [1,8,6,2,5,4,8,3,7]\n\nOutput:\n 49\n\nExplanation:\n The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [1,1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= height[i] <= 10\n4",
      "solution": "class Solution(object):\n    # @return an integer\n    def maxArea(self, height):\n        max_area, i, j = 0, 0, len(height) - 1\n        while i < j:\n            max_area = max(max_area, min(height[i], height[j]) * (j - i))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return max_area",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Remove Duplicates from Sorted Array",
      "difficulty": "EASY",
      "category": "Array, Two Pointers",
      "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array",
      "slug": "remove-duplicates-from-sorted-array",
      "description": "Given an integer array \nnums\n sorted in \nnon-decreasing order\n, remove the duplicates \nin-place\n such that each unique element appears only \nonce\n. The \nrelative order\n of the elements should be kept the \nsame\n. Then return \nthe number of unique elements in \nnums\n.\n\n\nConsider the number of unique elements of \nnums\n to be \nk\n, to get accepted, you need to do the following things:\n\n\n\n\nChange the array \nnums\n such that the first \nk\n elements of \nnums\n contain the unique elements in the order they were present in \nnums\n initially. The remaining elements of \nnums\n are not important as well as the size of \nnums\n.\n\n\nReturn \nk\n.\n\n\n\n\nCustom Judge:\n\n\nThe judge will test your solution with the following code:\n\n\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\n\n\nIf all assertions pass, then your solution will be \naccepted\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,2]\n\nOutput:\n 2, nums = [1,2,_]\n\nExplanation:\n Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,0,1,1,1,2,2,3,3,4]\n\nOutput:\n 5, nums = [0,1,2,3,4,_,_,_,_,_]\n\nExplanation:\n Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 3 * 10\n4\n\n\n-100 <= nums[i] <= 100\n\n\nnums\n is sorted in \nnon-decreasing\n order.",
      "solution": "class Solution(object):\n    # @param a list of integers\n    # @return an integer\n    def removeDuplicates(self, A):\n        if not A:\n            return 0\n\n        last = 0\n        for i in xrange(len(A)):\n            if A[last] != A[i]:\n                last += 1\n                A[last] = A[i]\n        return last + 1",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Next Permutation",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers",
      "link": "https://leetcode.com/problems/next-permutation",
      "slug": "next-permutation",
      "description": "A \npermutation\n of an array of integers is an arrangement of its members into a sequence or linear order.\n\n\n\n\nFor example, for \narr = [1,2,3]\n, the following are all the permutations of \narr\n: \n[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]\n.\n\n\n\n\nThe \nnext permutation\n of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the \nnext permutation\n of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n\n\n\nFor example, the next permutation of \narr = [1,2,3]\n is \n[1,3,2]\n.\n\n\nSimilarly, the next permutation of \narr = [2,3,1]\n is \n[3,1,2]\n.\n\n\nWhile the next permutation of \narr = [3,2,1]\n is \n[1,2,3]\n because \n[3,2,1]\n does not have a lexicographical larger rearrangement.\n\n\n\n\nGiven an array of integers \nnums\n, \nfind the next permutation of\n \nnums\n.\n\n\nThe replacement must be \nin place\n and use only constant extra memory.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n [1,3,2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,1]\n\nOutput:\n [1,2,3]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,1,5]\n\nOutput:\n [1,5,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 100",
      "solution": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in reversed(xrange(len(nums)-1)):\n            if nums[i] < nums[i+1]:\n                k = i\n                break\n        else:\n            nums.reverse()\n            return\n\n        for i in reversed(xrange(k+1, len(nums))):\n            if nums[i] > nums[k]:\n                l = i\n                break\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]\n        \nclass Solution2(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in xrange(len(nums)-1):\n            if nums[i] < nums[i+1]:\n                k = i\n\n        if k == -1:\n            nums.reverse()\n            return\n\n        for i in xrange(k+1, len(nums)):\n            if nums[i] > nums[k]:\n                l = i\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Sliding Window Maximum",
      "difficulty": "HARD",
      "category": "Array, Queue, Sliding Window, Heap (Priority Queue), Monotonic Queue",
      "link": "https://leetcode.com/problems/sliding-window-maximum",
      "slug": "sliding-window-maximum",
      "description": "You are given an array of integers \nnums\n, there is a sliding window of size \nk\n which is moving from the very left of the array to the very right. You can only see the \nk\n numbers in the window. Each time the sliding window moves right by one position.\n\n\nReturn \nthe max sliding window\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,-1,-3,5,3,6,7], k = 3\n\nOutput:\n [3,3,5,5,6,7]\n\nExplanation:\n \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       \n3\n\n 1 [3  -1  -3] 5  3  6  7       \n3\n\n 1  3 [-1  -3  5] 3  6  7      \n 5\n\n 1  3  -1 [-3  5  3] 6  7       \n5\n\n 1  3  -1  -3 [5  3  6] 7       \n6\n\n 1  3  -1  -3  5 [3  6  7]      \n7\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1], k = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n1 <= k <= nums.length",
      "solution": "\nfrom collections import deque\n\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result, dq = [], deque()\n        for i in xrange(len(nums)):\n            if dq and i-dq[0] == k:\n                dq.popleft()\n            while dq and nums[dq[-1]] <= nums[i]:\n                dq.pop()\n            dq.append(i)\n            if i >= k-1:\n                result.append(nums[dq[0]])\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Pascal's Triangle",
      "difficulty": "EASY",
      "category": "Array, Dynamic Programming",
      "link": "https://leetcode.com/problems/pascals-triangle",
      "slug": "pascals-triangle",
      "description": "Given an integer \nnumRows\n, return the first numRows of \nPascal's triangle\n.\n\n\nIn \nPascal's triangle\n, each number is the sum of the two numbers directly above it as shown:\n\n\n\n\n \n\n\nExample 1:\n\n\nInput:\n numRows = 5\n\nOutput:\n [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n\nExample 2:\n\n\nInput:\n numRows = 1\n\nOutput:\n [[1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numRows <= 30",
      "solution": "class Solution(object):\n    # @return a list of lists of integers\n    def generate(self, numRows):\n        result = []\n        for i in xrange(numRows):\n            result.append([])\n            for j in xrange(i + 1):\n                if j in (0, i):\n                    result[i].append(1)\n                else:\n                    result[i].append(result[i - 1][j - 1] + result[i - 1][j])\n        return result\n\n    def generate2(self, numRows):\n        if not numRows: return []\n        res = [[1]]\n        for i in range(1, numRows):\n            res += [map(lambda x, y: x + y, res[-1] + [0], [0] + res[-1])]\n        return res[:numRows]\n\n    def generate3(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if numRows == 0: return []\n        if numRows == 1: return [[1]]\n        res = [[1], [1, 1]]\n\n        def add(nums):\n            res = nums[:1]\n            for i, j in enumerate(nums):\n                if i < len(nums) - 1:\n                    res += [nums[i] + nums[i + 1]]\n            res += nums[:1]\n            return res\n\n        while len(res) < numRows:\n            res.extend([add(res[-1])])\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Diameter of Binary Tree",
      "difficulty": "EASY",
      "category": "Tree, Depth-First Search, Binary Tree",
      "link": "https://leetcode.com/problems/diameter-of-binary-tree",
      "slug": "diameter-of-binary-tree",
      "description": "Given the \nroot\n of a binary tree, return \nthe length of the \ndiameter\n of the tree\n.\n\n\nThe \ndiameter\n of a binary tree is the \nlength\n of the longest path between any two nodes in a tree. This path may or may not pass through the \nroot\n.\n\n\nThe \nlength\n of a path between two nodes is represented by the number of edges between them.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5]\n\nOutput:\n 3\n\nExplanation:\n 3 is the length of the path [4,2,1,3] or [5,2,1,3].\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1,2]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-100 <= Node.val <= 100",
      "solution": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def diameterOfBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def iter_dfs(node):\n            result = 0\n            stk = [(1, [node, [0]])]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, ret = params\n                    if not node:\n                        continue\n                    ret1, ret2 = [0], [0]\n                    stk.append((2, [node, ret1, ret2, ret]))\n                    stk.append((1, [node.right, ret2]))\n                    stk.append((1, [node.left, ret1]))\n                elif step == 2:\n                    node, ret1, ret2, ret = params\n                    result = max(result, ret1[0]+ret2[0])\n                    ret[0] = 1+max(ret1[0], ret2[0])\n            return result\n        \n        return iter_dfs(root)\n\nclass Solution2(object):\n    def diameterOfBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(root):\n            if not root: \n                return 0, 0\n            left_d, left_h = dfs(root.left)\n            right_d, right_h = dfs(root.right)\n            return max(left_d, right_d, left_h+right_h), 1+max(left_h, right_h)\n \n        return dfs(root)[0]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Number of Visible People in a Queue",
      "difficulty": "HARD",
      "category": "Array, Stack, Monotonic Stack",
      "link": "https://leetcode.com/problems/number-of-visible-people-in-a-queue",
      "slug": "number-of-visible-people-in-a-queue",
      "description": "There are \nn\n people standing in a queue, and they numbered from \n0\n to \nn - 1\n in \nleft to right\n order. You are given an array \nheights\n of \ndistinct\n integers where \nheights[i]\n represents the height of the \ni\nth\n person.\n\n\nA person can \nsee\n another person to their right in the queue if everybody in between is \nshorter\n than both of them. More formally, the \ni\nth\n person can see the \nj\nth\n person if \ni < j\n and \nmin(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1])\n.\n\n\nReturn \nan array \nanswer\n of length \nn\n where \nanswer[i]\n is the \nnumber of people\n the \ni\nth\n person can \nsee\n to their right in the queue\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [10,6,8,5,11,9]\n\nOutput:\n [3,1,2,1,1,0]\n\nExplanation:\n\nPerson 0 can see person 1, 2, and 4.\nPerson 1 can see person 2.\nPerson 2 can see person 3 and 4.\nPerson 3 can see person 4.\nPerson 4 can see person 5.\nPerson 5 can see no one since nobody is to the right of them.\n\n\n\nExample 2:\n\n\n\n\nInput:\n heights = [5,1,2,3,10]\n\nOutput:\n [4,1,1,1,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == heights.length\n\n\n1 <= n <= 10\n5\n\n\n1 <= heights[i] <= 10\n5\n\n\nAll the values of \nheights\n are \nunique\n.",
      "solution": "class Solution(object):\n    def canSeePersonsCount(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(heights)\n        stk = []\n        for i, h in enumerate(heights):\n            while stk and heights[stk[-1]] < h:\n                result[stk.pop()] += 1\n            if stk:\n                result[stk[-1]] += 1\n            if stk and heights[stk[-1]] == h:\n                stk.pop()\n            stk.append(i)\n        return result\n\nclass Solution2(object):\n    def canSeePersonsCount(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(heights)\n        stk = []\n        for i in reversed(xrange(len(heights))):\n            cnt = 0\n            while stk and heights[stk[-1]] < heights[i]:\n                stk.pop()\n                cnt += 1\n            result[i] = cnt+1 if stk else cnt\n            if stk and heights[stk[-1]] == heights[i]:\n                stk.pop()\n            stk.append(i)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Find Peak Element",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/find-peak-element",
      "slug": "find-peak-element",
      "description": "A peak element is an element that is strictly greater than its neighbors.\n\n\nGiven a \n0-indexed\n integer array \nnums\n, find a peak element, and return its index. If the array contains multiple peaks, return the index to \nany of the peaks\n.\n\n\nYou may imagine that \nnums[-1] = nums[n] = -∞\n. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\n\nYou must write an algorithm that runs in \nO(log n)\n time.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,1]\n\nOutput:\n 2\n\nExplanation:\n 3 is a peak element and your function should return the index number 2.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,1,3,5,6,4]\n\nOutput:\n 5\n\nExplanation:\n Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\nnums[i] != nums[i + 1]\n for all valid \ni\n.",
      "solution": "class Solution(object):\n    def findPeakElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            mid = left + (right - left) / 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Longest Palindromic Substring",
      "difficulty": "MEDIUM",
      "category": "Two Pointers, String, Dynamic Programming",
      "link": "https://leetcode.com/problems/longest-palindromic-substring",
      "slug": "longest-palindromic-substring",
      "description": "Given a string \ns\n, return \nthe longest\n \npalindromic\n \nsubstring\n in \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"babad\"\n\nOutput:\n \"bab\"\n\nExplanation:\n \"aba\" is also a valid answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"cbbd\"\n\nOutput:\n \"bb\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consist of only digits and English letters.",
      "solution": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def preProcess(s):\n            if not s:\n                return ['^', '$']\n            T = ['^']\n            for c in s:\n                T +=  ['#', c]\n            T += ['#', '$']\n            return T\n\n        T = preProcess(s)\n        P = [0] * len(T)\n        center, right = 0, 0\n        for i in xrange(1, len(T) - 1):\n            i_mirror = 2 * center - i\n            if right > i:\n                P[i] = min(right - i, P[i_mirror])\n            else:\n                P[i] = 0\n\n            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:\n                P[i] += 1\n\n            if i + P[i] > right:\n                center, right = i, i + P[i]\n\n        max_i = 0\n        for i in xrange(1, len(T) - 1):\n            if P[i] > P[max_i]:\n                max_i = i\n        start = (max_i - 1 - P[max_i]) // 2\n        return s[start : start + P[max_i]]\n\nclass Solution2(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return (right-left+1)-2\n        \n        left, right = -1, -2\n        for i in xrange(len(s)):\n            l = max(expand(s, i, i), expand(s, i, i+1))\n            if l > right-left+1:\n                right = i+l//2\n                left = right-l+1\n        return s[left:right+1] if left >= 0 else \"\"",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Russian Doll Envelopes",
      "difficulty": "HARD",
      "category": "Array, Binary Search, Dynamic Programming, Sorting",
      "link": "https://leetcode.com/problems/russian-doll-envelopes",
      "slug": "russian-doll-envelopes",
      "description": "You are given a 2D array of integers \nenvelopes\n where \nenvelopes[i] = [w\ni\n, h\ni\n]\n represents the width and the height of an envelope.\n\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\n\nReturn \nthe maximum number of envelopes you can Russian doll (i.e., put one inside the other)\n.\n\n\nNote:\n You cannot rotate an envelope.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n envelopes = [[5,4],[6,4],[6,7],[2,3]]\n\nOutput:\n 3\n\nExplanation:\n The maximum number of envelopes you can Russian doll is \n3\n ([2,3] => [5,4] => [6,7]).\n\n\n\nExample 2:\n\n\n\n\nInput:\n envelopes = [[1,1],[1,1],[1,1]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= envelopes.length <= 10\n5\n\n\nenvelopes[i].length == 2\n\n\n1 <= w\ni\n, h\ni\n <= 10\n5",
      "solution": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def insert(target):\n            left, right = 0, len(result) - 1\n            while left <= right:\n                mid = left + (right - left) / 2\n                if result[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            if left == len(result):\n                result.append(target)\n            else:\n                result[left] = target\n\n        result = []\n\n        envelopes.sort(lambda x, y: y[1] - x[1] if x[0] == y[0] else \\\n                                    x[0] - y[0])\n        for envelope in envelopes:\n            insert(envelope[1])\n\n        return len(result)",
      "explanation": "N/A",
      "time_complexity": "O(nlogn + nlogk) = O(nlogn), k is the length of the result.",
      "space_complexity": "O(1)"
    },
    {
      "title": "Set Matrix Zeroes",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Matrix",
      "link": "https://leetcode.com/problems/set-matrix-zeroes",
      "slug": "set-matrix-zeroes",
      "description": "Given an \nm x n\n integer matrix \nmatrix\n, if an element is \n0\n, set its entire row and column to \n0\n's.\n\n\nYou must do it \nin place\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,1,1],[1,0,1],[1,1,1]]\n\nOutput:\n [[1,0,1],[0,0,0],[1,0,1]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n\nOutput:\n [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[0].length\n\n\n1 <= m, n <= 200\n\n\n-2\n31\n <= matrix[i][j] <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nA straightforward solution using \nO(mn)\n space is probably a bad idea.\n\n\nA simple improvement uses \nO(m + n)\n space, but still not the best solution.\n\n\nCould you devise a constant space solution?",
      "solution": "from functools import reduce\nclass Solution(object):\n    # @param matrix, a list of lists of integers\n    # RETURN NOTHING, MODIFY matrix IN PLACE.\n    def setZeroes(self, matrix):\n        first_col = reduce(lambda acc, i: acc or matrix[i][0] == 0, xrange(len(matrix)), False)\n        first_row = reduce(lambda acc, j: acc or matrix[0][j] == 0, xrange(len(matrix[0])), False)\n\n        for i in xrange(1, len(matrix)):\n            for j in xrange(1, len(matrix[0])):\n                if matrix[i][j] == 0:\n                    matrix[i][0], matrix[0][j] = 0, 0\n\n        for i in xrange(1, len(matrix)):\n            for j in xrange(1, len(matrix[0])):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n\n        if first_col:\n            for i in xrange(len(matrix)):\n                matrix[i][0] = 0\n\n        if first_row:\n            for j in xrange(len(matrix[0])):\n                matrix[0][j] = 0",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Move Zeroes",
      "difficulty": "EASY",
      "category": "Array, Two Pointers",
      "link": "https://leetcode.com/problems/move-zeroes",
      "slug": "move-zeroes",
      "description": "Given an integer array \nnums\n, move all \n0\n's to the end of it while maintaining the relative order of the non-zero elements.\n\n\nNote\n that you must do this in-place without making a copy of the array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [0,1,0,3,12]\n\nOutput:\n [1,3,12,0,0]\n\nExample 2:\n\n\nInput:\n nums = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you minimize the total number of operations done?",
      "solution": "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i]:\n                nums[i], nums[pos] = nums[pos], nums[i]\n                pos += 1\n\n    def moveZeroes2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort(cmp=lambda a, b: 0 if b else -1)\n\nclass Solution2(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i]:\n                nums[pos] = nums[i]\n                pos += 1\n\n        for i in xrange(pos, len(nums)):\n            nums[i] = 0",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Word Break",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, String, Dynamic Programming, Trie, Memoization",
      "link": "https://leetcode.com/problems/word-break",
      "slug": "word-break",
      "description": "Given a string \ns\n and a dictionary of strings \nwordDict\n, return \ntrue\n if \ns\n can be segmented into a space-separated sequence of one or more dictionary words.\n\n\nNote\n that the same word in the dictionary may be reused multiple times in the segmentation.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"leetcode\", wordDict = [\"leet\",\"code\"]\n\nOutput:\n true\n\nExplanation:\n Return true because \"leetcode\" can be segmented as \"leet code\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\n\nOutput:\n true\n\nExplanation:\n Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\nNote that you are allowed to reuse a dictionary word.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 300\n\n\n1 <= wordDict.length <= 1000\n\n\n1 <= wordDict[i].length <= 20\n\n\ns\n and \nwordDict[i]\n consist of only lowercase English letters.\n\n\nAll the strings of \nwordDict\n are \nunique\n.",
      "solution": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: Set[str]\n        :rtype: bool\n        \"\"\"\n        n = len(s)\n\n        max_len = 0\n        for string in wordDict:\n            max_len = max(max_len, len(string))\n\n        can_break = [False for _ in xrange(n + 1)]\n        can_break[0] = True\n        for i in xrange(1, n + 1):\n            for l in xrange(1, min(i, max_len) + 1):\n                if can_break[i-l] and s[i-l:i] in wordDict:\n                    can_break[i] = True\n                    break\n\n        return can_break[-1]",
      "explanation": "N/A",
      "time_complexity": "O(n * l^2)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Number of Islands",
      "difficulty": "MEDIUM",
      "category": "Array, Depth-First Search, Breadth-First Search, Union Find, Matrix",
      "link": "https://leetcode.com/problems/number-of-islands",
      "slug": "number-of-islands",
      "description": "Given an \nm x n\n 2D binary grid \ngrid\n which represents a map of \n'1'\ns (land) and \n'0'\ns (water), return \nthe number of islands\n.\n\n\nAn \nisland\n is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 300\n\n\ngrid[i][j]\n is \n'0'\n or \n'1'\n.",
      "solution": "class UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n       if self.set[x] != x:\n           self.set[x] = self.find_set(self.set[x])  # path compression.\n       return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root != y_root:\n            self.set[min(x_root, y_root)] = max(x_root, y_root)\n            self.count -= 1\n\nclass Solution(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        def index(n, i, j):\n            return i*n + j\n    \n        if not grid:\n            return 0\n\n        zero_count = 0\n        union_find = UnionFind(len(grid)*len(grid[0]))\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j] == '1':\n                    if i and grid[i-1][j] == '1':\n                        union_find.union_set(index(len(grid[0]), i-1, j),\n                                             index(len(grid[0]),i, j))\n                    if j and grid[i][j-1] == '1':\n                        union_find.union_set(index(len(grid[0]), i, j-1),\n                                             index(len(grid[0]), i, j))\n                else:\n                    zero_count += 1        \n        return union_find.count-zero_count\n\n\n# dfs solutionclass Solution2(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def dfs(grid, i, j):\n            if grid[i][j] == '0':\n                return False\n            grid[i][j] = '0'\n            stk = [(i, j)]\n            while stk:\n                r, c = stk.pop()\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(grid) and\n                            0 <= nc < len(grid[0]) and\n                            grid[nr][nc] == '1'):\n                        continue\n                    grid[nr][nc] = '0'\n                    stk.append((nr, nc))\n            return True\n\n        count = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if dfs(grid, i, j):\n                    count += 1\n        return count\n\n \nimport collections\n\n\n# bfs solutionclass Solution3(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def bfs(grid, i, j):\n            if grid[i][j] == '0':\n                return False\n            grid[i][j] ='0'\n            q = collections.deque([(i, j)])\n            while q:\n                r, c = q.popleft()\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(grid) and\n                            0 <= nc < len(grid[0]) and\n                            grid[nr][nc] == '1'):\n                        continue\n                    grid[nr][nc] = '0'\n                    q.append((nr, nc))\n            return True\n\n        count = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if bfs(grid, i, j):\n                    count += 1\n        return count",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "First Missing Positive",
      "difficulty": "HARD",
      "category": "Array, Hash Table",
      "link": "https://leetcode.com/problems/first-missing-positive",
      "slug": "first-missing-positive",
      "description": "Given an unsorted integer array \nnums\n. Return the \nsmallest positive integer\n that is \nnot present\n in \nnums\n.\n\n\nYou must implement an algorithm that runs in \nO(n)\n time and uses \nO(1)\n auxiliary space.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,0]\n\nOutput:\n 3\n\nExplanation:\n The numbers in the range [1,2] are all in the array.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,4,-1,1]\n\nOutput:\n 2\n\nExplanation:\n 1 is in the array but 2 is missing.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [7,8,9,11,12]\n\nOutput:\n 1\n\nExplanation:\n The smallest positive integer 1 is missing.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1",
      "solution": "class Solution(object):\n    # @param A, a list of integers\n    # @return an integer\n    def firstMissingPositive(self, A):\n        i = 0\n        while i < len(A):\n            if A[i] > 0 and A[i] - 1 < len(A) and A[i] != A[A[i]-1]:\n                A[A[i]-1], A[i] = A[i], A[A[i]-1]\n            else:\n                i += 1\n\n        for i, integer in enumerate(A):\n            if integer != i + 1:\n                return i + 1\n        return len(A) + 1",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Best Time to Buy and Sell Stock II",
      "difficulty": "MEDIUM",
      "category": "Array, Dynamic Programming, Greedy",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii",
      "slug": "best-time-to-buy-and-sell-stock-ii",
      "description": "You are given an integer array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold \nat most one\n share of the stock at any time. However, you can buy it then immediately sell it on the \nsame day\n.\n\n\nFind and return \nthe \nmaximum\n profit you can achieve\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 7\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [1,2,3,4,5]\n\nOutput:\n 4\n\nExplanation:\n Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n\n\n\nExample 3:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 3 * 10\n4\n\n\n0 <= prices[i] <= 10\n4",
      "solution": "class Solution:\n    def maxProfit(self, prices) -> int:\n        # intial approach \n        # buy and sell when possible \n        # profit = 0\n        # for i in range(1, len(prices)):\n        #     if prices[i] > prices[i-1]:\n        #         profit +=  prices[i] - prices[i-1]\n        # return profit \n\n        # DP\n        # 2 states, hold , not hold \n        # dp[i][0] = max profit on day i if we hold stock at the end of the day.\n        # dp[i][1] = max profit on day i if we do NOT hold stock at the end of the day. \n        dp = [[0] * 2 for _ in range(len(prices))]\n        dp[0] = [-prices[0], 0] # Base case: hold = -price, not hold = 0\n        for i in range(1, len(prices)):\n            # Case 1: holding → max of holding from yesterday or buying today\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])\n            # Case 2: not holding → max of not holding from yesterday or selling today\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])\n        # On the last day, max profit only if we are **not holding**\n        return dp[len(prices)-1][1]\n\n    # recursion\n\n    # def maxProfit(self, prices: List[int]) -> int:\n        \n    #     @lru_cache(maxsize=None)\n    #     def dfs(i, holding):\n    #         if i == len(prices):\n    #             return 0\n            \n    #         if not holding:\n    #             # Option to buy or skip\n    #             return max(\n    #                 dfs(i+1, 1) - prices[i],  # Buy\n    #                 dfs(i+1, 0)               # Skip\n    #             )\n    #         else:\n    #             # Option to sell or hold\n    #             return max(\n    #                 dfs(i+1, 0) + prices[i],  # Sell\n    #                 dfs(i+1, 1)               # Hold\n    #             )\n        \n    #     return dfs(0, 0)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "String to Integer (atoi)",
      "difficulty": "MEDIUM",
      "category": "String",
      "link": "https://leetcode.com/problems/string-to-integer-atoi",
      "slug": "string-to-integer-atoi",
      "description": "Implement the \nmyAtoi(string s)\n function, which converts a string to a 32-bit signed integer.\n\n\nThe algorithm for \nmyAtoi(string s)\n is as follows:\n\n\n\n\nWhitespace\n: Ignore any leading whitespace (\n\" \"\n).\n\n\nSignedness\n: Determine the sign by checking if the next character is \n'-'\n or \n'+'\n, assuming positivity if neither present.\n\n\nConversion\n: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.\n\n\nRounding\n: If the integer is out of the 32-bit signed integer range \n[-2\n31\n, 2\n31\n - 1]\n, then round the integer to remain in the range. Specifically, integers less than \n-2\n31\n should be rounded to \n-2\n31\n, and integers greater than \n2\n31\n - 1\n should be rounded to \n2\n31\n - 1\n.\n\n\n\n\nReturn the integer as the final result.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"42\"\n\n\nOutput:\n \n42\n\n\nExplanation:\n\n\n\nThe underlined characters are what is read in and the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n42\n\" (\"42\" is read in)\n           ^\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \" -042\"\n\n\nOutput:\n \n-42\n\n\nExplanation:\n\n\n\nStep 1: \"\n   \n-042\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   \n-\n042\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -\n042\n\" (\"042\" is read in, leading zeros ignored in the result)\n               ^\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"1337c0d3\"\n\n\nOutput:\n \n1337\n\n\nExplanation:\n\n\n\nStep 1: \"1337c0d3\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"1337c0d3\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n1337\nc0d3\" (\"1337\" is read in; reading stops because the next character is a non-digit)\n             ^\n\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"0-1\"\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\nStep 1: \"0-1\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"0-1\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n0\n-1\" (\"0\" is read in; reading stops because the next character is a non-digit)\n          ^\n\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"words and 987\"\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nReading stops at the first non-digit character 'w'.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 200\n\n\ns\n consists of English letters (lower-case and upper-case), digits (\n0-9\n), \n' '\n, \n'+'\n, \n'-'\n, and \n'.'\n.",
      "solution": "class Solution(object):\n    def myAtoi(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: int\n        \"\"\"\n        INT_MAX =  2147483647\n        INT_MIN = -2147483648\n        result = 0\n\n        if not str:\n            return result\n\n        i = 0\n        while i < len(str) and str[i].isspace():\n            i += 1\n\n        if len(str) == i:\n            return result\n\n        sign = 1\n        if str[i] == \"+\":\n            i += 1\n        elif str[i] == \"-\":\n            sign = -1\n            i += 1\n\n        while i < len(str) and '0' <= str[i] <= '9':\n            if result > (INT_MAX - int(str[i])) / 10:\n                return INT_MAX if sign > 0 else INT_MIN\n            result = result * 10 + int(str[i])\n            i += 1\n\n        return sign * result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Minimum Window Substring",
      "difficulty": "HARD",
      "category": "Hash Table, String, Sliding Window",
      "link": "https://leetcode.com/problems/minimum-window-substring",
      "slug": "minimum-window-substring",
      "description": "Given two strings \ns\n and \nt\n of lengths \nm\n and \nn\n respectively, return \nthe \nminimum window\n \nsubstring\n of \ns\n such that every character in \nt\n (\nincluding duplicates\n) is included in the window\n. If there is no such substring, return \nthe empty string \n\"\"\n.\n\n\nThe testcases will be generated such that the answer is \nunique\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"ADOBECODEBANC\", t = \"ABC\"\n\nOutput:\n \"BANC\"\n\nExplanation:\n The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"a\", t = \"a\"\n\nOutput:\n \"a\"\n\nExplanation:\n The entire string s is the minimum window.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"a\", t = \"aa\"\n\nOutput:\n \"\"\n\nExplanation:\n Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == s.length\n\n\nn == t.length\n\n\n1 <= m, n <= 10\n5\n\n\ns\n and \nt\n consist of uppercase and lowercase English letters.\n\n\n\n\n \n\n\nFollow up:\n Could you find an algorithm that runs in \nO(m + n)\n time?",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        count, remain = collections.Counter(t), len(t)\n        i, left, right = 0, -1, -1\n        for j, c in enumerate(s):\n            remain -= count[c] > 0\n            count[c] -= 1\n            if remain:\n                continue\n            while count[s[i]] < 0:  # greedily discard uneeds\n                count[s[i]] += 1\n                i += 1\n            if right == -1 or j-i+1 < right-left+1:\n                left, right = i, j\n        return s[left:right+1]\n\nclass Solution2(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        current_count = [0 for i in xrange(52)]\n        expected_count = [0 for i in xrange(52)]\n\n        for char in t:\n            expected_count[ord(char) - ord('a')] += 1\n\n        i, count, start, min_width, min_start = 0, 0, 0, float(\"inf\"), 0\n        while i < len(s):\n            current_count[ord(s[i]) - ord('a')] += 1\n            if current_count[ord(s[i]) - ord('a')] <= expected_count[ord(s[i]) - ord('a')]:\n                count += 1\n\n            if count == len(t):\n                while expected_count[ord(s[start]) - ord('a')] == 0 or \\\n                      current_count[ord(s[start]) - ord('a')] > expected_count[ord(s[start]) - ord('a')]:\n                    current_count[ord(s[start]) - ord('a')] -= 1\n                    start += 1\n\n                if min_width > i - start + 1:\n                    min_width = i - start + 1\n                    min_start = start\n            i += 1\n\n        if min_width == float(\"inf\"):\n            return \"\"\n\n        return s[min_start:min_start + min_width]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(k), k is the number of different characters"
    },
    {
      "title": "Group Anagrams",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, String, Sorting",
      "link": "https://leetcode.com/problems/group-anagrams",
      "slug": "group-anagrams",
      "description": "Given an array of strings \nstrs\n, group the \nanagrams\n together. You can return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nstrs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n\n\nOutput:\n \n[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\n\nExplanation:\n\n\n\n\nThere is no string in strs that can be rearranged to form \n\"bat\"\n.\n\n\nThe strings \n\"nat\"\n and \n\"tan\"\n are anagrams as they can be rearranged to form each other.\n\n\nThe strings \n\"ate\"\n, \n\"eat\"\n, and \n\"tea\"\n are anagrams as they can be rearranged to form each other.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nstrs = [\"\"]\n\n\nOutput:\n \n[[\"\"]]\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nstrs = [\"a\"]\n\n\nOutput:\n \n[[\"a\"]]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 10\n4\n\n\n0 <= strs[i].length <= 100\n\n\nstrs[i]\n consists of lowercase English letters.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagrams_map, result = collections.defaultdict(list), []\n        for s in strs:\n            sorted_str = (\"\").join(sorted(s))\n            anagrams_map[sorted_str].append(s)\n        for anagram in anagrams_map.values():\n            anagram.sort()\n            result.append(anagram)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n * glogg), g is the max size of groups.",
      "space_complexity": "O(n)"
    },
    {
      "title": "Range Module",
      "difficulty": "HARD",
      "category": "Design, Segment Tree, Ordered Set",
      "link": "https://leetcode.com/problems/range-module",
      "slug": "range-module",
      "description": "A Range Module is a module that tracks ranges of numbers. Design a data structure to track the ranges represented as \nhalf-open intervals\n and query about them.\n\n\nA \nhalf-open interval\n \n[left, right)\n denotes all the real numbers \nx\n where \nleft <= x < right\n.\n\n\nImplement the \nRangeModule\n class:\n\n\n\n\nRangeModule()\n Initializes the object of the data structure.\n\n\nvoid addRange(int left, int right)\n Adds the \nhalf-open interval\n \n[left, right)\n, tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval \n[left, right)\n that are not already tracked.\n\n\nboolean queryRange(int left, int right)\n Returns \ntrue\n if every real number in the interval \n[left, right)\n is currently being tracked, and \nfalse\n otherwise.\n\n\nvoid removeRange(int left, int right)\n Stops tracking every real number currently being tracked in the \nhalf-open interval\n \n[left, right)\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"RangeModule\", \"addRange\", \"removeRange\", \"queryRange\", \"queryRange\", \"queryRange\"]\n[[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]\n\nOutput\n\n[null, null, null, true, false, true]\n\n\nExplanation\n\nRangeModule rangeModule = new RangeModule();\nrangeModule.addRange(10, 20);\nrangeModule.removeRange(14, 16);\nrangeModule.queryRange(10, 14); // return True,(Every number in [10, 14) is being tracked)\nrangeModule.queryRange(13, 15); // return False,(Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)\nrangeModule.queryRange(16, 17); // return True, (The number 16 in [16, 17) is still being tracked, despite the remove operation)\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= left < right <= 10\n9\n\n\nAt most \n10\n4\n calls will be made to \naddRange\n, \nqueryRange\n, and \nremoveRange\n.",
      "solution": "#        removeRange: O(n)\n#        queryRange:  O(logn)\n\nimport bisect\n\nclass RangeModule(object):\n\n    def __init__(self):\n        self.__intervals = []\n\n    def addRange(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: void\n        \"\"\"\n        tmp = []\n        i = 0\n        for interval in self.__intervals:\n            if right < interval[0]:\n                tmp.append((left, right))\n                break\n            elif interval[1] < left:\n                tmp.append(interval)\n            else:\n                left = min(left, interval[0])\n                right = max(right, interval[1])\n            i += 1\n        if i == len(self.__intervals):\n            tmp.append((left, right))\n        while i < len(self.__intervals):\n            tmp.append(self.__intervals[i])\n            i += 1\n        self.__intervals = tmp\n\n    def queryRange(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: bool\n        \"\"\"\n        i = bisect.bisect_left(self.__intervals, (left, float(\"inf\")))\n        if i: i -= 1\n        return bool(self.__intervals) and \\\n               self.__intervals[i][0] <= left and \\\n               right <= self.__intervals[i][1]\n\n    def removeRange(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: void\n        \"\"\"\n        tmp = []\n        for interval in self.__intervals:\n            if interval[1] <= left or interval[0] >= right:\n                tmp.append(interval)\n            else:\n                if interval[0] < left:\n                    tmp.append((interval[0], left))\n                if right < interval[1]:\n                    tmp.append((right, interval[1]))\n        self.__intervals = tmp",
      "explanation": "N/A",
      "time_complexity": "addRange:    O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Longest Increasing Subsequence",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search, Dynamic Programming",
      "link": "https://leetcode.com/problems/longest-increasing-subsequence",
      "slug": "longest-increasing-subsequence",
      "description": "Given an integer array \nnums\n, return \nthe length of the longest \nstrictly increasing \nsubsequence\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [10,9,2,5,3,7,101,18]\n\nOutput:\n 4\n\nExplanation:\n The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,1,0,3,2,3]\n\nOutput:\n 4\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [7,7,7,7,7,7,7]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2500\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n Can you come up with an algorithm that runs in \nO(n log(n))\n time complexity?",
      "solution": "\nimport bisect\n\nclass Solution(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        LIS = []\n        def insert(target):\n            left = bisect.bisect_left(LIS, target)\n            # If not found, append the target.\n            if left == len(LIS):\n                LIS.append(target)\n            else:\n                LIS[left] = target\n    \n        for num in nums:\n            insert(num)\n        return len(LIS)\n\nclass Solution2(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        LIS = []\n        def insert(target):\n            left, right = 0, len(LIS) - 1\n            # Find the first index \"left\" which satisfies LIS[left] >= target\n            while left <= right:\n                mid = left + (right - left) // 2\n                if LIS[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            # If not found, append the target.\n            if left == len(LIS):\n                LIS.append(target)\n            else:\n                LIS[left] = target\n\n        for num in nums:\n            insert(num)\n\n        return len(LIS)\n\n\n# bit, fenwick treeclass Solution3(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        class BIT(object):  # 0-indexed.\n            def __init__(self, n, default=0, fn=lambda x, y: x+y):\n                self.__bit = [default]*(n+1)  # Extra one for dummy node.\n                self.__default = default\n                self.__fn = fn\n\n            def update(self, i, val):\n                i += 1  # Extra one for dummy node.\n                while i < len(self.__bit):\n                    self.__bit[i] = self.__fn(self.__bit[i], val)\n                    i += (i & -i)\n\n            def query(self, i):\n                i += 1  # Extra one for dummy node.\n                ret = self.__default\n                while i > 0:\n                    ret = self.__fn(ret, self.__bit[i])\n                    i -= (i & -i)\n                return ret\n    \n        lookup = {x:i for i, x in enumerate(sorted(set(nums)))}\n        bit = BIT(len(lookup), fn=max)\n        for x in nums:\n            bit.update(lookup[x], bit.query(lookup[x]-1)+1)\n        return bit.query(len(lookup)-1)\n\n\n# Range Maximum Queryclass SegmentTree(object):  # 0-based index\n    def __init__(self, N,\n                 build_fn=lambda x, y: [y]*(2*x),\n                 query_fn=lambda x, y: y if x is None else max(x, y),  # (lambda x, y: y if x is None else min(x, y))\n                 update_fn=lambda x, y: y,\n                 default_val=0):\n        self.N = N\n        self.H = (N-1).bit_length()\n        self.query_fn = query_fn\n        self.update_fn = update_fn\n        self.default_val = default_val\n        self.tree = build_fn(N, default_val)\n        self.lazy = [None]*N\n\n    def __apply(self, x, val):\n        self.tree[x] = self.update_fn(self.tree[x], val)\n        if x < self.N:\n            self.lazy[x] = self.update_fn(self.lazy[x], val)\n\n    def update(self, L, R, h):  # Time: O(logN), Space: O(N)\n        def pull(x):\n            while x > 1:\n                x //= 2\n                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n                if self.lazy[x] is not None:\n                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])\n\n        L += self.N\n        R += self.N\n        L0, R0 = L, R\n        while L <= R:\n            if L & 1:  # is right child\n                self.__apply(L, h) \n                L += 1\n            if R & 1 == 0:  # is left child\n                self.__apply(R, h)\n                R -= 1\n            L //= 2\n            R //= 2\n        pull(L0)\n        pull(R0)\n\n    def query(self, L, R):  # Time: O(logN), Space: O(N)\n        def push(x):\n            n = 2**self.H\n            while n != 1:\n                y = x // n\n                if self.lazy[y] is not None:\n                    self.__apply(y*2, self.lazy[y])\n                    self.__apply(y*2 + 1, self.lazy[y])\n                    self.lazy[y] = None\n                n //= 2\n\n        result = None\n        if L > R:\n            return result\n\n        L += self.N\n        R += self.N\n        push(L)\n        push(R)\n        while L <= R:\n            if L & 1:  # is right child\n                result = self.query_fn(result, self.tree[L])\n                L += 1\n            if R & 1 == 0:  # is left child\n                result = self.query_fn(result, self.tree[R])\n                R -= 1\n            L //= 2\n            R //= 2\n        return result\n    \n    def __str__(self):\n        showList = []\n        for i in xrange(self.N):\n            showList.append(self.query(i, i))\n        return \",\".join(map(str, showList))\n\n\n# optimized from Solution5class Solution4(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        val_to_idx = {num:i for i, num in enumerate(sorted(set(nums)))}\n        st = SegmentTree(len(val_to_idx))\n        for x in nums:\n            st.update(val_to_idx[x], val_to_idx[x], st.query(0, val_to_idx[x]-1)+1 if val_to_idx[x] >= 1 else 1)\n        return st.query(0, len(val_to_idx)-1) if len(val_to_idx) >= 1 else 0\n\n\n# Traditional DP solution.class Solution5(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        dp = []  # dp[i]: the length of LIS ends with nums[i]\n        for i in xrange(len(nums)):\n            dp.append(1)\n            for j in xrange(i):\n                if nums[j] < nums[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp) if dp else 0",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n)"
    },
    {
      "title": "N-Queens",
      "difficulty": "HARD",
      "category": "Array, Backtracking",
      "link": "https://leetcode.com/problems/n-queens",
      "slug": "n-queens",
      "description": "The \nn-queens\n puzzle is the problem of placing \nn\n queens on an \nn x n\n chessboard such that no two queens attack each other.\n\n\nGiven an integer \nn\n, return \nall distinct solutions to the \nn-queens puzzle\n. You may return the answer in \nany order\n.\n\n\nEach solution contains a distinct board configuration of the n-queens' placement, where \n'Q'\n and \n'.'\n both indicate a queen and an empty space, respectively.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4\n\nOutput:\n [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n\nExplanation:\n There exist two distinct solutions to the 4-queens puzzle as shown above\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n [[\"Q\"]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 9",
      "solution": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        def dfs(row):\n            if row == n:\n                result.append(map(lambda x: '.'*x + \"Q\" + '.'*(n-x-1), curr))\n                return\n            for i in xrange(n):\n                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:\n                    continue\n                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True\n                curr.append(i)\n                dfs(row+1)\n                curr.pop()\n                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False\n\n        result, curr = [], []\n        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)\n        dfs(0)\n        return result\n\n\n# For any point (x,y), if we want the new point (p,q) don't share the same row, column, or diagonal.\n# then there must have ```p+q != x+y``` and ```p-q!= x-y```\n# the former focus on eliminate 'left bottom right top' diagonal\n# the latter focus on eliminate 'left top right bottom' diagonal\n\n# - col_per_row: the list of column index per row\n# - cur_row：current row we are seraching for valid column\n# - xy_diff：the list of x-y\n# - xy_sum：the list of x+yclass Solution2(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        def dfs(col_per_row, xy_diff, xy_sum):\n            cur_row = len(col_per_row)\n            if cur_row == n:\n                ress.append(col_per_row)\n            for col in range(n):\n                if col not in col_per_row and cur_row-col not in xy_diff and cur_row+col not in xy_sum:\n                    dfs(col_per_row+[col], xy_diff+[cur_row-col], xy_sum+[cur_row+col])\n        ress = []\n        dfs([], [], [])\n        return [['.'*i + 'Q' + '.'*(n-i-1) for i in res] for res in ress]",
      "explanation": "N/A",
      "time_complexity": "O(n^2 * n!)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Add Two Integers",
      "difficulty": "EASY",
      "category": "Math",
      "link": "https://leetcode.com/problems/add-two-integers",
      "slug": "add-two-integers",
      "description": "Given two integers \nnum1\n and \nnum2\n, return \nthe \nsum\n of the two integers\n.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num1 = 12, num2 = 5\n\nOutput:\n 17\n\nExplanation:\n num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is returned.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num1 = -10, num2 = 4\n\nOutput:\n -6\n\nExplanation:\n num1 + num2 = -6, so -6 is returned.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-100 <= num1, num2 <= 100",
      "solution": "\n# mathclass Solution(object):\n    def sum(self, num1, num2):\n        \"\"\"\n        :type num1: int\n        :type num2: int\n        :rtype: int\n        \"\"\"\n        return num1+num2",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Basic Calculator",
      "difficulty": "HARD",
      "category": "Math, String, Stack, Recursion",
      "link": "https://leetcode.com/problems/basic-calculator",
      "slug": "basic-calculator",
      "description": "Given a string \ns\n representing a valid expression, implement a basic calculator to evaluate it, and return \nthe result of the evaluation\n.\n\n\nNote:\n You are \nnot\n allowed to use any built-in function which evaluates strings as mathematical expressions, such as \neval()\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"1 + 1\"\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \" 2-1 + 2 \"\n\nOutput:\n 3\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"(1+(4+5+2)-3)+(6+8)\"\n\nOutput:\n 23\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 3 * 10\n5\n\n\ns\n consists of digits, \n'+'\n, \n'-'\n, \n'('\n, \n')'\n, and \n' '\n.\n\n\ns\n represents a valid expression.\n\n\n'+'\n is \nnot\n used as a unary operation (i.e., \n\"+1\"\n and \n\"+(2 + 3)\"\n is invalid).\n\n\n'-'\n could be used as a unary operation (i.e., \n\"-1\"\n and \n\"-(2 + 3)\"\n is valid).\n\n\nThere will be no two consecutive operators in the input.\n\n\nEvery number and running calculation will fit in a signed 32-bit integer.",
      "solution": "\nimport operator\n\nclass Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def compute(operands, operators):\n            right, left = operands.pop(), operands.pop()\n            operands.append(ops[operators.pop()](left, right))\n\n        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}\n        precedence = {'+':0, '-':0, '*':1, '/':1}\n        operands, operators, operand = [], [], 0\n        for i in xrange(len(s)):\n            if s[i].isdigit():\n                operand = operand*10 + int(s[i])\n                if i == len(s)-1 or not s[i+1].isdigit():\n                    operands.append(operand)\n                    operand = 0\n            elif s[i] == '(':\n                operators.append(s[i])\n            elif s[i] == ')':\n                while operators[-1] != '(':\n                    compute(operands, operators)\n                operators.pop()\n            elif s[i] in precedence:\n                while operators and operators[-1] in precedence and \\\n                      precedence[operators[-1]] >= precedence[s[i]]:\n                    compute(operands, operators)\n                operators.append(s[i])\n        while operators:\n            compute(operands, operators)\n        return operands[-1]\n\nclass Solution2(object):\n    # @param {string} s\n    # @return {integer}\n    def calculate(self, s):\n        operands, operators = [], []\n        operand = \"\"\n        for i in reversed(xrange(len(s))):\n            if s[i].isdigit():\n                operand += s[i]\n                if i == 0 or not s[i-1].isdigit():\n                    operands.append(int(operand[::-1]))\n                    operand = \"\"\n            elif s[i] == ')' or s[i] == '+' or s[i] == '-':\n                operators.append(s[i])\n            elif s[i] == '(':\n                while operators[-1] != ')':\n                    self.compute(operands, operators)\n                operators.pop()\n\n        while operators:\n            self.compute(operands, operators)\n\n        return operands[-1]\n\n    def compute(self, operands, operators):\n        left, right = operands.pop(), operands.pop()\n        op = operators.pop()\n        if op == '+':\n            operands.append(left + right)\n        elif op == '-':\n            operands.append(left - right)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "LRU Cache",
      "difficulty": "MEDIUM",
      "category": "Hash Table, Linked List, Design, Doubly-Linked List",
      "link": "https://leetcode.com/problems/lru-cache",
      "slug": "lru-cache",
      "description": "Design a data structure that follows the constraints of a \nLeast Recently Used (LRU) cache\n.\n\n\nImplement the \nLRUCache\n class:\n\n\n\n\nLRUCache(int capacity)\n Initialize the LRU cache with \npositive\n size \ncapacity\n.\n\n\nint get(int key)\n Return the value of the \nkey\n if the key exists, otherwise return \n-1\n.\n\n\nvoid put(int key, int value)\n Update the value of the \nkey\n if the \nkey\n exists. Otherwise, add the \nkey-value\n pair to the cache. If the number of keys exceeds the \ncapacity\n from this operation, \nevict\n the least recently used key.\n\n\n\n\nThe functions \nget\n and \nput\n must each run in \nO(1)\n average time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n\nOutput\n\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n\nExplanation\n\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= capacity <= 3000\n\n\n0 <= key <= 10\n4\n\n\n0 <= value <= 10\n5\n\n\nAt most \n2 * 10\n5\n calls will be made to \nget\n and \nput\n.",
      "solution": "\nimport collections\n\n\n# using OrderedDictclass LRUCache(object):\n    def __init__(self, capacity):\n        self.cache = collections.OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        val = self.cache[key]\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.cache and len(self.cache) == self.capacity:\n            self.cache.popitem(last=False)\n        self.__update(key, val)\n    \n    def __update(self, key, val):\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = val\n\n\n\nclass ListNode(object):\n    def __init__(self, key, val):\n        self.val = val\n        self.key = key\n        self.next = None\n        self.prev = None\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\nclass LRUCache2(object):\n\n    def __init__(self, capacity):\n        self.list = LinkedList()\n        self.dict = {}\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.dict:\n            return -1\n        val = self.dict[key].val\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.dict and len(self.dict) == self.capacity:\n            del self.dict[self.list.head.key]\n            self.list.delete(self.list.head)\n        self.__update(key, val)\n\n    def __update(self, key, val):\n        if key in self.dict:\n            self.list.delete(self.dict[key])\n        node = ListNode(key, val)\n        self.list.insert(node)\n        self.dict[key] = node",
      "explanation": "N/A",
      "time_complexity": "O(1), per operation.",
      "space_complexity": "O(k), k is the capacity of cache."
    },
    {
      "title": "Merge Strings Alternately",
      "difficulty": "EASY",
      "category": "Two Pointers, String",
      "link": "https://leetcode.com/problems/merge-strings-alternately",
      "slug": "merge-strings-alternately",
      "description": "You are given two strings \nword1\n and \nword2\n. Merge the strings by adding letters in alternating order, starting with \nword1\n. If a string is longer than the other, append the additional letters onto the end of the merged string.\n\n\nReturn \nthe merged string.\n\n\n \n\n\nExample 1:\n\n\n\r\n\nInput:\n word1 = \"abc\", word2 = \"pqr\"\r\n\nOutput:\n \"apbqcr\"\r\n\nExplanation:\n The merged string will be merged as so:\r\nword1:  a   b   c\r\nword2:    p   q   r\r\nmerged: a p b q c r\r\n\n\n\nExample 2:\n\n\n\r\n\nInput:\n word1 = \"ab\", word2 = \"pqrs\"\r\n\nOutput:\n \"apbqrs\"\r\n\nExplanation:\n Notice that as word2 is longer, \"rs\" is appended to the end.\r\nword1:  a   b \r\nword2:    p   q   r   s\r\nmerged: a p b q   r   s\r\n\n\n\nExample 3:\n\n\n\r\n\nInput:\n word1 = \"abcd\", word2 = \"pq\"\r\n\nOutput:\n \"apbqcd\"\r\n\nExplanation:\n Notice that as word1 is longer, \"cd\" is appended to the end.\r\nword1:  a   b   c   d\r\nword2:    p   q \r\nmerged: a p b q c   d\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word1.length, word2.length <= 100\n\n\nword1\n and \nword2\n consist of lowercase English letters.",
      "solution": "class Solution(object):\n    def mergeAlternately(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: str\n        \"\"\"\n        result = []\n        i = 0\n        while i < len(word1) or i < len(word2):\n            if i < len(word1):\n                result.append(word1[i])\n            if i < len(word2):\n                result.append(word2[i])\n            i += 1\n        return \"\".join(result)",
      "explanation": "N/A",
      "time_complexity": "O(m + n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Text Justification",
      "difficulty": "HARD",
      "category": "Array, String, Simulation",
      "link": "https://leetcode.com/problems/text-justification",
      "slug": "text-justification",
      "description": "Given an array of strings \nwords\n and a width \nmaxWidth\n, format the text such that each line has exactly \nmaxWidth\n characters and is fully (left and right) justified.\n\n\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces \n' '\n when necessary so that each line has exactly \nmaxWidth\n characters.\n\n\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n\n\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\n\n\nNote:\n\n\n\n\nA word is defined as a character sequence consisting of non-space characters only.\n\n\nEach word's length is guaranteed to be greater than \n0\n and not exceed \nmaxWidth\n.\n\n\nThe input array \nwords\n contains at least one word.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n\nOutput:\n\n[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n\nOutput:\n\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\n\nExplanation:\n Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n\nOutput:\n\n[\n  \"Science  is  what we\",\n  \"understand      well\",\n  \"enough to explain to\",\n  \"a  computer.  Art is\",\n  \"everything  else  we\",\n  \"do                  \"\n]\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 300\n\n\n1 <= words[i].length <= 20\n\n\nwords[i]\n consists of only English letters and symbols.\n\n\n1 <= maxWidth <= 100\n\n\nwords[i].length <= maxWidth",
      "solution": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        def addSpaces(i, spaceCnt, maxWidth, is_last):\n            if i < spaceCnt:\n                # For the last line of text, it should be left justified,\n                # and no extra space is inserted between words.\n                return 1 if is_last else (maxWidth // spaceCnt) + int(i < maxWidth % spaceCnt)\n            return 0\n\n        def connect(words, maxWidth, begin, end, length, is_last):\n            s = []  # The extra space O(k) is spent here.\n            n = end - begin\n            for i in xrange(n):\n                s += words[begin + i],\n                s += ' ' * addSpaces(i, n - 1, maxWidth - length, is_last),\n            # For only one word in a line.\n            line = \"\".join(s)\n            if len(line) < maxWidth:\n                line += ' ' * (maxWidth - len(line))\n            return line\n\n        res = []\n        begin, length = 0, 0\n        for i in xrange(len(words)):\n            if length + len(words[i]) + (i - begin) > maxWidth:\n                res += connect(words, maxWidth, begin, i, length, False),\n                begin, length = i, 0\n            length += len(words[i])\n\n        # Last line.\n        res += connect(words, maxWidth, begin, len(words), length, True),\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(k), k is maxWidth."
    },
    {
      "title": "Maximal Rectangle",
      "difficulty": "HARD",
      "category": "Array, Dynamic Programming, Stack, Matrix, Monotonic Stack",
      "link": "https://leetcode.com/problems/maximal-rectangle",
      "slug": "maximal-rectangle",
      "description": "Given a \nrows x cols\n binary \nmatrix\n filled with \n0\n's and \n1\n's, find the largest rectangle containing only \n1\n's and return \nits area\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\n\nOutput:\n 6\n\nExplanation:\n The maximal rectangle is shown in the above picture.\n\n\n\nExample 2:\n\n\n\n\nInput:\n matrix = [[\"0\"]]\n\nOutput:\n 0\n\n\n\nExample 3:\n\n\n\n\nInput:\n matrix = [[\"1\"]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nrows == matrix.length\n\n\ncols == matrix[i].length\n\n\n1 <= row, cols <= 200\n\n\nmatrix[i][j]\n is \n'0'\n or \n'1'\n.",
      "solution": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        def largestRectangleArea(heights):\n            stk, result, i = [-1], 0, 0\n            for i in xrange(len(heights)+1):\n                while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):\n                    result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))\n                stk.append(i) \n            return result\n\n        if not matrix:\n            return 0\n        result = 0\n        heights = [0]*len(matrix[0])\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[0])):\n                heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0\n            result = max(result, largestRectangleArea(heights))\n        return result\n\n\n# DP solution.class Solution2(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        if not matrix:\n            return 0\n\n        result = 0\n        m = len(matrix)\n        n = len(matrix[0])\n        L = [0 for _ in xrange(n)]\n        H = [0 for _ in xrange(n)]\n        R = [n for _ in xrange(n)]\n\n        for i in xrange(m):\n            left = 0\n            for j in xrange(n):\n                if matrix[i][j] == '1':\n                    L[j] = max(L[j], left)\n                    H[j] += 1\n                else:\n                    L[j] = 0\n                    H[j] = 0\n                    R[j] = n\n                    left = j + 1\n\n            right = n\n            for j in reversed(xrange(n)):\n                if matrix[i][j] == '1':\n                    R[j] = min(R[j], right)\n                    result = max(result, H[j] * (R[j] - L[j]))\n                else:\n                    right = j\n\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Majority Element",
      "difficulty": "EASY",
      "category": "Array, Hash Table, Divide and Conquer, Sorting, Counting",
      "link": "https://leetcode.com/problems/majority-element",
      "slug": "majority-element",
      "description": "Given an array \nnums\n of size \nn\n, return \nthe majority element\n.\n\n\nThe majority element is the element that appears more than \n⌊n / 2⌋\n times. You may assume that the majority element always exists in the array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [3,2,3]\n\nOutput:\n 3\n\nExample 2:\n\n\nInput:\n nums = [2,2,1,1,1,2,2]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 5 * 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n\n\n \n\n\nFollow-up:\n Could you solve the problem in linear time and in \nO(1)\n space?",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def boyer_moore_majority_vote():\n            result, cnt = None, 0\n            for x in nums:\n                if not cnt:\n                    result = x\n                if x == result:\n                    cnt += 1\n                else:\n                    cnt -= 1\n            return result\n\n        return boyer_moore_majority_vote()\n\n\nimport collections\n\nclass Solution2(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return collections.Counter(nums).most_common(1)[0][0]\n\n\nimport collections\n\nclass Solution3(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sorted(collections.Counter(nums).items(), key=lambda a: a[1], reverse=True)[0][0]",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Subarray Sum Equals K",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Prefix Sum",
      "link": "https://leetcode.com/problems/subarray-sum-equals-k",
      "slug": "subarray-sum-equals-k",
      "description": "Given an array of integers \nnums\n and an integer \nk\n, return \nthe total number of subarrays whose sum equals to\n \nk\n.\n\n\nA subarray is a contiguous \nnon-empty\n sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,1,1], k = 2\n\nOutput:\n 2\n\nExample 2:\n\n\nInput:\n nums = [1,2,3], k = 3\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2 * 10\n4\n\n\n-1000 <= nums[i] <= 1000\n\n\n-10\n7\n <= k <= 10\n7",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def subarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        accumulated_sum = 0\n        lookup = collections.defaultdict(int)\n        lookup[0] += 1\n        for num in nums:\n            accumulated_sum += num\n            result += lookup[accumulated_sum - k]\n            lookup[accumulated_sum] += 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Lowest Common Ancestor of a Binary Tree",
      "difficulty": "MEDIUM",
      "category": "Tree, Depth-First Search, Binary Tree",
      "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree",
      "slug": "lowest-common-ancestor-of-a-binary-tree",
      "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\n\nAccording to the \ndefinition of LCA on Wikipedia\n: “The lowest common ancestor is defined between two nodes \np\n and \nq\n as the lowest node in \nT\n that has both \np\n and \nq\n as descendants (where we allow \na node to be a descendant of itself\n).”\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n\nOutput:\n 3\n\nExplanation:\n The LCA of nodes 5 and 1 is 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n\nOutput:\n 5\n\nExplanation:\n The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [1,2], p = 1, q = 2\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 10\n5\n]\n.\n\n\n-10\n9\n <= Node.val <= 10\n9\n\n\nAll \nNode.val\n are \nunique\n.\n\n\np != q\n\n\np\n and \nq\n will exist in the tree.",
      "solution": "class Solution(object):\n    # @param {TreeNode} root\n    # @param {TreeNode} p\n    # @param {TreeNode} q\n    # @return {TreeNode}\n    def lowestCommonAncestor(self, root, p, q):\n        if root in (None, p, q):\n            return root\n\n        left, right = [self.lowestCommonAncestor(child, p, q) \\\n                         for child in (root.left, root.right)]\n        # 1. If the current subtree contains both p and q,\n        #    return their LCA.\n        # 2. If only one of them is in that subtree,\n        #    return that one of them.\n        # 3. If neither of them is in that subtree,\n        #    return the node of that subtree.\n        return root if left and right else left or right",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Peak Index in a Mountain Array",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/peak-index-in-a-mountain-array",
      "slug": "peak-index-in-a-mountain-array",
      "description": "You are given an integer \nmountain\n array \narr\n of length \nn\n where the values increase to a \npeak element\n and then decrease.\n\n\nReturn the index of the peak element.\n\n\nYour task is to solve it in \nO(log(n))\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \narr = [0,1,0]\n\n\nOutput:\n \n1\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \narr = [0,2,1,0]\n\n\nOutput:\n \n1\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \narr = [0,10,5,2]\n\n\nOutput:\n \n1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= arr.length <= 10\n5\n\n\n0 <= arr[i] <= 10\n6\n\n\narr\n is \nguaranteed\n to be a mountain array.",
      "solution": "class Solution(object):\n    def peakIndexInMountainArray(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(arr)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if arr[mid] > arr[mid+1]:\n                right = mid-1\n            else:\n                left = mid+1\n        return left",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Search in Rotated Sorted Array",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/search-in-rotated-sorted-array",
      "slug": "search-in-rotated-sorted-array",
      "description": "There is an integer array \nnums\n sorted in ascending order (with \ndistinct\n values).\n\n\nPrior to being passed to your function, \nnums\n is \npossibly rotated\n at an unknown pivot index \nk\n (\n1 <= k < nums.length\n) such that the resulting array is \n[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]\n (\n0-indexed\n). For example, \n[0,1,2,4,5,6,7]\n might be rotated at pivot index \n3\n and become \n[4,5,6,7,0,1,2]\n.\n\n\nGiven the array \nnums\n \nafter\n the possible rotation and an integer \ntarget\n, return \nthe index of \ntarget\n if it is in \nnums\n, or \n-1\n if it is not in \nnums\n.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [4,5,6,7,0,1,2], target = 0\n\nOutput:\n 4\n\nExample 2:\n\n\nInput:\n nums = [4,5,6,7,0,1,2], target = 3\n\nOutput:\n -1\n\nExample 3:\n\n\nInput:\n nums = [1], target = 0\n\nOutput:\n -1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 5000\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nAll values of \nnums\n are \nunique\n.\n\n\nnums\n is an ascending array that is possibly rotated.\n\n\n-10\n4\n <= target <= 10\n4",
      "solution": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) / 2\n\n            if nums[mid] == target:\n                return mid\n            elif (nums[mid] >= nums[left] and nums[left] <= target < nums[mid]) or \\\n                 (nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])):\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return -1",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Pow(x, n)",
      "difficulty": "MEDIUM",
      "category": "Math, Recursion",
      "link": "https://leetcode.com/problems/powx-n",
      "slug": "powx-n",
      "description": "Implement \npow(x, n)\n, which calculates \nx\n raised to the power \nn\n (i.e., \nx\nn\n).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 2.00000, n = 10\n\nOutput:\n 1024.00000\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = 2.10000, n = 3\n\nOutput:\n 9.26100\n\n\n\nExample 3:\n\n\n\n\nInput:\n x = 2.00000, n = -2\n\nOutput:\n 0.25000\n\nExplanation:\n 2\n-2\n = 1/2\n2\n = 1/4 = 0.25\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-100.0 < x < 100.0\n\n\n-2\n31\n <= n <= 2\n31\n-1\n\n\nn\n is an integer.\n\n\nEither \nx\n is not zero or \nn > 0\n.\n\n\n-10\n4\n <= x\nn\n <= 10\n4",
      "solution": "class Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        result = 1\n        abs_n = abs(n)\n        while abs_n:\n            if abs_n & 1:\n                result *= x\n            abs_n >>= 1\n            x *= x\n\n        return 1 / result if n < 0 else result\n\n\n# Recursive solution.class Solution2(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        if n < 0 and n != -n:\n            return 1.0 / self.myPow(x, -n)\n        if n == 0:\n            return 1\n        v = self.myPow(x, n / 2)\n        if n % 2 == 0:\n            return v * v\n        else:\n            return v * v * x",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(logn)"
    },
    {
      "title": "Binary Tree Maximum Path Sum",
      "difficulty": "HARD",
      "category": "Dynamic Programming, Tree, Depth-First Search, Binary Tree",
      "link": "https://leetcode.com/problems/binary-tree-maximum-path-sum",
      "slug": "binary-tree-maximum-path-sum",
      "description": "A \npath\n in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence \nat most once\n. Note that the path does not need to pass through the root.\n\n\nThe \npath sum\n of a path is the sum of the node's values in the path.\n\n\nGiven the \nroot\n of a binary tree, return \nthe maximum \npath sum\n of any \nnon-empty\n path\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3]\n\nOutput:\n 6\n\nExplanation:\n The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [-10,9,20,null,null,15,7]\n\nOutput:\n 42\n\nExplanation:\n The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 3 * 10\n4\n]\n.\n\n\n-1000 <= Node.val <= 1000",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return an integer\n    def maxPathSum(self, root):\n        def iter_dfs(node):\n            result = float(\"-inf\")\n            max_sum = [0]\n            stk = [(1, [node, max_sum])]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, ret = params\n                    if not node:\n                        continue\n                    ret1, ret2 = [0], [0]\n                    stk.append((2, [node, ret1, ret2, ret]))\n                    stk.append((1, [node.right, ret2]))\n                    stk.append((1, [node.left, ret1]))\n                elif step == 2:\n                    node, ret1, ret2, ret = params\n                    result = max(result, node.val+max(ret1[0], 0)+max(ret2[0], 0))\n                    ret[0] = node.val+max(ret1[0], ret2[0], 0)\n            return result\n        \n        return iter_dfs(root)\n\nclass Solution2(object):\n    # @param root, a tree node\n    # @return an integer\n    def maxPathSum(self, root):\n        def dfs(node):\n            if not node:\n                return (float(\"-inf\"), 0)\n            max_left, curr_left = dfs(node.left)\n            max_right, curr_right = dfs(node.right)\n            return (max(max_left, max_right, node.val+max(curr_left, 0)+max(curr_right, 0)),\n                    node.val+max(curr_left, curr_right, 0))\n        \n        return dfs(root)[0]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h), h is height of binary tree"
    },
    {
      "title": "Apply Substitutions",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, String, Depth-First Search, Breadth-First Search, Graph, Topological Sort",
      "link": "https://leetcode.com/problems/apply-substitutions",
      "slug": "apply-substitutions",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "\nimport collections\n\n\n# topological sortclass Solution(object):\n    def applySubstitutions(self, replacements, text):\n        \"\"\"\n        :type replacements: List[List[str]]\n        :type text: str\n        :rtype: str\n        \"\"\"\n        def find_adj(s):\n            result = set()\n            i = 0\n            while i < len(s):\n                if s[i] != '%':\n                    i += 1\n                    continue\n                j = next(j for j in xrange(i+1, len(s)) if s[j] == '%')\n                result.add(s[i+1:j])\n                i = j+1\n            return result\n        \n        def replace(s):\n            result = []\n            i = 0\n            while i < len(s):\n                if s[i] != '%':\n                    result.append(s[i])\n                    i += 1\n                    continue\n                j = next(j for j in xrange(i+1, len(s)) if s[j] == '%')\n                result.append(lookup[s[i+1:j]])\n                i = j+1\n            return \"\".join(result)\n        \n        def topological_sort():\n            adj = collections.defaultdict(set)\n            in_degree = collections.defaultdict(int)\n            for u, s in replacements:\n                for v in find_adj(s):\n                    adj[v].add(u)\n                    in_degree[u] += 1\n            result = []\n            q = [u for u, _ in replacements if not in_degree[u]]\n            while q:\n                new_q = []\n                for u in q:\n                    lookup[u] = replace(lookup[u])\n                    for v in adj[u]:\n                        in_degree[v] -= 1\n                        if in_degree[v]:\n                            continue\n                        new_q.append(v)\n                q = new_q\n            return result\n\n        lookup = {k:v for k, v in replacements}\n        topological_sort()\n        return replace(text)\n\n\n# memoizationclass Solution2(object):\n    def applySubstitutions(self, replacements, text):\n        \"\"\"\n        :type replacements: List[List[str]]\n        :type text: str\n        :rtype: str\n        \"\"\"\n        lookup = {k:v for k, v in replacements}\n        memo = {}\n        def replace(s):\n            if s not in memo:\n                result = []\n                i = 0\n                while i < len(s):\n                    if s[i] != '%':\n                        result.append(s[i])\n                        i += 1\n                        continue\n                    j = next(j for j in xrange(i+1, len(s)) if s[j] == '%')\n                    result.append(replace(lookup[s[i+1:j]]))\n                    i = j+1\n                memo[s] = \"\".join(result)\n            return memo[s]\n\n        return replace(text)",
      "explanation": "N/A",
      "time_complexity": "O(r * 2^r)",
      "space_complexity": "O(r * 2^r)"
    },
    {
      "title": "Letter Combinations of a Phone Number",
      "difficulty": "MEDIUM",
      "category": "Hash Table, String, Backtracking",
      "link": "https://leetcode.com/problems/letter-combinations-of-a-phone-number",
      "slug": "letter-combinations-of-a-phone-number",
      "description": "Given a string containing digits from \n2-9\n inclusive, return all possible letter combinations that the number could represent. Return the answer in \nany order\n.\n\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n digits = \"23\"\n\nOutput:\n [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n\n\n\nExample 2:\n\n\n\n\nInput:\n digits = \"\"\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n digits = \"2\"\n\nOutput:\n [\"a\",\"b\",\"c\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= digits.length <= 4\n\n\ndigits[i]\n is a digit in the range \n['2', '9']\n.",
      "solution": "\n# iterative solutionclass Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        if not digits:\n            return []\n\n        lookup = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n        total = 1\n        for digit in digits:\n            total *= len(lookup[int(digit)])\n        result = []\n        for i in xrange(total):\n            base, curr = total, []\n            for digit in digits:\n                choices = lookup[int(digit)]\n                base //= len(choices)\n                curr.append(choices[(i//base)%len(choices)])\n            result.append(\"\".join(curr))\n        return result\n\n\n# iterative solutionclass Solution2(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        if not digits:\n            return []\n\n        result = [\"\"]\n        lookup = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n        for digit in reversed(digits):\n            choices = lookup[int(digit)]\n            m, n = len(choices), len(result)\n            result.extend([result[i % n] for i in xrange(n, m*n)])\n            for i in xrange(m*n):\n                result[i] = choices[i//n] + result[i]\n        return result\n\n\n# recursive solutionclass Solution3(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        lookup = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n\n        def letterCombinationsRecu(result, digits, curr, n):\n            if n == len(digits):\n                result.append(\"\".join(curr))\n                return\n            for choice in lookup[int(digits[n])]:\n                curr.append(choice)\n                letterCombinationsRecu(result, digits, curr, n+1)\n                curr.pop()\n\n        if not digits:\n            return []\n        result = []\n        letterCombinationsRecu(result, digits, [], 0)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n * 4^n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Largest Rectangle in Histogram",
      "difficulty": "HARD",
      "category": "Array, Stack, Monotonic Stack",
      "link": "https://leetcode.com/problems/largest-rectangle-in-histogram",
      "slug": "largest-rectangle-in-histogram",
      "description": "Given an array of integers \nheights\n representing the histogram's bar height where the width of each bar is \n1\n, return \nthe area of the largest rectangle in the histogram\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [2,1,5,6,2,3]\n\nOutput:\n 10\n\nExplanation:\n The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n heights = [2,4]\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= heights.length <= 10\n5\n\n\n0 <= heights[i] <= 10\n4",
      "solution": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stk, result = [-1], 0\n        for i in xrange(len(heights)+1):\n            while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):\n                result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))\n            stk.append(i) \n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Merge Two Sorted Lists",
      "difficulty": "EASY",
      "category": "Linked List, Recursion",
      "link": "https://leetcode.com/problems/merge-two-sorted-lists",
      "slug": "merge-two-sorted-lists",
      "description": "You are given the heads of two sorted linked lists \nlist1\n and \nlist2\n.\n\n\nMerge the two lists into one \nsorted\n list. The list should be made by splicing together the nodes of the first two lists.\n\n\nReturn \nthe head of the merged linked list\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n list1 = [1,2,4], list2 = [1,3,4]\n\nOutput:\n [1,1,2,3,4,4]\n\n\n\nExample 2:\n\n\n\n\nInput:\n list1 = [], list2 = []\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n list1 = [], list2 = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in both lists is in the range \n[0, 50]\n.\n\n\n-100 <= Node.val <= 100\n\n\nBoth \nlist1\n and \nlist2\n are sorted in \nnon-decreasing\n order.",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, self.next)\n\nclass Solution(object):\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        curr = dummy = ListNode(0)\n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        curr.next = l1 or l2\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Happy Number",
      "difficulty": "EASY",
      "category": "Hash Table, Math, Two Pointers",
      "link": "https://leetcode.com/problems/happy-number",
      "slug": "happy-number",
      "description": "Write an algorithm to determine if a number \nn\n is happy.\n\n\nA \nhappy number\n is a number defined by the following process:\n\n\n\n\nStarting with any positive integer, replace the number by the sum of the squares of its digits.\n\n\nRepeat the process until the number equals 1 (where it will stay), or it \nloops endlessly in a cycle\n which does not include 1.\n\n\nThose numbers for which this process \nends in 1\n are happy.\n\n\n\n\nReturn \ntrue\n \nif\n \nn\n \nis a happy number, and\n \nfalse\n \nif not\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 19\n\nOutput:\n true\n\nExplanation:\n\n1\n2\n + 9\n2\n = 82\n8\n2\n + 2\n2\n = 68\n6\n2\n + 8\n2\n = 100\n1\n2\n + 0\n2\n + 0\n2\n = 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2\n31\n - 1",
      "solution": "class Solution(object):\n    # @param {integer} n\n    # @return {boolean}\n    def isHappy(self, n):\n        lookup = {}\n        while n != 1 and n not in lookup:\n            lookup[n] = True\n            n = self.nextNumber(n)\n        return n == 1\n\n    def nextNumber(self, n):\n        new = 0\n        for char in str(n):\n            new += int(char)**2\n        return new",
      "explanation": "N/A",
      "time_complexity": "O(k), where k is the steps to be happy number",
      "space_complexity": "O(k)"
    },
    {
      "title": "Find Minimum in Rotated Sorted Array",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array",
      "slug": "find-minimum-in-rotated-sorted-array",
      "description": "Suppose an array of length \nn\n sorted in ascending order is \nrotated\n between \n1\n and \nn\n times. For example, the array \nnums = [0,1,2,4,5,6,7]\n might become:\n\n\n\n\n[4,5,6,7,0,1,2]\n if it was rotated \n4\n times.\n\n\n[0,1,2,4,5,6,7]\n if it was rotated \n7\n times.\n\n\n\n\nNotice that \nrotating\n an array \n[a[0], a[1], a[2], ..., a[n-1]]\n 1 time results in the array \n[a[n-1], a[0], a[1], a[2], ..., a[n-2]]\n.\n\n\nGiven the sorted rotated array \nnums\n of \nunique\n elements, return \nthe minimum element of this array\n.\n\n\nYou must write an algorithm that runs in \nO(log n) time\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,4,5,1,2]\n\nOutput:\n 1\n\nExplanation:\n The original array was [1,2,3,4,5] rotated 3 times.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [4,5,6,7,0,1,2]\n\nOutput:\n 0\n\nExplanation:\n The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [11,13,15,17]\n\nOutput:\n 11\n\nExplanation:\n The original array was [11,13,15,17] and it was rotated 4 times. \n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 5000\n\n\n-5000 <= nums[i] <= 5000\n\n\nAll the integers of \nnums\n are \nunique\n.\n\n\nnums\n is sorted and rotated between \n1\n and \nn\n times.",
      "solution": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums)\n        target = nums[-1]\n\n        while left < right:\n            mid = left + (right - left) / 2\n\n            if nums[mid] <= target:\n                right = mid\n            else:\n                left = mid + 1\n\n        return nums[left]\n\nclass Solution2(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] >= nums[right]:\n            mid = left + (right - left) / 2\n\n            if nums[mid] < nums[left]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return nums[left]",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Merge Sorted Array",
      "difficulty": "EASY",
      "category": "Array, Two Pointers, Sorting",
      "link": "https://leetcode.com/problems/merge-sorted-array",
      "slug": "merge-sorted-array",
      "description": "You are given two integer arrays \nnums1\n and \nnums2\n, sorted in \nnon-decreasing order\n, and two integers \nm\n and \nn\n, representing the number of elements in \nnums1\n and \nnums2\n respectively.\n\n\nMerge\n \nnums1\n and \nnums2\n into a single array sorted in \nnon-decreasing order\n.\n\n\nThe final sorted array should not be returned by the function, but instead be \nstored inside the array \nnums1\n. To accommodate this, \nnums1\n has a length of \nm + n\n, where the first \nm\n elements denote the elements that should be merged, and the last \nn\n elements are set to \n0\n and should be ignored. \nnums2\n has a length of \nn\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n\nOutput:\n [1,2,2,3,5,6]\n\nExplanation:\n The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [\n1\n,\n2\n,2,\n3\n,5,6] with the underlined elements coming from nums1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1], m = 1, nums2 = [], n = 0\n\nOutput:\n [1]\n\nExplanation:\n The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums1 = [0], m = 0, nums2 = [1], n = 1\n\nOutput:\n [1]\n\nExplanation:\n The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m + n\n\n\nnums2.length == n\n\n\n0 <= m, n <= 200\n\n\n1 <= m + n <= 200\n\n\n-10\n9\n <= nums1[i], nums2[j] <= 10\n9\n\n\n\n\n \n\n\nFollow up: \nCan you come up with an algorithm that runs in \nO(m + n)\n time?",
      "solution": "class Solution(object):\n    # @param A  a list of integers\n    # @param m  an integer, length of A\n    # @param B  a list of integers\n    # @param n  an integer, length of B\n    # @return nothing\n    def merge(self, A, m, B, n):\n        last, i, j = m + n - 1, m - 1, n - 1\n\n        while i >= 0 and j >= 0:\n            if A[i] > B[j]:\n                A[last] = A[i]\n                last, i = last - 1, i - 1\n            else:\n                A[last] = B[j]\n                last, j = last - 1, j - 1\n\n        while j >= 0:\n                A[last] = B[j]\n                last, j = last - 1, j - 1",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Sort Colors",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers, Sorting",
      "link": "https://leetcode.com/problems/sort-colors",
      "slug": "sort-colors",
      "description": "Given an array \nnums\n with \nn\n objects colored red, white, or blue, sort them \nin-place\n \nso that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\n\nWe will use the integers \n0\n, \n1\n, and \n2\n to represent the color red, white, and blue, respectively.\n\n\nYou must solve this problem without using the library's sort function.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,0,2,1,1,0]\n\nOutput:\n [0,0,1,1,2,2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,0,1]\n\nOutput:\n [0,1,2]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 300\n\n\nnums[i]\n is either \n0\n, \n1\n, or \n2\n.\n\n\n\n\n \n\n\nFollow up:\n Could you come up with a one-pass algorithm using only constant extra space?",
      "solution": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        def triPartition(nums, target):\n            i, left, right = 0, 0, len(nums)-1\n            while i <= right:\n                if nums[i] > target:\n                    nums[i], nums[right] = nums[right], nums[i]\n                    right -= 1\n                else:\n                    if nums[i] < target:\n                        nums[left], nums[i] = nums[i], nums[left]\n                        left += 1\n                    i += 1\n\n        triPartition(nums, 1)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Fibonacci Number",
      "difficulty": "EASY",
      "category": "Math, Dynamic Programming, Recursion, Memoization",
      "link": "https://leetcode.com/problems/fibonacci-number",
      "slug": "fibonacci-number",
      "description": "The \nFibonacci numbers\n, commonly denoted \nF(n)\n form a sequence, called the \nFibonacci sequence\n, such that each number is the sum of the two preceding ones, starting from \n0\n and \n1\n. That is,\n\n\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\n\n\nGiven \nn\n, calculate \nF(n)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 1\n\nExplanation:\n F(2) = F(1) + F(0) = 1 + 0 = 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 2\n\nExplanation:\n F(3) = F(2) + F(1) = 1 + 1 = 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 4\n\nOutput:\n 3\n\nExplanation:\n F(4) = F(3) + F(2) = 2 + 1 = 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 30",
      "solution": "\nimport itertools\n\nclass Solution(object):\n    def fib(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        def matrix_expo(A, K):\n            result = [[int(i==j) for j in xrange(len(A))] \\\n                      for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b for a, b in itertools.izip(row, col)) \\\n                     for col in ZB] for row in A]\n\n        T = [[1, 1],\n             [1, 0]]\n        return matrix_mult([[1, 0]], matrix_expo(T, N))[0][1]  # [a1, a0] * T^N\n\nclass Solution2(object):\n    def fib(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        prev, current = 0, 1\n        for i in xrange(N):\n            prev, current = current, prev + current,\n        return prev",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Valid Sudoku",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Matrix",
      "link": "https://leetcode.com/problems/valid-sudoku",
      "slug": "valid-sudoku",
      "description": "Determine if a \n9 x 9\n Sudoku board is valid. Only the filled cells need to be validated \naccording to the following rules\n:\n\n\n\n\nEach row must contain the digits \n1-9\n without repetition.\n\n\nEach column must contain the digits \n1-9\n without repetition.\n\n\nEach of the nine \n3 x 3\n sub-boxes of the grid must contain the digits \n1-9\n without repetition.\n\n\n\n\nNote:\n\n\n\n\nA Sudoku board (partially filled) could be valid but is not necessarily solvable.\n\n\nOnly the filled cells need to be validated according to the mentioned rules.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\nInput:\n board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput:\n false\n\nExplanation:\n Same as Example 1, except with the \n5\n in the top left corner being modified to \n8\n. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nboard.length == 9\n\n\nboard[i].length == 9\n\n\nboard[i][j]\n is a digit \n1-9\n or \n'.'\n.",
      "solution": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        for i in xrange(9):\n            if not self.isValidList([board[i][j] for j in xrange(9)]) or \\\n               not self.isValidList([board[j][i] for j in xrange(9)]):\n                return False\n        for i in xrange(3):\n            for j in xrange(3):\n                if not self.isValidList([board[m][n] for n in xrange(3 * j, 3 * j + 3) \\\n                                                     for m in xrange(3 * i, 3 * i + 3)]):\n                    return False\n        return True\n\n    def isValidList(self, xs):\n        xs = filter(lambda x: x != '.', xs)\n        return len(set(xs)) == len(xs)",
      "explanation": "N/A",
      "time_complexity": "O(9^2)",
      "space_complexity": "O(9)"
    },
    {
      "title": "Decode String",
      "difficulty": "MEDIUM",
      "category": "String, Stack, Recursion",
      "link": "https://leetcode.com/problems/decode-string",
      "slug": "decode-string",
      "description": "Given an encoded string, return its decoded string.\n\n\nThe encoding rule is: \nk[encoded_string]\n, where the \nencoded_string\n inside the square brackets is being repeated exactly \nk\n times. Note that \nk\n is guaranteed to be a positive integer.\n\n\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, \nk\n. For example, there will not be input like \n3a\n or \n2[4]\n.\n\n\nThe test cases are generated so that the length of the output will never exceed \n10\n5\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"3[a]2[bc]\"\n\nOutput:\n \"aaabcbc\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"3[a2[c]]\"\n\nOutput:\n \"accaccacc\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"2[abc]3[cd]ef\"\n\nOutput:\n \"abcabccdcdcdef\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 30\n\n\ns\n consists of lowercase English letters, digits, and square brackets \n'[]'\n.\n\n\ns\n is guaranteed to be \na valid\n input.\n\n\nAll the integers in \ns\n are in the range \n[1, 300]\n.",
      "solution": "class Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n, curr, nums, strs = 0, [], [], []\n        for c in s:\n            if c.isdigit():\n                n = n*10 + ord(c)-ord('0')\n            elif c.isalpha():\n                curr.append(c)\n            elif c == '[':\n                nums.append(n)\n                strs.append(curr)\n                n, curr = 0, []\n            elif c == ']':\n                strs[-1].extend(curr*nums.pop())\n                curr = strs.pop()\n        return \"\".join(curr)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Reverse Linked List",
      "difficulty": "EASY",
      "category": "Linked List, Recursion",
      "link": "https://leetcode.com/problems/reverse-linked-list",
      "slug": "reverse-linked-list",
      "description": "Given the \nhead\n of a singly linked list, reverse the list, and return \nthe reversed list\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5]\n\nOutput:\n [5,4,3,2,1]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2]\n\nOutput:\n [2,1]\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is the range \n[0, 5000]\n.\n\n\n-5000 <= Node.val <= 5000\n\n\n\n\n \n\n\nFollow up:\n A linked list can be reversed either iteratively or recursively. Could you implement both?",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\n# Iterative solution.class Solution(object):\n    # @param {ListNode} head\n    # @return {ListNode}\n    def reverseList(self, head):\n        dummy = ListNode(float(\"-inf\"))\n        while head:\n            dummy.next, head.next, head = head, dummy.next, head.next\n        return dummy.next\n\n# Recursive solution.class Solution2(object):\n    # @param {ListNode} head\n    # @return {ListNode}\n    def reverseList(self, head):\n        [begin, end] = self.reverseListRecu(head)\n        return begin\n\n    def reverseListRecu(self, head):\n        if not head:\n            return [None, None]\n\n        [begin, end] = self.reverseListRecu(head.next)\n\n        if end:\n            end.next = head\n            head.next = None\n            return [begin, head]\n        else:\n            return [head, head]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Find Words Containing Character",
      "difficulty": "EASY",
      "category": "Array, String",
      "link": "https://leetcode.com/problems/find-words-containing-character",
      "slug": "find-words-containing-character",
      "description": "You are given a \n0-indexed\n array of strings \nwords\n and a character \nx\n.\n\n\nReturn \nan \narray of indices\n representing the words that contain the character \nx\n.\n\n\nNote\n that the returned array may be in \nany\n order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"leet\",\"code\"], x = \"e\"\n\nOutput:\n [0,1]\n\nExplanation:\n \"e\" occurs in both words: \"l\nee\nt\", and \"cod\ne\n\". Hence, we return indices 0 and 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"abc\",\"bcd\",\"aaaa\",\"cbc\"], x = \"a\"\n\nOutput:\n [0,2]\n\nExplanation:\n \"a\" occurs in \"\na\nbc\", and \"\naaaa\n\". Hence, we return indices 0 and 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"abc\",\"bcd\",\"aaaa\",\"cbc\"], x = \"z\"\n\nOutput:\n []\n\nExplanation:\n \"z\" does not occur in any of the words. Hence, we return an empty array.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 50\n\n\n1 <= words[i].length <= 50\n\n\nx\n is a lowercase English letter.\n\n\nwords[i]\n consists only of lowercase English letters.",
      "solution": "class Solution(object):\n    def findWordsContaining(self, words, x):\n        \"\"\"\n        :type words: List[str]\n        :type x: str\n        :rtype: List[int]\n        \"\"\"\n        return [i for i, w in enumerate(words) if x in w]",
      "explanation": "N/A",
      "time_complexity": "O(n * l)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Create Hello World Function",
      "difficulty": "EASY",
      "category": "String",
      "link": "https://leetcode.com/problems/create-hello-world-function",
      "slug": "create-hello-world-function",
      "description": "Write a function \ncreateHelloWorld\n. It should return a new function that always returns \n\"Hello World\"\n.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n args = []\n\nOutput:\n \"Hello World\"\n\nExplanation:\n\nconst f = createHelloWorld();\nf(); // \"Hello World\"\n\nThe function returned by createHelloWorld should always return \"Hello World\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n args = [{},null,42]\n\nOutput:\n \"Hello World\"\n\nExplanation:\n\nconst f = createHelloWorld();\nf({}, null, 42); // \"Hello World\"\n\nAny arguments could be passed to the function but it should still always return \"Hello World\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= args.length <= 10",
      "solution": "# Solution not found in kamyu104 repository",
      "explanation": "N/A",
      "time_complexity": "N/A",
      "space_complexity": "N/A"
    },
    {
      "title": "Rotate Image",
      "difficulty": "MEDIUM",
      "category": "Array, Math, Matrix",
      "link": "https://leetcode.com/problems/rotate-image",
      "slug": "rotate-image",
      "description": "You are given an \nn x n\n 2D \nmatrix\n representing an image, rotate the image by \n90\n degrees (clockwise).\n\n\nYou have to rotate the image \nin-place\n, which means you have to modify the input 2D matrix directly. \nDO NOT\n allocate another 2D matrix and do the rotation.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [[7,4,1],[8,5,2],[9,6,3]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n\nOutput:\n [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 20\n\n\n-1000 <= matrix[i][j] <= 1000",
      "solution": "class Solution(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        n = len(matrix)\n\n        # anti-diagonal mirror\n        for i in xrange(n):\n            for j in xrange(n - i):\n                matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j]\n\n        # horizontal mirror\n        for i in xrange(n / 2):\n            for j in xrange(n):\n                matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]\n\n        return matrix\nclass Solution2(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        return [list(reversed(x)) for x in zip(*matrix)]",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n^2)"
    },
    {
      "title": "Max Consecutive Ones",
      "difficulty": "EASY",
      "category": "Array",
      "link": "https://leetcode.com/problems/max-consecutive-ones",
      "slug": "max-consecutive-ones",
      "description": "Given a binary array \nnums\n, return \nthe maximum number of consecutive \n1\n's in the array\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,0,1,1,1]\n\nOutput:\n 3\n\nExplanation:\n The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,0,1,1,0,1]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\nnums[i]\n is either \n0\n or \n1\n.",
      "solution": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, local_max = 0, 0\n        for n in nums:\n            local_max = (local_max + 1 if n else 0)\n            result = max(result, local_max)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "LFU Cache",
      "difficulty": "HARD",
      "category": "Hash Table, Linked List, Design, Doubly-Linked List",
      "link": "https://leetcode.com/problems/lfu-cache",
      "slug": "lfu-cache",
      "description": "Design and implement a data structure for a \nLeast Frequently Used (LFU)\n cache.\n\n\nImplement the \nLFUCache\n class:\n\n\n\n\nLFUCache(int capacity)\n Initializes the object with the \ncapacity\n of the data structure.\n\n\nint get(int key)\n Gets the value of the \nkey\n if the \nkey\n exists in the cache. Otherwise, returns \n-1\n.\n\n\nvoid put(int key, int value)\n Update the value of the \nkey\n if present, or inserts the \nkey\n if not already present. When the cache reaches its \ncapacity\n, it should invalidate and remove the \nleast frequently used\n key before inserting a new item. For this problem, when there is a \ntie\n (i.e., two or more keys with the same frequency), the \nleast recently used\n \nkey\n would be invalidated.\n\n\n\n\nTo determine the least frequently used key, a \nuse counter\n is maintained for each key in the cache. The key with the smallest \nuse counter\n is the least frequently used key.\n\n\nWhen a key is first inserted into the cache, its \nuse counter\n is set to \n1\n (due to the \nput\n operation). The \nuse counter\n for a key in the cache is incremented either a \nget\n or \nput\n operation is called on it.\n\n\nThe functions \nget\n and \nput\n must each run in \nO(1)\n average time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\n\nOutput\n\n[null, null, null, 1, null, -1, 3, null, -1, 3, 4]\n\n\nExplanation\n\n// cnt(x) = the use counter for key x\n// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)\nLFUCache lfu = new LFUCache(2);\nlfu.put(1, 1);   // cache=[1,_], cnt(1)=1\nlfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1\nlfu.get(1);      // return 1\n                 // cache=[1,2], cnt(2)=1, cnt(1)=2\nlfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.\n                 // cache=[3,1], cnt(3)=1, cnt(1)=2\nlfu.get(2);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=[3,1], cnt(3)=2, cnt(1)=2\nlfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.\n                 // cache=[4,3], cnt(4)=1, cnt(3)=2\nlfu.get(1);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=[3,4], cnt(4)=1, cnt(3)=3\nlfu.get(4);      // return 4\n                 // cache=[4,3], cnt(4)=2, cnt(3)=3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= capacity <= 10\n4\n\n\n0 <= key <= 10\n5\n\n\n0 <= value <= 10\n9\n\n\nAt most \n2 * 10\n5\n calls will be made to \nget\n and \nput\n.",
      "solution": "\nimport collections\n\n\n# using OrderedDictclass LFUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.__capa = capacity\n        self.__size = 0\n        self.__min_freq = float(\"inf\")\n        self.__freq_to_nodes = collections.defaultdict(collections.OrderedDict)\n        self.__key_to_freq = {}\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.__key_to_freq:\n            return -1\n        value = self.__freq_to_nodes[self.__key_to_freq[key]][key]\n        self.__update(key, value)\n        return value\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: void\n        \"\"\"\n        if self.__capa <= 0:\n            return\n\n        if key not in self.__key_to_freq and self.__size == self.__capa:\n            del self.__key_to_freq[self.__freq_to_nodes[self.__min_freq].popitem(last=False)[0]]\n            if not self.__freq_to_nodes[self.__min_freq]:\n                del self.__freq_to_nodes[self.__min_freq]\n            self.__size -= 1\n        self.__update(key, value)\n        \n    def __update(self, key, value):\n        freq = 0\n        if key in self.__key_to_freq:\n            freq = self.__key_to_freq[key]\n            del self.__freq_to_nodes[freq][key]\n            if not self.__freq_to_nodes[freq]:\n                del self.__freq_to_nodes[freq]\n                if self.__min_freq == freq:\n                    self.__min_freq += 1\n            self.__size -= 1\n\n        freq += 1\n        self.__min_freq = min(self.__min_freq, freq)\n        self.__key_to_freq[key] = freq\n        self.__freq_to_nodes[freq][key] = value\n        self.__size += 1\n\n\nimport collections\n\nclass ListNode(object):\n    def __init__(self, key, value, freq):\n        self.key = key\n        self.val = value\n        self.freq = freq\n        self.next = None\n        self.prev = None\n\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def append(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\n\nclass LFUCache2(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.__capa = capacity\n        self.__size = 0\n        self.__min_freq = float(\"inf\")\n        self.__freq_to_nodes = collections.defaultdict(LinkedList)\n        self.__key_to_node = {}\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.__key_to_node:\n            return -1\n        value = self.__key_to_node[key].val\n        self.__update(key, value)\n        return value\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: void\n        \"\"\"\n        if self.__capa <= 0:\n            return\n\n        if key not in self.__key_to_node and self.__size == self.__capa:\n            del self.__key_to_node[self.__freq_to_nodes[self.__min_freq].head.key]\n            self.__freq_to_nodes[self.__min_freq].delete(self.__freq_to_nodes[self.__min_freq].head)\n            if not self.__freq_to_nodes[self.__min_freq].head:\n                del self.__freq_to_nodes[self.__min_freq]\n            self.__size -= 1\n        self.__update(key, value)\n        \n    def __update(self, key, value):\n        freq = 0\n        if key in self.__key_to_node:\n            old_node = self.__key_to_node[key]\n            freq = old_node.freq\n            self.__freq_to_nodes[freq].delete(old_node)\n            if not self.__freq_to_nodes[freq].head:\n                del self.__freq_to_nodes[freq]\n                if self.__min_freq == freq:\n                    self.__min_freq += 1\n            self.__size -= 1\n\n        freq += 1\n        self.__min_freq = min(self.__min_freq, freq)\n        self.__key_to_node[key] = ListNode(key, value, freq)\n        self.__freq_to_nodes[freq].append(self.__key_to_node[key])\n        self.__size += 1",
      "explanation": "N/A",
      "time_complexity": "O(1), per operation",
      "space_complexity": "O(k), k is the capacity of cache"
    },
    {
      "title": "Power of Two",
      "difficulty": "EASY",
      "category": "Math, Bit Manipulation, Recursion",
      "link": "https://leetcode.com/problems/power-of-two",
      "slug": "power-of-two",
      "description": "Given an integer \nn\n, return \ntrue\n if it is a power of two. Otherwise, return \nfalse\n.\n\n\nAn integer \nn\n is a power of two, if there exists an integer \nx\n such that \nn == 2\nx\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n true\n\nExplanation: \n2\n0\n = 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 16\n\nOutput:\n true\n\nExplanation: \n2\n4\n = 16\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= n <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you solve it without loops/recursion?",
      "solution": "class Solution(object):\n    # @param {integer} n\n    # @return {boolean}\n    def isPowerOfTwo(self, n):\n        return n > 0 and (n & (n - 1)) == 0\n\nclass Solution2(object):\n    # @param {integer} n\n    # @return {boolean}\n    def isPowerOfTwo(self, n):\n        return n > 0 and (n & ~-n) == 0",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Max Consecutive Ones III",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search, Sliding Window, Prefix Sum",
      "link": "https://leetcode.com/problems/max-consecutive-ones-iii",
      "slug": "max-consecutive-ones-iii",
      "description": "Given a binary array \nnums\n and an integer \nk\n, return \nthe maximum number of consecutive \n1\n's in the array if you can flip at most\n \nk\n \n0\n's.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\n\nOutput:\n 6\n\nExplanation:\n [1,1,1,0,0,\n1\n,1,1,1,1,\n1\n]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\n\nOutput:\n 10\n\nExplanation:\n [0,0,\n1,1,\n1\n,\n1\n,1,1,1,\n1\n,1,1\n,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\nnums[i]\n is either \n0\n or \n1\n.\n\n\n0 <= k <= nums.length",
      "solution": "class Solution(object):\n    def longestOnes(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        result, i = 0, 0\n        for j in xrange(len(A)):\n            K -= int(A[j] == 0)\n            while K < 0:\n                K += int(A[i] == 0)\n                i += 1\n            result = max(result, j-i+1)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Escape the Spreading Fire",
      "difficulty": "HARD",
      "category": "Array, Binary Search, Breadth-First Search, Matrix",
      "link": "https://leetcode.com/problems/escape-the-spreading-fire",
      "slug": "escape-the-spreading-fire",
      "description": "You are given a \n0-indexed\n 2D integer array \ngrid\n of size \nm x n\n which represents a field. Each cell has one of three values:\n\n\n\n\n0\n represents grass,\n\n\n1\n represents fire,\n\n\n2\n represents a wall that you and fire cannot pass through.\n\n\n\n\nYou are situated in the top-left cell, \n(0, 0)\n, and you want to travel to the safehouse at the bottom-right cell, \n(m - 1, n - 1)\n. Every minute, you may move to an \nadjacent\n grass cell. \nAfter\n your move, every fire cell will spread to all \nadjacent\n cells that are not walls.\n\n\nReturn \nthe \nmaximum\n number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse\n. If this is impossible, return \n-1\n. If you can \nalways\n reach the safehouse regardless of the minutes stayed, return \n10\n9\n.\n\n\nNote that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\n\n\nA cell is \nadjacent\n to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]\n\nOutput:\n 3\n\nExplanation:\n The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]\n\nOutput:\n -1\n\nExplanation:\n The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[0,0,0],[2,2,0],[1,2,0]]\n\nOutput:\n 1000000000\n\nExplanation:\n The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 10\n9\n is returned.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n2 <= m, n <= 300\n\n\n4 <= m * n <= 2 * 10\n4\n\n\ngrid[i][j]\n is either \n0\n, \n1\n, or \n2\n.\n\n\ngrid[0][0] == grid[m - 1][n - 1] == 0",
      "solution": "\nimport collections\n\n\n# bfsclass Solution(object):\n    def maximumMinutes(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        GRASS, FIRE, WALL, PERSON = range(4)\n        INF = 10**9\n        def bfs(grid):\n            time = collections.defaultdict(int)\n            d = 0\n            q = [(r, c, FIRE) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c] == FIRE]\n            q.append((0, 0, PERSON))\n            while q:\n                new_q = []\n                for r, c, t in q:\n                    for dr, dc in DIRECTIONS:\n                        nr, nc = r+dr, c+dc\n                        if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and\n                                grid[nr][nc] != WALL and\n                                ((t == FIRE and grid[nr][nc] != FIRE) or\n                                 (t == PERSON and (grid[nr][nc] == GRASS or (grid[nr][nc] == FIRE and (nr, nc) == (len(grid)-1, len(grid[0])-1) and d+1 == time[FIRE, nr, nc]))))):\n                            continue\n                        if grid[nr][nc] != FIRE:\n                            grid[nr][nc] = t\n                        if (nr, nc) in ((len(grid)-1, len(grid[0])-1), (len(grid)-1, len(grid[0])-2), (len(grid)-2, len(grid[0])-1)):\n                            time[t, nr, nc] = d+1\n                        new_q.append((nr, nc, t))\n                q = new_q\n                d += 1\n            return time\n\n        time = bfs(grid)\n        if not time[PERSON, len(grid)-1, len(grid[0])-1]:\n            return -1\n        if not time[FIRE, len(grid)-1, len(grid[0])-1]:\n            return INF\n        diff = time[FIRE, len(grid)-1, len(grid[0])-1]-time[PERSON, len(grid)-1, len(grid[0])-1]\n        return diff if diff+2 in (time[FIRE, len(grid)-1, len(grid[0])-2]-time[PERSON, len(grid)-1, len(grid[0])-2],\n                                  time[FIRE, len(grid)-2, len(grid[0])-1]-time[PERSON, len(grid)-2, len(grid[0])-1]) else diff-1\n\n\n# bfsclass Solution2(object):\n    def maximumMinutes(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        FIRE, WALL, PERSON = range(1, 4)\n        INF = 10**9\n        def bfs(grid):\n            time = {FIRE:[[INF]*len(grid[0]) for _ in xrange(len(grid))],\n                    PERSON:[[INF]*len(grid[0]) for _ in xrange(len(grid))]}\n            d = 0\n            q = [(r, c, FIRE) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c] == FIRE]\n            q.append((0, 0, PERSON))\n            for r, c, t in q:\n                time[t][r][c] = d\n            while q:\n                new_q = []\n                for r, c, t in q:\n                    for dr, dc in DIRECTIONS:\n                        nr, nc = r+dr, c+dc\n                        if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and\n                                grid[nr][nc] != WALL and time[t][nr][nc] == INF and\n                                (t == FIRE or\n                                 d+1 < time[FIRE][nr][nc] or (d+1 == time[FIRE][nr][nc] and (nr, nc) == (len(grid)-1, len(grid[0])-1)))):\n                            continue\n                        time[t][nr][nc] = d+1\n                        new_q.append((nr, nc, t))\n                q = new_q\n                d += 1\n            return time\n\n        time = bfs(grid)\n        if time[PERSON][-1][-1] == INF:\n            return -1\n        if time[FIRE][-1][-1] == INF:\n            return INF\n        diff = time[FIRE][-1][-1]-time[PERSON][-1][-1]\n        return diff if diff+2 in (time[FIRE][-1][-2]-time[PERSON][-1][-2], time[FIRE][-2][-1]-time[PERSON][-2][-1]) else diff-1",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "Squares of a Sorted Array",
      "difficulty": "EASY",
      "category": "Array, Two Pointers, Sorting",
      "link": "https://leetcode.com/problems/squares-of-a-sorted-array",
      "slug": "squares-of-a-sorted-array",
      "description": "Given an integer array \nnums\n sorted in \nnon-decreasing\n order, return \nan array of \nthe squares of each number\n sorted in non-decreasing order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-4,-1,0,3,10]\n\nOutput:\n [0,1,9,16,100]\n\nExplanation:\n After squaring, the array becomes [16,1,0,9,100].\nAfter sorting, it becomes [0,1,9,16,100].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-7,-3,2,3,11]\n\nOutput:\n [4,9,9,49,121]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= \n10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nnums\n is sorted in \nnon-decreasing\n order.\n\n\n\n\n \n\n\nFollow up:\n Squaring each element and sorting the new array is very trivial, could you find an \nO(n)\n solution using a different approach?",
      "solution": "\nimport bisect\n\nclass Solution(object):\n    def sortedSquares(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        right = bisect.bisect_left(A, 0)\n        left = right-1\n        result = []\n        while 0 <= left or right < len(A):\n            if right == len(A) or \\\n               (0 <= left and A[left]**2 < A[right]**2):\n                result.append(A[left]**2)\n                left -= 1\n            else:\n                result.append(A[right]**2)\n                right += 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Burst Balloons",
      "difficulty": "HARD",
      "category": "Array, Dynamic Programming",
      "link": "https://leetcode.com/problems/burst-balloons",
      "slug": "burst-balloons",
      "description": "You are given \nn\n balloons, indexed from \n0\n to \nn - 1\n. Each balloon is painted with a number on it represented by an array \nnums\n. You are asked to burst all the balloons.\n\n\nIf you burst the \ni\nth\n balloon, you will get \nnums[i - 1] * nums[i] * nums[i + 1]\n coins. If \ni - 1\n or \ni + 1\n goes out of bounds of the array, then treat it as if there is a balloon with a \n1\n painted on it.\n\n\nReturn \nthe maximum coins you can collect by bursting the balloons wisely\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,1,5,8]\n\nOutput:\n 167\n\nExplanation:\n\nnums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,5]\n\nOutput:\n 10\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 300\n\n\n0 <= nums[i] <= 100",
      "solution": "\nclass Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        coins = [1] + [i for i in nums if i > 0] + [1]\n        n = len(coins)\n        max_coins = [[0 for _ in xrange(n)] for _ in xrange(n)]\n\n        for k in xrange(2, n):\n            for left in xrange(n - k):\n                right = left + k\n                for i in xrange(left + 1, right):\n                    max_coins[left][right] = \\\n                        max(max_coins[left][right],\n                            coins[left] * coins[i] * coins[right] +\n                            max_coins[left][i] +\n                            max_coins[i][right])\n\n        return max_coins[0][-1]",
      "explanation": "N/A",
      "time_complexity": "O(n^3)",
      "space_complexity": "O(n^2)"
    },
    {
      "title": "Climbing Stairs",
      "difficulty": "EASY",
      "category": "Math, Dynamic Programming, Memoization",
      "link": "https://leetcode.com/problems/climbing-stairs",
      "slug": "climbing-stairs",
      "description": "You are climbing a staircase. It takes \nn\n steps to reach the top.\n\n\nEach time you can either climb \n1\n or \n2\n steps. In how many distinct ways can you climb to the top?\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 2\n\nExplanation:\n There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 3\n\nExplanation:\n There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 45",
      "solution": "\nimport itertools\n\nclass Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def matrix_expo(A, K):\n            result = [[int(i==j) for j in xrange(len(A))] \\\n                      for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b for a, b in itertools.izip(row, col)) \\\n                     for col in ZB] for row in A]\n\n        T = [[1, 1],\n             [1, 0]]\n        return matrix_mult([[1,  0]], matrix_expo(T, n))[0][0]  # [a0, a(-1)] * T^n\n\nclass Solution2(object):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    def climbStairs(self, n):\n        prev, current = 0, 1\n        for i in xrange(n):\n            prev, current = current, prev + current,\n        return current",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Longest Palindrome by Concatenating Two Letter Words",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, String, Greedy, Counting",
      "link": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words",
      "slug": "longest-palindrome-by-concatenating-two-letter-words",
      "description": "You are given an array of strings \nwords\n. Each element of \nwords\n consists of \ntwo\n lowercase English letters.\n\n\nCreate the \nlongest possible palindrome\n by selecting some elements from \nwords\n and concatenating them in \nany order\n. Each element can be selected \nat most once\n.\n\n\nReturn \nthe \nlength\n of the longest palindrome that you can create\n. If it is impossible to create any palindrome, return \n0\n.\n\n\nA \npalindrome\n is a string that reads the same forward and backward.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"lc\",\"cl\",\"gg\"]\n\nOutput:\n 6\n\nExplanation:\n One longest palindrome is \"lc\" + \"gg\" + \"cl\" = \"lcggcl\", of length 6.\nNote that \"clgglc\" is another longest palindrome that can be created.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ab\"]\n\nOutput:\n 8\n\nExplanation:\n One longest palindrome is \"ty\" + \"lc\" + \"cl\" + \"yt\" = \"tylcclyt\", of length 8.\nNote that \"lcyttycl\" is another longest palindrome that can be created.\n\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"cc\",\"ll\",\"xx\"]\n\nOutput:\n 2\n\nExplanation:\n One longest palindrome is \"cc\", of length 2.\nNote that \"ll\" is another longest palindrome that can be created, and so is \"xx\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 10\n5\n\n\nwords[i].length == 2\n\n\nwords[i]\n consists of lowercase English letters.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def longestPalindrome(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter(words)\n        result = remain = 0\n        for x, c in cnt.iteritems():\n            if x == x[::-1]:\n                result += c//2\n                remain |= c%2\n            elif x < x[::-1] and x[::-1] in cnt:\n                result += min(c, cnt[x[::-1]])\n        return result*4+remain*2",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Maximum Subarray",
      "difficulty": "MEDIUM",
      "category": "Array, Divide and Conquer, Dynamic Programming",
      "link": "https://leetcode.com/problems/maximum-subarray",
      "slug": "maximum-subarray",
      "description": "Given an integer array \nnums\n, find the \nsubarray\n with the largest sum, and return \nits sum\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-2,1,-3,4,-1,2,1,-5,4]\n\nOutput:\n 6\n\nExplanation:\n The subarray [4,-1,2,1] has the largest sum 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1]\n\nOutput:\n 1\n\nExplanation:\n The subarray [1] has the largest sum 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [5,4,-1,7,8]\n\nOutput:\n 23\n\nExplanation:\n The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n If you have figured out the \nO(n)\n solution, try coding another solution using the \ndivide and conquer\n approach, which is more subtle.",
      "solution": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, curr = float(\"-inf\"), float(\"-inf\")\n        for x in nums:\n            curr = max(curr+x, x)\n            result = max(result, curr)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Triangle Judgement",
      "difficulty": "EASY",
      "category": "Database",
      "link": "https://leetcode.com/problems/triangle-judgement",
      "slug": "triangle-judgement",
      "description": "Table: \nTriangle\n\n\n\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| x           | int  |\n| y           | int  |\n| z           | int  |\n+-------------+------+\nIn SQL, (x, y, z) is the primary key column for this table.\nEach row of this table contains the lengths of three line segments.\n\n\n\n \n\n\nReport for every three line segments whether they can form a triangle.\n\n\nReturn the result table in \nany order\n.\n\n\nThe result format is in the following example.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nTriangle table:\n+----+----+----+\n| x  | y  | z  |\n+----+----+----+\n| 13 | 15 | 30 |\n| 10 | 20 | 15 |\n+----+----+----+\n\nOutput:\n \n+----+----+----+----------+\n| x  | y  | z  | triangle |\n+----+----+----+----------+\n| 13 | 15 | 30 | No       |\n| 10 | 20 | 15 | Yes      |\n+----+----+----+----------+",
      "solution": "# Solution not found in kamyu104 repository",
      "explanation": "N/A",
      "time_complexity": "N/A",
      "space_complexity": "N/A"
    },
    {
      "title": "Min Stack",
      "difficulty": "MEDIUM",
      "category": "Stack, Design",
      "link": "https://leetcode.com/problems/min-stack",
      "slug": "min-stack",
      "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\n\nImplement the \nMinStack\n class:\n\n\n\n\nMinStack()\n initializes the stack object.\n\n\nvoid push(int val)\n pushes the element \nval\n onto the stack.\n\n\nvoid pop()\n removes the element on the top of the stack.\n\n\nint top()\n gets the top element of the stack.\n\n\nint getMin()\n retrieves the minimum element in the stack.\n\n\n\n\nYou must implement a solution with \nO(1)\n time complexity for each function.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n\nOutput\n\n[null,null,null,null,-3,null,0,-2]\n\n\nExplanation\n\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= val <= 2\n31\n - 1\n\n\nMethods \npop\n, \ntop\n and \ngetMin\n operations will always be called on \nnon-empty\n stacks.\n\n\nAt most \n3 * 10\n4\n calls will be made to \npush\n, \npop\n, \ntop\n, and \ngetMin\n.",
      "solution": "class MinStack(object):\n    def __init__(self):\n        self.min = None\n        self.stack = []\n\n    # @param x, an integer\n    # @return an integer\n    def push(self, x):\n        if not self.stack:\n            self.stack.append(0)\n            self.min = x\n        else:\n            self.stack.append(x - self.min)\n            if x < self.min:\n                self.min = x\n\n    # @return nothing\n    def pop(self):\n        x = self.stack.pop()\n        if x < 0:\n            self.min = self.min - x\n\n    # @return an integer\n    def top(self):\n        x = self.stack[-1]\n        if x > 0:\n            return x + self.min\n        else:\n            return self.min\n\n    # @return an integer\n    def getMin(self):\n        return self.min\nclass MinStack2(object):\n    def __init__(self):\n        self.stack, self.minStack = [], []\n    # @param x, an integer\n    # @return an integer\n    def push(self, x):\n        self.stack.append(x)\n        if len(self.minStack):\n            if x < self.minStack[-1][0]:\n                self.minStack.append([x, 1])\n            elif x == self.minStack[-1][0]:\n                self.minStack[-1][1] += 1\n        else:\n            self.minStack.append([x, 1])\n\n    # @return nothing\n    def pop(self):\n        x = self.stack.pop()\n        if x == self.minStack[-1][0]:\n            self.minStack[-1][1] -= 1\n            if self.minStack[-1][1] == 0:\n                self.minStack.pop()\n\n    # @return an integer\n    def top(self):\n        return self.stack[-1]\n\n    # @return an integer\n    def getMin(self):\n        return self.minStack[-1][0]\n\n# time: O(1)\n# space: O(n)\nclass MinStack3(object):\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x):\n        if self.stack:\n            current_min = min(x, self.stack[-1][0])\n            self.stack.append((current_min, x))\n        else:\n            self.stack.append((x, x))\n\n    def pop(self):\n        return self.stack.pop()[1]\n\n    def top(self):\n        return self.stack[-1][1]\n\n    def getMin(self):\n        return self.stack[-1][0]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Logger Rate Limiter",
      "difficulty": "EASY",
      "category": "Hash Table, Design, Data Stream",
      "link": "https://leetcode.com/problems/logger-rate-limiter",
      "slug": "logger-rate-limiter",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "\nimport collections\n\nclass Logger(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__dq = collections.deque()\n        self.__printed = set()\n\n    def shouldPrintMessage(self, timestamp, message):\n        \"\"\"\n        Returns true if the message should be printed in the given timestamp, otherwise returns false. The timestamp is in seconds granularity.\n        :type timestamp: int\n        :type message: str\n        :rtype: bool\n        \"\"\"\n        while self.__dq and self.__dq[0][0] <= timestamp - 10:\n            self.__printed.remove(self.__dq.popleft()[1])\n        if message in self.__printed:\n            return False\n        self.__dq.append((timestamp, message))\n        self.__printed.add(message)\n        return True",
      "explanation": "N/A",
      "time_complexity": "O(1), amortized",
      "space_complexity": "O(k), k is the max number of printed messages in last 10 seconds"
    },
    {
      "title": "Reorder List",
      "difficulty": "MEDIUM",
      "category": "Linked List, Two Pointers, Stack, Recursion",
      "link": "https://leetcode.com/problems/reorder-list",
      "slug": "reorder-list",
      "description": "You are given the head of a singly linked-list. The list can be represented as:\n\n\n\nL\n0\n → L\n1\n → … → L\nn - 1\n → L\nn\n\n\n\n\nReorder the list to be on the following form:\n\n\n\nL\n0\n → L\nn\n → L\n1\n → L\nn - 1\n → L\n2\n → L\nn - 2\n → …\n\n\n\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4]\n\nOutput:\n [1,4,2,3]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5]\n\nOutput:\n [1,5,2,4,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[1, 5 * 10\n4\n]\n.\n\n\n1 <= Node.val <= 1000",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\nclass Solution(object):\n    # @param head, a ListNode\n    # @return nothing\n    def reorderList(self, head):\n        if head == None or head.next == None:\n            return head\n\n        fast, slow, prev = head, head, None\n        while fast != None and fast.next != None:\n            fast, slow, prev = fast.next.next, slow.next, slow\n        current, prev.next, prev = slow, None, None\n\n        while current != None:\n            current.next, prev, current = prev, current, current.next\n\n        l1, l2 = head, prev\n        dummy = ListNode(0)\n        current = dummy\n\n        while l1 != None and l2 != None:\n            current.next, current, l1 = l1, l1, l1.next\n            current.next, current, l2 = l2, l2, l2.next\n\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Zero Array Transformation I",
      "difficulty": "MEDIUM",
      "category": "Array, Prefix Sum",
      "link": "https://leetcode.com/problems/zero-array-transformation-i",
      "slug": "zero-array-transformation-i",
      "description": "You are given an integer array \nnums\n of length \nn\n and a 2D array \nqueries\n, where \nqueries[i] = [l\ni\n, r\ni\n]\n.\n\n\nFor each \nqueries[i]\n:\n\n\n\n\nSelect a \nsubset\n of indices within the range \n[l\ni\n, r\ni\n]\n in \nnums\n.\n\n\nDecrement the values at the selected indices by 1.\n\n\n\n\nA \nZero Array\n is an array where all elements are equal to 0.\n\n\nReturn \ntrue\n if it is \npossible\n to transform \nnums\n into a \nZero Array \nafter processing all the queries sequentially, otherwise return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,0,1], queries = [[0,2]]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\n\n\nFor i = 0:\n\n\n\n\nSelect the subset of indices as \n[0, 2]\n and decrement the values at these indices by 1.\n\n\nThe array will become \n[0, 0, 0]\n, which is a Zero Array.\n\n\n\n\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [4,3,2,1], queries = [[1,3],[0,2]]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\n\n\nFor i = 0:\n\n\n\n\nSelect the subset of indices as \n[1, 2, 3]\n and decrement the values at these indices by 1.\n\n\nThe array will become \n[4, 2, 1, 0]\n.\n\n\n\n\n\n\nFor i = 1:\n\n\n\n\nSelect the subset of indices as \n[0, 1, 2]\n and decrement the values at these indices by 1.\n\n\nThe array will become \n[3, 1, 0, 0]\n, which is not a Zero Array.\n\n\n\n\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n0 <= nums[i] <= 10\n5\n\n\n1 <= queries.length <= 10\n5\n\n\nqueries[i].length == 2\n\n\n0 <= l\ni\n <= r\ni\n < nums.length",
      "solution": "\n# line sweepclass Solution(object):\n    def isZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        events = [0]*(len(nums)+1)\n        for l, r in queries:\n            events[l] += 1\n            events[r+1] -= 1\n        curr = 0\n        for i in xrange(len(nums)):\n            curr += events[i]\n            if nums[i] > curr:\n                return False\n        return True",
      "explanation": "N/A",
      "time_complexity": "O(n + q)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Search Insert Position",
      "difficulty": "EASY",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/search-insert-position",
      "slug": "search-insert-position",
      "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 5\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 2\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 7\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nnums\n contains \ndistinct\n values sorted in \nascending\n order.\n\n\n-10\n4\n <= target <= 10\n4",
      "solution": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if nums[mid] >= target:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return left",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Koko Eating Bananas",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/koko-eating-bananas",
      "slug": "koko-eating-bananas",
      "description": "Koko loves to eat bananas. There are \nn\n piles of bananas, the \ni\nth\n pile has \npiles[i]\n bananas. The guards have gone and will come back in \nh\n hours.\n\n\nKoko can decide her bananas-per-hour eating speed of \nk\n. Each hour, she chooses some pile of bananas and eats \nk\n bananas from that pile. If the pile has less than \nk\n bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\n\nReturn \nthe minimum integer\n \nk\n \nsuch that she can eat all the bananas within\n \nh\n \nhours\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n piles = [3,6,7,11], h = 8\n\nOutput:\n 4\n\n\n\nExample 2:\n\n\n\n\nInput:\n piles = [30,11,23,4,20], h = 5\n\nOutput:\n 30\n\n\n\nExample 3:\n\n\n\n\nInput:\n piles = [30,11,23,4,20], h = 6\n\nOutput:\n 23\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= piles.length <= 10\n4\n\n\npiles.length <= h <= 10\n9\n\n\n1 <= piles[i] <= 10\n9",
      "solution": "class Solution(object):\n    def minEatingSpeed(self, piles, H):\n        \"\"\"\n        :type piles: List[int]\n        :type H: int\n        :rtype: int\n        \"\"\"\n        def possible(piles, H, K):\n            return sum((pile-1)//K+1 for pile in piles) <= H\n\n        left, right = 1, max(piles)\n        while left <= right:\n            mid = left + (right-left)//2\n            if possible(piles, H, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left",
      "explanation": "N/A",
      "time_complexity": "O(nlogr)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Rotate Array",
      "difficulty": "MEDIUM",
      "category": "Array, Math, Two Pointers",
      "link": "https://leetcode.com/problems/rotate-array",
      "slug": "rotate-array",
      "description": "Given an integer array \nnums\n, rotate the array to the right by \nk\n steps, where \nk\n is non-negative.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,4,5,6,7], k = 3\n\nOutput:\n [5,6,7,1,2,3,4]\n\nExplanation:\n\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-1,-100,3,99], k = 2\n\nOutput:\n [3,99,-1,-100]\n\nExplanation:\n \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\n0 <= k <= 10\n5\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nTry to come up with as many solutions as you can. There are at least \nthree\n different ways to solve this problem.\n\n\nCould you do it in-place with \nO(1)\n extra space?",
      "solution": "class Solution(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    def rotate(self, nums, k):\n        def reverse(nums, start, end):\n            while start < end:\n                nums[start], nums[end - 1] = nums[end - 1], nums[start]\n                start += 1\n                end -= 1\n\n        k %= len(nums)\n        reverse(nums, 0, len(nums))\n        reverse(nums, 0, k)\n        reverse(nums, k, len(nums))\n\n\nfrom fractions import gcd\n\nclass Solution2(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n\n    def rotate(self, nums, k):\n        def apply_cycle_permutation(k, offset, cycle_len, nums):\n            tmp = nums[offset]\n            for i in xrange(1, cycle_len):\n                nums[(offset + i * k) % len(nums)], tmp = tmp, nums[(offset + i * k) % len(nums)]\n            nums[offset] = tmp\n\n        k %= len(nums)\n        num_cycles = gcd(len(nums), k)\n        cycle_len = len(nums) / num_cycles\n        for i in xrange(num_cycles):\n            apply_cycle_permutation(k, i, cycle_len, nums)\n\nclass Solution3(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n\n    def rotate(self, nums, k):\n        count = 0\n        start = 0\n        while count < len(nums):\n            curr = start\n            prev = nums[curr]\n            while True:\n                idx = (curr + k) % len(nums)\n                nums[idx], prev = prev, nums[idx]\n                curr = idx\n                count += 1\n                if start == curr:\n                    break\n            start += 1\n\nclass Solution4(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    def rotate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums[:] = nums[len(nums) - k:] + nums[:len(nums) - k]\n        \nclass Solution5(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    def rotate(self, nums, k):\n        while k > 0:\n            nums.insert(0, nums.pop())\n            k -= 1",
      "explanation": "N/A",
      "time_complexity": "O(k * n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Find All Duplicates in an Array",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table",
      "link": "https://leetcode.com/problems/find-all-duplicates-in-an-array",
      "slug": "find-all-duplicates-in-an-array",
      "description": "Given an integer array \nnums\n of length \nn\n where all the integers of \nnums\n are in the range \n[1, n]\n and each integer appears \nat most\n \ntwice\n, return \nan array of all the integers that appears \ntwice\n.\n\n\nYou must write an algorithm that runs in \nO(n)\n time and uses only \nconstant\n auxiliary space, excluding the space needed to store the output\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [4,3,2,7,8,2,3,1]\n\nOutput:\n [2,3]\n\nExample 2:\n\n\nInput:\n nums = [1,1,2]\n\nOutput:\n [1]\n\nExample 3:\n\n\nInput:\n nums = [1]\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 10\n5\n\n\n1 <= nums[i] <= n\n\n\nEach element in \nnums\n appears \nonce\n or \ntwice\n.",
      "solution": "class Solution(object):\n    def findDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i in nums:\n            if nums[abs(i)-1] < 0:\n                result.append(abs(i))\n            else:\n                nums[abs(i)-1] *= -1\n        return result\n\nclass Solution2(object):\n    def findDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        i = 0\n        while i < len(nums):\n            if nums[i] != nums[nums[i]-1]:\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\n            else:\n                i += 1\n\n        for i in xrange(len(nums)):\n            if i != nums[i]-1:\n                result.append(nums[i])\n        return result\n\n\nfrom collections import Counterclass Solution3(object):\n    def findDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return [elem for elem, count in Counter(nums).items() if count == 2]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n), this doesn't satisfy the question"
    },
    {
      "title": "Meeting Rooms II",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers, Greedy, Sorting, Heap (Priority Queue), Prefix Sum",
      "link": "https://leetcode.com/problems/meeting-rooms-ii",
      "slug": "meeting-rooms-ii",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "class Solution(object):\n    # @param {Interval[]} intervals\n    # @return {integer}\n    def minMeetingRooms(self, intervals):\n        result, curr = 0, 0\n        line = [x for i, j in intervals for x in [[i, 1], [j, -1]]]\n        line.sort()\n        for _, num in line:\n            curr += num\n            result = max(result, curr)\n        return result\n\nclass Solution2(object):\n    # @param {Interval[]} intervals\n    # @return {integer}\n    def minMeetingRooms(self, intervals):\n        starts, ends = [], []\n        for start, end in intervals:\n            starts.append(start)\n            ends.append(end)\n\n        starts.sort()\n        ends.sort()\n\n        s, e = 0, 0\n        min_rooms, cnt_rooms = 0, 0\n        while s < len(starts):\n            if starts[s] < ends[e]:\n                cnt_rooms += 1  # Acquire a room.\n                # Update the min number of rooms.\n                min_rooms = max(min_rooms, cnt_rooms)\n                s += 1\n            else:\n                cnt_rooms -= 1  # Release a room.\n                e += 1\n\n        return min_rooms\n\n\nfrom heapq import heappush, heappop\n\nclass Solution3(object):\n    def minMeetingRooms(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return 0\n        \n        intervals.sort(key=lambda x: x[0])\n        free_rooms = []\n        \n        heappush(free_rooms, intervals[0][1])\n        for interval in intervals[1:]:\n            if free_rooms[0] <= interval[0]:\n                heappop(free_rooms)\n            \n            heappush(free_rooms, interval[1])\n        \n        return len(free_rooms)",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Meeting Rooms III",
      "difficulty": "HARD",
      "category": "Array, Hash Table, Sorting, Heap (Priority Queue), Simulation",
      "link": "https://leetcode.com/problems/meeting-rooms-iii",
      "slug": "meeting-rooms-iii",
      "description": "You are given an integer \nn\n. There are \nn\n rooms numbered from \n0\n to \nn - 1\n.\n\n\nYou are given a 2D integer array \nmeetings\n where \nmeetings[i] = [start\ni\n, end\ni\n]\n means that a meeting will be held during the \nhalf-closed\n time interval \n[start\ni\n, end\ni\n)\n. All the values of \nstart\ni\n are \nunique\n.\n\n\nMeetings are allocated to rooms in the following manner:\n\n\n\n\nEach meeting will take place in the unused room with the \nlowest\n number.\n\n\nIf there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the \nsame\n duration as the original meeting.\n\n\nWhen a room becomes unused, meetings that have an earlier original \nstart\n time should be given the room.\n\n\n\n\nReturn\n the \nnumber\n of the room that held the most meetings. \nIf there are multiple rooms, return\n the room with the \nlowest\n number.\n\n\nA \nhalf-closed interval\n \n[a, b)\n is the interval between \na\n and \nb\n \nincluding\n \na\n and \nnot including\n \nb\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]\n\nOutput:\n 0\n\nExplanation:\n\n- At time 0, both rooms are not being used. The first meeting starts in room 0.\n- At time 1, only room 1 is not being used. The second meeting starts in room 1.\n- At time 2, both rooms are being used. The third meeting is delayed.\n- At time 3, both rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period [5,10).\n- At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period [10,11).\nBoth rooms 0 and 1 held 2 meetings, so we return 0. \n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\n\nOutput:\n 1\n\nExplanation:\n\n- At time 1, all three rooms are not being used. The first meeting starts in room 0.\n- At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1.\n- At time 3, only room 2 is not being used. The third meeting starts in room 2.\n- At time 4, all three rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period [5,10).\n- At time 6, all three rooms are being used. The fifth meeting is delayed.\n- At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period [10,12).\nRoom 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1. \n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100\n\n\n1 <= meetings.length <= 10\n5\n\n\nmeetings[i].length == 2\n\n\n0 <= start\ni\n < end\ni\n <= 5 * 10\n5\n\n\nAll the values of \nstart\ni\n are \nunique\n.",
      "solution": "\nimport heapq\n\n\n# one heap solutionclass Solution(object):\n    def mostBooked(self, n, meetings):\n        \"\"\"\n        :type n: int\n        :type meetings: List[List[int]]\n        :rtype: int\n        \"\"\"\n        meetings.sort()\n        min_heap = [(meetings[0][0], i) for i in xrange(n)]\n        result = [0]*n\n        for s, e in meetings:\n            while min_heap and min_heap[0][0] < s:\n                _, i = heapq.heappop(min_heap)\n                heapq.heappush(min_heap, (s, i))\n            e2, i = heapq.heappop(min_heap)\n            heapq.heappush(min_heap, (e2+(e-s), i))\n            result[i] += 1\n        return max(xrange(n), key=lambda x:result[x])\n\n\nimport heapq\n\n\n# two heaps solutionclass Solution2(object):\n    def mostBooked(self, n, meetings):\n        \"\"\"\n        :type n: int\n        :type meetings: List[List[int]]\n        :rtype: \n        \"\"\"\n        meetings.sort()\n        unused, used = range(n), []\n        result = [0]*n\n        for s, e in meetings:\n            while used and used[0][0] <= s:\n                _, i = heapq.heappop(used)\n                heapq.heappush(unused, i)\n            if unused:\n                i = heapq.heappop(unused)\n                heapq.heappush(used, (e, i))\n            else:\n                e2, i = heapq.heappop(used)\n                heapq.heappush(used, (e2+(e-s), i))\n            result[i] += 1\n        return max(xrange(n), key=lambda x:result[x])",
      "explanation": "N/A",
      "time_complexity": "O(mlogm + n + mlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Snapshot Array",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Binary Search, Design",
      "link": "https://leetcode.com/problems/snapshot-array",
      "slug": "snapshot-array",
      "description": "Implement a SnapshotArray that supports the following interface:\n\n\n\n\nSnapshotArray(int length)\n initializes an array-like data structure with the given length. \nInitially, each element equals 0\n.\n\n\nvoid set(index, val)\n sets the element at the given \nindex\n to be equal to \nval\n.\n\n\nint snap()\n takes a snapshot of the array and returns the \nsnap_id\n: the total number of times we called \nsnap()\n minus \n1\n.\n\n\nint get(index, snap_id)\n returns the value at the given \nindex\n, at the time we took the snapshot with the given \nsnap_id\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n [\"SnapshotArray\",\"set\",\"snap\",\"set\",\"get\"]\n[[3],[0,5],[],[0,6],[0,0]]\n\nOutput:\n [null,null,0,null,5]\n\nExplanation: \n\nSnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3\nsnapshotArr.set(0,5);  // Set array[0] = 5\nsnapshotArr.snap();  // Take a snapshot, return snap_id = 0\nsnapshotArr.set(0,6);\nsnapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= length <= 5 * 10\n4\n\n\n0 <= index < length\n\n\n0 <= val <= 10\n9\n\n\n0 <= snap_id < \n(the total number of times we call \nsnap()\n)\n\n\nAt most \n5 * 10\n4\n calls will be made to \nset\n, \nsnap\n, and \nget\n.",
      "solution": "#        get: O(logn), n is the total number of set\n\nimport collections\nimport bisect\n\nclass SnapshotArray(object):\n\n    def __init__(self, length):\n        \"\"\"\n        :type length: int\n        \"\"\"\n        self.__A = collections.defaultdict(lambda: [[0, 0]])\n        self.__snap_id = 0\n\n\n    def set(self, index, val):\n        \"\"\"\n        :type index: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        if self.__A[index][-1][0] == self.__snap_id:\n            self.__A[index][-1][1] = val\n        else:\n            self.__A[index].append([self.__snap_id, val])\n\n\n    def snap(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        self.__snap_id += 1\n        return self.__snap_id - 1\n\n\n    def get(self, index, snap_id):\n        \"\"\"\n        :type index: int\n        :type snap_id: int\n        :rtype: int\n        \"\"\"\n        i = bisect.bisect_left(self.__A[index], [snap_id+1, float(\"-inf\")]) - 1\n        return self.__A[index][i][1]",
      "explanation": "N/A",
      "time_complexity": "set: O(1)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Path With Maximum Minimum Value",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search, Depth-First Search, Breadth-First Search, Union Find, Heap (Priority Queue), Matrix",
      "link": "https://leetcode.com/problems/path-with-maximum-minimum-value",
      "slug": "path-with-maximum-minimum-value",
      "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
      "solution": "\n# binary search + dfs solutionclass Solution(object):\n    def maximumMinimumPath(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        def check(A, val, r, c, lookup):\n            if r == len(A)-1 and c == len(A[0])-1:\n                return True\n            lookup.add((r, c))\n            for d in directions:\n                nr, nc = r + d[0], c + d[1]\n                if 0 <= nr < len(A) and \\\n                   0 <= nc < len(A[0]) and \\\n                   (nr, nc) not in lookup and \\\n                   A[nr][nc] >= val and \\\n                   check(A, val, nr, nc, lookup):\n                    return True\n            return False\n        \n        vals, ceil = [], min(A[0][0], A[-1][-1])\n        for i in xrange(len(A)):\n            for j in xrange(len(A[0])):\n                if A[i][j] <= ceil:\n                    vals.append(A[i][j])\n        vals = list(set(vals))\n        vals.sort()\n        left, right = 0, len(vals)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(A, vals[mid], 0, 0, set()):\n                right = mid-1\n            else:\n                left = mid+1\n        return vals[right]\n\n\nimport heapq\n\n\n# Dijkstra algorithm solutionclass Solution2(object):\n    def maximumMinimumPath(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        max_heap = [(-A[0][0], 0, 0)]\n        lookup = set([(0, 0)])\n        while max_heap:\n            i, r, c = heapq.heappop(max_heap)\n            if r == len(A)-1 and c == len(A[0])-1:\n                return -i\n            for d in directions:\n                nr, nc = r+d[0], c+d[1]\n                if 0 <= nr < len(A) and \\\n                   0 <= nc < len(A[0]) and \\\n                   (nr, nc) not in lookup:\n                    heapq.heappush(max_heap, (-min(-i, A[nr][nc]), nr, nc))\n                    lookup.add((nr, nc))    \n        return -1",
      "explanation": "N/A",
      "time_complexity": "O(m * n * log(m * n))",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "Search Suggestions System",
      "difficulty": "MEDIUM",
      "category": "Array, String, Binary Search, Trie, Sorting, Heap (Priority Queue)",
      "link": "https://leetcode.com/problems/search-suggestions-system",
      "slug": "search-suggestions-system",
      "description": "You are given an array of strings \nproducts\n and a string \nsearchWord\n.\n\n\nDesign a system that suggests at most three product names from \nproducts\n after each character of \nsearchWord\n is typed. Suggested products should have common prefix with \nsearchWord\n. If there are more than three products with a common prefix return the three lexicographically minimums products.\n\n\nReturn \na list of lists of the suggested products after each character of \nsearchWord\n is typed\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n products = [\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"], searchWord = \"mouse\"\n\nOutput:\n [[\"mobile\",\"moneypot\",\"monitor\"],[\"mobile\",\"moneypot\",\"monitor\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"]]\n\nExplanation:\n products sorted lexicographically = [\"mobile\",\"moneypot\",\"monitor\",\"mouse\",\"mousepad\"].\nAfter typing m and mo all products match and we show user [\"mobile\",\"moneypot\",\"monitor\"].\nAfter typing mou, mous and mouse the system suggests [\"mouse\",\"mousepad\"].\n\n\n\nExample 2:\n\n\n\n\nInput:\n products = [\"havana\"], searchWord = \"havana\"\n\nOutput:\n [[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"]]\n\nExplanation:\n The only word \"havana\" will be always suggested while typing the search word.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= products.length <= 1000\n\n\n1 <= products[i].length <= 3000\n\n\n1 <= sum(products[i].length) <= 2 * 10\n4\n\n\nAll the strings of \nproducts\n are \nunique\n.\n\n\nproducts[i]\n consists of lowercase English letters.\n\n\n1 <= searchWord.length <= 1000\n\n\nsearchWord\n consists of lowercase English letters.",
      "solution": "#                      , l is the average length of product name\n#        suggest: O(l^2)\n\nimport collections\n\nclass TrieNode(object):\n\n    def __init__(self):\n        self.__TOP_COUNT = 3\n        self.leaves = collections.defaultdict(TrieNode)\n        self.infos = []\n\n    def insert(self, words, i):\n        curr = self\n        for c in words[i]:\n            curr = curr.leaves[c]\n            curr.add_info(words, i)\n\n    def add_info(self, words, i):\n        self.infos.append(i)\n        self.infos.sort(key=lambda x: words[x])\n        if len(self.infos) > self.__TOP_COUNT:\n            self.infos.pop()\n\nclass Solution(object):\n    def suggestedProducts(self, products, searchWord):\n        \"\"\"\n        :type products: List[str]\n        :type searchWord: str\n        :rtype: List[List[str]]\n        \"\"\"\n        trie = TrieNode()\n        for i in xrange(len(products)):\n            trie.insert(products, i)\n        result = [[] for _ in xrange(len(searchWord))]\n        for i, c in enumerate(searchWord):\n            if c not in trie.leaves:\n                break\n            trie = trie.leaves[c]\n            result[i] = map(lambda x: products[x], trie.infos)\n        return result\n\n\n#                                   , l is the average length of product name\n#        suggest: O(l^2)class TrieNode2(object):\n\n    def __init__(self):\n        self.__TOP_COUNT = 3\n        self.leaves = collections.defaultdict(TrieNode2)\n        self.infos = []\n\n    def insert(self, words, i):\n        curr = self\n        for c in words[i]:\n            curr = curr.leaves[c]\n            curr.add_info(i)\n\n    def add_info(self, i):\n        if len(self.infos) == self.__TOP_COUNT:\n            return\n        self.infos.append(i)\n\nclass Solution2(object):\n    def suggestedProducts(self, products, searchWord):\n        \"\"\"\n        :type products: List[str]\n        :type searchWord: str\n        :rtype: List[List[str]]\n        \"\"\"\n        products.sort()\n        trie = TrieNode2()\n        for i in xrange(len(products)):\n            trie.insert(products, i)\n        result = [[] for _ in xrange(len(searchWord))]\n        for i, c in enumerate(searchWord):\n            if c not in trie.leaves:\n                break\n            trie = trie.leaves[c]\n            result[i] = map(lambda x: products[x], trie.infos)\n        return result\n\n\n#                                   , l is the average length of product name\n#        suggest: O(l^2 * n)\nimport bisect\n\nclass Solution3(object):\n    def suggestedProducts(self, products, searchWord):\n        \"\"\"\n        :type products: List[str]\n        :type searchWord: str\n        :rtype: List[List[str]]\n        \"\"\"\n        products.sort()  # Time: O(n * l * log(n * l))\n        result = []\n        prefix = \"\"\n        for i, c in enumerate(searchWord):  # Time: O(l)\n            prefix += c\n            start = bisect.bisect_left(products, prefix)  # Time: O(log(n * l))\n            new_products = []\n            for j in xrange(start, len(products)):  # Time: O(n * l)\n                if not (i < len(products[j]) and products[j][i] == c):\n                    break\n                new_products.append(products[j])\n            products = new_products\n            result.append(products[:3])\n        return result",
      "explanation": "N/A",
      "time_complexity": "ctor: O(n * l * log(n * l)), n is the number of products",
      "space_complexity": "O(n * l)"
    },
    {
      "title": "Same Tree",
      "difficulty": "EASY",
      "category": "Tree, Depth-First Search, Breadth-First Search, Binary Tree",
      "link": "https://leetcode.com/problems/same-tree",
      "slug": "same-tree",
      "description": "Given the roots of two binary trees \np\n and \nq\n, write a function to check if they are the same or not.\n\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n p = [1,2,3], q = [1,2,3]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n p = [1,2], q = [1,null,2]\n\nOutput:\n false\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n p = [1,2,1], q = [1,1,2]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in both trees is in the range \n[0, 100]\n.\n\n\n-10\n4\n <= Node.val <= 10\n4",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\nclass Solution(object):\n    # @param p, a tree node\n    # @param q, a tree node\n    # @return a boolean\n    def isSameTree(self, p, q):\n        if p is None and q is None:\n            return True\n\n        if p is not None and q is not None:\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n        return False",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h), h is height of binary tree"
    },
    {
      "title": "Course Schedule",
      "difficulty": "MEDIUM",
      "category": "Depth-First Search, Breadth-First Search, Graph, Topological Sort",
      "link": "https://leetcode.com/problems/course-schedule",
      "slug": "course-schedule",
      "description": "There are a total of \nnumCourses\n courses you have to take, labeled from \n0\n to \nnumCourses - 1\n. You are given an array \nprerequisites\n where \nprerequisites[i] = [a\ni\n, b\ni\n]\n indicates that you \nmust\n take course \nb\ni\n first if you want to take course \na\ni\n.\n\n\n\n\nFor example, the pair \n[0, 1]\n, indicates that to take course \n0\n you have to first take course \n1\n.\n\n\n\n\nReturn \ntrue\n if you can finish all courses. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [[1,0]]\n\nOutput:\n true\n\nExplanation:\n There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\n\n\nExample 2:\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [[1,0],[0,1]]\n\nOutput:\n false\n\nExplanation:\n There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numCourses <= 2000\n\n\n0 <= prerequisites.length <= 5000\n\n\nprerequisites[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < numCourses\n\n\nAll the pairs prerequisites[i] are \nunique\n.",
      "solution": "\nimport collections\n\n\n# Khan's algorithm (bfs solution)class Solution(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        q = [u for u in xrange(numCourses) if u not in in_degree]\n        while q:\n            new_q = []\n            for u in q:\n                result.append(u)\n                for v in adj[u]:\n                    in_degree[v] -= 1\n                    if in_degree[v] == 0:\n                        new_q.append(v)\n            q = new_q\n        return len(result) == numCourses\n\n\nimport collections\n\n\n# dfs solutionclass Solution2(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        stk = [u for u in xrange(numCourses) if u not in in_degree]\n        while stk:\n            u = stk.pop()\n            result.append(u)\n            for v in adj[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    stk.append(v)\n        return len(result) == numCourses",
      "explanation": "N/A",
      "time_complexity": "O(|V| + |E|)",
      "space_complexity": "O(|E|)"
    },
    {
      "title": "Reverse Integer",
      "difficulty": "MEDIUM",
      "category": "Math",
      "link": "https://leetcode.com/problems/reverse-integer",
      "slug": "reverse-integer",
      "description": "Given a signed 32-bit integer \nx\n, return \nx\n with its digits reversed\n. If reversing \nx\n causes the value to go outside the signed 32-bit integer range \n[-2\n31\n, 2\n31\n - 1]\n, then return \n0\n.\n\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 123\n\nOutput:\n 321\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = -123\n\nOutput:\n -321\n\n\n\nExample 3:\n\n\n\n\nInput:\n x = 120\n\nOutput:\n 21\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= x <= 2\n31\n - 1",
      "solution": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 0:\n            return -self.reverse(-x)\n\n        result = 0\n        while x:\n            result = result * 10 + x % 10\n            x //= 10\n        return result if result <= 0x7fffffff else 0  # Handle overflow.\n\n    def reverse2(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 0:\n            x = int(str(x)[::-1][-1] + str(x)[::-1][:-1])\n        else:\n            x = int(str(x)[::-1])\n        x = 0 if abs(x) > 0x7FFFFFFF else x\n        return x\n\n    def reverse3(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        s = cmp(x, 0)\n        r = int(repr(s * x)[::-1])\n        return s * r * (r < 2 ** 31)",
      "explanation": "N/A",
      "time_complexity": "O(logn) = O(1)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Number of Provinces",
      "difficulty": "MEDIUM",
      "category": "Depth-First Search, Breadth-First Search, Union Find, Graph",
      "link": "https://leetcode.com/problems/number-of-provinces",
      "slug": "number-of-provinces",
      "description": "There are \nn\n cities. Some of them are connected, while some are not. If city \na\n is connected directly with city \nb\n, and city \nb\n is connected directly with city \nc\n, then city \na\n is connected indirectly with city \nc\n.\n\n\nA \nprovince\n is a group of directly or indirectly connected cities and no other cities outside of the group.\n\n\nYou are given an \nn x n\n matrix \nisConnected\n where \nisConnected[i][j] = 1\n if the \ni\nth\n city and the \nj\nth\n city are directly connected, and \nisConnected[i][j] = 0\n otherwise.\n\n\nReturn \nthe total number of \nprovinces\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 200\n\n\nn == isConnected.length\n\n\nn == isConnected[i].length\n\n\nisConnected[i][j]\n is \n1\n or \n0\n.\n\n\nisConnected[i][i] == 1\n\n\nisConnected[i][j] == isConnected[j][i]",
      "solution": "# Solution not found in kamyu104 repository",
      "explanation": "N/A",
      "time_complexity": "N/A",
      "space_complexity": "N/A"
    },
    {
      "title": "Painting a Grid With Three Different Colors",
      "difficulty": "HARD",
      "category": "Dynamic Programming",
      "link": "https://leetcode.com/problems/painting-a-grid-with-three-different-colors",
      "slug": "painting-a-grid-with-three-different-colors",
      "description": "You are given two integers \nm\n and \nn\n. Consider an \nm x n\n grid where each cell is initially white. You can paint each cell \nred\n, \ngreen\n, or \nblue\n. All cells \nmust\n be painted.\n\n\nReturn\n the number of ways to color the grid with \nno two adjacent cells having the same color\n. Since the answer can be very large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 1, n = 1\n\nOutput:\n 3\n\nExplanation:\n The three possible colorings are shown in the image above.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n m = 1, n = 2\n\nOutput:\n 6\n\nExplanation:\n The six possible colorings are shown in the image above.\n\n\n\nExample 3:\n\n\n\n\nInput:\n m = 5, n = 5\n\nOutput:\n 580986\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m <= 5\n\n\n1 <= n <= 1000",
      "solution": "\nimport collections\nimport itertools\n\n\n# better complexity for small m, super large n\n# matrix exponentiation solutionclass Solution(object):\n    def colorTheGrid(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def backtracking(mask1, mask2, basis, result):  # Time: O(2^m), Space: O(2^m)\n            if not basis:\n                result.append(mask2)\n                return\n            for i in xrange(3):\n                if (mask1 == -1 or mask1//basis%3 != i) and (mask2 == -1 or mask2//(basis*3)%3 != i):\n                    backtracking(mask1, mask2+i*basis if mask2 != -1 else i*basis, basis//3, result)\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A]\n \n        def matrix_expo(A, K):\n            result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def normalize(basis, mask):\n            norm = {}\n            result = 0\n            while basis:\n                x = mask//basis%3\n                if x not in norm:\n                    norm[x] = len(norm)\n                result += norm[x]*basis\n                basis //= 3\n            return result\n\n        if m > n:\n            m, n = n, m\n        basis = 3**(m-1)\n        masks = []\n        backtracking(-1, -1, basis, masks)  # Time: O(2^m), Space: O(2^m)\n        assert(len(masks) == 3 * 2**(m-1))\n        lookup = {mask:normalize(basis, mask) for mask in masks}  # Time: O(m * 2^m)\n        normalized_mask_cnt = collections.Counter(lookup[mask] for mask in masks)\n        assert(len(normalized_mask_cnt) == 3*2**(m-1) // 3 // (2 if m >= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance\n        adj = collections.defaultdict(list)\n        for mask in normalized_mask_cnt.iterkeys():  # O(3^m) leaves which are all in depth m => Time: O(3^m), Space: O(3^m)\n            backtracking(mask, -1, basis, adj[mask])\n        normalized_adj = collections.defaultdict(lambda:collections.defaultdict(int))\n        for mask1, masks2 in adj.iteritems():\n            for mask2 in masks2:\n                normalized_adj[mask1][lookup[mask2]] = (normalized_adj[mask1][lookup[mask2]]+1)%MOD\n        # divided by 3 * 2 is since the first two colors in upper row are normalized to speed up performance,\n        # since first two colors in lower row which has at most 3 choices could be also normalized, lower bound is upper bound divided by at most 3\n        assert(2*3**m // 3 // 2 // 3 <= sum(len(v) for v in normalized_adj.itervalues()) <= 2*3**m // 3 // 2)\n        return reduce(lambda x,y: (x+y)%MOD,\n                      matrix_mult([normalized_mask_cnt.values()],\n                                   matrix_expo([[normalized_adj[mask1][mask2]\n                                                 for mask2 in normalized_mask_cnt.iterkeys()] \n                                                 for mask1 in normalized_mask_cnt.iterkeys()], n-1))[0],\n                      0)  # Time: O((2^m)^3 * logn), Space: O((2^m)^2)\n\n\nimport collections\n\n\n# better complexity for small m, large nclass Solution2(object):\n    def colorTheGrid(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def find_masks(m, basis):  # Time: 3 + 3*2 + 3*2*2 + ... + 3*2^(m-1) = 3 * (2^m - 1) = O(2^m), Space: O(2^m)\n            masks = [0]\n            for c in xrange(m):\n                new_masks = []\n                for mask in masks:\n                    choices = {0, 1, 2}\n                    if c > 0:\n                        choices.discard(mask//basis)  # get left grid\n                    for x in choices:\n                        new_masks.append((x*basis)+(mask//3))  # encoding mask\n                masks = new_masks\n            return masks\n\n        def find_adj(m, basis, dp):\n            #        3*2^(m-1) * (1+2*((3/2)^(m-1)-1)/((3/2)-1)) =\n            #        3*2^(m-1) * (1+4*((3/2)^(m-1)-1)) =\n            #        3*2^(m-1) * (4*(3/2)^(m-1)-3) =\n            #        4*3^m-9*2^(m-1) =\n            #        O(3^m),\n            adj = collections.defaultdict(list)\n            for mask in dp.iterkeys():  # O(2^m)\n                adj[mask].append(mask)\n            for c in xrange(m):\n                assert(sum(len(v) for v in adj.itervalues()) == (3**c * 2**(m-(c-1)) if c >= 1 else 3 * 2**(m-1)) // 3 // (2 if m >= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance\n                new_adj = collections.defaultdict(list)\n                for mask1, mask2s in adj.iteritems():\n                    for mask in mask2s:\n                        choices = {0, 1, 2}\n                        choices.discard(mask%3)  # get up grid\n                        if c > 0:\n                            choices.discard(mask//basis)  # get left grid\n                        for x in choices:\n                            new_adj[mask1].append((x*basis)+(mask//3))  # encoding mask\n                adj = new_adj\n            assert(sum(3**c * 2**(m-(c-1)) if c >= 1 else 3 * 2**(m-1) for c in xrange(m)) == 4*3**m-9*2**(m-1))\n            return adj\n \n        def normalize(basis, mask):\n            norm = {}\n            result = 0\n            while basis:\n                x = mask//basis%3\n                if x not in norm:\n                    norm[x] = len(norm)\n                result += norm[x]*basis\n                basis //= 3\n            return result\n\n        if m > n:\n            m, n = n, m\n        basis = 3**(m-1)\n        masks = find_masks(m, basis)  # alternative of backtracking, Time: O(2^m), Space: O(2^m)\n        assert(len(masks) == 3 * 2**(m-1))\n        lookup = {mask:normalize(basis, mask) for mask in masks}  # Time: O(m * 2^m)\n        dp = collections.Counter(lookup[mask] for mask in masks)  # normalize colors to speed up performance\n        adj = find_adj(m, basis, dp)  # alternative of backtracking, Time: O(3^m), Space: O(3^m)\n        # proof:\n        #   'o' uses the same color with its bottom-left one, \n        #   'x' uses the remaining color different from its left one and bottom-left one,\n        #   k is the cnt of 'o', \n        #     [3, 1(o), 1(x), 1(o), ..., 1(o), 1(x)] => nCr(m-1, k) * 3 * 2 * 2^k for k in xrange(m) = 3 * 2 * (2+1)^(m-1) = 2*3^m combinations\n        #     [2,    2,    1,    2, ...,  2,      1]\n        # another proof:\n        #   given previous pair of colors, each pair of '?' has 3 choices of colors\n        #     [3, ?, ?, ..., ?] => 3 * 2 * 3^(m-1) = 2*3^m combinations\n        #         |  |       |\n        #         3  3       3\n        #         |  |       |\n        #     [2, ?, ?, ..., ?]\n        normalized_adj = collections.defaultdict(lambda:collections.defaultdict(int))\n        for mask1, mask2s in adj.iteritems():\n            for mask2 in mask2s:\n                normalized_adj[lookup[mask1]][lookup[mask2]] = (normalized_adj[lookup[mask1]][lookup[mask2]]+1)%MOD\n        # divided by 3 * 2 is since the first two colors in upper row are normalized to speed up performance,\n        # since first two colors in lower row which has at most 3 choices could be also normalized, lower bound is upper bound divided by at most 3\n        assert(2*3**m // 3 // 2 // 3 <= sum(len(v) for v in normalized_adj.itervalues()) <= 2*3**m // 3 // 2)\n        for _ in xrange(n-1):  # Time: O(n * 3^m), Space: O(2^m)\n            assert(len(dp) == 3*2**(m-1) // 3 // (2 if m >= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance\n            new_dp = collections.Counter()\n            for mask, v in dp.iteritems():\n                for new_mask, cnt in normalized_adj[mask].iteritems():\n                    new_dp[lookup[new_mask]] = (new_dp[lookup[new_mask]] + v*cnt) % MOD\n            dp = new_dp\n        return reduce(lambda x,y: (x+y)%MOD, dp.itervalues(), 0)  # Time: O(2^m)\n\n\nimport collections\n\n\n# better complexity for large m, large nclass Solution3(object):\n    def colorTheGrid(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def normalize(basis, mask, lookup):  # compute and cache, at most O(3*2^(m-3)) time and space\n            if mask not in lookup[basis]:\n                norm = {}\n                result, b = 0, basis\n                while b:\n                    x = mask//b%3\n                    if x not in norm:\n                        norm[x] = len(norm)\n                    result += norm[x]*b\n                    b //= 3\n                lookup[basis][mask] = result\n            return lookup[basis][mask]\n\n        if m > n:\n            m, n = n, m\n        basis = b = 3**(m-1)\n        lookup = collections.defaultdict(dict)\n        dp = collections.Counter({0: 1})\n        for idx in xrange(m*n):\n            r, c = divmod(idx, m)\n            # sliding window with size m doesn't cross rows:\n            #   [3, 2, ..., 2] => 3*2^(m-1) combinations\n            assert(r != 0 or c != 0 or len(dp) == 1)\n            assert(r != 0 or c == 0 or len(dp) == 3*2**(c-1) // 3 // (2 if c >= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance\n            assert(r == 0 or c != 0 or len(dp) == 3*2**(m-1) // 3 // (2 if m >= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance\n            # sliding window with size m crosses rows:\n            #   [*, ..., *, *, 3, 2, ..., 2] => 3*3 * 2^(m-2) combinations\n            #   [2, ..., 2, 3, *, *, ..., *]\n            assert(r == 0 or c == 0 or len(dp) == (1 if m == 1 else 2 if m == 2 else 3*3 * 2**(m-2) // 3 // 2))  # divided by 3 * 2 for m >= 3 is since the first two colors of window are normalized to speed up performance\n            new_dp = collections.Counter()\n            for mask, v in dp.iteritems():\n                choices = {0, 1, 2}\n                if r > 0:\n                    choices.discard(mask%3)  # get up grid\n                if c > 0:\n                    choices.discard(mask//basis)  # get left grid\n                for x in choices:\n                    new_mask = normalize(basis//b, ((x*basis)+(mask//3))//b, lookup)*b  # encoding mask\n                    new_dp[new_mask] = (new_dp[new_mask]+v)%MOD\n            if b > 1:\n                b //= 3\n            dp = new_dp\n        return reduce(lambda x,y: (x+y)%MOD, dp.itervalues(), 0)  # Time: O(2^m)",
      "explanation": "N/A",
      "time_complexity": "(m * n grids) * (O(3*3*2^(m-2)) possible states per grid) = O(n * m * 2^m)",
      "space_complexity": "O(3*3*2^(m-2)) = O(2^m)"
    },
    {
      "title": "Merge k Sorted Lists",
      "difficulty": "HARD",
      "category": "Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort",
      "link": "https://leetcode.com/problems/merge-k-sorted-lists",
      "slug": "merge-k-sorted-lists",
      "description": "You are given an array of \nk\n linked-lists \nlists\n, each linked-list is sorted in ascending order.\n\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n lists = [[1,4,5],[1,3,4],[2,6]]\n\nOutput:\n [1,1,2,3,4,4,5,6]\n\nExplanation:\n The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted linked list:\n1->1->2->3->4->4->5->6\n\n\n\nExample 2:\n\n\n\n\nInput:\n lists = []\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n lists = [[]]\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nk == lists.length\n\n\n0 <= k <= 10\n4\n\n\n0 <= lists[i].length <= 500\n\n\n-10\n4\n <= lists[i][j] <= 10\n4\n\n\nlists[i]\n is sorted in \nascending order\n.\n\n\nThe sum of \nlists[i].length\n will not exceed \n10\n4\n.",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\t\t\n        if self:\t\t\n            return \"{} -> {}\".format(self.val, self.next)\n\n\n# Merge two by two solution.class Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        if not lists:\n            return None\n        left, right = 0, len(lists) - 1\n        while right > 0:\n            lists[left] = mergeTwoLists(lists[left], lists[right])\n            left += 1\n            right -= 1\n            if left >= right:\n                left = 0\n        return lists[0]\n\n\n# Divide and Conquer solution.class Solution2(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        def mergeKListsHelper(lists, begin, end):\n            if begin > end:\n                return None\n            if begin == end:\n                return lists[begin]\n            return mergeTwoLists(mergeKListsHelper(lists, begin, (begin + end) / 2), \\\n                                 mergeKListsHelper(lists, (begin + end) / 2 + 1, end))\n\n        return mergeKListsHelper(lists, 0, len(lists) - 1)\n\n\n# Heap solution.\nimport heapqclass Solution3(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        dummy = ListNode(0)\n        current = dummy\n\n        heap = []\n        for sorted_list in lists:\n            if sorted_list:\n                heapq.heappush(heap, (sorted_list.val, sorted_list))\n\n        while heap:\n            smallest = heapq.heappop(heap)[1]\n            current.next = smallest\n            current = current.next\n            if smallest.next:\n                heapq.heappush(heap, (smallest.next.val, smallest.next))\n\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(nlogk)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Reverse Nodes in k-Group",
      "difficulty": "HARD",
      "category": "Linked List, Recursion",
      "link": "https://leetcode.com/problems/reverse-nodes-in-k-group",
      "slug": "reverse-nodes-in-k-group",
      "description": "Given the \nhead\n of a linked list, reverse the nodes of the list \nk\n at a time, and return \nthe modified list\n.\n\n\nk\n is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of \nk\n then left-out nodes, in the end, should remain as it is.\n\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 2\n\nOutput:\n [2,1,4,3,5]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 3\n\nOutput:\n [3,2,1,4,5]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is \nn\n.\n\n\n1 <= k <= n <= 5000\n\n\n0 <= Node.val <= 1000\n\n\n\n\n \n\n\nFollow-up:\n Can you solve the problem in \nO(1)\n extra memory space?",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\nclass Solution(object):\n    # @param head, a ListNode\n    # @param k, an integer\n    # @return a ListNode\n    def reverseKGroup(self, head, k):\n        dummy = ListNode(-1)\n        dummy.next = head\n\n        cur, cur_dummy = head, dummy\n        length = 0\n\n        while cur:\n            next_cur = cur.next\n            length = (length + 1) % k\n\n            if length == 0:\n                next_dummy = cur_dummy.next\n                self.reverse(cur_dummy, cur.next)\n                cur_dummy = next_dummy\n\n            cur = next_cur\n\n        return dummy.next\n\n    def reverse(self, begin, end):\n            first = begin.next\n            cur = first.next\n\n            while cur != end:\n                first.next = cur.next\n                cur.next = begin.next\n                begin.next = cur\n                cur = first.next",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Separate Squares I",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search",
      "link": "https://leetcode.com/problems/separate-squares-i",
      "slug": "separate-squares-i",
      "description": "You are given a 2D integer array \nsquares\n. Each \nsquares[i] = [x\ni\n, y\ni\n, l\ni\n]\n represents the coordinates of the bottom-left point and the side length of a square parallel to the x-axis.\n\n\nFind the \nminimum\n y-coordinate value of a horizontal line such that the total area of the squares above the line \nequals\n the total area of the squares below the line.\n\n\nAnswers within \n10\n-5\n of the actual answer will be accepted.\n\n\nNote\n: Squares \nmay\n overlap. Overlapping areas should be counted \nmultiple times\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nsquares = [[0,0,1],[2,2,1]]\n\n\nOutput:\n \n1.00000\n\n\nExplanation:\n\n\n\n\nAny horizontal line between \ny = 1\n and \ny = 2\n will have 1 square unit above it and 1 square unit below it. The lowest option is 1.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nsquares = [[0,0,2],[1,1,1]]\n\n\nOutput:\n \n1.16667\n\n\nExplanation:\n\n\n\n\nThe areas are:\n\n\n\n\nBelow the line: \n7/6 * 2 (Red) + 1/6 (Blue) = 15/6 = 2.5\n.\n\n\nAbove the line: \n5/6 * 2 (Red) + 5/6 (Blue) = 15/6 = 2.5\n.\n\n\n\n\nSince the areas above and below the line are equal, the output is \n7/6 = 1.16667\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= squares.length <= 5 * 10\n4\n\n\nsquares[i] = [x\ni\n, y\ni\n, l\ni\n]\n\n\nsquares[i].length == 3\n\n\n0 <= x\ni\n, y\ni\n <= 10\n9\n\n\n1 <= l\ni\n <= 10\n9\n\n\nThe total area of all the squares will not exceed \n10\n12\n.",
      "solution": "\n# sort, line sweepclass Solution(object):\n    def separateSquares(self, squares):\n        \"\"\"\n        :type squares: List[List[int]]\n        :rtype: float\n        \"\"\"\n        events = []\n        for x, y, l in squares:\n            events.append((y, 1, l))\n            events.append((y+l, -1, l))\n        events.sort(key=lambda e: e[0])\n        total = curr = 0.0\n        prev = events[0][0]\n        for y, v, l in events:\n            if y != prev:\n                total += (y-prev)*curr\n                prev = y\n            curr += l*v\n        expect = total/2.0\n        total = curr = 0.0\n        prev = events[0][0]\n        for y, v, l in events:\n            if y != prev:\n                if total+(y-prev)*curr >= expect:\n                    break\n                total += (y-prev)*curr\n                prev = y\n            curr += l*v\n        return prev+(expect-total)/curr\n\n\n# binary searchclass Solution2(object):\n    def separateSquares(self, squares):\n        \"\"\"\n        :type squares: List[List[int]]\n        :rtype: float\n        \"\"\"\n        EPS = 1e-5\n        def binary_search(left, right, check):\n            while right-left > EPS:\n                mid = left+(right-left)/2.0\n                if check(mid):\n                    right = mid\n                else:\n                    left = mid\n            return left\n    \n        def check(k):\n            result = 0\n            for x, y, l in squares:\n                if y >= k:\n                    result += l**2\n                elif y+l <= k:\n                    result -= l**2\n                else:\n                    result += l*(((y+l)-k)-(k-y))\n            return result <= 0\n    \n        return binary_search(min(y for _, y, _ in squares), max(y+l for _, y, l in squares), check)",
      "explanation": "N/A",
      "time_complexity": "O(nlogr)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Daily Temperatures",
      "difficulty": "MEDIUM",
      "category": "Array, Stack, Monotonic Stack",
      "link": "https://leetcode.com/problems/daily-temperatures",
      "slug": "daily-temperatures",
      "description": "Given an array of integers \ntemperatures\n represents the daily temperatures, return \nan array\n \nanswer\n \nsuch that\n \nanswer[i]\n \nis the number of days you have to wait after the\n \ni\nth\n \nday to get a warmer temperature\n. If there is no future day for which this is possible, keep \nanswer[i] == 0\n instead.\n\n\n \n\n\nExample 1:\n\n\nInput:\n temperatures = [73,74,75,71,69,72,76,73]\n\nOutput:\n [1,1,4,2,1,1,0,0]\n\nExample 2:\n\n\nInput:\n temperatures = [30,40,50,60]\n\nOutput:\n [1,1,1,0]\n\nExample 3:\n\n\nInput:\n temperatures = [30,60,90]\n\nOutput:\n [1,1,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= temperatures.length <= 10\n5\n\n\n30 <= temperatures[i] <= 100",
      "solution": "class Solution(object):\n    def dailyTemperatures(self, temperatures):\n        \"\"\"\n        :type temperatures: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0] * len(temperatures)\n        stk = []\n        for i in xrange(len(temperatures)):\n            while stk and \\\n                  temperatures[stk[-1]] < temperatures[i]:\n                idx = stk.pop()\n                result[idx] = i-idx\n            stk.append(i)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    }
  ],
  "Bloomberg": [
    {
      "title": "Two Sum",
      "difficulty": "EASY",
      "category": "Array, Hash Table",
      "link": "https://leetcode.com/problems/two-sum",
      "slug": "two-sum",
      "description": "Given an array of integers \nnums\n and an integer \ntarget\n, return \nindices of the two numbers such that they add up to \ntarget\n.\n\n\nYou may assume that each input would have \nexactly\n one solution\n, and you may not use the \nsame\n element twice.\n\n\nYou can return the answer in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,7,11,15], target = 9\n\nOutput:\n [0,1]\n\nExplanation:\n Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,4], target = 6\n\nOutput:\n [1,2]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,3], target = 6\n\nOutput:\n [0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n-10\n9\n <= target <= 10\n9\n\n\nOnly one valid answer exists.\n\n\n\n\n \n\n\nFollow-up: \nCan you come up with an algorithm that is less than \nO(n\n2\n)\n \ntime complexity?",
      "solution": "from typing import List\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n\n        for idx in range(len(nums)):\n            val = target - nums[idx]\n            if val in seen:\n                return [idx, seen[val]]\n            else:\n                seen[nums[idx]] = idx",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Longest Substring Without Repeating Characters",
      "difficulty": "MEDIUM",
      "category": "Hash Table, String, Sliding Window",
      "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters",
      "slug": "longest-substring-without-repeating-characters",
      "description": "Given a string \ns\n, find the length of the \nlongest\n \nsubstring\n without duplicate characters.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abcabcbb\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"abc\", with the length of 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"bbbbb\"\n\nOutput:\n 1\n\nExplanation:\n The answer is \"b\", with the length of 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"pwwkew\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 5 * 10\n4\n\n\ns\n consists of English letters, digits, symbols and spaces.",
      "solution": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, left = 0, 0\n        lookup = {}\n        for right in xrange(len(s)):\n            if s[right] in lookup:\n                left = max(left, lookup[s[right]]+1)\n            lookup[s[right]] = right\n            result = max(result, right-left+1)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Container With Most Water",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers, Greedy",
      "link": "https://leetcode.com/problems/container-with-most-water",
      "slug": "container-with-most-water",
      "description": "You are given an integer array \nheight\n of length \nn\n. There are \nn\n vertical lines drawn such that the two endpoints of the \ni\nth\n line are \n(i, 0)\n and \n(i, height[i])\n.\n\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\n\nReturn \nthe maximum amount of water a container can store\n.\n\n\nNotice\n that you may not slant the container.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [1,8,6,2,5,4,8,3,7]\n\nOutput:\n 49\n\nExplanation:\n The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [1,1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= height[i] <= 10\n4",
      "solution": "class Solution(object):\n    # @return an integer\n    def maxArea(self, height):\n        max_area, i, j = 0, 0, len(height) - 1\n        while i < j:\n            max_area = max(max_area, min(height[i], height[j]) * (j - i))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return max_area",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Decode String",
      "difficulty": "MEDIUM",
      "category": "String, Stack, Recursion",
      "link": "https://leetcode.com/problems/decode-string",
      "slug": "decode-string",
      "description": "Given an encoded string, return its decoded string.\n\n\nThe encoding rule is: \nk[encoded_string]\n, where the \nencoded_string\n inside the square brackets is being repeated exactly \nk\n times. Note that \nk\n is guaranteed to be a positive integer.\n\n\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, \nk\n. For example, there will not be input like \n3a\n or \n2[4]\n.\n\n\nThe test cases are generated so that the length of the output will never exceed \n10\n5\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"3[a]2[bc]\"\n\nOutput:\n \"aaabcbc\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"3[a2[c]]\"\n\nOutput:\n \"accaccacc\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"2[abc]3[cd]ef\"\n\nOutput:\n \"abcabccdcdcdef\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 30\n\n\ns\n consists of lowercase English letters, digits, and square brackets \n'[]'\n.\n\n\ns\n is guaranteed to be \na valid\n input.\n\n\nAll the integers in \ns\n are in the range \n[1, 300]\n.",
      "solution": "class Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n, curr, nums, strs = 0, [], [], []\n        for c in s:\n            if c.isdigit():\n                n = n*10 + ord(c)-ord('0')\n            elif c.isalpha():\n                curr.append(c)\n            elif c == '[':\n                nums.append(n)\n                strs.append(curr)\n                n, curr = 0, []\n            elif c == ']':\n                strs[-1].extend(curr*nums.pop())\n                curr = strs.pop()\n        return \"\".join(curr)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Valid Anagram",
      "difficulty": "EASY",
      "category": "Hash Table, String, Sorting",
      "link": "https://leetcode.com/problems/valid-anagram",
      "slug": "valid-anagram",
      "description": "Given two strings \ns\n and \nt\n, return \ntrue\n if \nt\n is an \nanagram\n of \ns\n, and \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"anagram\", t = \"nagaram\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"rat\", t = \"car\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length, t.length <= 5 * 10\n4\n\n\ns\n and \nt\n consist of lowercase English letters.\n\n\n\n\n \n\n\nFollow up:\n What if the inputs contain Unicode characters? How would you adapt your solution to such a case?",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s) != len(t):\n            return False\n        count = collections.defaultdict(int)\n        for c in s:\n            count[c] += 1\n        for c in t:\n            count[c] -= 1\n            if count[c] < 0:\n                return False\n        return True\n\nclass Solution2(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        return collections.Counter(s) == collections.Counter(t)\n\nclass Solution3(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        return sorted(s) == sorted(t)",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Contains Duplicate",
      "difficulty": "EASY",
      "category": "Array, Hash Table, Sorting",
      "link": "https://leetcode.com/problems/contains-duplicate",
      "slug": "contains-duplicate",
      "description": "Given an integer array \nnums\n, return \ntrue\n if any value appears \nat least twice\n in the array, and return \nfalse\n if every element is distinct.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,3,1]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThe element 1 occurs at the indices 0 and 3.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,2,3,4]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nAll elements are distinct.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,1,1,3,3,4,3,2,4,2]\n\n\nOutput:\n \ntrue\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9",
      "solution": "class Solution(object):\n    # @param {integer[]} nums\n    # @return {boolean}\n    def containsDuplicate(self, nums):\n        return len(nums) > len(set(nums))",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Flatten a Multilevel Doubly Linked List",
      "difficulty": "MEDIUM",
      "category": "Linked List, Depth-First Search, Doubly-Linked List",
      "link": "https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list",
      "slug": "flatten-a-multilevel-doubly-linked-list",
      "description": "You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional \nchild pointer\n. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a \nmultilevel data structure\n as shown in the example below.\n\n\nGiven the \nhead\n of the first level of the list, \nflatten\n the list so that all the nodes appear in a single-level, doubly linked list. Let \ncurr\n be a node with a child list. The nodes in the child list should appear \nafter\n \ncurr\n and \nbefore\n \ncurr.next\n in the flattened list.\n\n\nReturn \nthe \nhead\n of the flattened list. The nodes in the list must have \nall\n of their child pointers set to \nnull\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n\nOutput:\n [1,2,3,7,8,11,12,9,10,4,5,6]\n\nExplanation:\n The multilevel linked list in the input is shown.\nAfter flattening the multilevel linked list it becomes:\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,null,3]\n\nOutput:\n [1,3,2]\n\nExplanation:\n The multilevel linked list in the input is shown.\nAfter flattening the multilevel linked list it becomes:\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = []\n\nOutput:\n []\n\nExplanation:\n There could be empty list in the input.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of Nodes will not exceed \n1000\n.\n\n\n1 <= Node.val <= 10\n5\n\n\n\n\n \n\n\nHow the multilevel linked list is represented in test cases:\n\n\nWe use the multilevel linked list from \nExample 1\n above:\n\n\n\n 1---2---3---4---5---6--NULL\n         |\n         7---8---9---10--NULL\n             |\n             11--12--NULL\n\n\nThe serialization of each level is as follows:\n\n\n\n[1,2,3,4,5,6,null]\n[7,8,9,10,null]\n[11,12,null]\n\n\n\nTo serialize all levels together, we will add nulls in each level to signify no node connects to the upper node of the previous level. The serialization becomes:\n\n\n\n[1,    2,    3, 4, 5, 6, null]\n             |\n[null, null, 7,    8, 9, 10, null]\n                   |\n[            null, 11, 12, null]\n\n\n\nMerging the serialization of each level and removing trailing nulls we obtain:\n\n\n\n[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]",
      "solution": "class Node(object):\n    def __init__(self, val, prev, next, child):\n        self.val = val\n        self.prev = prev\n        self.next = next\n        self.child = child\n\nclass Solution(object):\n    def flatten(self, head):\n        \"\"\"\n        :type head: Node\n        :rtype: Node\n        \"\"\"\n        curr = head\n        while curr:\n            if curr.child:\n                curr_next = curr.next\n                curr.child.prev = curr\n                curr.next = curr.child\n                last_child = curr\n                while last_child.next:\n                    last_child = last_child.next\n                if curr_next:\n                    last_child.next = curr_next\n                    curr_next.prev = last_child\n                curr.child = None\n            curr = curr.next\n        return head",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Word Search",
      "difficulty": "MEDIUM",
      "category": "Array, String, Backtracking, Depth-First Search, Matrix",
      "link": "https://leetcode.com/problems/word-search",
      "slug": "word-search",
      "description": "Given an \nm x n\n grid of characters \nboard\n and a string \nword\n, return \ntrue\n \nif\n \nword\n \nexists in the grid\n.\n\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == board.length\n\n\nn = board[i].length\n\n\n1 <= m, n <= 6\n\n\n1 <= word.length <= 15\n\n\nboard\n and \nword\n consists of only lowercase and uppercase English letters.\n\n\n\n\n \n\n\nFollow up:\n Could you use search pruning to make your solution faster with a larger \nboard\n?",
      "solution": "class Solution(object):\n    # @param board, a list of lists of 1 length string\n    # @param word, a string\n    # @return a boolean\n    def exist(self, board, word):\n        visited = [[False for j in xrange(len(board[0]))] for i in xrange(len(board))]\n\n        for i in xrange(len(board)):\n            for j in xrange(len(board[0])):\n                if self.existRecu(board, word, 0, i, j, visited):\n                    return True\n\n        return False\n\n    def existRecu(self, board, word, cur, i, j, visited):\n        if cur == len(word):\n            return True\n\n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[cur]:\n            return False\n\n        visited[i][j] = True\n        result = self.existRecu(board, word, cur + 1, i + 1, j, visited) or\\\n                 self.existRecu(board, word, cur + 1, i - 1, j, visited) or\\\n                 self.existRecu(board, word, cur + 1, i, j + 1, visited) or\\\n                 self.existRecu(board, word, cur + 1, i, j - 1, visited)\n        visited[i][j] = False\n\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(m * n * 4 * 3^(l - 1)) ~= O(m * n * 3^l), l is the length of the word",
      "space_complexity": "O(l)"
    },
    {
      "title": "Rotate Image",
      "difficulty": "MEDIUM",
      "category": "Array, Math, Matrix",
      "link": "https://leetcode.com/problems/rotate-image",
      "slug": "rotate-image",
      "description": "You are given an \nn x n\n 2D \nmatrix\n representing an image, rotate the image by \n90\n degrees (clockwise).\n\n\nYou have to rotate the image \nin-place\n, which means you have to modify the input 2D matrix directly. \nDO NOT\n allocate another 2D matrix and do the rotation.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [[7,4,1],[8,5,2],[9,6,3]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n\nOutput:\n [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 20\n\n\n-1000 <= matrix[i][j] <= 1000",
      "solution": "class Solution(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        n = len(matrix)\n\n        # anti-diagonal mirror\n        for i in xrange(n):\n            for j in xrange(n - i):\n                matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j]\n\n        # horizontal mirror\n        for i in xrange(n / 2):\n            for j in xrange(n):\n                matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]\n\n        return matrix\nclass Solution2(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        return [list(reversed(x)) for x in zip(*matrix)]",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n^2)"
    },
    {
      "title": "Valid Parentheses",
      "difficulty": "EASY",
      "category": "String, Stack",
      "link": "https://leetcode.com/problems/valid-parentheses",
      "slug": "valid-parentheses",
      "description": "Given a string \ns\n containing just the characters \n'('\n, \n')'\n, \n'{'\n, \n'}'\n, \n'['\n and \n']'\n, determine if the input string is valid.\n\n\nAn input string is valid if:\n\n\n\n\nOpen brackets must be closed by the same type of brackets.\n\n\nOpen brackets must be closed in the correct order.\n\n\nEvery close bracket has a corresponding open bracket of the same type.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"()\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"()[]{}\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"(]\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"([])\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"([)]\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of parentheses only \n'()[]{}'\n.",
      "solution": "class Solution(object):\n    # @return a boolean\n    def isValid(self, s):\n        stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        for parenthese in s:\n            if parenthese in lookup:\n                stack.append(parenthese)\n            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:\n                return False\n        return len(stack) == 0",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Longest Common Prefix",
      "difficulty": "EASY",
      "category": "String, Trie",
      "link": "https://leetcode.com/problems/longest-common-prefix",
      "slug": "longest-common-prefix",
      "description": "Write a function to find the longest common prefix string amongst an array of strings.\n\n\nIf there is no common prefix, return an empty string \n\"\"\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n strs = [\"flower\",\"flow\",\"flight\"]\n\nOutput:\n \"fl\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n strs = [\"dog\",\"racecar\",\"car\"]\n\nOutput:\n \"\"\n\nExplanation:\n There is no common prefix among the input strings.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 200\n\n\n0 <= strs[i].length <= 200\n\n\nstrs[i]\n consists of only lowercase English letters if it is non-empty.",
      "solution": "class Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n\n        for i in xrange(len(strs[0])):\n            for string in strs[1:]:\n                if i >= len(string) or string[i] != strs[0][i]:\n                    return strs[0][:i]\n        return strs[0]\n\nclass Solution2(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        prefix = \"\"\n        \n        for chars in zip(*strs):\n            if all(c == chars[0] for c in chars):\n                prefix += chars[0]\n            else:\n                return prefix\n            \n        return prefix",
      "explanation": "N/A",
      "time_complexity": "O(n * k), k is the length of the common prefix",
      "space_complexity": "O(k)"
    },
    {
      "title": "Trapping Rain Water",
      "difficulty": "HARD",
      "category": "Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack",
      "link": "https://leetcode.com/problems/trapping-rain-water",
      "slug": "trapping-rain-water",
      "description": "Given \nn\n non-negative integers representing an elevation map where the width of each bar is \n1\n, compute how much water it can trap after raining.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [0,1,0,2,1,0,1,3,2,1,2,1]\n\nOutput:\n 6\n\nExplanation:\n The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [4,2,0,3,2,5]\n\nOutput:\n 9\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n1 <= n <= 2 * 10\n4\n\n\n0 <= height[i] <= 10\n5",
      "solution": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result, left, right, level = 0, 0, len(height)-1, 0\n        while left < right:\n            if height[left] < height[right]:\n                lower = height[left]\n                left += 1\n            else:\n                lower = height[right]\n                right -= 1\n            level = max(level, lower)\n            result += level-lower\n        return result\n\nclass Solution2(object):\n    # @param A, a list of integers\n    # @return an integer\n    def trap(self, A):\n        result = 0\n        top = 0\n        for i in xrange(len(A)):\n            if A[top] < A[i]:\n                top = i\n\n        second_top = 0\n        for i in xrange(top):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        second_top = len(A) - 1\n        for i in reversed(xrange(top, len(A))):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        return result\n\nclass Solution3(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        right = [0]*len(height)\n        mx = 0\n        for i in reversed(xrange(len(height))):\n            right[i] = mx\n            mx = max(mx, height[i])\n        result = left = 0\n        for i in xrange(len(height)):\n            left = max(left, height[i])\n            result += max(min(left, right[i])-height[i], 0)\n        return result\n\nclass Solution4(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        stk = []\n        for i in xrange(len(height)):\n            prev = 0\n            while stk and height[stk[-1]] <= height[i]:\n                j = stk.pop()\n                result += (height[j] - prev) * (i - j - 1)\n                prev = height[j]\n            if stk:\n                result += (height[i] - prev) * (i - stk[-1] - 1)\n            stk.append(i)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Subsets",
      "difficulty": "MEDIUM",
      "category": "Array, Backtracking, Bit Manipulation",
      "link": "https://leetcode.com/problems/subsets",
      "slug": "subsets",
      "description": "Given an integer array \nnums\n of \nunique\n elements, return \nall possible\n \nsubsets\n \n(the power set)\n.\n\n\nThe solution set \nmust not\n contain duplicate subsets. Return the solution in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0]\n\nOutput:\n [[],[0]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n\n\n-10 <= nums[i] <= 10\n\n\nAll the numbers of \nnums\n are \nunique\n.",
      "solution": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        result = [[]]\n        for i in xrange(len(nums)):\n            size = len(result)\n            for j in xrange(size):\n                result.append(list(result[j]))\n                result[-1].append(nums[i])\n        return result\n\nclass Solution2(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i, count = 0, 1 << len(nums)\n        nums.sort()\n\n        while i < count:\n            cur = []\n            for j in xrange(len(nums)):\n                if i & 1 << j:\n                    cur.append(nums[j])\n            result.append(cur)\n            i += 1\n\n        return result\n\nclass Solution3(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        return self.subsetsRecu([], sorted(nums))\n\n    def subsetsRecu(self, cur, nums):\n        if not nums:\n            return [cur]\n\n        return self.subsetsRecu(cur, nums[1:]) + self.subsetsRecu(cur + [nums[0]], nums[1:])",
      "explanation": "N/A",
      "time_complexity": "O(n * 2^n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Merge Intervals",
      "difficulty": "MEDIUM",
      "category": "Array, Sorting",
      "link": "https://leetcode.com/problems/merge-intervals",
      "slug": "merge-intervals",
      "description": "Given an array of \nintervals\n where \nintervals[i] = [start\ni\n, end\ni\n]\n, merge all overlapping intervals, and return \nan array of the non-overlapping intervals that cover all the intervals in the input\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n intervals = [[1,3],[2,6],[8,10],[15,18]]\n\nOutput:\n [[1,6],[8,10],[15,18]]\n\nExplanation:\n Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\n\n\nExample 2:\n\n\n\n\nInput:\n intervals = [[1,4],[4,5]]\n\nOutput:\n [[1,5]]\n\nExplanation:\n Intervals [1,4] and [4,5] are considered overlapping.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= intervals.length <= 10\n4\n\n\nintervals[i].length == 2\n\n\n0 <= start\ni\n <= end\ni\n <= 10\n4",
      "solution": "class Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        intervals.sort()\n        result = []\n        for interval in intervals:\n            if not result or interval[0] > result[-1][1]:\n                result.append(interval)\n            else:\n                result[-1][1] = max(result[-1][1], interval[1])\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Divide Array Into Arrays With Max Difference",
      "difficulty": "MEDIUM",
      "category": "Array, Greedy, Sorting",
      "link": "https://leetcode.com/problems/divide-array-into-arrays-with-max-difference",
      "slug": "divide-array-into-arrays-with-max-difference",
      "description": "You are given an integer array \nnums\n of size \nn\n where \nn\n is a multiple of 3 and a positive integer \nk\n.\n\n\nDivide the array \nnums\n into \nn / 3\n arrays of size \n3\n satisfying the following condition:\n\n\n\n\nThe difference between \nany\n two elements in one array is \nless than or equal\n to \nk\n.\n\n\n\n\nReturn a \n2D\n array containing the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return \nany\n of them.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,3,4,8,7,9,3,5,1], k = 2\n\n\nOutput:\n \n[[1,1,3],[3,4,5],[7,8,9]]\n\n\nExplanation:\n\n\nThe difference between any two elements in each array is less than or equal to 2.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [2,4,2,2,5,2], k = 2\n\n\nOutput:\n \n[]\n\n\nExplanation:\n\n\nDifferent ways to divide \nnums\n into 2 arrays of size 3 are:\n\n\n\n\n[[2,2,2],[2,4,5]] (and its permutations)\n\n\n[[2,2,4],[2,2,5]] (and its permutations)\n\n\n\n\nBecause there are four 2s there will be an array with the elements 2 and 5 no matter how we divide it. since \n5 - 2 = 3 > k\n, the condition is not satisfied and so there is no valid division.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [4,2,9,8,2,12,7,12,10,5,8,5,5,7,9,2,5,11], k = 14\n\n\nOutput:\n \n[[2,2,2],[4,5,5],[5,5,7],[7,8,8],[9,9,10],[11,12,12]]\n\n\nExplanation:\n\n\nThe difference between any two elements in each array is less than or equal to 14.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 10\n5\n\n\nn \nis a multiple of 3\n\n\n1 <= nums[i] <= 10\n5\n\n\n1 <= k <= 10\n5",
      "solution": "\n# sortclass Solution(object):\n    def divideArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        return [nums[i:i+3] for i in xrange(0, len(nums), 3)] if all(nums[i+2]-nums[i] <= k for i in xrange(0, len(nums), 3)) else []",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Generate Tag for Video Caption",
      "difficulty": "EASY",
      "category": "String, Simulation",
      "link": "https://leetcode.com/problems/generate-tag-for-video-caption",
      "slug": "generate-tag-for-video-caption",
      "description": "You are given a string \ncaption\n representing the caption for a video.\n\n\nThe following actions must be performed \nin order\n to generate a \nvalid tag\n for the video:\n\n\n\n\n\n\nCombine all words\n in the string into a single \ncamelCase string\n prefixed with \n'#'\n. A \ncamelCase string\n is one where the first letter of all words \nexcept\n the first one is capitalized. All characters after the first character in \neach\n word must be lowercase.\n\n\n\n\n\n\nRemove\n all characters that are not an English letter, \nexcept\n the first \n'#'\n.\n\n\n\n\n\n\nTruncate\n the result to a maximum of 100 characters.\n\n\n\n\n\n\nReturn the \ntag\n after performing the actions on \ncaption\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ncaption = \"Leetcode daily streak achieved\"\n\n\nOutput:\n \n\"#leetcodeDailyStreakAchieved\"\n\n\nExplanation:\n\n\nThe first letter for all words except \n\"leetcode\"\n should be capitalized.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ncaption = \"can I Go There\"\n\n\nOutput:\n \n\"#canIGoThere\"\n\n\nExplanation:\n\n\nThe first letter for all words except \n\"can\"\n should be capitalized.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ncaption = \"hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\"\n\n\nOutput:\n \n\"#hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\"\n\n\nExplanation:\n\n\nSince the first word has length 101, we need to truncate the last two letters from the word.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= caption.length <= 150\n\n\ncaption\n consists only of English letters and \n' '\n.",
      "solution": "\n# stringclass Solution(object):\n    def generateTag(self, caption):\n        \"\"\"\n        :type caption: str\n        :rtype: str\n        \"\"\"\n        L = 100\n        result = ['#']\n        for i in xrange(len(caption)):\n            if caption[i] == ' ':\n                continue\n            result.append(caption[i].upper() if i == 0 or caption[i-1] == ' ' else caption[i].lower())\n            if len(result) == L:\n                break\n        if 1 < len(result):\n            result[1] = result[1].lower()\n        return \"\".join(result)\n\n\n# stringclass Solution2(object):\n    def generateTag(self, caption):\n        \"\"\"\n        :type caption: str\n        :rtype: str\n        \"\"\"\n        L = 100\n        return ('#'+\"\".join(x.lower() if i == 0 else x[0].upper()+x[1:].lower() for i, x in enumerate(caption.split())))[:L]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Maximum Difference Between Increasing Elements",
      "difficulty": "EASY",
      "category": "Array",
      "link": "https://leetcode.com/problems/maximum-difference-between-increasing-elements",
      "slug": "maximum-difference-between-increasing-elements",
      "description": "Given a \n0-indexed\n integer array \nnums\n of size \nn\n, find the \nmaximum difference\n between \nnums[i]\n and \nnums[j]\n (i.e., \nnums[j] - nums[i]\n), such that \n0 <= i < j < n\n and \nnums[i] < nums[j]\n.\n\n\nReturn \nthe \nmaximum difference\n. \nIf no such \ni\n and \nj\n exists, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [7,\n1\n,\n5\n,4]\n\nOutput:\n 4\n\nExplanation:\n\nThe maximum difference occurs with i = 1 and j = 2, nums[j] - nums[i] = 5 - 1 = 4.\nNote that with i = 1 and j = 0, the difference nums[j] - nums[i] = 7 - 1 = 6, but i > j, so it is not valid.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [9,4,3,2]\n\nOutput:\n -1\n\nExplanation:\n\nThere is no i and j such that i < j and nums[i] < nums[j].\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [\n1\n,5,2,\n10\n]\n\nOutput:\n 9\n\nExplanation:\n\nThe maximum difference occurs with i = 0 and j = 3, nums[j] - nums[i] = 10 - 1 = 9.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n2 <= n <= 1000\n\n\n1 <= nums[i] <= 10\n9",
      "solution": "class Solution(object):\n    def maximumDifference(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, prefix = 0, float(\"inf\")\n        for x in nums: \n            result = max(result, x-prefix)\n            prefix = min(prefix, x)\n        return result if result else -1",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "4Sum",
      "difficulty": "MEDIUM",
      "category": "Array, Two Pointers, Sorting",
      "link": "https://leetcode.com/problems/4sum",
      "slug": "4sum",
      "description": "Given an array \nnums\n of \nn\n integers, return \nan array of all the \nunique\n quadruplets\n \n[nums[a], nums[b], nums[c], nums[d]]\n such that:\n\n\n\n\n0 <= a, b, c, d < n\n\n\na\n, \nb\n, \nc\n, and \nd\n are \ndistinct\n.\n\n\nnums[a] + nums[b] + nums[c] + nums[d] == target\n\n\n\n\nYou may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,0,-1,0,-2,2], target = 0\n\nOutput:\n [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,2,2,2,2], target = 8\n\nOutput:\n [[2,2,2,2]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 200\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n-10\n9\n <= target <= 10\n9",
      "solution": "\nimport collections\n\n\n# Two pointer solution. (1356ms)class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        result = []\n        for i in xrange(len(nums) - 3):\n            if i and nums[i] == nums[i - 1]:\n                continue\n            for j in xrange(i + 1, len(nums) - 2):\n                if j != i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                total = target - nums[i] - nums[j]\n                left, right = j + 1, len(nums) - 1\n                while left < right:\n                    if nums[left] + nums[right] == total:\n                        result.append([nums[i], nums[j], nums[left], nums[right]])\n                        right -= 1\n                        left += 1\n                        while left < right and nums[left] == nums[left - 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right + 1]:\n                            right -= 1\n                    elif nums[left] + nums[right] > total:\n                        right -= 1\n                    else:\n                        left += 1\n        return result\n\n\n# Hash solution. (224ms)class Solution2(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, lookup = sorted(nums), [], collections.defaultdict(list)\n        for i in xrange(0, len(nums) - 1):\n            for j in xrange(i + 1, len(nums)):\n                is_duplicated = False\n                for [x, y] in lookup[nums[i] + nums[j]]:\n                    if nums[x] == nums[i]:\n                        is_duplicated = True\n                        break\n                if not is_duplicated:\n                    lookup[nums[i] + nums[j]].append([i, j])\n        ans = {}\n        for c in xrange(2, len(nums)):\n            for d in xrange(c+1, len(nums)):\n                if target - nums[c] - nums[d] in lookup:\n                    for [a, b] in lookup[target - nums[c] - nums[d]]:\n                        if b < c:\n                            quad = [nums[a], nums[b], nums[c], nums[d]]\n                            quad_hash = \" \".join(str(quad))\n                            if quad_hash not in ans:\n                                ans[quad_hash] = True\n                                result.append(quad)\n        return result\n\nclass Solution3(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, lookup = sorted(nums), [], collections.defaultdict(list)\n        for i in xrange(0, len(nums) - 1):\n            for j in xrange(i + 1, len(nums)):\n                lookup[nums[i] + nums[j]].append([i, j])\n\n        for i in lookup.keys():\n            if target - i in lookup:\n                for x in lookup[i]:\n                    for y in lookup[target - i]:\n                        [a, b], [c, d] = x, y\n                        if a is not c and a is not d and \\\n                           b is not c and b is not d:\n                            quad = sorted([nums[a], nums[b], nums[c], nums[d]])\n                            if quad not in result:\n                                result.append(quad)\n        return sorted(result)",
      "explanation": "N/A",
      "time_complexity": "O(n^2 * p) ~ O(n^4)",
      "space_complexity": "O(n^2)"
    },
    {
      "title": "Fibonacci Number",
      "difficulty": "EASY",
      "category": "Math, Dynamic Programming, Recursion, Memoization",
      "link": "https://leetcode.com/problems/fibonacci-number",
      "slug": "fibonacci-number",
      "description": "The \nFibonacci numbers\n, commonly denoted \nF(n)\n form a sequence, called the \nFibonacci sequence\n, such that each number is the sum of the two preceding ones, starting from \n0\n and \n1\n. That is,\n\n\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\n\n\nGiven \nn\n, calculate \nF(n)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 1\n\nExplanation:\n F(2) = F(1) + F(0) = 1 + 0 = 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 2\n\nExplanation:\n F(3) = F(2) + F(1) = 1 + 1 = 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 4\n\nOutput:\n 3\n\nExplanation:\n F(4) = F(3) + F(2) = 2 + 1 = 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 30",
      "solution": "\nimport itertools\n\nclass Solution(object):\n    def fib(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        def matrix_expo(A, K):\n            result = [[int(i==j) for j in xrange(len(A))] \\\n                      for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b for a, b in itertools.izip(row, col)) \\\n                     for col in ZB] for row in A]\n\n        T = [[1, 1],\n             [1, 0]]\n        return matrix_mult([[1, 0]], matrix_expo(T, N))[0][1]  # [a1, a0] * T^N\n\nclass Solution2(object):\n    def fib(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        prev, current = 0, 1\n        for i in xrange(N):\n            prev, current = current, prev + current,\n        return prev",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Longest Palindromic Substring",
      "difficulty": "MEDIUM",
      "category": "Two Pointers, String, Dynamic Programming",
      "link": "https://leetcode.com/problems/longest-palindromic-substring",
      "slug": "longest-palindromic-substring",
      "description": "Given a string \ns\n, return \nthe longest\n \npalindromic\n \nsubstring\n in \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"babad\"\n\nOutput:\n \"bab\"\n\nExplanation:\n \"aba\" is also a valid answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"cbbd\"\n\nOutput:\n \"bb\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consist of only digits and English letters.",
      "solution": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def preProcess(s):\n            if not s:\n                return ['^', '$']\n            T = ['^']\n            for c in s:\n                T +=  ['#', c]\n            T += ['#', '$']\n            return T\n\n        T = preProcess(s)\n        P = [0] * len(T)\n        center, right = 0, 0\n        for i in xrange(1, len(T) - 1):\n            i_mirror = 2 * center - i\n            if right > i:\n                P[i] = min(right - i, P[i_mirror])\n            else:\n                P[i] = 0\n\n            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:\n                P[i] += 1\n\n            if i + P[i] > right:\n                center, right = i, i + P[i]\n\n        max_i = 0\n        for i in xrange(1, len(T) - 1):\n            if P[i] > P[max_i]:\n                max_i = i\n        start = (max_i - 1 - P[max_i]) // 2\n        return s[start : start + P[max_i]]\n\nclass Solution2(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return (right-left+1)-2\n        \n        left, right = -1, -2\n        for i in xrange(len(s)):\n            l = max(expand(s, i, i), expand(s, i, i+1))\n            if l > right-left+1:\n                right = i+l//2\n                left = right-l+1\n        return s[left:right+1] if left >= 0 else \"\"",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Max Consecutive Ones",
      "difficulty": "EASY",
      "category": "Array",
      "link": "https://leetcode.com/problems/max-consecutive-ones",
      "slug": "max-consecutive-ones",
      "description": "Given a binary array \nnums\n, return \nthe maximum number of consecutive \n1\n's in the array\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,0,1,1,1]\n\nOutput:\n 3\n\nExplanation:\n The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,0,1,1,0,1]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\nnums[i]\n is either \n0\n or \n1\n.",
      "solution": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, local_max = 0, 0\n        for n in nums:\n            local_max = (local_max + 1 if n else 0)\n            result = max(result, local_max)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Maximum Difference Between Even and Odd Frequency II",
      "difficulty": "HARD",
      "category": "String, Sliding Window, Enumeration, Prefix Sum",
      "link": "https://leetcode.com/problems/maximum-difference-between-even-and-odd-frequency-ii",
      "slug": "maximum-difference-between-even-and-odd-frequency-ii",
      "description": "You are given a string \ns\n and an integer \nk\n. Your task is to find the \nmaximum\n difference between the frequency of \ntwo\n characters, \nfreq[a] - freq[b]\n, in a \nsubstring\n \nsubs\n of \ns\n, such that:\n\n\n\n\nsubs\n has a size of \nat least\n \nk\n.\n\n\nCharacter \na\n has an \nodd frequency\n in \nsubs\n.\n\n\nCharacter \nb\n has a \nnon-zero\n \neven frequency\n in \nsubs\n.\n\n\n\n\nReturn the \nmaximum\n difference.\n\n\nNote\n that \nsubs\n can contain more than 2 \ndistinct\n characters.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"12233\", k = 4\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\nFor the substring \n\"12233\"\n, the frequency of \n'1'\n is 1 and the frequency of \n'3'\n is 2. The difference is \n1 - 2 = -1\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"1122211\", k = 3\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nFor the substring \n\"11222\"\n, the frequency of \n'2'\n is 3 and the frequency of \n'1'\n is 2. The difference is \n3 - 2 = 1\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"110\", k = 3\n\n\nOutput:\n \n-1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= s.length <= 3 * 10\n4\n\n\ns\n consists only of digits \n'0'\n to \n'4'\n.\n\n\nThe input is generated that at least one substring has a character with an even frequency and a character with an odd frequency.\n\n\n1 <= k <= s.length",
      "solution": "\n# prefix sum, two pointers, sliding windowclass Solution(object):\n    def maxDifference(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def diff(x, y):\n            prefix1, prefix2, prefix = [0]*(len(s)+1), [0]*(len(s)+1), [0]*(len(s)+1)\n            for i in xrange(len(s)):\n                prefix1[i+1] = prefix1[i]+int(s[i] == x)\n                prefix2[i+1] = prefix2[i]+int(s[i] == y)\n                prefix[i+1] = prefix[i]+(int(s[i] == x)-int(s[i] == y))\n            result = float(\"-inf\")\n            mn = [[float(\"inf\")]*2 for _ in xrange(2)]\n            left = 0\n            for right in xrange(k-1, len(s)):\n                while k <= right-left+1 and prefix1[right+1]-prefix1[left] and prefix2[right+1]-prefix2[left]:\n                    i, j = prefix1[left]%2, prefix2[left]%2\n                    mn[i][j] = min(mn[i][j], prefix[left])\n                    left += 1\n                i, j = prefix1[right+1]%2, prefix2[right+1]%2\n                result = max(result, prefix[right+1]-mn[i^1][j])\n            return result\n        \n        lookup = set(s)\n        return max(diff(x, y) for x in lookup for y in lookup if x != y)",
      "explanation": "N/A",
      "time_complexity": "O(d^2 * n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Invalid Transactions",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, String, Sorting",
      "link": "https://leetcode.com/problems/invalid-transactions",
      "slug": "invalid-transactions",
      "description": "A transaction is possibly invalid if:\n\n\n\n\nthe amount exceeds \n$1000\n, or;\n\n\nif it occurs within (and including) \n60\n minutes of another transaction with the \nsame name\n in a \ndifferent city\n.\n\n\n\n\nYou are given an array of strings \ntransaction\n where \ntransactions[i]\n consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.\n\n\nReturn a list of \ntransactions\n that are possibly invalid. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n\nOutput:\n [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n\nExplanation:\n The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.\n\n\nExample 2:\n\n\n\n\nInput:\n transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\n\nOutput:\n [\"alice,50,1200,mtv\"]\n\n\n\nExample 3:\n\n\n\n\nInput:\n transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\n\nOutput:\n [\"bob,50,1200,mtv\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\ntransactions.length <= 1000\n\n\nEach \ntransactions[i]\n takes the form \n\"{name},{time},{amount},{city}\"\n\n\nEach \n{name}\n and \n{city}\n consist of lowercase English letters, and have lengths between \n1\n and \n10\n.\n\n\nEach \n{time}\n consist of digits, and represent an integer between \n0\n and \n1000\n.\n\n\nEach \n{amount}\n consist of digits, and represent an integer between \n0\n and \n2000\n.",
      "solution": "\n\nimport collections\n\nclass Solution:\n    def invalidTransactions(self, transactions):\n        AMOUNT, MINUTES = 1000, 60\n        trans = map(lambda x: (x[0], int(x[1]), int(x[2]), x[3]),\n                    (transaction.split(',') for transaction in transactions))\n        trans.sort(key=lambda t: t[1])\n        trans_indexes = collections.defaultdict(list)\n        for i, t in enumerate(trans):\n            trans_indexes[t[0]].append(i)\n        result = []\n        for name, indexes in trans_indexes.iteritems():\n            left, right = 0, 0\n            for i, t_index in enumerate(indexes):\n                t = trans[t_index]\n                if (t[2] > AMOUNT):\n                    result.append(\"{},{},{},{}\".format(*t))\n                    continue\n                while left+1 < len(indexes) and trans[indexes[left]][1] < t[1]-MINUTES:\n                    left += 1\n                while right+1 < len(indexes) and trans[indexes[right+1]][1] <= t[1]+MINUTES:\n                    right += 1\n                for i in xrange(left, right+1):\n                    if trans[indexes[i]][3] != t[3]:\n                        result.append(\"{},{},{},{}\".format(*t))\n                        break\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Math, Design, Randomized",
      "link": "https://leetcode.com/problems/insert-delete-getrandom-o1",
      "slug": "insert-delete-getrandom-o1",
      "description": "Implement the \nRandomizedSet\n class:\n\n\n\n\nRandomizedSet()\n Initializes the \nRandomizedSet\n object.\n\n\nbool insert(int val)\n Inserts an item \nval\n into the set if not present. Returns \ntrue\n if the item was not present, \nfalse\n otherwise.\n\n\nbool remove(int val)\n Removes an item \nval\n from the set if present. Returns \ntrue\n if the item was present, \nfalse\n otherwise.\n\n\nint getRandom()\n Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the \nsame probability\n of being returned.\n\n\n\n\nYou must implement the functions of the class such that each function works in \naverage\n \nO(1)\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], [], [1], [2], []]\n\nOutput\n\n[null, true, false, true, 2, true, false, 2]\n\n\nExplanation\n\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= val <= 2\n31\n - 1\n\n\nAt most \n2 * \n10\n5\n calls will be made to \ninsert\n, \nremove\n, and \ngetRandom\n.\n\n\nThere will be \nat least one\n element in the data structure when \ngetRandom\n is called.",
      "solution": "\nfrom random import randint\nclass RandomizedSet(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__set = []\n        self.__used = {}\n\n\n    def insert(self, val):\n        \"\"\"\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        if val in self.__used:\n            return False\n\n        self.__set += val,\n        self.__used[val] = len(self.__set)-1\n\n        return True\n\n\n    def remove(self, val):\n        \"\"\"\n        Removes a value from the set. Returns true if the set contained the specified element.\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        if val not in self.__used:\n            return False\n\n        self.__used[self.__set[-1]] = self.__used[val]\n        self.__set[self.__used[val]], self.__set[-1] = self.__set[-1], self.__set[self.__used[val]]\n\n        self.__used.pop(val)\n        self.__set.pop()\n\n        return True\n\n    def getRandom(self):\n        \"\"\"\n        Get a random element from the set.\n        :rtype: int\n        \"\"\"\n        return self.__set[randint(0, len(self.__set)-1)]",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Add Binary",
      "difficulty": "EASY",
      "category": "Math, String, Bit Manipulation, Simulation",
      "link": "https://leetcode.com/problems/add-binary",
      "slug": "add-binary",
      "description": "Given two binary strings \na\n and \nb\n, return \ntheir sum as a binary string\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n a = \"11\", b = \"1\"\n\nOutput:\n \"100\"\n\nExample 2:\n\n\nInput:\n a = \"1010\", b = \"1011\"\n\nOutput:\n \"10101\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= a.length, b.length <= 10\n4\n\n\na\n and \nb\n consist only of \n'0'\n or \n'1'\n characters.\n\n\nEach string does not contain leading zeros except for the zero itself.",
      "solution": "class Solution(object):\n    # @param a, a string\n    # @param b, a string\n    # @return a string\n    def addBinary(self, a, b):\n        result, carry, val = \"\", 0, 0\n        for i in xrange(max(len(a), len(b))):\n            val = carry\n            if i < len(a):\n                val += int(a[-(i + 1)])\n            if i < len(b):\n                val += int(b[-(i + 1)])\n            carry, val = divmod(val, 2)\n            result += str(val)\n        if carry:\n            result += str(carry)\n        return result[::-1]\n\n\nfrom itertools import izip_longest\n\nclass Solution2(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        result = \"\"\n        carry = 0\n        for x, y in izip_longest(reversed(a), reversed(b), fillvalue=\"0\"):\n            carry, remainder = divmod(int(x)+int(y)+carry, 2)\n            result += str(remainder)\n        \n        if carry:\n            result += str(carry)\n        \n        return result[::-1]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Students and Examinations",
      "difficulty": "EASY",
      "category": "Database",
      "link": "https://leetcode.com/problems/students-and-examinations",
      "slug": "students-and-examinations",
      "description": "Table: \nStudents\n\n\n\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| student_id    | int     |\n| student_name  | varchar |\n+---------------+---------+\nstudent_id is the primary key (column with unique values) for this table.\nEach row of this table contains the ID and the name of one student in the school.\n\n\n\n \n\n\nTable: \nSubjects\n\n\n\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| subject_name | varchar |\n+--------------+---------+\nsubject_name is the primary key (column with unique values) for this table.\nEach row of this table contains the name of one subject in the school.\n\n\n\n \n\n\nTable: \nExaminations\n\n\n\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| student_id   | int     |\n| subject_name | varchar |\n+--------------+---------+\nThere is no primary key (column with unique values) for this table. It may contain duplicates.\nEach student from the Students table takes every course from the Subjects table.\nEach row of this table indicates that a student with ID student_id attended the exam of subject_name.\n\n\n\n \n\n\nWrite a solution to find the number of times each student attended each exam.\n\n\nReturn the result table ordered by \nstudent_id\n and \nsubject_name\n.\n\n\nThe result format is in the following example.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nStudents table:\n+------------+--------------+\n| student_id | student_name |\n+------------+--------------+\n| 1          | Alice        |\n| 2          | Bob          |\n| 13         | John         |\n| 6          | Alex         |\n+------------+--------------+\nSubjects table:\n+--------------+\n| subject_name |\n+--------------+\n| Math         |\n| Physics      |\n| Programming  |\n+--------------+\nExaminations table:\n+------------+--------------+\n| student_id | subject_name |\n+------------+--------------+\n| 1          | Math         |\n| 1          | Physics      |\n| 1          | Programming  |\n| 2          | Programming  |\n| 1          | Physics      |\n| 1          | Math         |\n| 13         | Math         |\n| 13         | Programming  |\n| 13         | Physics      |\n| 2          | Math         |\n| 1          | Math         |\n+------------+--------------+\n\nOutput:\n \n+------------+--------------+--------------+----------------+\n| student_id | student_name | subject_name | attended_exams |\n+------------+--------------+--------------+----------------+\n| 1          | Alice        | Math         | 3              |\n| 1          | Alice        | Physics      | 2              |\n| 1          | Alice        | Programming  | 1              |\n| 2          | Bob          | Math         | 1              |\n| 2          | Bob          | Physics      | 0              |\n| 2          | Bob          | Programming  | 1              |\n| 6          | Alex         | Math         | 0              |\n| 6          | Alex         | Physics      | 0              |\n| 6          | Alex         | Programming  | 0              |\n| 13         | John         | Math         | 1              |\n| 13         | John         | Physics      | 1              |\n| 13         | John         | Programming  | 1              |\n+------------+--------------+--------------+----------------+\n\nExplanation:\n \nThe result table should contain all students and all subjects.\nAlice attended the Math exam 3 times, the Physics exam 2 times, and the Programming exam 1 time.\nBob attended the Math exam 1 time, the Programming exam 1 time, and did not attend the Physics exam.\nAlex did not attend any exams.\nJohn attended the Math exam 1 time, the Physics exam 1 time, and the Programming exam 1 time.",
      "solution": "# Solution not found in kamyu104 repository",
      "explanation": "N/A",
      "time_complexity": "N/A",
      "space_complexity": "N/A"
    },
    {
      "title": "Palindrome Partitioning",
      "difficulty": "MEDIUM",
      "category": "String, Dynamic Programming, Backtracking",
      "link": "https://leetcode.com/problems/palindrome-partitioning",
      "slug": "palindrome-partitioning",
      "description": "Given a string \ns\n, partition \ns\n such that every \nsubstring\n of the partition is a \npalindrome\n. Return \nall possible palindrome partitioning of \ns\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"aab\"\n\nOutput:\n [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n\nExample 2:\n\n\nInput:\n s = \"a\"\n\nOutput:\n [[\"a\"]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 16\n\n\ns\n contains only lowercase English letters.",
      "solution": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        is_palindrome = [[False] * len(s) for i in xrange(len(s))]\n        for i in reversed(xrange(len(s))):\n            for j in xrange(i, len(s)):\n                is_palindrome[i][j] = s[i] == s[j] and ((j - i < 2) or is_palindrome[i + 1][j - 1])\n\n        sub_partition = [[] for _ in xrange(len(s))]\n        for i in reversed(xrange(len(s))):\n            for j in xrange(i, len(s)):\n                if is_palindrome[i][j]:\n                    if j + 1 < len(s):\n                        for p in sub_partition[j + 1]:\n                            sub_partition[i].append([s[i:j + 1]] + p)\n                    else:\n                        sub_partition[i].append([s[i:j + 1]])\n\n        return sub_partition[0]\n\n\n# recursive solutionclass Solution2(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        result = []\n        self.partitionRecu(result, [], s, 0)\n        return result\n\n    def partitionRecu(self, result, cur, s, i):\n        if i == len(s):\n            result.append(list(cur))\n        else:\n            for j in xrange(i, len(s)):\n                if self.isPalindrome(s[i: j + 1]):\n                    cur.append(s[i: j + 1])\n                    self.partitionRecu(result, cur, s, j + 1)\n                    cur.pop()\n\n    def isPalindrome(self, s):\n        for i in xrange(len(s) / 2):\n            if s[i] != s[-(i + 1)]:\n                return False\n        return True",
      "explanation": "N/A",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Best Time to Buy and Sell Stock",
      "difficulty": "EASY",
      "category": "Array, Dynamic Programming",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
      "slug": "best-time-to-buy-and-sell-stock",
      "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nYou want to maximize your profit by choosing a \nsingle day\n to buy one stock and choosing a \ndifferent day in the future\n to sell that stock.\n\n\nReturn \nthe maximum profit you can achieve from this transaction\n. If you cannot achieve any profit, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 5\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transactions are done and the max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n4",
      "solution": "class Solution:\n    def maxProfit(self, prices) -> int:\n        profit = 0\n        buy = prices[0]\n\n        for price in range(1, len(prices)):\n            profit = max(profit, prices[price] - buy)\n            buy = min(prices[price], buy)\n\n        return profit",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Search a 2D Matrix",
      "difficulty": "MEDIUM",
      "category": "Array, Binary Search, Matrix",
      "link": "https://leetcode.com/problems/search-a-2d-matrix",
      "slug": "search-a-2d-matrix",
      "description": "You are given an \nm x n\n integer matrix \nmatrix\n with the following two properties:\n\n\n\n\nEach row is sorted in non-decreasing order.\n\n\nThe first integer of each row is greater than the last integer of the previous row.\n\n\n\n\nGiven an integer \ntarget\n, return \ntrue\n \nif\n \ntarget\n \nis in\n \nmatrix\n \nor\n \nfalse\n \notherwise\n.\n\n\nYou must write a solution in \nO(log(m * n))\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 100\n\n\n-10\n4\n <= matrix[i][j], target <= 10\n4",
      "solution": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not matrix:\n            return False\n\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n\n        while left < right:\n            mid = left + (right - left) / 2\n            if matrix[mid / n][mid % n] >= target:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left < m * n and matrix[left / n][left % n] == target",
      "explanation": "N/A",
      "time_complexity": "O(logm + logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Merge Sorted Array",
      "difficulty": "EASY",
      "category": "Array, Two Pointers, Sorting",
      "link": "https://leetcode.com/problems/merge-sorted-array",
      "slug": "merge-sorted-array",
      "description": "You are given two integer arrays \nnums1\n and \nnums2\n, sorted in \nnon-decreasing order\n, and two integers \nm\n and \nn\n, representing the number of elements in \nnums1\n and \nnums2\n respectively.\n\n\nMerge\n \nnums1\n and \nnums2\n into a single array sorted in \nnon-decreasing order\n.\n\n\nThe final sorted array should not be returned by the function, but instead be \nstored inside the array \nnums1\n. To accommodate this, \nnums1\n has a length of \nm + n\n, where the first \nm\n elements denote the elements that should be merged, and the last \nn\n elements are set to \n0\n and should be ignored. \nnums2\n has a length of \nn\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n\nOutput:\n [1,2,2,3,5,6]\n\nExplanation:\n The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [\n1\n,\n2\n,2,\n3\n,5,6] with the underlined elements coming from nums1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1], m = 1, nums2 = [], n = 0\n\nOutput:\n [1]\n\nExplanation:\n The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums1 = [0], m = 0, nums2 = [1], n = 1\n\nOutput:\n [1]\n\nExplanation:\n The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m + n\n\n\nnums2.length == n\n\n\n0 <= m, n <= 200\n\n\n1 <= m + n <= 200\n\n\n-10\n9\n <= nums1[i], nums2[j] <= 10\n9\n\n\n\n\n \n\n\nFollow up: \nCan you come up with an algorithm that runs in \nO(m + n)\n time?",
      "solution": "class Solution(object):\n    # @param A  a list of integers\n    # @param m  an integer, length of A\n    # @param B  a list of integers\n    # @param n  an integer, length of B\n    # @return nothing\n    def merge(self, A, m, B, n):\n        last, i, j = m + n - 1, m - 1, n - 1\n\n        while i >= 0 and j >= 0:\n            if A[i] > B[j]:\n                A[last] = A[i]\n                last, i = last - 1, i - 1\n            else:\n                A[last] = B[j]\n                last, j = last - 1, j - 1\n\n        while j >= 0:\n                A[last] = B[j]\n                last, j = last - 1, j - 1",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Generate Parentheses",
      "difficulty": "MEDIUM",
      "category": "String, Dynamic Programming, Backtracking",
      "link": "https://leetcode.com/problems/generate-parentheses",
      "slug": "generate-parentheses",
      "description": "Given \nn\n pairs of parentheses, write a function to \ngenerate all combinations of well-formed parentheses\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n n = 3\n\nOutput:\n [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n\nExample 2:\n\n\nInput:\n n = 1\n\nOutput:\n [\"()\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 8",
      "solution": "\n# iterative solutionclass Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result, curr = [], []\n        stk = [(1, (n, n))]\n        while stk:\n            step, args = stk.pop()\n            if step == 1:\n                left, right = args\n                if left == 0 and right == 0:\n                    result.append(\"\".join(curr))\n                if left < right:\n                    stk.append((3, tuple()))\n                    stk.append((1, (left, right-1)))\n                    stk.append((2, (')')))\n                if left > 0:\n                    stk.append((3, tuple()))\n                    stk.append((1, (left-1, right)))\n                    stk.append((2, ('(')))\n            elif step == 2:\n                curr.append(args[0])\n            elif step == 3:\n                curr.pop()\n        return result\n\n\n# recursive solutionclass Solution2(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        def generateParenthesisRecu(left, right, curr, result):\n            if left == 0 and right == 0:\n                result.append(\"\".join(curr))\n            if left > 0:\n                curr.append('(')\n                generateParenthesisRecu(left-1, right, curr, result)\n                curr.pop()\n            if left < right:\n                curr.append(')')\n                generateParenthesisRecu(left, right-1, curr, result)\n                curr.pop()\n\n        result = []\n        generateParenthesisRecu(n, n, [], result)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(4^n / n^(3/2)) ~= Catalan numbers",
      "space_complexity": "O(n)"
    },
    {
      "title": "Product of Array Except Self",
      "difficulty": "MEDIUM",
      "category": "Array, Prefix Sum",
      "link": "https://leetcode.com/problems/product-of-array-except-self",
      "slug": "product-of-array-except-self",
      "description": "Given an integer array \nnums\n, return \nan array\n \nanswer\n \nsuch that\n \nanswer[i]\n \nis equal to the product of all the elements of\n \nnums\n \nexcept\n \nnums[i]\n.\n\n\nThe product of any prefix or suffix of \nnums\n is \nguaranteed\n to fit in a \n32-bit\n integer.\n\n\nYou must write an algorithm that runs in \nO(n)\n time and without using the division operation.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,2,3,4]\n\nOutput:\n [24,12,8,6]\n\nExample 2:\n\n\nInput:\n nums = [-1,1,0,-3,3]\n\nOutput:\n [0,0,9,0,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n5\n\n\n-30 <= nums[i] <= 30\n\n\nThe input is generated such that \nanswer[i]\n is \nguaranteed\n to fit in a \n32-bit\n integer.\n\n\n\n\n \n\n\nFollow up:\n Can you solve the problem in \nO(1)\n extra space complexity? (The output array \ndoes not\n count as extra space for space complexity analysis.)",
      "solution": "class Solution(object):\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def productExceptSelf(self, nums):\n        if not nums:\n            return []\n\n        left_product = [1 for _ in xrange(len(nums))]\n        for i in xrange(1, len(nums)):\n            left_product[i] = left_product[i - 1] * nums[i - 1]\n\n        right_product = 1\n        for i in xrange(len(nums) - 2, -1, -1):\n            right_product *= nums[i + 1]\n            left_product[i] = left_product[i] * right_product\n\n        return left_product",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Max Area of Island",
      "difficulty": "MEDIUM",
      "category": "Array, Depth-First Search, Breadth-First Search, Union Find, Matrix",
      "link": "https://leetcode.com/problems/max-area-of-island",
      "slug": "max-area-of-island",
      "description": "You are given an \nm x n\n binary matrix \ngrid\n. An island is a group of \n1\n's (representing land) connected \n4-directionally\n (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n\n\nThe \narea\n of an island is the number of cells with a value \n1\n in the island.\n\n\nReturn \nthe maximum \narea\n of an island in \ngrid\n. If there is no island, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n\nOutput:\n 6\n\nExplanation:\n The answer is not 11, because the island must be connected 4-directionally.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[0,0,0,0,0,0,0,0]]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 50\n\n\ngrid[i][j]\n is either \n0\n or \n1\n.",
      "solution": "class Solution(object):\n    def maxAreaOfIsland(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [[-1,  0], [ 1,  0], [ 0,  1], [ 0, -1]]\n\n        def dfs(i, j, grid, area):\n            if not (0 <= i < len(grid) and \\\n                    0 <= j < len(grid[0]) and \\\n                    grid[i][j] > 0):\n                return False\n            grid[i][j] *= -1\n            area[0] += 1\n            for d in directions:\n                dfs(i+d[0], j+d[1], grid, area)\n            return True\n\n        result = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                area = [0]\n                if dfs(i, j, grid, area):\n                    result = max(result, area[0])\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n), the max depth of dfs may be m * n"
    }
  ],
  "Apple": [
    {
      "title": "LRU Cache",
      "difficulty": "MEDIUM",
      "category": "Hash Table, Linked List, Design, Doubly-Linked List",
      "link": "https://leetcode.com/problems/lru-cache",
      "slug": "lru-cache",
      "description": "Design a data structure that follows the constraints of a \nLeast Recently Used (LRU) cache\n.\n\n\nImplement the \nLRUCache\n class:\n\n\n\n\nLRUCache(int capacity)\n Initialize the LRU cache with \npositive\n size \ncapacity\n.\n\n\nint get(int key)\n Return the value of the \nkey\n if the key exists, otherwise return \n-1\n.\n\n\nvoid put(int key, int value)\n Update the value of the \nkey\n if the \nkey\n exists. Otherwise, add the \nkey-value\n pair to the cache. If the number of keys exceeds the \ncapacity\n from this operation, \nevict\n the least recently used key.\n\n\n\n\nThe functions \nget\n and \nput\n must each run in \nO(1)\n average time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n\nOutput\n\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n\nExplanation\n\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= capacity <= 3000\n\n\n0 <= key <= 10\n4\n\n\n0 <= value <= 10\n5\n\n\nAt most \n2 * 10\n5\n calls will be made to \nget\n and \nput\n.",
      "solution": "\nimport collections\n\n\n# using OrderedDictclass LRUCache(object):\n    def __init__(self, capacity):\n        self.cache = collections.OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        val = self.cache[key]\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.cache and len(self.cache) == self.capacity:\n            self.cache.popitem(last=False)\n        self.__update(key, val)\n    \n    def __update(self, key, val):\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = val\n\n\n\nclass ListNode(object):\n    def __init__(self, key, val):\n        self.val = val\n        self.key = key\n        self.next = None\n        self.prev = None\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\nclass LRUCache2(object):\n\n    def __init__(self, capacity):\n        self.list = LinkedList()\n        self.dict = {}\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.dict:\n            return -1\n        val = self.dict[key].val\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.dict and len(self.dict) == self.capacity:\n            del self.dict[self.list.head.key]\n            self.list.delete(self.list.head)\n        self.__update(key, val)\n\n    def __update(self, key, val):\n        if key in self.dict:\n            self.list.delete(self.dict[key])\n        node = ListNode(key, val)\n        self.list.insert(node)\n        self.dict[key] = node",
      "explanation": "N/A",
      "time_complexity": "O(1), per operation.",
      "space_complexity": "O(k), k is the capacity of cache."
    },
    {
      "title": "Best Time to Buy and Sell Stock",
      "difficulty": "EASY",
      "category": "Array, Dynamic Programming",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
      "slug": "best-time-to-buy-and-sell-stock",
      "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nYou want to maximize your profit by choosing a \nsingle day\n to buy one stock and choosing a \ndifferent day in the future\n to sell that stock.\n\n\nReturn \nthe maximum profit you can achieve from this transaction\n. If you cannot achieve any profit, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 5\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transactions are done and the max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n4",
      "solution": "class Solution:\n    def maxProfit(self, prices) -> int:\n        profit = 0\n        buy = prices[0]\n\n        for price in range(1, len(prices)):\n            profit = max(profit, prices[price] - buy)\n            buy = min(prices[price], buy)\n\n        return profit",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Top K Frequent Elements",
      "difficulty": "MEDIUM",
      "category": "Array, Hash Table, Divide and Conquer, Sorting, Heap (Priority Queue), Bucket Sort, Counting, Quickselect",
      "link": "https://leetcode.com/problems/top-k-frequent-elements",
      "slug": "top-k-frequent-elements",
      "description": "Given an integer array \nnums\n and an integer \nk\n, return \nthe\n \nk\n \nmost frequent elements\n. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,1,1,2,2,3], k = 2\n\nOutput:\n [1,2]\n\nExample 2:\n\n\nInput:\n nums = [1], k = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nk\n is in the range \n[1, the number of unique elements in the array]\n.\n\n\nIt is \nguaranteed\n that the answer is \nunique\n.\n\n\n\n\n \n\n\nFollow up:\n Your algorithm's time complexity must be better than \nO(n log n)\n, where n is the array's size.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        counts = collections.Counter(nums)\n        buckets = [[] for _ in xrange(len(nums)+1)]\n        for i, count in counts.iteritems():\n            buckets[count].append(i)\n\n        result = []\n        for i in reversed(xrange(len(buckets))):\n            for j in xrange(len(buckets[i])):\n                result.append(buckets[i][j])\n                if len(result) == k:\n                    return result\n        return result\n\n\n# Quick Select Solution\nfrom random import randintclass Solution2(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        counts = collections.Counter(nums)\n        p = []\n        for key, val in counts.iteritems():\n            p.append((-val, key))\n        self.kthElement(p, k-1)\n\n        result = []\n        for i in xrange(k):\n            result.append(p[i][1])\n        return result\n\n    def kthElement(self, nums, k):\n        def PartitionAroundPivot(left, right, pivot_idx, nums):\n            pivot_value = nums[pivot_idx]\n            new_pivot_idx = left\n            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n            for i in xrange(left, right):\n                if nums[i] < pivot_value:\n                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                    new_pivot_idx += 1\n\n            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n            return new_pivot_idx\n\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k:\n                return\n            elif new_pivot_idx > k:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k.\n                left = new_pivot_idx + 1\n\nclass Solution3(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        return [key for key, _ in collections.Counter(nums).most_common(k)]",
      "explanation": "N/A",
      "time_complexity": "O(nlogk)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Best Time to Buy and Sell Stock II",
      "difficulty": "MEDIUM",
      "category": "Array, Dynamic Programming, Greedy",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii",
      "slug": "best-time-to-buy-and-sell-stock-ii",
      "description": "You are given an integer array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold \nat most one\n share of the stock at any time. However, you can buy it then immediately sell it on the \nsame day\n.\n\n\nFind and return \nthe \nmaximum\n profit you can achieve\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 7\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [1,2,3,4,5]\n\nOutput:\n 4\n\nExplanation:\n Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n\n\n\nExample 3:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 3 * 10\n4\n\n\n0 <= prices[i] <= 10\n4",
      "solution": "class Solution:\n    def maxProfit(self, prices) -> int:\n        # intial approach \n        # buy and sell when possible \n        # profit = 0\n        # for i in range(1, len(prices)):\n        #     if prices[i] > prices[i-1]:\n        #         profit +=  prices[i] - prices[i-1]\n        # return profit \n\n        # DP\n        # 2 states, hold , not hold \n        # dp[i][0] = max profit on day i if we hold stock at the end of the day.\n        # dp[i][1] = max profit on day i if we do NOT hold stock at the end of the day. \n        dp = [[0] * 2 for _ in range(len(prices))]\n        dp[0] = [-prices[0], 0] # Base case: hold = -price, not hold = 0\n        for i in range(1, len(prices)):\n            # Case 1: holding → max of holding from yesterday or buying today\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])\n            # Case 2: not holding → max of not holding from yesterday or selling today\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])\n        # On the last day, max profit only if we are **not holding**\n        return dp[len(prices)-1][1]\n\n    # recursion\n\n    # def maxProfit(self, prices: List[int]) -> int:\n        \n    #     @lru_cache(maxsize=None)\n    #     def dfs(i, holding):\n    #         if i == len(prices):\n    #             return 0\n            \n    #         if not holding:\n    #             # Option to buy or skip\n    #             return max(\n    #                 dfs(i+1, 1) - prices[i],  # Buy\n    #                 dfs(i+1, 0)               # Skip\n    #             )\n    #         else:\n    #             # Option to sell or hold\n    #             return max(\n    #                 dfs(i+1, 0) + prices[i],  # Sell\n    #                 dfs(i+1, 1)               # Hold\n    #             )\n        \n    #     return dfs(0, 0)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Longest Common Prefix",
      "difficulty": "EASY",
      "category": "String, Trie",
      "link": "https://leetcode.com/problems/longest-common-prefix",
      "slug": "longest-common-prefix",
      "description": "Write a function to find the longest common prefix string amongst an array of strings.\n\n\nIf there is no common prefix, return an empty string \n\"\"\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n strs = [\"flower\",\"flow\",\"flight\"]\n\nOutput:\n \"fl\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n strs = [\"dog\",\"racecar\",\"car\"]\n\nOutput:\n \"\"\n\nExplanation:\n There is no common prefix among the input strings.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 200\n\n\n0 <= strs[i].length <= 200\n\n\nstrs[i]\n consists of only lowercase English letters if it is non-empty.",
      "solution": "class Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n\n        for i in xrange(len(strs[0])):\n            for string in strs[1:]:\n                if i >= len(string) or string[i] != strs[0][i]:\n                    return strs[0][:i]\n        return strs[0]\n\nclass Solution2(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        prefix = \"\"\n        \n        for chars in zip(*strs):\n            if all(c == chars[0] for c in chars):\n                prefix += chars[0]\n            else:\n                return prefix\n            \n        return prefix",
      "explanation": "N/A",
      "time_complexity": "O(n * k), k is the length of the common prefix",
      "space_complexity": "O(k)"
    },
    {
      "title": "Maximum Subarray",
      "difficulty": "MEDIUM",
      "category": "Array, Divide and Conquer, Dynamic Programming",
      "link": "https://leetcode.com/problems/maximum-subarray",
      "slug": "maximum-subarray",
      "description": "Given an integer array \nnums\n, find the \nsubarray\n with the largest sum, and return \nits sum\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-2,1,-3,4,-1,2,1,-5,4]\n\nOutput:\n 6\n\nExplanation:\n The subarray [4,-1,2,1] has the largest sum 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1]\n\nOutput:\n 1\n\nExplanation:\n The subarray [1] has the largest sum 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [5,4,-1,7,8]\n\nOutput:\n 23\n\nExplanation:\n The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n If you have figured out the \nO(n)\n solution, try coding another solution using the \ndivide and conquer\n approach, which is more subtle.",
      "solution": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, curr = float(\"-inf\"), float(\"-inf\")\n        for x in nums:\n            curr = max(curr+x, x)\n            result = max(result, curr)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Best Time to Buy and Sell Stock III",
      "difficulty": "HARD",
      "category": "Array, Dynamic Programming",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii",
      "slug": "best-time-to-buy-and-sell-stock-iii",
      "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nFind the maximum profit you can achieve. You may complete \nat most two transactions\n.\n\n\nNote:\n You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [3,3,5,0,0,3,1,4]\n\nOutput:\n 6\n\nExplanation:\n Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [1,2,3,4,5]\n\nOutput:\n 4\n\nExplanation:\n Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n\n\n\nExample 3:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transaction is done, i.e. max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n5",
      "solution": "from typing import List\n\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        max_txn = k\n        n = len(prices)\n        # dp[t][d] = max profit with at most t transactions by day d\n        # t ∈ [0..2] (number of transactions)\n        # d ∈ [0..n-1] (days)\n        dp = [[0] * n for _ in range(max_txn + 1)]\n\n        for t in range(1, max_txn+1):\n            max_profit_so_far = -prices[0]\n            for d in range(1, n):\n                # Option 1: don't sell today, carry forward previous max\n                # Option 2: sell today, and find best buy day using max_so_far\n                dp[t][d] = max(dp[t][d-1], prices[d] + max_profit_so_far)\n                # Update max_so_far for future days\n                max_profit_so_far = max(max_profit_so_far, dp[t-1][d] - prices[d])\n        # last day upto max_txn \n        return dp[max_txn][n-1]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Kth Largest Element in an Array",
      "difficulty": "MEDIUM",
      "category": "Array, Divide and Conquer, Sorting, Heap (Priority Queue), Quickselect",
      "link": "https://leetcode.com/problems/kth-largest-element-in-an-array",
      "slug": "kth-largest-element-in-an-array",
      "description": "Given an integer array \nnums\n and an integer \nk\n, return \nthe\n \nk\nth\n \nlargest element in the array\n.\n\n\nNote that it is the \nk\nth\n largest element in the sorted order, not the \nk\nth\n distinct element.\n\n\nCan you solve it without sorting?\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [3,2,1,5,6,4], k = 2\n\nOutput:\n 5\n\nExample 2:\n\n\nInput:\n nums = [3,2,3,1,2,4,5,5,6], k = 4\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4",
      "solution": "\nfrom random import randint\n\n\n# optimized for duplicated numsclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        nth_element(nums, k-1, compare=lambda a, b: a > b)\n        return nums[k-1]\n\nclass Solution2(object):\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = self.PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k - 1:\n                return nums[new_pivot_idx]\n            elif new_pivot_idx > k - 1:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k - 1.\n                left = new_pivot_idx + 1\n\n    def PartitionAroundPivot(self, left, right, pivot_idx, nums):\n        pivot_value = nums[pivot_idx]\n        new_pivot_idx = left\n        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n        for i in xrange(left, right):\n            if nums[i] > pivot_value:\n                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                new_pivot_idx += 1\n\n        nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n        return new_pivot_idx",
      "explanation": "N/A",
      "time_complexity": "O(n) on average, using Median of Medians could achieve O(n) (Intro Select)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Merge k Sorted Lists",
      "difficulty": "HARD",
      "category": "Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort",
      "link": "https://leetcode.com/problems/merge-k-sorted-lists",
      "slug": "merge-k-sorted-lists",
      "description": "You are given an array of \nk\n linked-lists \nlists\n, each linked-list is sorted in ascending order.\n\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n lists = [[1,4,5],[1,3,4],[2,6]]\n\nOutput:\n [1,1,2,3,4,4,5,6]\n\nExplanation:\n The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted linked list:\n1->1->2->3->4->4->5->6\n\n\n\nExample 2:\n\n\n\n\nInput:\n lists = []\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n lists = [[]]\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nk == lists.length\n\n\n0 <= k <= 10\n4\n\n\n0 <= lists[i].length <= 500\n\n\n-10\n4\n <= lists[i][j] <= 10\n4\n\n\nlists[i]\n is sorted in \nascending order\n.\n\n\nThe sum of \nlists[i].length\n will not exceed \n10\n4\n.",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\t\t\n        if self:\t\t\n            return \"{} -> {}\".format(self.val, self.next)\n\n\n# Merge two by two solution.class Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        if not lists:\n            return None\n        left, right = 0, len(lists) - 1\n        while right > 0:\n            lists[left] = mergeTwoLists(lists[left], lists[right])\n            left += 1\n            right -= 1\n            if left >= right:\n                left = 0\n        return lists[0]\n\n\n# Divide and Conquer solution.class Solution2(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        def mergeKListsHelper(lists, begin, end):\n            if begin > end:\n                return None\n            if begin == end:\n                return lists[begin]\n            return mergeTwoLists(mergeKListsHelper(lists, begin, (begin + end) / 2), \\\n                                 mergeKListsHelper(lists, (begin + end) / 2 + 1, end))\n\n        return mergeKListsHelper(lists, 0, len(lists) - 1)\n\n\n# Heap solution.\nimport heapqclass Solution3(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        dummy = ListNode(0)\n        current = dummy\n\n        heap = []\n        for sorted_list in lists:\n            if sorted_list:\n                heapq.heappush(heap, (sorted_list.val, sorted_list))\n\n        while heap:\n            smallest = heapq.heappop(heap)[1]\n            current.next = smallest\n            current = current.next\n            if smallest.next:\n                heapq.heappush(heap, (smallest.next.val, smallest.next))\n\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(nlogk)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Number of Islands",
      "difficulty": "MEDIUM",
      "category": "Array, Depth-First Search, Breadth-First Search, Union Find, Matrix",
      "link": "https://leetcode.com/problems/number-of-islands",
      "slug": "number-of-islands",
      "description": "Given an \nm x n\n 2D binary grid \ngrid\n which represents a map of \n'1'\ns (land) and \n'0'\ns (water), return \nthe number of islands\n.\n\n\nAn \nisland\n is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 300\n\n\ngrid[i][j]\n is \n'0'\n or \n'1'\n.",
      "solution": "class UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n       if self.set[x] != x:\n           self.set[x] = self.find_set(self.set[x])  # path compression.\n       return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root != y_root:\n            self.set[min(x_root, y_root)] = max(x_root, y_root)\n            self.count -= 1\n\nclass Solution(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        def index(n, i, j):\n            return i*n + j\n    \n        if not grid:\n            return 0\n\n        zero_count = 0\n        union_find = UnionFind(len(grid)*len(grid[0]))\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j] == '1':\n                    if i and grid[i-1][j] == '1':\n                        union_find.union_set(index(len(grid[0]), i-1, j),\n                                             index(len(grid[0]),i, j))\n                    if j and grid[i][j-1] == '1':\n                        union_find.union_set(index(len(grid[0]), i, j-1),\n                                             index(len(grid[0]), i, j))\n                else:\n                    zero_count += 1        \n        return union_find.count-zero_count\n\n\n# dfs solutionclass Solution2(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def dfs(grid, i, j):\n            if grid[i][j] == '0':\n                return False\n            grid[i][j] = '0'\n            stk = [(i, j)]\n            while stk:\n                r, c = stk.pop()\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(grid) and\n                            0 <= nc < len(grid[0]) and\n                            grid[nr][nc] == '1'):\n                        continue\n                    grid[nr][nc] = '0'\n                    stk.append((nr, nc))\n            return True\n\n        count = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if dfs(grid, i, j):\n                    count += 1\n        return count\n\n \nimport collections\n\n\n# bfs solutionclass Solution3(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def bfs(grid, i, j):\n            if grid[i][j] == '0':\n                return False\n            grid[i][j] ='0'\n            q = collections.deque([(i, j)])\n            while q:\n                r, c = q.popleft()\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(grid) and\n                            0 <= nc < len(grid[0]) and\n                            grid[nr][nc] == '1'):\n                        continue\n                    grid[nr][nc] = '0'\n                    q.append((nr, nc))\n            return True\n\n        count = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if bfs(grid, i, j):\n                    count += 1\n        return count",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "Rotate Image",
      "difficulty": "MEDIUM",
      "category": "Array, Math, Matrix",
      "link": "https://leetcode.com/problems/rotate-image",
      "slug": "rotate-image",
      "description": "You are given an \nn x n\n 2D \nmatrix\n representing an image, rotate the image by \n90\n degrees (clockwise).\n\n\nYou have to rotate the image \nin-place\n, which means you have to modify the input 2D matrix directly. \nDO NOT\n allocate another 2D matrix and do the rotation.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [[7,4,1],[8,5,2],[9,6,3]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n\nOutput:\n [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 20\n\n\n-1000 <= matrix[i][j] <= 1000",
      "solution": "class Solution(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        n = len(matrix)\n\n        # anti-diagonal mirror\n        for i in xrange(n):\n            for j in xrange(n - i):\n                matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j]\n\n        # horizontal mirror\n        for i in xrange(n / 2):\n            for j in xrange(n):\n                matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]\n\n        return matrix\nclass Solution2(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        return [list(reversed(x)) for x in zip(*matrix)]",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n^2)"
    },
    {
      "title": "Best Time to Buy and Sell Stock IV",
      "difficulty": "HARD",
      "category": "Array, Dynamic Programming",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv",
      "slug": "best-time-to-buy-and-sell-stock-iv",
      "description": "You are given an integer array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day, and an integer \nk\n.\n\n\nFind the maximum profit you can achieve. You may complete at most \nk\n transactions: i.e. you may buy at most \nk\n times and sell at most \nk\n times.\n\n\nNote:\n You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n k = 2, prices = [2,4,1]\n\nOutput:\n 2\n\nExplanation:\n Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n k = 2, prices = [3,2,6,5,0,3]\n\nOutput:\n 7\n\nExplanation:\n Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= 100\n\n\n1 <= prices.length <= 1000\n\n\n0 <= prices[i] <= 1000",
      "solution": "from typing import List\n\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        max_txn = k\n        n = len(prices)\n        # dp[t][d] = max profit with at most t transactions by day d\n        # t ∈ [0..2] (number of transactions)\n        # d ∈ [0..n-1] (days)\n        dp = [[0] * n for _ in range(max_txn + 1)]\n\n        for t in range(1, max_txn+1):\n            max_profit_so_far = -prices[0]\n            for d in range(1, n):\n                # Option 1: don't sell today, carry forward previous max\n                # Option 2: sell today, and find best buy day using max_so_far\n                dp[t][d] = max(dp[t][d-1], prices[d] + max_profit_so_far)\n                # Update max_so_far for future days\n                max_profit_so_far = max(max_profit_so_far, dp[t-1][d] - prices[d])\n        # last day upto max_txn \n        return dp[max_txn][n-1]",
      "explanation": "N/A",
      "time_complexity": "O(k * n)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Merge Intervals",
      "difficulty": "MEDIUM",
      "category": "Array, Sorting",
      "link": "https://leetcode.com/problems/merge-intervals",
      "slug": "merge-intervals",
      "description": "Given an array of \nintervals\n where \nintervals[i] = [start\ni\n, end\ni\n]\n, merge all overlapping intervals, and return \nan array of the non-overlapping intervals that cover all the intervals in the input\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n intervals = [[1,3],[2,6],[8,10],[15,18]]\n\nOutput:\n [[1,6],[8,10],[15,18]]\n\nExplanation:\n Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\n\n\nExample 2:\n\n\n\n\nInput:\n intervals = [[1,4],[4,5]]\n\nOutput:\n [[1,5]]\n\nExplanation:\n Intervals [1,4] and [4,5] are considered overlapping.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= intervals.length <= 10\n4\n\n\nintervals[i].length == 2\n\n\n0 <= start\ni\n <= end\ni\n <= 10\n4",
      "solution": "class Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        intervals.sort()\n        result = []\n        for interval in intervals:\n            if not result or interval[0] > result[-1][1]:\n                result.append(interval)\n            else:\n                result[-1][1] = max(result[-1][1], interval[1])\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Valid Parentheses",
      "difficulty": "EASY",
      "category": "String, Stack",
      "link": "https://leetcode.com/problems/valid-parentheses",
      "slug": "valid-parentheses",
      "description": "Given a string \ns\n containing just the characters \n'('\n, \n')'\n, \n'{'\n, \n'}'\n, \n'['\n and \n']'\n, determine if the input string is valid.\n\n\nAn input string is valid if:\n\n\n\n\nOpen brackets must be closed by the same type of brackets.\n\n\nOpen brackets must be closed in the correct order.\n\n\nEvery close bracket has a corresponding open bracket of the same type.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"()\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"()[]{}\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"(]\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"([])\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"([)]\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of parentheses only \n'()[]{}'\n.",
      "solution": "class Solution(object):\n    # @return a boolean\n    def isValid(self, s):\n        stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        for parenthese in s:\n            if parenthese in lookup:\n                stack.append(parenthese)\n            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:\n                return False\n        return len(stack) == 0",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    }
  ]
}