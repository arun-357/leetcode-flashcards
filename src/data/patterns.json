{
  "Arrays": [
    {
      "title": "Move Zeroes",
      "difficulty": "Easy",
      "category": "Arrays",
      "link": "https://leetcode.com/problems/move-zeroes",
      "slug": "move-zeroes",
      "description": "Given an integer array \nnums\n, move all \n0\n's to the end of it while maintaining the relative order of the non-zero elements.\n\n\nNote\n that you must do this in-place without making a copy of the array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [0,1,0,3,12]\n\nOutput:\n [1,3,12,0,0]\n\nExample 2:\n\n\nInput:\n nums = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you minimize the total number of operations done?",
      "solution": "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i]:\n                nums[i], nums[pos] = nums[pos], nums[i]\n                pos += 1\n\n    def moveZeroes2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort(cmp=lambda a, b: 0 if b else -1)\n\nclass Solution2(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i]:\n                nums[pos] = nums[i]\n                pos += 1\n\n        for i in xrange(pos, len(nums)):\n            nums[i] = 0",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Majority Element",
      "difficulty": "Easy",
      "category": "Arrays",
      "link": "https://leetcode.com/problems/majority-element",
      "slug": "majority-element",
      "description": "Given an array \nnums\n of size \nn\n, return \nthe majority element\n.\n\n\nThe majority element is the element that appears more than \n⌊n / 2⌋\n times. You may assume that the majority element always exists in the array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [3,2,3]\n\nOutput:\n 3\n\nExample 2:\n\n\nInput:\n nums = [2,2,1,1,1,2,2]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 5 * 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n\n\n \n\n\nFollow-up:\n Could you solve the problem in linear time and in \nO(1)\n space?",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def boyer_moore_majority_vote():\n            result, cnt = None, 0\n            for x in nums:\n                if not cnt:\n                    result = x\n                if x == result:\n                    cnt += 1\n                else:\n                    cnt -= 1\n            return result\n\n        return boyer_moore_majority_vote()\n\n\nimport collections\n\nclass Solution2(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return collections.Counter(nums).most_common(1)[0][0]\n\n\nimport collections\n\nclass Solution3(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sorted(collections.Counter(nums).items(), key=lambda a: a[1], reverse=True)[0][0]",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Remove Duplicates from Sorted Array",
      "difficulty": "Easy",
      "category": "Arrays",
      "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array",
      "slug": "remove-duplicates-from-sorted-array",
      "description": "Given an integer array \nnums\n sorted in \nnon-decreasing order\n, remove the duplicates \nin-place\n such that each unique element appears only \nonce\n. The \nrelative order\n of the elements should be kept the \nsame\n. Then return \nthe number of unique elements in \nnums\n.\n\n\nConsider the number of unique elements of \nnums\n to be \nk\n, to get accepted, you need to do the following things:\n\n\n\n\nChange the array \nnums\n such that the first \nk\n elements of \nnums\n contain the unique elements in the order they were present in \nnums\n initially. The remaining elements of \nnums\n are not important as well as the size of \nnums\n.\n\n\nReturn \nk\n.\n\n\n\n\nCustom Judge:\n\n\nThe judge will test your solution with the following code:\n\n\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\n\n\nIf all assertions pass, then your solution will be \naccepted\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,2]\n\nOutput:\n 2, nums = [1,2,_]\n\nExplanation:\n Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,0,1,1,1,2,2,3,3,4]\n\nOutput:\n 5, nums = [0,1,2,3,4,_,_,_,_,_]\n\nExplanation:\n Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 3 * 10\n4\n\n\n-100 <= nums[i] <= 100\n\n\nnums\n is sorted in \nnon-decreasing\n order.",
      "solution": "class Solution(object):\n    # @param a list of integers\n    # @return an integer\n    def removeDuplicates(self, A):\n        if not A:\n            return 0\n\n        last = 0\n        for i in xrange(len(A)):\n            if A[last] != A[i]:\n                last += 1\n                A[last] = A[i]\n        return last + 1",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Best Time to Buy and Sell Stock",
      "difficulty": "Easy",
      "category": "Arrays",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
      "slug": "best-time-to-buy-and-sell-stock",
      "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nYou want to maximize your profit by choosing a \nsingle day\n to buy one stock and choosing a \ndifferent day in the future\n to sell that stock.\n\n\nReturn \nthe maximum profit you can achieve from this transaction\n. If you cannot achieve any profit, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 5\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transactions are done and the max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n4",
      "solution": "class Solution:\n    def maxProfit(self, prices) -> int:\n        profit = 0\n        buy = prices[0]\n\n        for price in range(1, len(prices)):\n            profit = max(profit, prices[price] - buy)\n            buy = min(prices[price], buy)\n\n        return profit",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Rotate Array",
      "difficulty": "Medium",
      "category": "Arrays",
      "link": "https://leetcode.com/problems/rotate-array",
      "slug": "rotate-array",
      "description": "Given an integer array \nnums\n, rotate the array to the right by \nk\n steps, where \nk\n is non-negative.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,4,5,6,7], k = 3\n\nOutput:\n [5,6,7,1,2,3,4]\n\nExplanation:\n\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-1,-100,3,99], k = 2\n\nOutput:\n [3,99,-1,-100]\n\nExplanation:\n \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\n0 <= k <= 10\n5\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nTry to come up with as many solutions as you can. There are at least \nthree\n different ways to solve this problem.\n\n\nCould you do it in-place with \nO(1)\n extra space?",
      "solution": "class Solution(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    def rotate(self, nums, k):\n        def reverse(nums, start, end):\n            while start < end:\n                nums[start], nums[end - 1] = nums[end - 1], nums[start]\n                start += 1\n                end -= 1\n\n        k %= len(nums)\n        reverse(nums, 0, len(nums))\n        reverse(nums, 0, k)\n        reverse(nums, k, len(nums))\n\n\nfrom fractions import gcd\n\nclass Solution2(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n\n    def rotate(self, nums, k):\n        def apply_cycle_permutation(k, offset, cycle_len, nums):\n            tmp = nums[offset]\n            for i in xrange(1, cycle_len):\n                nums[(offset + i * k) % len(nums)], tmp = tmp, nums[(offset + i * k) % len(nums)]\n            nums[offset] = tmp\n\n        k %= len(nums)\n        num_cycles = gcd(len(nums), k)\n        cycle_len = len(nums) / num_cycles\n        for i in xrange(num_cycles):\n            apply_cycle_permutation(k, i, cycle_len, nums)\n\nclass Solution3(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n\n    def rotate(self, nums, k):\n        count = 0\n        start = 0\n        while count < len(nums):\n            curr = start\n            prev = nums[curr]\n            while True:\n                idx = (curr + k) % len(nums)\n                nums[idx], prev = prev, nums[idx]\n                curr = idx\n                count += 1\n                if start == curr:\n                    break\n            start += 1\n\nclass Solution4(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    def rotate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums[:] = nums[len(nums) - k:] + nums[:len(nums) - k]\n        \nclass Solution5(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    def rotate(self, nums, k):\n        while k > 0:\n            nums.insert(0, nums.pop())\n            k -= 1",
      "explanation": "N/A",
      "time_complexity": "O(k * n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Product of Array Except Self",
      "difficulty": "Medium",
      "category": "Arrays",
      "link": "https://leetcode.com/problems/product-of-array-except-self",
      "slug": "product-of-array-except-self",
      "description": "Given an integer array \nnums\n, return \nan array\n \nanswer\n \nsuch that\n \nanswer[i]\n \nis equal to the product of all the elements of\n \nnums\n \nexcept\n \nnums[i]\n.\n\n\nThe product of any prefix or suffix of \nnums\n is \nguaranteed\n to fit in a \n32-bit\n integer.\n\n\nYou must write an algorithm that runs in \nO(n)\n time and without using the division operation.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,2,3,4]\n\nOutput:\n [24,12,8,6]\n\nExample 2:\n\n\nInput:\n nums = [-1,1,0,-3,3]\n\nOutput:\n [0,0,9,0,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n5\n\n\n-30 <= nums[i] <= 30\n\n\nThe input is generated such that \nanswer[i]\n is \nguaranteed\n to fit in a \n32-bit\n integer.\n\n\n\n\n \n\n\nFollow up:\n Can you solve the problem in \nO(1)\n extra space complexity? (The output array \ndoes not\n count as extra space for space complexity analysis.)",
      "solution": "class Solution(object):\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def productExceptSelf(self, nums):\n        if not nums:\n            return []\n\n        left_product = [1 for _ in xrange(len(nums))]\n        for i in xrange(1, len(nums)):\n            left_product[i] = left_product[i - 1] * nums[i - 1]\n\n        right_product = 1\n        for i in xrange(len(nums) - 2, -1, -1):\n            right_product *= nums[i + 1]\n            left_product[i] = left_product[i] * right_product\n\n        return left_product",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Best Time to Buy and Sell Stock II",
      "difficulty": "Medium",
      "category": "Arrays",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii",
      "slug": "best-time-to-buy-and-sell-stock-ii",
      "description": "You are given an integer array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold \nat most one\n share of the stock at any time. However, you can buy it then immediately sell it on the \nsame day\n.\n\n\nFind and return \nthe \nmaximum\n profit you can achieve\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 7\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [1,2,3,4,5]\n\nOutput:\n 4\n\nExplanation:\n Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n\n\n\nExample 3:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 3 * 10\n4\n\n\n0 <= prices[i] <= 10\n4",
      "solution": "class Solution:\n    def maxProfit(self, prices) -> int:\n        # intial approach \n        # buy and sell when possible \n        # profit = 0\n        # for i in range(1, len(prices)):\n        #     if prices[i] > prices[i-1]:\n        #         profit +=  prices[i] - prices[i-1]\n        # return profit \n\n        # DP\n        # 2 states, hold , not hold \n        # dp[i][0] = max profit on day i if we hold stock at the end of the day.\n        # dp[i][1] = max profit on day i if we do NOT hold stock at the end of the day. \n        dp = [[0] * 2 for _ in range(len(prices))]\n        dp[0] = [-prices[0], 0] # Base case: hold = -price, not hold = 0\n        for i in range(1, len(prices)):\n            # Case 1: holding → max of holding from yesterday or buying today\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])\n            # Case 2: not holding → max of not holding from yesterday or selling today\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])\n        # On the last day, max profit only if we are **not holding**\n        return dp[len(prices)-1][1]\n\n    # recursion\n\n    # def maxProfit(self, prices: List[int]) -> int:\n        \n    #     @lru_cache(maxsize=None)\n    #     def dfs(i, holding):\n    #         if i == len(prices):\n    #             return 0\n            \n    #         if not holding:\n    #             # Option to buy or skip\n    #             return max(\n    #                 dfs(i+1, 1) - prices[i],  # Buy\n    #                 dfs(i+1, 0)               # Skip\n    #             )\n    #         else:\n    #             # Option to sell or hold\n    #             return max(\n    #                 dfs(i+1, 0) + prices[i],  # Sell\n    #                 dfs(i+1, 1)               # Hold\n    #             )\n        \n    #     return dfs(0, 0)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Number of Zero-Filled Subarrays",
      "difficulty": "Medium",
      "category": "Arrays",
      "link": "https://leetcode.com/problems/number-of-zero-filled-subarrays",
      "slug": "number-of-zero-filled-subarrays",
      "description": "Given an integer array \nnums\n, return \nthe number of \nsubarrays\n filled with \n0\n.\n\n\nA \nsubarray\n is a contiguous non-empty sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,0,0,2,0,0,4]\n\nOutput:\n 6\n\nExplanation:\n \nThere are 4 occurrences of [0] as a subarray.\nThere are 2 occurrences of [0,0] as a subarray.\nThere is no occurrence of a subarray with a size more than 2 filled with 0. Therefore, we return 6.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,0,0,2,0,0]\n\nOutput:\n 9\n\nExplanation:\n\nThere are 5 occurrences of [0] as a subarray.\nThere are 3 occurrences of [0,0] as a subarray.\nThere is 1 occurrence of [0,0,0] as a subarray.\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [2,10,2019]\n\nOutput:\n 0\n\nExplanation:\n There is no subarray filled with 0. Therefore, we return 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9",
      "solution": "\n# two pointers, combinatoricsclass Solution(object):\n    def zeroFilledSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        prev = -1\n        for i in xrange(len(nums)):\n            if nums[i]:\n                prev = i\n                continue\n            result += i-prev\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Increasing Triplet Subsequence",
      "difficulty": "Medium",
      "category": "Arrays",
      "link": "https://leetcode.com/problems/increasing-triplet-subsequence",
      "slug": "increasing-triplet-subsequence",
      "description": "Given an integer array \nnums\n, return \ntrue\n if there exists a triple of indices \n(i, j, k)\n such that \ni < j < k\n and \nnums[i] < nums[j] < nums[k]\n. If no such indices exists, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,4,5]\n\nOutput:\n true\n\nExplanation:\n Any triplet where i < j < k is valid.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [5,4,3,2,1]\n\nOutput:\n false\n\nExplanation:\n No triplet exists.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [2,1,5,0,4,6]\n\nOutput:\n true\n\nExplanation:\n The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 5 * 10\n5\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you implement a solution that runs in \nO(n)\n time complexity and \nO(1)\n space complexity?",
      "solution": "\nimport bisect\n\nclass Solution(object):\n    def increasingTriplet(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        min_num, a, b = float(\"inf\"), float(\"inf\"), float(\"inf\")\n        for c in nums:\n            if min_num >= c:\n                min_num = c\n            elif b >= c:\n                a, b = min_num, c\n            else:  # a < b < c\n                return True\n        return False\n\n# Generalization of k-uplet.class Solution_Generalization(object):\n    def increasingTriplet(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        def increasingKUplet(nums, k):\n            inc = [float('inf')] * (k - 1)\n            for num in nums:\n                i = bisect.bisect_left(inc, num)\n                if i >= k - 1:\n                    return True\n                inc[i] = num\n            return k == 0\n\n        return increasingKUplet(nums, 3)",
      "explanation": "N/A",
      "time_complexity": "O(n * logk)",
      "space_complexity": "O(k)"
    },
    {
      "title": "First Missing Positive",
      "difficulty": "Hard",
      "category": "Arrays",
      "link": "https://leetcode.com/problems/first-missing-positive",
      "slug": "first-missing-positive",
      "description": "Given an unsorted integer array \nnums\n. Return the \nsmallest positive integer\n that is \nnot present\n in \nnums\n.\n\n\nYou must implement an algorithm that runs in \nO(n)\n time and uses \nO(1)\n auxiliary space.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,0]\n\nOutput:\n 3\n\nExplanation:\n The numbers in the range [1,2] are all in the array.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,4,-1,1]\n\nOutput:\n 2\n\nExplanation:\n 1 is in the array but 2 is missing.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [7,8,9,11,12]\n\nOutput:\n 1\n\nExplanation:\n The smallest positive integer 1 is missing.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1",
      "solution": "class Solution(object):\n    # @param A, a list of integers\n    # @return an integer\n    def firstMissingPositive(self, A):\n        i = 0\n        while i < len(A):\n            if A[i] > 0 and A[i] - 1 < len(A) and A[i] != A[A[i]-1]:\n                A[A[i]-1], A[i] = A[i], A[A[i]-1]\n            else:\n                i += 1\n\n        for i, integer in enumerate(A):\n            if integer != i + 1:\n                return i + 1\n        return len(A) + 1",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    }
  ],
  "Strings": [
    {
      "title": "Is Subsequence",
      "difficulty": "Easy",
      "category": "Strings",
      "link": "https://leetcode.com/problems/is-subsequence",
      "slug": "is-subsequence",
      "description": "Given two strings \ns\n and \nt\n, return \ntrue\n if \ns\n is a \nsubsequence\n of \nt\n, or \nfalse\n otherwise\n.\n\n\nA \nsubsequence\n of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \n\"ace\"\n is a subsequence of \n\"\na\nb\nc\nd\ne\n\"\n while \n\"aec\"\n is not).\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"abc\", t = \"ahbgdc\"\n\nOutput:\n true\n\nExample 2:\n\n\nInput:\n s = \"axc\", t = \"ahbgdc\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 100\n\n\n0 <= t.length <= 10\n4\n\n\ns\n and \nt\n consist only of lowercase English letters.\n\n\n\n\n \n\n\nFollow up:\n Suppose there are lots of incoming \ns\n, say \ns\n1\n, s\n2\n, ..., s\nk\n where \nk >= 10\n9\n, and you want to check one by one to see if \nt\n has its subsequence. In this scenario, how would you change your code?",
      "solution": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return True\n\n        i = 0\n        for c in t:\n            if c == s[i]:\n                i += 1\n            if i == len(s):\n                break\n        return i == len(s)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Valid Palindrome",
      "difficulty": "Easy",
      "category": "Strings",
      "link": "https://leetcode.com/problems/valid-palindrome",
      "slug": "valid-palindrome",
      "description": "A phrase is a \npalindrome\n if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\n\nGiven a string \ns\n, return \ntrue\n if it is a \npalindrome\n, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"A man, a plan, a canal: Panama\"\n\nOutput:\n true\n\nExplanation:\n \"amanaplanacanalpanama\" is a palindrome.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"race a car\"\n\nOutput:\n false\n\nExplanation:\n \"raceacar\" is not a palindrome.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \" \"\n\nOutput:\n true\n\nExplanation:\n s is an empty string \"\" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 2 * 10\n5\n\n\ns\n consists only of printable ASCII characters.",
      "solution": "class Solution(object):\n    # @param s, a string\n    # @return a boolean\n    def isPalindrome(self, s):\n        i, j = 0, len(s) - 1\n        while i < j:\n            while i < j and not s[i].isalnum():\n                i += 1\n            while i < j and not s[j].isalnum():\n                j -= 1\n            if s[i].lower() != s[j].lower():\n                return False\n            i, j = i + 1, j - 1\n        return True",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Longest Common Prefix",
      "difficulty": "Easy",
      "category": "Strings",
      "link": "https://leetcode.com/problems/longest-common-prefix",
      "slug": "longest-common-prefix",
      "description": "Write a function to find the longest common prefix string amongst an array of strings.\n\n\nIf there is no common prefix, return an empty string \n\"\"\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n strs = [\"flower\",\"flow\",\"flight\"]\n\nOutput:\n \"fl\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n strs = [\"dog\",\"racecar\",\"car\"]\n\nOutput:\n \"\"\n\nExplanation:\n There is no common prefix among the input strings.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 200\n\n\n0 <= strs[i].length <= 200\n\n\nstrs[i]\n consists of only lowercase English letters if it is non-empty.",
      "solution": "class Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n\n        for i in xrange(len(strs[0])):\n            for string in strs[1:]:\n                if i >= len(string) or string[i] != strs[0][i]:\n                    return strs[0][:i]\n        return strs[0]\n\nclass Solution2(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        prefix = \"\"\n        \n        for chars in zip(*strs):\n            if all(c == chars[0] for c in chars):\n                prefix += chars[0]\n            else:\n                return prefix\n            \n        return prefix",
      "explanation": "N/A",
      "time_complexity": "O(n * k), k is the length of the common prefix",
      "space_complexity": "O(k)"
    },
    {
      "title": "Zigzag Conversion",
      "difficulty": "Medium",
      "category": "Strings",
      "link": "https://leetcode.com/problems/zigzag-conversion",
      "slug": "zigzag-conversion",
      "description": "The string \n\"PAYPALISHIRING\"\n is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\n\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\n\n\nAnd then read line by line: \n\"PAHNAPLSIIGYIR\"\n\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\n\n\nstring convert(string s, int numRows);\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"PAYPALISHIRING\", numRows = 3\n\nOutput:\n \"PAHNAPLSIIGYIR\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"PAYPALISHIRING\", numRows = 4\n\nOutput:\n \"PINALSIGYAHRPI\"\n\nExplanation:\n\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"A\", numRows = 1\n\nOutput:\n \"A\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consists of English letters (lower-case and upper-case), \n','\n and \n'.'\n.\n\n\n1 <= numRows <= 1000",
      "solution": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        if numRows == 1:\n            return s\n        step, zigzag = 2 * numRows - 2, \"\"\n        for i in xrange(numRows):\n            for j in xrange(i, len(s), step):\n                zigzag += s[j]\n                if 0 < i < numRows - 1 and j + step - 2 * i < len(s):\n                    zigzag += s[j + step - 2 * i]\n        return zigzag",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Reverse Words in a String",
      "difficulty": "Medium",
      "category": "Strings",
      "link": "https://leetcode.com/problems/reverse-words-in-a-string",
      "slug": "reverse-words-in-a-string",
      "description": "Given an input string \ns\n, reverse the order of the \nwords\n.\n\n\nA \nword\n is defined as a sequence of non-space characters. The \nwords\n in \ns\n will be separated by at least one space.\n\n\nReturn \na string of the words in reverse order concatenated by a single space.\n\n\nNote\n that \ns\n may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"the sky is blue\"\n\nOutput:\n \"blue is sky the\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"  hello world  \"\n\nOutput:\n \"world hello\"\n\nExplanation:\n Your reversed string should not contain leading or trailing spaces.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"a good   example\"\n\nOutput:\n \"example good a\"\n\nExplanation:\n You need to reduce multiple spaces between two words to a single space in the reversed string.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n contains English letters (upper-case and lower-case), digits, and spaces \n' '\n.\n\n\nThere is \nat least one\n word in \ns\n.\n\n\n\n\n \n\n\nFollow-up: \nIf the string data type is mutable in your language, can you solve it \nin-place\n with \nO(1)\n extra space?",
      "solution": "class Solution(object):\n    # @param s, a string\n    # @return a string\n    def reverseWords(self, s):\n        return ' '.join(reversed(s.split()))",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Guess the Word",
      "difficulty": "Hard",
      "category": "Strings",
      "link": "https://leetcode.com/problems/guess-the-word",
      "slug": "guess-the-word",
      "description": "You are given an array of unique strings \nwords\n where \nwords[i]\n is six letters long. One word of \nwords\n was chosen as a secret word.\n\n\nYou are also given the helper object \nMaster\n. You may call \nMaster.guess(word)\n where \nword\n is a six-letter-long string, and it must be from \nwords\n. \nMaster.guess(word)\n returns:\n\n\n\n\n-1\n if \nword\n is not from \nwords\n, or\n\n\nan integer representing the number of exact matches (value and position) of your guess to the secret word.\n\n\n\n\nThere is a parameter \nallowedGuesses\n for each test case where \nallowedGuesses\n is the maximum number of times you can call \nMaster.guess(word)\n.\n\n\nFor each test case, you should call \nMaster.guess\n with the secret word without exceeding the maximum number of allowed guesses. You will get:\n\n\n\n\n\"Either you took too many guesses, or you did not find the secret word.\"\n if you called \nMaster.guess\n more than \nallowedGuesses\n times or if you did not call \nMaster.guess\n with the secret word, or\n\n\n\"You guessed the secret word correctly.\"\n if you called \nMaster.guess\n with the secret word with the number of calls to \nMaster.guess\n less than or equal to \nallowedGuesses\n.\n\n\n\n\nThe test cases are generated such that you can guess the secret word with a reasonable strategy (other than using the bruteforce method).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n secret = \"acckzz\", words = [\"acckzz\",\"ccbazz\",\"eiowzz\",\"abcczz\"], allowedGuesses = 10\n\nOutput:\n You guessed the secret word correctly.\n\nExplanation:\n\nmaster.guess(\"aaaaaa\") returns -1, because \"aaaaaa\" is not in wordlist.\nmaster.guess(\"acckzz\") returns 6, because \"acckzz\" is secret and has all 6 matches.\nmaster.guess(\"ccbazz\") returns 3, because \"ccbazz\" has 3 matches.\nmaster.guess(\"eiowzz\") returns 2, because \"eiowzz\" has 2 matches.\nmaster.guess(\"abcczz\") returns 4, because \"abcczz\" has 4 matches.\nWe made 5 calls to master.guess, and one of them was the secret, so we pass the test case.\n\n\n\nExample 2:\n\n\n\n\nInput:\n secret = \"hamada\", words = [\"hamada\",\"khaled\"], allowedGuesses = 10\n\nOutput:\n You guessed the secret word correctly.\n\nExplanation:\n Since there are two words, you can guess both.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 100\n\n\nwords[i].length == 6\n\n\nwords[i]\n consist of lowercase English letters.\n\n\nAll the strings of \nwordlist\n are \nunique\n.\n\n\nsecret\n exists in \nwords\n.\n\n\n10 <= allowedGuesses <= 30",
      "solution": "\nimport collections\nimport itertools\n\nclass Solution(object):\n    def findSecretWord(self, wordlist, master):\n        \"\"\"\n        :type wordlist: List[Str]\n        :type master: Master\n        :rtype: None\n        \"\"\"\n        possible = range(len(wordlist))\n        n = 0\n        while n < 6:\n            count = [collections.Counter(w[i] for w in wordlist) for i in xrange(6)]\n            guess = max(possible, key=lambda x: sum(count[i][c] for i, c in enumerate(wordlist[x])))\n            n = master.guess(wordlist[guess])\n            possible = [j for j in possible if sum(a == b for a, b in itertools.izip(wordlist[guess], wordlist[j])) == n]\n\nclass Solution2(object):\n    def findSecretWord(self, wordlist, master):\n        \"\"\"\n        :type wordlist: List[Str]\n        :type master: Master\n        :rtype: None\n        \"\"\"\n        def solve(H, possible):\n            min_max_group, best_guess = possible, None\n            for guess in possible:\n                groups = [[] for _ in xrange(7)]\n                for j in possible:\n                    if j != guess:\n                        groups[H[guess][j]].append(j)\n                max_group = max(groups, key=len)\n                if len(max_group) < len(min_max_group):\n                    min_max_group, best_guess = max_group, guess\n            return best_guess\n\n        H = [[sum(a == b for a, b in itertools.izip(wordlist[i], wordlist[j]))\n                  for j in xrange(len(wordlist))]\n                  for i in xrange(len(wordlist))]\n        possible = range(len(wordlist))\n        n = 0\n        while n < 6:\n            guess = solve(H, possible)\n            n = master.guess(wordlist[guess])\n            possible = [j for j in possible if H[guess][j] == n]\n\nclass Solution3(object):\n    def findSecretWord(self, wordlist, master):\n        \"\"\"\n        :type wordlist: List[Str]\n        :type master: Master\n        :rtype: None\n        \"\"\"\n        def solve(H, possible):\n            min_max_group, best_guess = possible, None\n            for guess in possible:\n                groups = [[] for _ in xrange(7)]\n                for j in possible:\n                    if j != guess:\n                        groups[H[guess][j]].append(j)\n                max_group = groups[0]\n                if len(max_group) < len(min_max_group):\n                    min_max_group, best_guess = max_group, guess\n            return best_guess\n\n        H = [[sum(a == b for a, b in itertools.izip(wordlist[i], wordlist[j]))\n                  for j in xrange(len(wordlist))]\n                  for i in xrange(len(wordlist))]\n        possible = range(len(wordlist))\n        n = 0\n        while n < 6:\n            guess = solve(H, possible)\n            n = master.guess(wordlist[guess])\n            possible = [j for j in possible if H[guess][j] == n]",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n)"
    }
  ],
  "Bit Manipulation": [
    {
      "title": "Single Number",
      "difficulty": "Easy",
      "category": "Bit Manipulation",
      "link": "https://leetcode.com/problems/single-number",
      "slug": "single-number",
      "description": "Given a \nnon-empty\n array of integers \nnums\n, every element appears \ntwice\n except for one. Find that single one.\n\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,2,1]\n\n\nOutput:\n \n1\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [4,1,2,1,2]\n\n\nOutput:\n \n4\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1]\n\n\nOutput:\n \n1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 3 * 10\n4\n\n\n-3 * 10\n4\n <= nums[i] <= 3 * 10\n4\n\n\nEach element in the array appears twice except for one element which appears only once.",
      "solution": "\nimport operator\nfrom functools import reduce\n\nclass Solution(object):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    def singleNumber(self, A):\n        return reduce(operator.xor, A)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Number of 1 Bits",
      "difficulty": "Easy",
      "category": "Bit Manipulation",
      "link": "https://leetcode.com/problems/number-of-1-bits",
      "slug": "number-of-1-bits",
      "description": "Given a positive integer \nn\n, write a function that returns the number of \nset bits\n in its binary representation (also known as the \nHamming weight\n).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 11\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\nThe input binary string \n1011\n has a total of three set bits.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 128\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nThe input binary string \n10000000\n has a total of one set bit.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nn = 2147483645\n\n\nOutput:\n \n30\n\n\nExplanation:\n\n\nThe input binary string \n1111111111111111111111111111101\n has a total of thirty set bits.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n If this function is called many times, how would you optimize it?",
      "solution": "#             , see https://github.com/python/cpython/blob/2.7/Objects/longobject.c#L3652\nclass Solution(object):\n    # @param n, an integer\n    # @return an integer\n    def hammingWeight(self, n):\n        n = (n & 0x55555555) + ((n >> 1) & 0x55555555)\n        n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\n        n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F)\n        n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF)\n        n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF)\n        return n\n\n\n# https://github.com/gcc-mirror/gcc/blob/master/libgcc/libgcc2.c#L856class Solution2(object):\n    def __init__(self):\n        self.__popcount_tab = \\\n        [ \\\n            0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5, \\\n            1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6, \\\n            1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6, \\\n            2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7, \\\n            1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6, \\\n            2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7, \\\n            2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7, \\\n            3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8 \\\n        ]\n\n    # @param n, an integer\n    # @return an integer\n    def hammingWeight(self, n):\n        result = 0\n        while n:\n            result += self.__popcount_tab[n & 0xff]\n            n >>= 8\n        return result\n\n    class Solution3(object):\n    # @param n, an integer\n    # @return an integer\n    def hammingWeight(self, n):\n        result = 0\n        while n:\n            n &= n - 1\n            result += 1\n        return result\nclass Solution4(object):\n    # @param n, an integer\n    # @return an integer\n    def hammingWeight(self, n: int) -> int:\n        b=\"{0:b}\".format(n)\n        result=b.count(\"1\")\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(logn) = O(32)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Counting Bits",
      "difficulty": "Easy",
      "category": "Bit Manipulation",
      "link": "https://leetcode.com/problems/counting-bits",
      "slug": "counting-bits",
      "description": "Given an integer \nn\n, return \nan array \nans\n of length \nn + 1\n such that for each \ni\n \n(\n0 <= i <= n\n)\n, \nans[i]\n is the \nnumber of \n1\n's\n in the binary representation of \ni\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n [0,1,1]\n\nExplanation:\n\n0 --> 0\n1 --> 1\n2 --> 10\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 5\n\nOutput:\n [0,1,1,2,1,2]\n\nExplanation:\n\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 10\n5\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nIt is very easy to come up with a solution with a runtime of \nO(n log n)\n. Can you do it in linear time \nO(n)\n and possibly in a single pass?\n\n\nCan you do it without using any built-in function (i.e., like \n__builtin_popcount\n in C++)?",
      "solution": "class Solution(object):\n    def countBits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: List[int]\n        \"\"\"\n        res = [0]\n        for i in xrange(1, num + 1):\n            # Number of 1's in i = (i & 1) + number of 1's in (i / 2).\n            res.append((i & 1) + res[i >> 1])\n        return res\n\n    def countBits2(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: List[int]\n        \"\"\"\n        s = [0]\n        while len(s) <= num:\n            s.extend(map(lambda x: x + 1, s))\n        return s[:num + 1]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Reverse Bits",
      "difficulty": "Easy",
      "category": "Bit Manipulation",
      "link": "https://leetcode.com/problems/reverse-bits",
      "slug": "reverse-bits",
      "description": "Reverse bits of a given 32 bits unsigned integer.\n\n\nNote:\n\n\n\n\nNote that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n\n\nIn Java, the compiler represents the signed integers using \n2's complement notation\n. Therefore, in \nExample 2\n below, the input represents the signed integer \n-3\n and the output represents the signed integer \n-1073741825\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nn = 43261596\n\n\nOutput:\n \n964176192\n\n\nExplanation:\n\n\n\n\n\n\n\n\nInteger\n\n\nBinary\n\n\n\n\n\n\n43261596\n\n\n00000010100101000001111010011100\n\n\n\n\n\n\n964176192\n\n\n00111001011110000010100101000000\n\n\n\n\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nn = 2147483644\n\n\nOutput:\n \n1073741822\n\n\nExplanation:\n\n\n\n\n\n\n\n\nInteger\n\n\nBinary\n\n\n\n\n\n\n2147483644\n\n\n01111111111111111111111111111100\n\n\n\n\n\n\n1073741822\n\n\n00111111111111111111111111111110\n\n\n\n\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 2\n31\n - 2\n\n\nn\n is even.\n\n\n\n\n \n\n\nFollow up:\n If this function is called many times, how would you optimize it?",
      "solution": "# Time : O(32)\nclass Solution(object):\n    # @param n, an integer\n    # @return an integer\n    def reverseBits(self, n):\n        n = (n >> 16) | (n << 16)\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8)\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4)\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2)\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1)\n        return n\n\n\n# Time : O(logn) = O(32)class Solution2(object):\n    # @param n, an integer\n    # @return an integer\n    def reverseBits(self, n):\n        result = 0\n        for i in xrange(32):\n            result <<= 1\n            result |= n & 1\n            n >>= 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "N/A",
      "space_complexity": "O(1)"
    },
    {
      "title": "Bitwise AND of Numbers Range",
      "difficulty": "Medium",
      "category": "Bit Manipulation",
      "link": "https://leetcode.com/problems/bitwise-and-of-numbers-range",
      "slug": "bitwise-and-of-numbers-range",
      "description": "Given two integers \nleft\n and \nright\n that represent the range \n[left, right]\n, return \nthe bitwise AND of all numbers in this range, inclusive\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n left = 5, right = 7\n\nOutput:\n 4\n\n\n\nExample 2:\n\n\n\n\nInput:\n left = 0, right = 0\n\nOutput:\n 0\n\n\n\nExample 3:\n\n\n\n\nInput:\n left = 1, right = 2147483647\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= left <= right <= 2\n31\n - 1",
      "solution": "class Solution(object):\n    # @param m, an integer\n    # @param n, an integer\n    # @return an integer\n    def rangeBitwiseAnd(self, m, n):\n        while m < n:\n            n &= n - 1\n        return n\n\nclass Solution2(object):\n    # @param m, an integer\n    # @param n, an integer\n    # @return an integer\n    def rangeBitwiseAnd(self, m, n):\n        i, diff = 0, n-m\n        while diff:\n            diff >>= 1\n            i += 1\n        return n & m >> i << i",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Single Number III",
      "difficulty": "Medium",
      "category": "Bit Manipulation",
      "link": "https://leetcode.com/problems/single-number-iii",
      "slug": "single-number-iii",
      "description": "Given an integer array \nnums\n, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in \nany order\n.\n\n\nYou must write an algorithm that runs in linear runtime complexity and uses only constant extra space.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,1,3,2,5]\n\nOutput:\n [3,5]\n\nExplanation: \n [5, 3] is also a valid answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-1,0]\n\nOutput:\n [-1,0]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [0,1]\n\nOutput:\n [1,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 3 * 10\n4\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\nEach integer in \nnums\n will appear twice, only two integers will appear once.",
      "solution": "\nimport operator\nimport collections\n\nclass Solution(object):\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def singleNumber(self, nums):\n        x_xor_y = reduce(operator.xor, nums)\n        bit =  x_xor_y & -x_xor_y\n        result = [0, 0]\n        for i in nums:\n            result[bool(i & bit)] ^= i\n        return result\n\nclass Solution2(object):\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def singleNumber(self, nums):\n        x_xor_y = 0\n        for i in nums:\n            x_xor_y ^= i\n\n        bit = x_xor_y & ~(x_xor_y - 1)\n\n        x = 0\n        for i in nums:\n            if i & bit:\n                x ^= i\n\n        return [x, x ^ x_xor_y]\n\nclass Solution3(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return [x[0] for x in sorted(collections.Counter(nums).items(), key=lambda i: i[1], reverse=False)[:2]]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Sum of Two Integers",
      "difficulty": "Medium",
      "category": "Bit Manipulation",
      "link": "https://leetcode.com/problems/sum-of-two-integers",
      "slug": "sum-of-two-integers",
      "description": "Given two integers \na\n and \nb\n, return \nthe sum of the two integers without using the operators\n \n+\n \nand\n \n-\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n a = 1, b = 2\n\nOutput:\n 3\n\nExample 2:\n\n\nInput:\n a = 2, b = 3\n\nOutput:\n 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-1000 <= a, b <= 1000",
      "solution": "class Solution(object):\n    def getSum(self, a, b):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :rtype: int\n        \"\"\"\n        bit_length = 32\n        neg_bit, mask = (1 << bit_length) >> 1, ~(~0 << bit_length)\n\n        a = (a | ~mask) if (a & neg_bit) else (a & mask)\n        b = (b | ~mask) if (b & neg_bit) else (b & mask)\n\n        while b:\n            carry = a & b\n            a ^= b\n            a = (a | ~mask) if (a & neg_bit) else (a & mask)\n            b = carry << 1\n            b = (b | ~mask) if (b & neg_bit) else (b & mask)\n\n        return a\n\n    def getSum2(self, a, b):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :rtype: int\n        \"\"\"\n        # 32 bits integer max\n        MAX = 0x7FFFFFFF\n        # 32 bits interger min\n        MIN = 0x80000000\n        # mask to get last 32 bits\n        mask = 0xFFFFFFFF\n        while b:\n            # ^ get different bits and & gets double 1s, << moves carry\n            a, b = (a ^ b) & mask, ((a & b) << 1) & mask\n        # if a is negative, get a's 32 bits complement positive first\n        # then get 32-bit positive's Python complement negative\n        return a if a <= MAX else ~(a ^ mask)\n\n    def minus(self, a, b):\n        b = self.getSum(~b, 1)\n        return self.getSum(a, b)\n\n    def multiply(self, a, b):\n        isNeg = (a > 0) ^ (b > 0)\n        x = a if a > 0 else self.getSum(~a, 1)\n        y = b if b > 0 else self.getSum(~b, 1)\n        ans = 0\n        while y & 0x01:\n            ans = self.getSum(ans, x)\n            y >>= 1\n            x <<= 1\n        return self.getSum(~ans, 1) if isNeg else ans\n\n    def divide(self, a, b):\n        isNeg = (a > 0) ^ (b > 0)\n        x = a if a > 0 else self.getSum(~a, 1)\n        y = b if b > 0 else self.getSum(~b, 1)\n        ans = 0\n        for i in range(31, -1, -1):\n            if (x >> i) >= y:\n                x = self.minus(x, y << i)\n                ans = self.getSum(ans, 1 << i)\n        return self.getSum(~ans, 1) if isNeg else ans",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    }
  ],
  "Hash Tables": [
    {
      "title": "Design HashMap",
      "difficulty": "Easy",
      "category": "Hash Tables",
      "link": "https://leetcode.com/problems/design-hashmap",
      "slug": "design-hashmap",
      "description": "Design a HashMap without using any built-in hash table libraries.\n\n\nImplement the \nMyHashMap\n class:\n\n\n\n\nMyHashMap()\n initializes the object with an empty map.\n\n\nvoid put(int key, int value)\n inserts a \n(key, value)\n pair into the HashMap. If the \nkey\n already exists in the map, update the corresponding \nvalue\n.\n\n\nint get(int key)\n returns the \nvalue\n to which the specified \nkey\n is mapped, or \n-1\n if this map contains no mapping for the \nkey\n.\n\n\nvoid remove(key)\n removes the \nkey\n and its corresponding \nvalue\n if the map contains the mapping for the \nkey\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]\n\nOutput\n\n[null, null, null, 1, -1, null, 1, null, -1]\n\n\nExplanation\n\nMyHashMap myHashMap = new MyHashMap();\nmyHashMap.put(1, 1); // The map is now [[1,1]]\nmyHashMap.put(2, 2); // The map is now [[1,1], [2,2]]\nmyHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]\nmyHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]\nmyHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)\nmyHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]\nmyHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]\nmyHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= key, value <= 10\n6\n\n\nAt most \n10\n4\n calls will be made to \nput\n, \nget\n, and \nremove\n.",
      "solution": "class ListNode(object):\n    def __init__(self, key, val):\n        self.val = val\n        self.key = key\n        self.next = None\n        self.prev = None\n\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\n\n    def find(self, key):\n        curr = self.head\n        while curr:\n            if curr.key == key:\n                break\n            curr = curr.next\n        return curr\n\nclass MyHashMap(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__data = [LinkedList() for _ in xrange(10000)]\n\n    def put(self, key, value):\n        \"\"\"\n        value will always be positive.\n        :type key: int\n        :type value: int\n        :rtype: void\n        \"\"\"\n        l = self.__data[key % len(self.__data)]\n        node = l.find(key)\n        if node:\n            node.val = value\n        else:\n            l.insert(ListNode(key, value))\n\n    def get(self, key):\n        \"\"\"\n        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key\n        :type key: int\n        :rtype: int\n        \"\"\"\n        l = self.__data[key % len(self.__data)]\n        node = l.find(key)\n        if node:\n            return node.val\n        else:\n            return -1\n\n    def remove(self, key):\n        \"\"\"\n        Removes the mapping of the specified value key if this map contains a mapping for the key\n        :type key: int\n        :rtype: void\n        \"\"\"\n        l = self.__data[key % len(self.__data)]\n        node = l.find(key)\n        if node:\n            l.delete(node)",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Maximum Number of Balloons",
      "difficulty": "Easy",
      "category": "Hash Tables",
      "link": "https://leetcode.com/problems/maximum-number-of-balloons",
      "slug": "maximum-number-of-balloons",
      "description": "Given a string \ntext\n, you want to use the characters of \ntext\n to form as many instances of the word \n\"balloon\"\n as possible.\n\n\nYou can use each character in \ntext\n \nat most once\n. Return the maximum number of instances that can be formed.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n text = \"nlaebolko\"\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n text = \"loonbalxballpoon\"\n\nOutput:\n 2\n\n\n\nExample 3:\n\n\n\n\nInput:\n text = \"leetcode\"\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= text.length <= 10\n4\n\n\ntext\n consists of lower case English letters only.\n\n\n\n\n \n\n\nNote:\n This question is the same as \n 2287: Rearrange Characters to Make Target String.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def maxNumberOfBalloons(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: int\n        \"\"\"\n        TARGET = \"balloon\"\n        source_count = collections.Counter(text)\n        target_count = collections.Counter(TARGET)\n        return min(source_count[c]//target_count[c] for c in target_count.iterkeys())",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Number of Good Pairs",
      "difficulty": "Easy",
      "category": "Hash Tables",
      "link": "https://leetcode.com/problems/number-of-good-pairs",
      "slug": "number-of-good-pairs",
      "description": "Given an array of integers \nnums\n, return \nthe number of \ngood pairs\n.\n\n\nA pair \n(i, j)\n is called \ngood\n if \nnums[i] == nums[j]\n and \ni\n < \nj\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,1,1,3]\n\nOutput:\n 4\n\nExplanation:\n There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,1,1,1]\n\nOutput:\n 6\n\nExplanation:\n Each pair in the array are \ngood\n.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n1 <= nums[i] <= 100",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def numIdenticalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(c*(c-1)//2 for c in collections.Counter(nums).itervalues())",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Isomorphic Strings",
      "difficulty": "Easy",
      "category": "Hash Tables",
      "link": "https://leetcode.com/problems/isomorphic-strings",
      "slug": "isomorphic-strings",
      "description": "Given two strings \ns\n and \nt\n, \ndetermine if they are isomorphic\n.\n\n\nTwo strings \ns\n and \nt\n are isomorphic if the characters in \ns\n can be replaced to get \nt\n.\n\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"egg\", t = \"add\"\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThe strings \ns\n and \nt\n can be made identical by:\n\n\n\n\nMapping \n'e'\n to \n'a'\n.\n\n\nMapping \n'g'\n to \n'd'\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"foo\", t = \"bar\"\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nThe strings \ns\n and \nt\n can not be made identical as \n'o'\n needs to be mapped to both \n'a'\n and \n'r'\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"paper\", t = \"title\"\n\n\nOutput:\n \ntrue\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 5 * 10\n4\n\n\nt.length == s.length\n\n\ns\n and \nt\n consist of any valid ascii character.",
      "solution": "\nfrom itertools import izip  # Generator version of zip.\nclass Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s) != len(t):\n            return False\n\n        s2t, t2s = {}, {}\n        for p, w in izip(s, t):\n            if w not in s2t and p not in t2s:\n                s2t[w] = p\n                t2s[p] = w\n            elif w not in s2t or s2t[w] != p:\n                # Contradict mapping.\n                return False\n        return True\n\nclass Solution2(object):\n    def isIsomorphic(self, s, t):\n        if len(s) != len(t):\n            return False\n\n        return self.halfIsom(s, t) and self.halfIsom(t, s)\n\n    def halfIsom(self, s, t):\n        lookup = {}\n        for i in xrange(len(s)):\n            if s[i] not in lookup:\n                lookup[s[i]] = t[i]\n            elif lookup[s[i]] != t[i]:\n                return False\n        return True",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Ransom Note",
      "difficulty": "Easy",
      "category": "Hash Tables",
      "link": "https://leetcode.com/problems/ransom-note",
      "slug": "ransom-note",
      "description": "Given two strings \nransomNote\n and \nmagazine\n, return \ntrue\n if \nransomNote\n can be constructed by using the letters from \nmagazine\n and \nfalse\n otherwise\n.\n\n\nEach letter in \nmagazine\n can only be used once in \nransomNote\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n ransomNote = \"a\", magazine = \"b\"\n\nOutput:\n false\n\nExample 2:\n\n\nInput:\n ransomNote = \"aa\", magazine = \"ab\"\n\nOutput:\n false\n\nExample 3:\n\n\nInput:\n ransomNote = \"aa\", magazine = \"aab\"\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= ransomNote.length, magazine.length <= 10\n5\n\n\nransomNote\n and \nmagazine\n consist of lowercase English letters.",
      "solution": "class Solution(object):\n    def canConstruct(self, ransomNote, magazine):\n        \"\"\"\n        :type ransomNote: str\n        :type magazine: str\n        :rtype: bool\n        \"\"\"\n        counts = [0] * 26\n        letters = 0\n\n        for c in ransomNote:\n            if counts[ord(c) - ord('a')] == 0:\n                letters += 1\n            counts[ord(c) - ord('a')] += 1\n\n        for c in magazine:\n            counts[ord(c) - ord('a')] -= 1\n            if counts[ord(c) - ord('a')] == 0:\n                letters -= 1\n                if letters == 0:\n                    break\n\n        return letters == 0\n\nimport collections\nclass Solution2(object):\n    def canConstruct(self, ransomNote, magazine):\n        \"\"\"\n        :type ransomNote: str\n        :type magazine: str\n        :rtype: bool\n        \"\"\"\n        return not collections.Counter(ransomNote) - collections.Counter(magazine)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Contains Duplicate II",
      "difficulty": "Easy",
      "category": "Hash Tables",
      "link": "https://leetcode.com/problems/contains-duplicate-ii",
      "slug": "contains-duplicate-ii",
      "description": "Given an integer array \nnums\n and an integer \nk\n, return \ntrue\n \nif there are two \ndistinct indices\n \ni\n and \nj\n in the array such that \nnums[i] == nums[j]\n and \nabs(i - j) <= k\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,1], k = 3\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,0,1,1], k = 1\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,2,3,1,2,3], k = 2\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n0 <= k <= 10\n5",
      "solution": "class Solution(object):\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {boolean}\n    def containsNearbyDuplicate(self, nums, k):\n        lookup = {}\n        for i, num in enumerate(nums):\n            if num not in lookup:\n                lookup[num] = i\n            else:\n                # If the value occurs before, check the difference.\n                if i - lookup[num] <= k:\n                    return True\n                # Update the index of the value.\n                lookup[num] = i\n        return False",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Group Anagrams",
      "difficulty": "Medium",
      "category": "Hash Tables",
      "link": "https://leetcode.com/problems/group-anagrams",
      "slug": "group-anagrams",
      "description": "Given an array of strings \nstrs\n, group the \nanagrams\n together. You can return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nstrs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n\n\nOutput:\n \n[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\n\nExplanation:\n\n\n\n\nThere is no string in strs that can be rearranged to form \n\"bat\"\n.\n\n\nThe strings \n\"nat\"\n and \n\"tan\"\n are anagrams as they can be rearranged to form each other.\n\n\nThe strings \n\"ate\"\n, \n\"eat\"\n, and \n\"tea\"\n are anagrams as they can be rearranged to form each other.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nstrs = [\"\"]\n\n\nOutput:\n \n[[\"\"]]\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nstrs = [\"a\"]\n\n\nOutput:\n \n[[\"a\"]]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 10\n4\n\n\n0 <= strs[i].length <= 100\n\n\nstrs[i]\n consists of lowercase English letters.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagrams_map, result = collections.defaultdict(list), []\n        for s in strs:\n            sorted_str = (\"\").join(sorted(s))\n            anagrams_map[sorted_str].append(s)\n        for anagram in anagrams_map.values():\n            anagram.sort()\n            result.append(anagram)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n * glogg), g is the max size of groups.",
      "space_complexity": "O(n)"
    },
    {
      "title": "Encode and Decode TinyURL",
      "difficulty": "Medium",
      "category": "Hash Tables",
      "link": "https://leetcode.com/problems/encode-and-decode-tinyurl",
      "slug": "encode-and-decode-tinyurl",
      "description": "Note: This is a companion problem to the \nSystem Design\n problem: \nDesign TinyURL\n.\n\n\nTinyURL is a URL shortening service where you enter a URL such as \nhttps://leetcode.com/problems/design-tinyurl\n and it returns a short URL such as \nhttp://tinyurl.com/4e9iAk\n. Design a class to encode a URL and decode a tiny URL.\n\n\nThere is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.\n\n\nImplement the \nSolution\n class:\n\n\n\n\nSolution()\n Initializes the object of the system.\n\n\nString encode(String longUrl)\n Returns a tiny URL for the given \nlongUrl\n.\n\n\nString decode(String shortUrl)\n Returns the original long URL for the given \nshortUrl\n. It is guaranteed that the given \nshortUrl\n was encoded by the same object.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n url = \"https://leetcode.com/problems/design-tinyurl\"\n\nOutput:\n \"https://leetcode.com/problems/design-tinyurl\"\n\n\nExplanation:\n\nSolution obj = new Solution();\nstring tiny = obj.encode(url); // returns the encoded tiny url.\nstring ans = obj.decode(tiny); // returns the original url after decoding it.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= url.length <= 10\n4\n\n\nurl\n is guranteed to be a valid URL.",
      "solution": "\nimport random\n\nclass Codec(object):\n    def __init__(self):\n        self.__random_length = 6\n        self.__tiny_url = \"http://tinyurl.com/\"\n        self.__alphabet = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        self.__lookup = {}\n\n    def encode(self, longUrl):\n        \"\"\"Encodes a URL to a shortened URL.\n\n        :type longUrl: str\n        :rtype: str\n        \"\"\"\n        def getRand():\n            rand = []\n            for _ in xrange(self.__random_length):\n                rand += self.__alphabet[random.randint(0, len(self.__alphabet)-1)]\n            return \"\".join(rand)\n\n        key = getRand()\n        while key in self.__lookup:\n            key = getRand()\n        self.__lookup[key] = longUrl\n        return self.__tiny_url + key\n\n    def decode(self, shortUrl):\n        \"\"\"Decodes a shortened URL to its original URL.\n\n        :type shortUrl: str\n        :rtype: str\n        \"\"\"\n        return self.__lookup[shortUrl[len(self.__tiny_url):]]\n\n\nfrom hashlib import sha256\n\nclass Codec2(object):\n\n    def __init__(self):\n        self._cache = {}\n        self.url = 'http://tinyurl.com/'\n\n    def encode(self, long_url):\n        \"\"\"Encodes a URL to a shortened URL.\n\n        :type long_url: str\n        :rtype: str\n        \"\"\"\n        key = sha256(long_url.encode()).hexdigest()[:6]\n        self._cache[key] = long_url\n        return self.url + key\n\n    def decode(self, short_url):\n        \"\"\"Decodes a shortened URL to its original URL.\n\n        :type short_url: str\n        :rtype: str\n        \"\"\"\n        key = short_url.replace(self.url, '')\n        return self._cache[key]",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Reorganize String",
      "difficulty": "Medium",
      "category": "Hash Tables",
      "link": "https://leetcode.com/problems/reorganize-string",
      "slug": "reorganize-string",
      "description": "Given a string \ns\n, rearrange the characters of \ns\n so that any two adjacent characters are not the same.\n\n\nReturn \nany possible rearrangement of\n \ns\n \nor return\n \n\"\"\n \nif not possible\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"aab\"\n\nOutput:\n \"aba\"\n\nExample 2:\n\n\nInput:\n s = \"aaab\"\n\nOutput:\n \"\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 500\n\n\ns\n consists of lowercase English letters.",
      "solution": "class Solution:\n    def reorganizeString(self, s: str) -> str:\n        freq = {}\n        \n        for ch in s:\n            freq[ch] = freq.get(ch, 0) + 1\n        \n        max_heap = [(-freq, key) for key, freq in freq.items()]\n        heapq.heapify(max_heap)\n\n        prev_freq = 0\n        prev_val = \"\"\n        res = []\n\n        while max_heap:\n            freq, val = heapq.heappop(max_heap)\n            res.append(val)\n\n            if prev_freq < 0:\n                heapq.heappush(max_heap, (prev_freq, prev_val))\n\n            freq += 1\n            prev_freq = freq\n            prev_val = val\n\n        return \"\".join(res) if len(res) == len(s) else \"\"",
      "explanation": "N/A",
      "time_complexity": "O(nloga) = O(n), a is the size of alphabet",
      "space_complexity": "O(a) = O(1)"
    },
    {
      "title": "Longest Consecutive Sequence",
      "difficulty": "Medium",
      "category": "Hash Tables",
      "link": "https://leetcode.com/problems/longest-consecutive-sequence",
      "slug": "longest-consecutive-sequence",
      "description": "Given an unsorted array of integers \nnums\n, return \nthe length of the longest consecutive elements sequence.\n\n\nYou must write an algorithm that runs in \nO(n)\n time.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [100,4,200,1,3,2]\n\nOutput:\n 4\n\nExplanation:\n The longest consecutive elements sequence is \n[1, 2, 3, 4]\n. Therefore its length is 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,3,7,2,5,8,4,6,0,1]\n\nOutput:\n 9\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,0,1,2]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9",
      "solution": "class Solution(object):\n    # @param num, a list of integer\n    # @return an integer\n    def longestConsecutive(self, num):\n        result, lengths = 1, {key: 0 for key in num}\n        for i in num:\n            if lengths[i] == 0:\n                lengths[i] = 1\n                left, right = lengths.get(i - 1, 0), lengths.get(i + 1, 0)\n                length = 1 + left + right\n                result, lengths[i - left], lengths[i + right] = max(result, length), length, length\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Split Array into Consecutive Subsequences",
      "difficulty": "Medium",
      "category": "Hash Tables",
      "link": "https://leetcode.com/problems/split-array-into-consecutive-subsequences",
      "slug": "split-array-into-consecutive-subsequences",
      "description": "You are given an integer array \nnums\n that is \nsorted in non-decreasing order\n.\n\n\nDetermine if it is possible to split \nnums\n into \none or more subsequences\n such that \nboth\n of the following conditions are true:\n\n\n\n\nEach subsequence is a \nconsecutive increasing sequence\n (i.e. each integer is \nexactly one\n more than the previous integer).\n\n\nAll subsequences have a length of \n3\n or more\n.\n\n\n\n\nReturn \ntrue\n if you can split \nnums\n according to the above conditions, or \nfalse\n otherwise\n.\n\n\nA \nsubsequence\n of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., \n[1,3,5]\n is a subsequence of \n[\n1\n,2,\n3\n,4,\n5\n]\n while \n[1,3,2]\n is not).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,3,4,5]\n\nOutput:\n true\n\nExplanation:\n nums can be split into the following subsequences:\n[\n1\n,\n2\n,\n3\n,3,4,5] --> 1, 2, 3\n[1,2,3,\n3\n,\n4\n,\n5\n] --> 3, 4, 5\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,3,3,4,4,5,5]\n\nOutput:\n true\n\nExplanation:\n nums can be split into the following subsequences:\n[\n1\n,\n2\n,\n3\n,3,\n4\n,4,\n5\n,5] --> 1, 2, 3, 4, 5\n[1,2,3,\n3\n,4,\n4\n,5,\n5\n] --> 3, 4, 5\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,2,3,4,4,5]\n\nOutput:\n false\n\nExplanation:\n It is impossible to split nums into consecutive increasing subsequences of length 3 or more.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-1000 <= nums[i] <= 1000\n\n\nnums\n is sorted in \nnon-decreasing\n order.",
      "solution": "class Solution(object):\n    def isPossible(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        pre, cur = float(\"-inf\"), 0\n        cnt1, cnt2, cnt3 = 0, 0, 0\n        i = 0\n        while i < len(nums):\n            cnt = 0\n            cur = nums[i]\n            while i < len(nums) and cur == nums[i]:\n                cnt += 1\n                i += 1\n\n            if cur != pre + 1:\n                if cnt1 != 0 or cnt2 != 0:\n                    return False\n                cnt1, cnt2, cnt3 = cnt, 0, 0\n            else:\n                if cnt < cnt1 + cnt2:\n                    return False\n                cnt1, cnt2, cnt3 = max(0, cnt - (cnt1 + cnt2 + cnt3)), \\\n                                   cnt1, \\\n                                   cnt2 + min(cnt3, cnt - (cnt1 + cnt2))\n            pre = cur\n        return cnt1 == 0 and cnt2 == 0",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Number of Matching Subsequences",
      "difficulty": "Medium",
      "category": "Hash Tables",
      "link": "https://leetcode.com/problems/number-of-matching-subsequences",
      "slug": "number-of-matching-subsequences",
      "description": "Given a string \ns\n and an array of strings \nwords\n, return \nthe number of\n \nwords[i]\n \nthat is a subsequence of\n \ns\n.\n\n\nA \nsubsequence\n of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n\n\n\nFor example, \n\"ace\"\n is a subsequence of \n\"abcde\"\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abcde\", words = [\"a\",\"bb\",\"acd\",\"ace\"]\n\nOutput:\n 3\n\nExplanation:\n There are three strings in words that are a subsequence of s: \"a\", \"acd\", \"ace\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"dsahjpjauf\", words = [\"ahjpjau\",\"ja\",\"ahbwzgqnuk\",\"tnmlanowax\"]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 5 * 10\n4\n\n\n1 <= words.length <= 5000\n\n\n1 <= words[i].length <= 50\n\n\ns\n and \nwords[i]\n consist of only lowercase English letters.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def numMatchingSubseq(self, S, words):\n        \"\"\"\n        :type S: str\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        waiting = collections.defaultdict(list)\n        for word in words:\n            it = iter(word)\n            waiting[next(it, None)].append(it)\n        for c in S:\n            for it in waiting.pop(c, ()):\n                waiting[next(it, None)].append(it)\n        return len(waiting[None])",
      "explanation": "N/A",
      "time_complexity": "O(n + w), n is the size of S, w is the size of words",
      "space_complexity": "O(k), k is the number of words"
    },
    {
      "title": "Number of Good Ways to Split a String",
      "difficulty": "Medium",
      "category": "Hash Tables",
      "link": "https://leetcode.com/problems/number-of-good-ways-to-split-a-string",
      "slug": "number-of-good-ways-to-split-a-string",
      "description": "You are given a string \ns\n.\n\n\nA split is called \ngood\n if you can split \ns\n into two non-empty strings \ns\nleft\n and \ns\nright\n where their concatenation is equal to \ns\n (i.e., \ns\nleft\n + s\nright\n = s\n) and the number of distinct letters in \ns\nleft\n and \ns\nright\n is the same.\n\n\nReturn \nthe number of \ngood splits\n you can make in \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"aacaba\"\n\nOutput:\n 2\n\nExplanation:\n There are 5 ways to split \n\"aacaba\"\n and 2 of them are good. \n(\"a\", \"acaba\") Left string and right string contains 1 and 3 different letters respectively.\n(\"aa\", \"caba\") Left string and right string contains 1 and 3 different letters respectively.\n(\"aac\", \"aba\") Left string and right string contains 2 and 2 different letters respectively (good split).\n(\"aaca\", \"ba\") Left string and right string contains 2 and 2 different letters respectively (good split).\n(\"aacab\", \"a\") Left string and right string contains 3 and 1 different letters respectively.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abcd\"\n\nOutput:\n 1\n\nExplanation:\n Split the string as follows (\"ab\", \"cd\").\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns\n consists of only lowercase English letters.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def numSplits(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        left_count, right_count = collections.Counter(), collections.Counter(s)\n        result = 0\n        for c in s:\n            left_count[c] += 1\n            right_count[c] -= 1\n            if not right_count[c]:\n                del right_count[c]\n            if len(left_count) == len(right_count):\n                result += 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    }
  ],
  "Two Pointers": [
    {
      "title": "Merge Sorted Array",
      "difficulty": "Easy",
      "category": "Two Pointers",
      "link": "https://leetcode.com/problems/merge-sorted-array",
      "slug": "merge-sorted-array",
      "description": "You are given two integer arrays \nnums1\n and \nnums2\n, sorted in \nnon-decreasing order\n, and two integers \nm\n and \nn\n, representing the number of elements in \nnums1\n and \nnums2\n respectively.\n\n\nMerge\n \nnums1\n and \nnums2\n into a single array sorted in \nnon-decreasing order\n.\n\n\nThe final sorted array should not be returned by the function, but instead be \nstored inside the array \nnums1\n. To accommodate this, \nnums1\n has a length of \nm + n\n, where the first \nm\n elements denote the elements that should be merged, and the last \nn\n elements are set to \n0\n and should be ignored. \nnums2\n has a length of \nn\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n\nOutput:\n [1,2,2,3,5,6]\n\nExplanation:\n The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [\n1\n,\n2\n,2,\n3\n,5,6] with the underlined elements coming from nums1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1], m = 1, nums2 = [], n = 0\n\nOutput:\n [1]\n\nExplanation:\n The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums1 = [0], m = 0, nums2 = [1], n = 1\n\nOutput:\n [1]\n\nExplanation:\n The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m + n\n\n\nnums2.length == n\n\n\n0 <= m, n <= 200\n\n\n1 <= m + n <= 200\n\n\n-10\n9\n <= nums1[i], nums2[j] <= 10\n9\n\n\n\n\n \n\n\nFollow up: \nCan you come up with an algorithm that runs in \nO(m + n)\n time?",
      "solution": "class Solution(object):\n    # @param A  a list of integers\n    # @param m  an integer, length of A\n    # @param B  a list of integers\n    # @param n  an integer, length of B\n    # @return nothing\n    def merge(self, A, m, B, n):\n        last, i, j = m + n - 1, m - 1, n - 1\n\n        while i >= 0 and j >= 0:\n            if A[i] > B[j]:\n                A[last] = A[i]\n                last, i = last - 1, i - 1\n            else:\n                A[last] = B[j]\n                last, j = last - 1, j - 1\n\n        while j >= 0:\n                A[last] = B[j]\n                last, j = last - 1, j - 1",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Two Sum II - Input Array Is Sorted",
      "difficulty": "Medium",
      "category": "Two Pointers",
      "link": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted",
      "slug": "two-sum-ii-input-array-is-sorted",
      "description": "Given a \n1-indexed\n array of integers \nnumbers\n that is already \nsorted in non-decreasing order\n, find two numbers such that they add up to a specific \ntarget\n number. Let these two numbers be \nnumbers[index\n1\n]\n and \nnumbers[index\n2\n]\n where \n1 <= index\n1\n < index\n2\n <= numbers.length\n.\n\n\nReturn\n the indices of the two numbers, \nindex\n1\n and \nindex\n2\n, \nadded by one\n as an integer array \n[index\n1\n, index\n2\n]\n of length 2.\n\n\nThe tests are generated such that there is \nexactly one solution\n. You \nmay not\n use the same element twice.\n\n\nYour solution must use only constant extra space.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n numbers = [\n2\n,\n7\n,11,15], target = 9\n\nOutput:\n [1,2]\n\nExplanation:\n The sum of 2 and 7 is 9. Therefore, index\n1\n = 1, index\n2\n = 2. We return [1, 2].\n\n\n\nExample 2:\n\n\n\n\nInput:\n numbers = [\n2\n,3,\n4\n], target = 6\n\nOutput:\n [1,3]\n\nExplanation:\n The sum of 2 and 4 is 6. Therefore index\n1\n = 1, index\n2\n = 3. We return [1, 3].\n\n\n\nExample 3:\n\n\n\n\nInput:\n numbers = [\n-1\n,\n0\n], target = -1\n\nOutput:\n [1,2]\n\nExplanation:\n The sum of -1 and 0 is -1. Therefore index\n1\n = 1, index\n2\n = 2. We return [1, 2].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= numbers.length <= 3 * 10\n4\n\n\n-1000 <= numbers[i] <= 1000\n\n\nnumbers\n is sorted in \nnon-decreasing order\n.\n\n\n-1000 <= target <= 1000\n\n\nThe tests are generated such that there is \nexactly one solution\n.",
      "solution": "class Solution(object):\n    def twoSum(self, nums, target):\n        start, end = 0, len(nums) - 1\n\n        while start != end:\n            sum = nums[start] + nums[end]\n            if sum > target:\n                end -= 1\n            elif sum < target:\n                start += 1\n            else:\n                return [start + 1, end + 1]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Container With Most Water",
      "difficulty": "Medium",
      "category": "Two Pointers",
      "link": "https://leetcode.com/problems/container-with-most-water",
      "slug": "container-with-most-water",
      "description": "You are given an integer array \nheight\n of length \nn\n. There are \nn\n vertical lines drawn such that the two endpoints of the \ni\nth\n line are \n(i, 0)\n and \n(i, height[i])\n.\n\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\n\nReturn \nthe maximum amount of water a container can store\n.\n\n\nNotice\n that you may not slant the container.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [1,8,6,2,5,4,8,3,7]\n\nOutput:\n 49\n\nExplanation:\n The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [1,1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= height[i] <= 10\n4",
      "solution": "class Solution(object):\n    # @return an integer\n    def maxArea(self, height):\n        max_area, i, j = 0, 0, len(height) - 1\n        while i < j:\n            max_area = max(max_area, min(height[i], height[j]) * (j - i))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return max_area",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "3Sum",
      "difficulty": "Medium",
      "category": "Two Pointers",
      "link": "https://leetcode.com/problems/3Sum",
      "slug": "3Sum",
      "description": "Given an integer array nums, return all the triplets \n[nums[i], nums[j], nums[k]]\n such that \ni != j\n, \ni != k\n, and \nj != k\n, and \nnums[i] + nums[j] + nums[k] == 0\n.\n\n\nNotice that the solution set must not contain duplicate triplets.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-1,0,1,2,-1,-4]\n\nOutput:\n [[-1,-1,2],[-1,0,1]]\n\nExplanation:\n \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,1,1]\n\nOutput:\n []\n\nExplanation:\n The only possible triplet does not sum up to 0.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [0,0,0]\n\nOutput:\n [[0,0,0]]\n\nExplanation:\n The only possible triplet sums up to 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= nums.length <= 3000\n\n\n-10\n5\n <= nums[i] <= 10\n5",
      "solution": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        nums.sort()\n        for i in reversed(xrange(2, len(nums))):\n            if i+1 < len(nums) and nums[i] == nums[i+1]:\n                continue\n            target = -nums[i]\n            left, right = 0, i-1\n            while left < right:\n                if nums[left]+nums[right] < target:\n                    left += 1\n                elif nums[left]+nums[right] > target:\n                    right -= 1\n                else:\n                    result.append([nums[left], nums[right], nums[i]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left-1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right+1]:\n                        right -= 1\n        return result\n\nclass Solution2(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, i = sorted(nums), [], 0\n        while i < len(nums) - 2:\n            if i == 0 or nums[i] != nums[i - 1]:\n                j, k = i + 1, len(nums) - 1\n                while j < k:\n                    if nums[i] + nums[j] + nums[k] < 0:\n                        j += 1\n                    elif nums[i] + nums[j] + nums[k] > 0:\n                        k -= 1\n                    else:\n                        result.append([nums[i], nums[j], nums[k]])\n                        j, k = j + 1, k - 1\n                        while j < k and nums[j] == nums[j - 1]:\n                            j += 1\n                        while j < k and nums[k] == nums[k + 1]:\n                            k -= 1\n            i += 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Trapping Rain Water",
      "difficulty": "Hard",
      "category": "Two Pointers",
      "link": "https://leetcode.com/problems/trapping-rain-water",
      "slug": "trapping-rain-water",
      "description": "Given \nn\n non-negative integers representing an elevation map where the width of each bar is \n1\n, compute how much water it can trap after raining.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [0,1,0,2,1,0,1,3,2,1,2,1]\n\nOutput:\n 6\n\nExplanation:\n The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [4,2,0,3,2,5]\n\nOutput:\n 9\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n1 <= n <= 2 * 10\n4\n\n\n0 <= height[i] <= 10\n5",
      "solution": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        l, r = 0, len(height) - 1\n        lm, rm = height[l], height[r]\n        water = 0\n        while l < r:\n            if lm < rm:\n                l += 1\n                lm = max(lm, height[l])\n                water += lm - height[l] \n            else:\n                r -= 1\n                rm = max(rm, height[r])\n                water += rm - height[r]\n        \n        return water",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    }
  ],
  "Prefix Sum": [
    {
      "title": "Range Sum Query - Immutable",
      "difficulty": "Easy",
      "category": "Prefix Sum",
      "link": "https://leetcode.com/problems/range-sum-query-immutable",
      "slug": "range-sum-query-immutable",
      "description": "Given an integer array \nnums\n, handle multiple queries of the following type:\n\n\n\n\nCalculate the \nsum\n of the elements of \nnums\n between indices \nleft\n and \nright\n \ninclusive\n where \nleft <= right\n.\n\n\n\n\nImplement the \nNumArray\n class:\n\n\n\n\nNumArray(int[] nums)\n Initializes the object with the integer array \nnums\n.\n\n\nint sumRange(int left, int right)\n Returns the \nsum\n of the elements of \nnums\n between indices \nleft\n and \nright\n \ninclusive\n (i.e. \nnums[left] + nums[left + 1] + ... + nums[right]\n).\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n\nOutput\n\n[null, 1, -1, -3]\n\n\nExplanation\n\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n5\n <= nums[i] <= 10\n5\n\n\n0 <= left <= right < nums.length\n\n\nAt most \n10\n4\n calls will be made to \nsumRange\n.",
      "solution": "#        lookup: O(1)\nclass NumArray(object):\n    def __init__(self, nums):\n        \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n        self.accu = [0]\n        for num in nums:\n            self.accu.append(self.accu[-1] + num),\n\n    def sumRange(self, i, j):\n        \"\"\"\n        sum of elements nums[i..j], inclusive.\n        :type i: int\n        :type j: int\n        :rtype: int\n        \"\"\"\n        return self.accu[j + 1] - self.accu[i]",
      "explanation": "N/A",
      "time_complexity": "ctor:   O(n),",
      "space_complexity": "O(n)"
    },
    {
      "title": "Subarray Sum Equals K",
      "difficulty": "Medium",
      "category": "Prefix Sum",
      "link": "https://leetcode.com/problems/subarray-sum-equals-k",
      "slug": "subarray-sum-equals-k",
      "description": "Given an array of integers \nnums\n and an integer \nk\n, return \nthe total number of subarrays whose sum equals to\n \nk\n.\n\n\nA subarray is a contiguous \nnon-empty\n sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,1,1], k = 2\n\nOutput:\n 2\n\nExample 2:\n\n\nInput:\n nums = [1,2,3], k = 3\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2 * 10\n4\n\n\n-1000 <= nums[i] <= 1000\n\n\n-10\n7\n <= k <= 10\n7",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def subarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        accumulated_sum = 0\n        lookup = collections.defaultdict(int)\n        lookup[0] += 1\n        for num in nums:\n            accumulated_sum += num\n            result += lookup[accumulated_sum - k]\n            lookup[accumulated_sum] += 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Subarray Sums Divisible by K",
      "difficulty": "Medium",
      "category": "Prefix Sum",
      "link": "https://leetcode.com/problems/subarray-sums-divisible-by-k",
      "slug": "subarray-sums-divisible-by-k",
      "description": "Given an integer array \nnums\n and an integer \nk\n, return \nthe number of non-empty \nsubarrays\n that have a sum divisible by \nk\n.\n\n\nA \nsubarray\n is a \ncontiguous\n part of an array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [4,5,0,-2,-3,1], k = 5\n\nOutput:\n 7\n\nExplanation:\n There are 7 subarrays with a sum divisible by k = 5:\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [5], k = 9\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 3 * 10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n2 <= k <= 10\n4",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def subarraysDivByK(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        count = collections.defaultdict(int)\n        count[0] = 1\n        result, prefix = 0, 0\n        for a in A:\n            prefix = (prefix+a) % K\n            result += count[prefix]\n            count[prefix] += 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Continuous Subarray Sum",
      "difficulty": "Medium",
      "category": "Prefix Sum",
      "link": "https://leetcode.com/problems/continuous-subarray-sum",
      "slug": "continuous-subarray-sum",
      "description": "Given an integer array nums and an integer k, return \ntrue\n \nif \nnums\n has a \ngood subarray\n or \nfalse\n otherwise\n.\n\n\nA \ngood subarray\n is a subarray where:\n\n\n\n\nits length is \nat least two\n, and\n\n\nthe sum of the elements of the subarray is a multiple of \nk\n.\n\n\n\n\nNote\n that:\n\n\n\n\nA \nsubarray\n is a contiguous part of the array.\n\n\nAn integer \nx\n is a multiple of \nk\n if there exists an integer \nn\n such that \nx = n * k\n. \n0\n is \nalways\n a multiple of \nk\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [23,\n2,4\n,6,7], k = 6\n\nOutput:\n true\n\nExplanation:\n [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [\n23,2,6,4,7\n], k = 6\n\nOutput:\n true\n\nExplanation:\n [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.\n42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [23,2,6,4,7], k = 13\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n0 <= nums[i] <= 10\n9\n\n\n0 <= sum(nums[i]) <= 2\n31\n - 1\n\n\n1 <= k <= 2\n31\n - 1",
      "solution": "class Solution(object):\n    def checkSubarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        count = 0\n        lookup = {0: -1}\n        for i, num in enumerate(nums):\n            count += num\n            if k:\n                count %= k\n            if count in lookup:\n                if i - lookup[count] > 1:\n                    return True\n            else:\n                lookup[count] = i\n\n        return False",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Contiguous Array",
      "difficulty": "Medium",
      "category": "Prefix Sum",
      "link": "https://leetcode.com/problems/contiguous-array",
      "slug": "contiguous-array",
      "description": "Given a binary array \nnums\n, return \nthe maximum length of a contiguous subarray with an equal number of \n0\n and \n1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [0,1]\n\nOutput:\n 2\n\nExplanation:\n [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,1,0]\n\nOutput:\n 2\n\nExplanation:\n [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [0,1,1,1,1,1,0,0,0]\n\nOutput:\n 6\n\nExplanation:\n [1,1,1,0,0,0] is the longest contiguous subarray with equal number of 0 and 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\nnums[i]\n is either \n0\n or \n1\n.",
      "solution": "class Solution(object):\n    def findMaxLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, count = 0, 0\n        lookup = {0: -1}\n        for i, num in enumerate(nums):\n            count += 1 if num == 1 else -1\n            if count in lookup:\n                result = max(result, i - lookup[count])\n            else:\n                lookup[count] = i\n\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    }
  ],
  "Sliding Window - Fixed Size": [
    {
      "title": "Maximum Average Subarray I",
      "difficulty": "Easy",
      "category": "Sliding Window - Fixed Size",
      "link": "https://leetcode.com/problems/maximum-average-subarray-i",
      "slug": "maximum-average-subarray-i",
      "description": "You are given an integer array \nnums\n consisting of \nn\n elements, and an integer \nk\n.\n\n\nFind a contiguous subarray whose \nlength is equal to\n \nk\n that has the maximum average value and return \nthis value\n. Any answer with a calculation error less than \n10\n-5\n will be accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,12,-5,-6,50,3], k = 4\n\nOutput:\n 12.75000\n\nExplanation:\n Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [5], k = 1\n\nOutput:\n 5.00000\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= k <= n <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4",
      "solution": "class Solution(object):\n    def findMaxAverage(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: float\n        \"\"\"\n        result = total = sum(nums[:k])\n        for i in xrange(k, len(nums)):\n            total += nums[i] - nums[i-k]\n            result = max(result, total)\n        return float(result) / k",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Find All Anagrams in a String",
      "difficulty": "Medium",
      "category": "Sliding Window - Fixed Size",
      "link": "https://leetcode.com/problems/find-all-anagrams-in-a-string",
      "slug": "find-all-anagrams-in-a-string",
      "description": "Given two strings \ns\n and \np\n, return an array of all the start indices of \np\n's \nanagrams\n in \ns\n. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"cbaebabacd\", p = \"abc\"\n\nOutput:\n [0,6]\n\nExplanation:\n\nThe substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abab\", p = \"ab\"\n\nOutput:\n [0,1,2]\n\nExplanation:\n\nThe substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\nThe substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\nThe substring with start index = 2 is \"ab\", which is an anagram of \"ab\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length, p.length <= 3 * 10\n4\n\n\ns\n and \np\n consist of lowercase English letters.",
      "solution": "class Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[int]\n        \"\"\"\n        result = []\n\n        cnts = [0] * 26\n        for c in p:\n            cnts[ord(c) - ord('a')] += 1\n\n        left, right = 0, 0\n        while right < len(s):\n            cnts[ord(s[right]) - ord('a')] -= 1\n            while left <= right and cnts[ord(s[right]) - ord('a')] < 0:\n                cnts[ord(s[left]) - ord('a')] += 1\n                left += 1\n            if right - left + 1 == len(p):\n                result.append(left)\n            right += 1\n\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Permutation in String",
      "difficulty": "Medium",
      "category": "Sliding Window - Fixed Size",
      "link": "https://leetcode.com/problems/permutation-in-string",
      "slug": "permutation-in-string",
      "description": "Given two strings \ns1\n and \ns2\n, return \ntrue\n if \ns2\n contains a \npermutation\n of \ns1\n, or \nfalse\n otherwise.\n\n\nIn other words, return \ntrue\n if one of \ns1\n's permutations is the substring of \ns2\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s1 = \"ab\", s2 = \"eidbaooo\"\n\nOutput:\n true\n\nExplanation:\n s2 contains one permutation of s1 (\"ba\").\n\n\n\nExample 2:\n\n\n\n\nInput:\n s1 = \"ab\", s2 = \"eidboaoo\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s1.length, s2.length <= 10\n4\n\n\ns1\n and \ns2\n consist of lowercase English letters.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def checkInclusion(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        counts = collections.Counter(s1)\n        l = len(s1)\n        for i in xrange(len(s2)):\n            if counts[s2[i]] > 0:\n                l -= 1\n            counts[s2[i]] -= 1\n            if l == 0:\n                return True\n            start = i + 1 - len(s1)\n            if start >= 0:\n                counts[s2[start]] += 1\n                if counts[s2[start]] > 0:\n                    l += 1\n        return False",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Maximum Sum of Distinct Subarrays With Length K",
      "difficulty": "Medium",
      "category": "Sliding Window - Fixed Size",
      "link": "https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k",
      "slug": "maximum-sum-of-distinct-subarrays-with-length-k",
      "description": "You are given an integer array \nnums\n and an integer \nk\n. Find the maximum subarray sum of all the subarrays of \nnums\n that meet the following conditions:\n\n\n\n\nThe length of the subarray is \nk\n, and\n\n\nAll the elements of the subarray are \ndistinct\n.\n\n\n\n\nReturn \nthe maximum subarray sum of all the subarrays that meet the conditions\n.\n If no subarray meets the conditions, return \n0\n.\n\n\nA \nsubarray\n is a contiguous non-empty sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,5,4,2,9,9,9], k = 3\n\nOutput:\n 15\n\nExplanation:\n The subarrays of nums with length 3 are:\n- [1,5,4] which meets the requirements and has a sum of 10.\n- [5,4,2] which meets the requirements and has a sum of 11.\n- [4,2,9] which meets the requirements and has a sum of 15.\n- [2,9,9] which does not meet the requirements because the element 9 is repeated.\n- [9,9,9] which does not meet the requirements because the element 9 is repeated.\nWe return 15 because it is the maximum subarray sum of all the subarrays that meet the conditions\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [4,4,4], k = 3\n\nOutput:\n 0\n\nExplanation:\n The subarrays of nums with length 3 are:\n- [4,4,4] which does not meet the requirements because the element 4 is repeated.\nWe return 0 because no subarrays meet the conditions.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= nums.length <= 10\n5\n\n\n1 <= nums[i] <= 10\n5",
      "solution": "\n# two pointersclass Solution(object):\n    def maximumSubarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = left = total = 0\n        lookup = set()\n        for right in xrange(len(nums)):\n            while nums[right] in lookup or len(lookup) == k:\n                lookup.remove(nums[left])\n                total -= nums[left]\n                left += 1\n            lookup.add(nums[right])\n            total += nums[right]\n            if len(lookup) == k:\n                result = max(result, total)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Substring with Concatenation of All Words",
      "difficulty": "Hard",
      "category": "Sliding Window - Fixed Size",
      "link": "https://leetcode.com/problems/substring-with-concatenation-of-all-words",
      "slug": "substring-with-concatenation-of-all-words",
      "description": "You are given a string \ns\n and an array of strings \nwords\n. All the strings of \nwords\n are of \nthe same length\n.\n\n\nA \nconcatenated string\n is a string that exactly contains all the strings of any permutation of \nwords\n concatenated.\n\n\n\n\nFor example, if \nwords = [\"ab\",\"cd\",\"ef\"]\n, then \n\"abcdef\"\n, \n\"abefcd\"\n, \n\"cdabef\"\n, \n\"cdefab\"\n, \n\"efabcd\"\n, and \n\"efcdab\"\n are all concatenated strings. \n\"acdbef\"\n is not a concatenated string because it is not the concatenation of any permutation of \nwords\n.\n\n\n\n\nReturn an array of \nthe starting indices\n of all the concatenated substrings in \ns\n. You can return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n\n\nOutput:\n \n[0,9]\n\n\nExplanation:\n\n\nThe substring starting at 0 is \n\"barfoo\"\n. It is the concatenation of \n[\"bar\",\"foo\"]\n which is a permutation of \nwords\n.\n\nThe substring starting at 9 is \n\"foobar\"\n. It is the concatenation of \n[\"foo\",\"bar\"]\n which is a permutation of \nwords\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n\n\nOutput:\n \n[]\n\n\nExplanation:\n\n\nThere is no concatenated substring.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n\n\nOutput:\n \n[6,9,12]\n\n\nExplanation:\n\n\nThe substring starting at 6 is \n\"foobarthe\"\n. It is the concatenation of \n[\"foo\",\"bar\",\"the\"]\n.\n\nThe substring starting at 9 is \n\"barthefoo\"\n. It is the concatenation of \n[\"bar\",\"the\",\"foo\"]\n.\n\nThe substring starting at 12 is \n\"thefoobar\"\n. It is the concatenation of \n[\"the\",\"foo\",\"bar\"]\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\n1 <= words.length <= 5000\n\n\n1 <= words[i].length <= 30\n\n\ns\n and \nwords[i]\n consist of lowercase English letters.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        if not words:\n            return []\n\n        result, m, n, k = [], len(s), len(words), len(words[0])\n        if m < n*k:\n            return result\n\n        lookup = collections.defaultdict(int)\n        for i in words:\n            lookup[i] += 1                # Space: O(n * k)\n\n        for i in xrange(k):               # Time:  O(k)\n            left, count = i, 0\n            tmp = collections.defaultdict(int)\n            for j in xrange(i, m-k+1, k): # Time:  O(m / k)\n                s1 = s[j:j+k]             # Time:  O(k)\n                if s1 in lookup:\n                    tmp[s1] += 1\n                    count += 1\n                    while tmp[s1] > lookup[s1]:\n                        tmp[s[left:left+k]] -= 1\n                        count -= 1\n                        left += k\n                    if count == n:\n                        result.append(left)\n                else:\n                    tmp = collections.defaultdict(int)\n                    count = 0\n                    left = j+k\n        return result\n\nclass Solution2(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        result, m, n, k = [], len(s), len(words), len(words[0])\n        if m < n*k:\n            return result\n\n        lookup = collections.defaultdict(int)\n        for i in words:\n            lookup[i] += 1                            # Space: O(n * k)\n\n        for i in xrange(m+1-k*n):                     # Time: O(m)\n            cur, j = collections.defaultdict(int), 0\n            while j < n:                              # Time: O(n)\n                word = s[i+j*k:i+j*k+k]               # Time: O(k)\n                if word not in lookup:\n                    break\n                cur[word] += 1\n                if cur[word] > lookup[word]:\n                    break\n                j += 1\n            if j == n:\n                result.append(i)\n\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(m * n * k), where m is string length, n is dictionary size, k is word length",
      "space_complexity": "O(n * k)"
    }
  ],
  "Sliding Window - Dynamic Size": [
    {
      "title": "Longest Substring Without Repeating Characters",
      "difficulty": "Medium",
      "category": "Sliding Window - Dynamic Size",
      "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters",
      "slug": "longest-substring-without-repeating-characters",
      "description": "Given a string \ns\n, find the length of the \nlongest\n \nsubstring\n without duplicate characters.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abcabcbb\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"abc\", with the length of 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"bbbbb\"\n\nOutput:\n 1\n\nExplanation:\n The answer is \"b\", with the length of 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"pwwkew\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 5 * 10\n4\n\n\ns\n consists of English letters, digits, symbols and spaces.",
      "solution": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        left = 0\n        count = {}\n        max_len = 0\n        for right in range(len(s)):\n            count[s[right]] = count.get(s[right], 0) + 1\n            while count[s[right]] > 1:\n                count[s[left]] -= 1\n                if count[s[left]] == 0:\n                    del count[s[left]]\n                left += 1\n            \n            max_len = max(max_len, right-left+1)\n        \n        return max_len",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Longest Repeating Character Replacement",
      "difficulty": "Medium",
      "category": "Sliding Window - Dynamic Size",
      "link": "https://leetcode.com/problems/longest-repeating-character-replacement",
      "slug": "longest-repeating-character-replacement",
      "description": "You are given a string \ns\n and an integer \nk\n. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most \nk\n times.\n\n\nReturn \nthe length of the longest substring containing the same letter you can get after performing the above operations\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"ABAB\", k = 2\n\nOutput:\n 4\n\nExplanation:\n Replace the two 'A's with two 'B's or vice versa.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"AABABBA\", k = 1\n\nOutput:\n 4\n\nExplanation:\n Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\nThere may exists other ways to achieve this answer too.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns\n consists of only uppercase English letters.\n\n\n0 <= k <= s.length",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def characterReplacement(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result, max_count = 0, 0\n        count = collections.Counter()\n        for i in xrange(len(s)):\n            count[s[i]] += 1\n            max_count = max(max_count, count[s[i]])\n            if result - max_count >= k:\n                count[s[i-result]] -= 1\n            else:\n                result += 1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Minimum Size Subarray Sum",
      "difficulty": "Medium",
      "category": "Sliding Window - Dynamic Size",
      "link": "https://leetcode.com/problems/minimum-size-subarray-sum",
      "slug": "minimum-size-subarray-sum",
      "description": "Given an array of positive integers \nnums\n and a positive integer \ntarget\n, return \nthe \nminimal length\n of a \nsubarray\n whose sum is greater than or equal to\n \ntarget\n. If there is no such subarray, return \n0\n instead.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n target = 7, nums = [2,3,1,2,4,3]\n\nOutput:\n 2\n\nExplanation:\n The subarray [4,3] has the minimal length under the problem constraint.\n\n\n\nExample 2:\n\n\n\n\nInput:\n target = 4, nums = [1,4,4]\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\nInput:\n target = 11, nums = [1,1,1,1,1,1,1,1]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= target <= 10\n9\n\n\n1 <= nums.length <= 10\n5\n\n\n1 <= nums[i] <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n If you have figured out the \nO(n)\n solution, try coding another solution of which the time complexity is \nO(n log(n))\n.",
      "solution": "class Solution(object):\n    # @param {integer} s\n    # @param {integer[]} nums\n    # @return {integer}\n    def minSubArrayLen(self, s, nums):\n        start = 0\n        sum = 0\n        min_size = float(\"inf\")\n        for i in xrange(len(nums)):\n            sum += nums[i]\n            while sum >= s:\n                min_size = min(min_size, i - start + 1)\n                sum -= nums[start]\n                start += 1\n\n        return min_size if min_size != float(\"inf\") else 0\n\n# Binary search solution.class Solution2(object):\n    # @param {integer} s\n    # @param {integer[]} nums\n    # @return {integer}\n    def minSubArrayLen(self, s, nums):\n        min_size = float(\"inf\")\n        sum_from_start = [n for n in nums]\n        for i in xrange(len(sum_from_start) - 1):\n            sum_from_start[i + 1] += sum_from_start[i]\n        for i in xrange(len(sum_from_start)):\n            end = self.binarySearch(lambda x, y: x <= y, sum_from_start, \\\n                                    i, len(sum_from_start), \\\n                                    sum_from_start[i] - nums[i] + s)\n            if end < len(sum_from_start):\n                min_size = min(min_size, end - i + 1)\n\n        return min_size if min_size != float(\"inf\") else 0\n\n    def binarySearch(self, compare, A, start, end, target):\n        while start < end:\n            mid = start + (end - start) / 2\n            if compare(target, A[mid]):\n                end = mid\n            else:\n                start = mid + 1\n        return start",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Max Consecutive Ones III",
      "difficulty": "Medium",
      "category": "Sliding Window - Dynamic Size",
      "link": "https://leetcode.com/problems/max-consecutive-ones-iii",
      "slug": "max-consecutive-ones-iii",
      "description": "Given a binary array \nnums\n and an integer \nk\n, return \nthe maximum number of consecutive \n1\n's in the array if you can flip at most\n \nk\n \n0\n's.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\n\nOutput:\n 6\n\nExplanation:\n [1,1,1,0,0,\n1\n,1,1,1,1,\n1\n]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\n\nOutput:\n 10\n\nExplanation:\n [0,0,\n1,1,\n1\n,\n1\n,1,1,1,\n1\n,1,1\n,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\nnums[i]\n is either \n0\n or \n1\n.\n\n\n0 <= k <= nums.length",
      "solution": "class Solution(object):\n    def longestOnes(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        result, i = 0, 0\n        for j in xrange(len(A)):\n            K -= int(A[j] == 0)\n            while K < 0:\n                K += int(A[i] == 0)\n                i += 1\n            result = max(result, j-i+1)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Minimum Window Substring",
      "difficulty": "Hard",
      "category": "Sliding Window - Dynamic Size",
      "link": "https://leetcode.com/problems/minimum-window-substring",
      "slug": "minimum-window-substring",
      "description": "Given two strings \ns\n and \nt\n of lengths \nm\n and \nn\n respectively, return \nthe \nminimum window\n \nsubstring\n of \ns\n such that every character in \nt\n (\nincluding duplicates\n) is included in the window\n. If there is no such substring, return \nthe empty string \n\"\"\n.\n\n\nThe testcases will be generated such that the answer is \nunique\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"ADOBECODEBANC\", t = \"ABC\"\n\nOutput:\n \"BANC\"\n\nExplanation:\n The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"a\", t = \"a\"\n\nOutput:\n \"a\"\n\nExplanation:\n The entire string s is the minimum window.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"a\", t = \"aa\"\n\nOutput:\n \"\"\n\nExplanation:\n Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == s.length\n\n\nn == t.length\n\n\n1 <= m, n <= 10\n5\n\n\ns\n and \nt\n consist of uppercase and lowercase English letters.\n\n\n\n\n \n\n\nFollow up:\n Could you find an algorithm that runs in \nO(m + n)\n time?",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        count, remain = collections.Counter(t), len(t)\n        i, left, right = 0, -1, -1\n        for j, c in enumerate(s):\n            remain -= count[c] > 0\n            count[c] -= 1\n            if remain:\n                continue\n            while count[s[i]] < 0:  # greedily discard uneeds\n                count[s[i]] += 1\n                i += 1\n            if right == -1 or j-i+1 < right-left+1:\n                left, right = i, j\n        return s[left:right+1]\n\nclass Solution2(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        current_count = [0 for i in xrange(52)]\n        expected_count = [0 for i in xrange(52)]\n\n        for char in t:\n            expected_count[ord(char) - ord('a')] += 1\n\n        i, count, start, min_width, min_start = 0, 0, 0, float(\"inf\"), 0\n        while i < len(s):\n            current_count[ord(s[i]) - ord('a')] += 1\n            if current_count[ord(s[i]) - ord('a')] <= expected_count[ord(s[i]) - ord('a')]:\n                count += 1\n\n            if count == len(t):\n                while expected_count[ord(s[start]) - ord('a')] == 0 or \\\n                      current_count[ord(s[start]) - ord('a')] > expected_count[ord(s[start]) - ord('a')]:\n                    current_count[ord(s[start]) - ord('a')] -= 1\n                    start += 1\n\n                if min_width > i - start + 1:\n                    min_width = i - start + 1\n                    min_start = start\n            i += 1\n\n        if min_width == float(\"inf\"):\n            return \"\"\n\n        return s[min_start:min_start + min_width]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(k), k is the number of different characters"
    }
  ],
  "Kadane's Algorithm": [
    {
      "title": "Maximum Subarray",
      "difficulty": "Medium",
      "category": "Kadane's Algorithm",
      "link": "https://leetcode.com/problems/maximum-subarray",
      "slug": "maximum-subarray",
      "description": "Given an integer array \nnums\n, find the \nsubarray\n with the largest sum, and return \nits sum\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-2,1,-3,4,-1,2,1,-5,4]\n\nOutput:\n 6\n\nExplanation:\n The subarray [4,-1,2,1] has the largest sum 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1]\n\nOutput:\n 1\n\nExplanation:\n The subarray [1] has the largest sum 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [5,4,-1,7,8]\n\nOutput:\n 23\n\nExplanation:\n The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n If you have figured out the \nO(n)\n solution, try coding another solution using the \ndivide and conquer\n approach, which is more subtle.",
      "solution": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, curr = float(\"-inf\"), float(\"-inf\")\n        for x in nums:\n            curr = max(curr+x, x)\n            result = max(result, curr)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Maximum Sum Circular Subarray",
      "difficulty": "Medium",
      "category": "Kadane's Algorithm",
      "link": "https://leetcode.com/problems/maximum-sum-circular-subarray",
      "slug": "maximum-sum-circular-subarray",
      "description": "Given a \ncircular integer array\n \nnums\n of length \nn\n, return \nthe maximum possible sum of a non-empty \nsubarray\n of \nnums\n.\n\n\nA \ncircular array\n means the end of the array connects to the beginning of the array. Formally, the next element of \nnums[i]\n is \nnums[(i + 1) % n]\n and the previous element of \nnums[i]\n is \nnums[(i - 1 + n) % n]\n.\n\n\nA \nsubarray\n may only include each element of the fixed buffer \nnums\n at most once. Formally, for a subarray \nnums[i], nums[i + 1], ..., nums[j]\n, there does not exist \ni <= k1\n, \nk2 <= j\n with \nk1 % n == k2 % n\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,-2,3,-2]\n\nOutput:\n 3\n\nExplanation:\n Subarray [3] has maximum sum 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [5,-3,5]\n\nOutput:\n 10\n\nExplanation:\n Subarray [5,5] has maximum sum 5 + 5 = 10.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [-3,-2,-3]\n\nOutput:\n -2\n\nExplanation:\n Subarray [-2] has maximum sum -2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 3 * 10\n4\n\n\n-3 * 10\n4\n <= nums[i] <= 3 * 10\n4",
      "solution": "class Solution(object):\n    def maxSubarraySumCircular(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        total, max_sum, cur_max, min_sum, cur_min = 0, -float(\"inf\"), 0, float(\"inf\"), 0\n        for a in A:\n            cur_max = max(cur_max+a, a)\n            max_sum = max(max_sum, cur_max)\n            cur_min = min(cur_min+a, a)\n            min_sum = min(min_sum, cur_min)\n            total += a\n        return max(max_sum, total-min_sum) if max_sum >= 0 else max_sum",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Maximum Product Subarray",
      "difficulty": "Medium",
      "category": "Kadane's Algorithm",
      "link": "https://leetcode.com/problems/maximum-product-subarray",
      "slug": "maximum-product-subarray",
      "description": "Given an integer array \nnums\n, find a \nsubarray\n that has the largest product, and return \nthe product\n.\n\n\nThe test cases are generated so that the answer will fit in a \n32-bit\n integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,3,-2,4]\n\nOutput:\n 6\n\nExplanation:\n [2,3] has the largest product 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-2,0,-1]\n\nOutput:\n 0\n\nExplanation:\n The result cannot be 2, because [-2,-1] is not a subarray.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2 * 10\n4\n\n\n-10 <= nums[i] <= 10\n\n\nThe product of any subarray of \nnums\n is \nguaranteed\n to fit in a \n32-bit\n integer.",
      "solution": "class Solution(object):\n    # @param A, a list of integers\n    # @return an integer\n    def maxProduct(self, A):\n        global_max, local_max, local_min = float(\"-inf\"), 1, 1\n        for x in A:\n            local_max, local_min = max(x, local_max * x, local_min * x), min(x, local_max * x, local_min * x)\n            global_max = max(global_max, local_max)\n        return global_max\nclass Solution2(object):\n    # @param A, a list of integers\n    # @return an integer\n    def maxProduct(self, A):\n        global_max, local_max, local_min = float(\"-inf\"), 1, 1\n        for x in A:\n            local_max = max(1, local_max)\n            if x > 0:\n                local_max, local_min = local_max * x, local_min * x\n            else:\n                local_max, local_min = local_min * x, local_max * x\n            global_max = max(global_max, local_max)\n        return global_max",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Best Sightseeing Pair",
      "difficulty": "Medium",
      "category": "Kadane's Algorithm",
      "link": "https://leetcode.com/problems/best-sightseeing-pair",
      "slug": "best-sightseeing-pair",
      "description": "You are given an integer array \nvalues\n where values[i] represents the value of the \ni\nth\n sightseeing spot. Two sightseeing spots \ni\n and \nj\n have a \ndistance\n \nj - i\n between them.\n\n\nThe score of a pair (\ni < j\n) of sightseeing spots is \nvalues[i] + values[j] + i - j\n: the sum of the values of the sightseeing spots, minus the distance between them.\n\n\nReturn \nthe maximum score of a pair of sightseeing spots\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n values = [8,1,5,2,6]\n\nOutput:\n 11\n\nExplanation:\n i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11\n\n\n\nExample 2:\n\n\n\n\nInput:\n values = [1,2]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= values.length <= 5 * 10\n4\n\n\n1 <= values[i] <= 1000",
      "solution": "class Solution(object):\n    def maxScoreSightseeingPair(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        result, curr = 0, 0\n        for x in A:\n            result = max(result, curr+x)\n            curr = max(curr, x)-1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    }
  ],
  "Matrix (2D Array)": [
    {
      "title": "Spiral Matrix",
      "difficulty": "Medium",
      "category": "Matrix (2D Array)",
      "link": "https://leetcode.com/problems/spiral-matrix",
      "slug": "spiral-matrix",
      "description": "Given an \nm x n\n \nmatrix\n, return \nall elements of the\n \nmatrix\n \nin spiral order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [1,2,3,6,9,8,7,4,5]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n\nOutput:\n [1,2,3,4,8,12,11,10,9,5,6,7]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 10\n\n\n-100 <= matrix[i][j] <= 100",
      "solution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        # Acronym: TRBL (like \"TROUBLE\")\n        # T → Top row (left to right)\n        # R → Right column (top to bottom)\n        # B → Bottom row (right to left)\n        # L → Left column (bottom to top)\n        # After T → top += 1\n        # After R → right -= 1\n        # After B → bottom -= 1\n        # After L → left += 1\n\n        rows, cols = len(matrix), len(matrix[0])\n        result = []\n        top, bottom = 0, rows - 1\n        left, right = 0, cols - 1\n\n        while len(result) < rows * cols:\n            # T\n            for i in range(left, right + 1):\n                result.append(matrix[top][i])\n            top += 1\n\n            # R\n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n            \n            # B\n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    result.append(matrix[bottom][i])\n                bottom -= 1\n            \n            # L\n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    result.append(matrix[i][left])\n                left += 1\n        \n        return result",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Rotate Image",
      "difficulty": "Medium",
      "category": "Matrix (2D Array)",
      "link": "https://leetcode.com/problems/rotate-image",
      "slug": "rotate-image",
      "description": "You are given an \nn x n\n 2D \nmatrix\n representing an image, rotate the image by \n90\n degrees (clockwise).\n\n\nYou have to rotate the image \nin-place\n, which means you have to modify the input 2D matrix directly. \nDO NOT\n allocate another 2D matrix and do the rotation.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [[7,4,1],[8,5,2],[9,6,3]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n\nOutput:\n [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 20\n\n\n-1000 <= matrix[i][j] <= 1000",
      "solution": "from typing import List\n\n# Pattern: Matrix transformation via symmetry + reversal (i.e., in-place transpose then horizontal reflection)\n# Why this maps: Rotating the image 90 degrees clockwise is equivalent to first transposing the matrix \n# (swapping symmetry across the main diagonal) and then reversing each row (horizontal reflection). \n# This avoids extra space by doing the transformation in-place.\n# Time Complexity: O(n^2) since we touch each element a constant number of times.\n# Space Complexity: O(1) extra space (in-place), aside from loop indices.\n\nclass Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Rotate the n x n matrix 90 degrees clockwise in-place.\n        \"\"\"\n        n = len(matrix)\n        # Edge guard: empty matrix or trivial 1x1 does not need work.\n        if n <= 1:\n            return  # nothing to do for size 0 or 1\n\n        # Step 1: Transpose in-place (swap matrix[i][j] with matrix[j][i] for j>i)\n        # This turns rows into columns along the main diagonal.\n        for i in range(n):\n            # Start j from i+1 to avoid swapping back and to skip diagonal (no-op).\n            for j in range(i + 1, n):\n                # Swap the symmetric elements across main diagonal.\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n        # Step 2: Reverse each row to complete 90-degree clockwise rotation.\n        # Reversing a row is equivalent to reflecting horizontally.\n        for row in matrix:\n            # slice reversal creates a reversed copy, then we assign back in-place to keep memory minimal.\n            row[:] = row[::-1]",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n^2)"
    },
    {
      "title": "Set Matrix Zeroes",
      "difficulty": "Medium",
      "category": "Matrix (2D Array)",
      "link": "https://leetcode.com/problems/set-matrix-zeroes",
      "slug": "set-matrix-zeroes",
      "description": "Given an \nm x n\n integer matrix \nmatrix\n, if an element is \n0\n, set its entire row and column to \n0\n's.\n\n\nYou must do it \nin place\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,1,1],[1,0,1],[1,1,1]]\n\nOutput:\n [[1,0,1],[0,0,0],[1,0,1]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n\nOutput:\n [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[0].length\n\n\n1 <= m, n <= 200\n\n\n-2\n31\n <= matrix[i][j] <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nA straightforward solution using \nO(mn)\n space is probably a bad idea.\n\n\nA simple improvement uses \nO(m + n)\n space, but still not the best solution.\n\n\nCould you devise a constant space solution?",
      "solution": "from typing import List\n\n# Pattern: In-place marker bookkeeping using first row and first column as flag storage.\n# Why this maps: To zero entire rows and columns when a zero is found without extra space, we reuse existing matrix\n#               cells (first row/col) as markers, avoiding auxiliary arrays. This is a classic constant-space matrix flagging trick.\n# Time Complexity: O(m * n) — we scan the matrix a few times, each cell handled a constant number of times.\n# Space Complexity: O(1) extra space (only a couple of boolean flags), modifying in-place.\n\nclass Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        # Early guard for malformed or empty input.\n        if not matrix or not matrix[0]:\n            return\n\n        rows, cols = len(matrix), len(matrix[0])\n\n        # Determine if the first row or first column originally contains any zero.\n        # Using `row` and `col` as index variable names for clarity.\n        first_row_has_zero = any(matrix[0][col] == 0 for col in range(cols))\n        first_col_has_zero = any(matrix[row][0] == 0 for row in range(rows))\n\n        # Use rest of matrix (excluding first row and column) to record markers into first row/col.\n        for row in range(1, rows):\n            for col in range(1, cols):\n                if matrix[row][col] == 0:\n                    matrix[0][col] = 0  # mark this column to be zeroed later\n                    matrix[row][0] = 0  # mark this row to be zeroed later\n\n        # Apply zeros based on markers in first row and first column.\n        for row in range(1, rows):\n            for col in range(1, cols):\n                if matrix[0][col] == 0 or matrix[row][0] == 0:\n                    matrix[row][col] = 0  # zero if either its row or column was marked\n\n        # Finally, zero out the first row and first column if they originally had any zero.\n        if first_row_has_zero:\n            for col in range(cols):\n                matrix[0][col] = 0\n\n        if first_col_has_zero:\n            for row in range(rows):\n                matrix[row][0] = 0",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Valid Sudoku",
      "difficulty": "Medium",
      "category": "Matrix (2D Array)",
      "link": "https://leetcode.com/problems/valid-sudoku",
      "slug": "valid-sudoku",
      "description": "Determine if a \n9 x 9\n Sudoku board is valid. Only the filled cells need to be validated \naccording to the following rules\n:\n\n\n\n\nEach row must contain the digits \n1-9\n without repetition.\n\n\nEach column must contain the digits \n1-9\n without repetition.\n\n\nEach of the nine \n3 x 3\n sub-boxes of the grid must contain the digits \n1-9\n without repetition.\n\n\n\n\nNote:\n\n\n\n\nA Sudoku board (partially filled) could be valid but is not necessarily solvable.\n\n\nOnly the filled cells need to be validated according to the mentioned rules.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\nInput:\n board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput:\n false\n\nExplanation:\n Same as Example 1, except with the \n5\n in the top left corner being modified to \n8\n. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nboard.length == 9\n\n\nboard[i].length == 9\n\n\nboard[i][j]\n is a digit \n1-9\n or \n'.'\n.",
      "solution": "from typing import List\nfrom collections import defaultdict\n\n# Pattern: Hashing with multiple constraint buckets (rows, columns, 3x3 boxes) using sets for O(1) membership checks.\n# Why this maps: Sudoku validity requires ensuring no duplicate digit appears in any row, column, or box.\n#               Using defaultdict of sets lets us group seen values per constraint and quickly detect conflicts.\n# Time Complexity: O(1) practically since board size is fixed (9x9) -> O(81) = O(1), but in general O(n^2) for n x n board.\n# Space Complexity: O(n^2) in the worst case to store seen entries across rows/cols/boxes.\n\nclass Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        # Using defaultdict to lazily create sets when first accessed for a row/col/box.\n        rows = defaultdict(set)   # maps row index -> set of seen digits in that row\n        cols = defaultdict(set)   # maps column index -> set of seen digits in that column\n        boxes = defaultdict(set)  # maps (row//3, col//3) -> set of seen digits in that 3x3 box\n\n        # Traverse every cell exactly once: detect duplicates in any constraint group.\n        for row in range(9):  # fixed 9 rows per standard Sudoku\n            for col in range(9):  # fixed 9 columns\n                val = board[row][col]\n                if val == \".\":  # empty cell imposes no constraint; skip it\n                    continue\n\n                # Compute which 3x3 box this cell belongs to using integer division.\n                box_key = (row // 3, col // 3)\n\n                # If value already exists in the row, column, or box, it's invalid.\n                if (val in rows[row]\n                    or val in cols[col]\n                    or val in boxes[box_key]):\n                    return False  # early exit on first violation\n\n                # Record the value in all three constraint trackers.\n                rows[row].add(val)\n                cols[col].add(val)\n                boxes[box_key].add(val)\n\n        # No conflicts found: board satisfies Sudoku uniqueness rules.\n        return True",
      "explanation": "N/A",
      "time_complexity": "O(9^2)",
      "space_complexity": "O(9)"
    },
    {
      "title": "Game of Life",
      "difficulty": "Medium",
      "category": "Matrix (2D Array)",
      "link": "https://leetcode.com/problems/game-of-life",
      "slug": "game-of-life",
      "description": "According to \nWikipedia's article\n: \"The \nGame of Life\n, also known simply as \nLife\n, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\n\n\nThe board is made up of an \nm x n\n grid of cells, where each cell has an initial state: \nlive\n (represented by a \n1\n) or \ndead\n (represented by a \n0\n). Each cell interacts with its \neight neighbors\n (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\n\n\n\nAny live cell with fewer than two live neighbors dies as if caused by under-population.\n\n\nAny live cell with two or three live neighbors lives on to the next generation.\n\n\nAny live cell with more than three live neighbors dies, as if by over-population.\n\n\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\n\n\n\nThe next state of the board is determined by applying the above rules simultaneously to every cell in the current state of the \nm x n\n grid \nboard\n. In this process, births and deaths occur \nsimultaneously\n.\n\n\nGiven the current state of the \nboard\n, \nupdate\n the \nboard\n to reflect its next state.\n\n\nNote\n that you do not need to return anything.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\n\nOutput:\n [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [[1,1],[1,0]]\n\nOutput:\n [[1,1],[1,1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == board.length\n\n\nn == board[i].length\n\n\n1 <= m, n <= 25\n\n\nboard[i][j]\n is \n0\n or \n1\n.\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nCould you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.\n\n\nIn this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?",
      "solution": "from typing import List\n\n# Pattern: In-place state transition encoding + neighbor traversal (constant-space simulation)\n# Why this maps: Game of Life requires computing next state based on neighbors while preserving original state for simultaneous update.\n#               We encode transitional states in-place (e.g., live->dead as -1, dead->live as 2) so we can count original live neighbors\n#               while marking changes without extra board. Then we finalize by normalizing encodings.\n# Time Complexity: O(m * n) where m,n are board dimensions; each cell inspects 8 neighbors constant work.\n# Space Complexity: O(1) extra space (in-place), only using a fixed list of direction offsets.\n\nclass Solution:\n    def gameOfLife(self, board: List[List[int]]) -> None:\n        \"\"\"\n        Compute the next state of the board in-place using transitional encodings.\n        \"\"\"\n        # Edge guard: empty board or malformed input\n        if not board or not board[0]:\n            return\n\n        rows, cols = len(board), len(board[0])\n        # All eight neighbor direction offsets (row delta, col delta)\n        directions = [\n            (1, -1), (-1, 1), (1, 1), (-1, -1),\n            (0, 1), (0, -1), (1, 0), (-1, 0)\n        ]\n\n        # First pass: determine transitions using encoded markers while preserving original state for neighbor counting.\n        for r in range(rows):\n            for c in range(cols):\n                liveCount = 0\n                # Count live neighbors; abs(...) handles encoding:\n                #   original live = 1, live->dead marked as -1 (abs=1) should still count as originally live.\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols and abs(board[nr][nc]) == 1:\n                        liveCount += 1\n\n                # Apply Game of Life rules using temporary markers:\n                if board[r][c] == 1:\n                    # Rule: live cell with fewer than 2 or more than 3 neighbors dies.\n                    if liveCount < 2 or liveCount > 3:\n                        board[r][c] = -1  # live -> dead (marker preserves that it was originally live)\n                else:\n                    # Rule: dead cell with exactly 3 live neighbors becomes live.\n                    if liveCount == 3:\n                        board[r][c] = 2   # dead -> live (marker indicates it was originally dead)\n\n        # Second pass: finalize the board by collapsing markers to final 0/1 states.\n        for r in range(rows):\n            for c in range(cols):\n                if board[r][c] == 2:\n                    board[r][c] = 1  # resurrected cell\n                elif board[r][c] == -1:\n                    board[r][c] = 0  # died cell",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(1)"
    }
  ],
  "Linked List": [
    {
      "title": "Intersection of Two Linked Lists",
      "difficulty": "Easy",
      "category": "Linked List",
      "link": "https://leetcode.com/problems/intersection-of-two-linked-lists",
      "slug": "intersection-of-two-linked-lists",
      "description": "Given the heads of two singly linked-lists \nheadA\n and \nheadB\n, return \nthe node at which the two lists intersect\n. If the two linked lists have no intersection at all, return \nnull\n.\n\n\nFor example, the following two linked lists begin to intersect at node \nc1\n:\n\n\n\n\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\n\n\nNote\n that the linked lists must \nretain their original structure\n after the function returns.\n\n\nCustom Judge:\n\n\nThe inputs to the \njudge\n are given as follows (your program is \nnot\n given these inputs):\n\n\n\n\nintersectVal\n - The value of the node where the intersection occurs. This is \n0\n if there is no intersected node.\n\n\nlistA\n - The first linked list.\n\n\nlistB\n - The second linked list.\n\n\nskipA\n - The number of nodes to skip ahead in \nlistA\n (starting from the head) to get to the intersected node.\n\n\nskipB\n - The number of nodes to skip ahead in \nlistB\n (starting from the head) to get to the intersected node.\n\n\n\n\nThe judge will then create the linked structure based on these inputs and pass the two heads, \nheadA\n and \nheadB\n to your program. If you correctly return the intersected node, then your solution will be \naccepted\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n\nOutput:\n Intersected at '8'\n\nExplanation:\n The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2\nnd\n node in A and 3\nrd\n node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3\nrd\n node in A and 4\nth\n node in B) point to the same location in memory.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n\nOutput:\n Intersected at '2'\n\nExplanation:\n The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n\nOutput:\n No intersection\n\nExplanation:\n From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes of \nlistA\n is in the \nm\n.\n\n\nThe number of nodes of \nlistB\n is in the \nn\n.\n\n\n1 <= m, n <= 3 * 10\n4\n\n\n1 <= Node.val <= 10\n5\n\n\n0 <= skipA <= m\n\n\n0 <= skipB <= n\n\n\nintersectVal\n is \n0\n if \nlistA\n and \nlistB\n do not intersect.\n\n\nintersectVal == listA[skipA] == listB[skipB]\n if \nlistA\n and \nlistB\n intersect.\n\n\n\n\n \n\n\nFollow up:\n Could you write a solution that runs in \nO(m + n)\n time and use only \nO(1)\n memory?",
      "solution": "class Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        # Two pointers for traversing the lists\n        ptrA, ptrB = headA, headB\n\n        # Traverse both lists\n        # When a pointer reaches the end, redirect it to the head of the other list\n        while ptrA != ptrB:\n            # Move to next node or switch to other list's head if reached end\n            ptrA = ptrA.next if ptrA else headB\n            ptrB = ptrB.next if ptrB else headA\n\n        # Either both are None (no intersection), or both point to intersection node\n        return ptrA",
      "explanation": "N/A",
      "time_complexity": "O(m + n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Design Linked List",
      "difficulty": "Medium",
      "category": "Linked List",
      "link": "https://leetcode.com/problems/design-linked-list",
      "slug": "design-linked-list",
      "description": "Design your implementation of the linked list. You can choose to use a singly or doubly linked list.\n\nA node in a singly linked list should have two attributes: \nval\n and \nnext\n. \nval\n is the value of the current node, and \nnext\n is a pointer/reference to the next node.\n\nIf you want to use the doubly linked list, you will need one more attribute \nprev\n to indicate the previous node in the linked list. Assume all nodes in the linked list are \n0-indexed\n.\n\n\nImplement the \nMyLinkedList\n class:\n\n\n\n\nMyLinkedList()\n Initializes the \nMyLinkedList\n object.\n\n\nint get(int index)\n Get the value of the \nindex\nth\n node in the linked list. If the index is invalid, return \n-1\n.\n\n\nvoid addAtHead(int val)\n Add a node of value \nval\n before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\n\n\nvoid addAtTail(int val)\n Append a node of value \nval\n as the last element of the linked list.\n\n\nvoid addAtIndex(int index, int val)\n Add a node of value \nval\n before the \nindex\nth\n node in the linked list. If \nindex\n equals the length of the linked list, the node will be appended to the end of the linked list. If \nindex\n is greater than the length, the node \nwill not be inserted\n.\n\n\nvoid deleteAtIndex(int index)\n Delete the \nindex\nth\n node in the linked list, if the index is valid.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n[[], [1], [3], [1, 2], [1], [1], [1]]\n\nOutput\n\n[null, null, null, null, 2, null, 3]\n\n\nExplanation\n\nMyLinkedList myLinkedList = new MyLinkedList();\nmyLinkedList.addAtHead(1);\nmyLinkedList.addAtTail(3);\nmyLinkedList.addAtIndex(1, 2);    // linked list becomes 1->2->3\nmyLinkedList.get(1);              // return 2\nmyLinkedList.deleteAtIndex(1);    // now the linked list is 1->3\nmyLinkedList.get(1);              // return 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= index, val <= 1000\n\n\nPlease do not use the built-in LinkedList library.\n\n\nAt most \n2000\n calls will be made to \nget\n, \naddAtHead\n, \naddAtTail\n, \naddAtIndex\n and \ndeleteAtIndex\n.",
      "solution": "class Node:\n    def __init__(self, val=0):\n        self.val = val\n        self.next = None\n\nclass MyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.size = 0\n\n    # Get the value of the index-th node (0-based)\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n        \n        current = self.head\n        for _ in range(index):\n            current = current.next\n        return current.val\n\n    # Insert a node at the head\n    def addAtHead(self, val: int) -> None:\n        new_node = Node(val)\n        new_node.next = self.head\n        self.head = new_node\n        self.size += 1\n\n    # Append a node at the tail\n    def addAtTail(self, val: int) -> None:\n        new_node = Node(val)\n        if not self.head:\n            self.head = new_node\n        else:\n            current = self.head\n            while current.next:\n                current = current.next\n            current.next = new_node\n        self.size += 1\n\n    # Insert a node before the index-th node\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0 or index > self.size:\n            return\n\n        if index == 0:\n            self.addAtHead(val)\n            return\n\n        new_node = Node(val)\n        current = self.head\n        for _ in range(index - 1):\n            current = current.next\n        new_node.next = current.next\n        current.next = new_node\n        self.size += 1\n\n    # Delete the index-th node if valid\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n\n        if index == 0:\n            self.head = self.head.next\n        else:\n            current = self.head\n            for _ in range(index - 1):\n                current = current.next\n            current.next = current.next.next\n\n        self.size -= 1",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Remove Nth Node From End of List",
      "difficulty": "Medium",
      "category": "Linked List",
      "link": "https://leetcode.com/problems/remove-nth-node-from-end-of-list",
      "slug": "remove-nth-node-from-end-of-list",
      "description": "Given the \nhead\n of a linked list, remove the \nn\nth\n node from the end of the list and return its head.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], n = 2\n\nOutput:\n [1,2,3,5]\n\n\n\nExample 2:\n\n\n\n\nInput:\n head = [1], n = 1\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = [1,2], n = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is \nsz\n.\n\n\n1 <= sz <= 30\n\n\n0 <= Node.val <= 100\n\n\n1 <= n <= sz\n\n\n\n\n \n\n\nFollow up:\n Could you do this in one pass?",
      "solution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        # Use a dummy node to handle edge cases (like removing the head)\n        res = ListNode(0, head)\n        dummy = res\n\n        # Move the `head` pointer n steps ahead so there's a gap of n between `head` and `dummy`\n        for _ in range(n):\n            head = head.next\n\n        # Move both pointers until `head` reaches the end\n        # Now, `dummy` points to the node before the one we want to remove\n        while head:\n            head = head.next\n            dummy = dummy.next\n\n        # Remove the target node\n        dummy.next = dummy.next.next\n\n        # Return the updated list (skip dummy)\n        return res.next",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Remove Duplicates from Sorted List II",
      "difficulty": "Medium",
      "category": "Linked List",
      "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii",
      "slug": "remove-duplicates-from-sorted-list-ii",
      "description": "Given the \nhead\n of a sorted linked list, \ndelete all nodes that have duplicate numbers, leaving only distinct numbers from the original list\n. Return \nthe linked list \nsorted\n as well\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,3,4,4,5]\n\nOutput:\n [1,2,5]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,1,1,2,3]\n\nOutput:\n [2,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 300]\n.\n\n\n-100 <= Node.val <= 100\n\n\nThe list is guaranteed to be \nsorted\n in ascending order.",
      "solution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        LeetCode 83 – Remove Duplicates from Sorted List\n        Pattern: **Linked List - Skip duplicates, keep one copy**\n\n        🔎 Pattern-identification clues:\n        - \"Sorted linked list\"\n        - \"Remove duplicates in-place\"\n        - Keep one instance of each value\n        \"\"\"\n\n        current = head  # Pointer to traverse the list\n\n        while current and current.next:\n            if current.val == current.next.val:\n                # Skip over the duplicate node\n                current.next = current.next.next\n            else:\n                current = current.next  # Move forward if no duplicate\n\n        return head\n\n\n    def deleteDuplicatesII(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        LeetCode 82 – Remove Duplicates from Sorted List II\n        Pattern: **Linked List - Skip all duplicates**\n\n        🔎 Pattern-identification clues:\n        - \"Sorted linked list\"\n        - \"Remove all nodes with duplicate numbers\"\n        - Don't keep any value that appears more than once\n        \"\"\"\n\n        # Dummy node simplifies edge cases (e.g., duplicates at head)\n        dummy = ListNode(0, head)\n        prev = dummy  # Pointer before current group being inspected\n\n        while head:\n            # If we see a duplicate group (head == head.next)\n            if head.next and head.val == head.next.val:\n                # Skip all nodes with the same value\n                while head.next and head.val == head.next.val:\n                    head = head.next\n                # Connect prev.next to the node after the duplicate group\n                prev.next = head.next\n            else:\n                # No duplicate at this node, move prev forward\n                prev = prev.next\n            # Move head forward\n            head = head.next\n\n        return dummy.next\n\n    def deleteDuplicatesUnsorted(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Removes duplicates from an unsorted singly-linked list.\n        \n        🔍 Pattern: Hashing + Linked List\n        - Track seen values using a set (O(1) lookup)\n        - Modify pointers to skip duplicate nodes\n        \"\"\"\n\n        if not head:\n            return None\n\n        seen = set()\n        dummy = ListNode(0, head)  # Clean dummy head approach\n        prev = dummy\n        curr = head\n\n        while curr:\n            if curr.val in seen:\n                prev.next = curr.next  # skip current node\n            else:\n                seen.add(curr.val)\n                prev = curr  # move prev only when node is kept\n            curr = curr.next  # always move current forward\n\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Swap Nodes in Pairs",
      "difficulty": "Medium",
      "category": "Linked List",
      "link": "https://leetcode.com/problems/swap-nodes-in-pairs",
      "slug": "swap-nodes-in-pairs",
      "description": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nhead = [1,2,3,4]\n\n\nOutput:\n \n[2,1,4,3]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nhead = []\n\n\nOutput:\n \n[]\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nhead = [1]\n\n\nOutput:\n \n[1]\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nhead = [1,2,3]\n\n\nOutput:\n \n[2,1,3]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 100]\n.\n\n\n0 <= Node.val <= 100",
      "solution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return None\n\n        # Dummy node simplifies edge case handling, especially for head swaps\n        dummy = ListNode(0, head)\n        previous = dummy    # Points to node before the pair\n        first = head        # Points to the first node in the pair\n\n        # Traverse the list while at least two nodes are available to swap\n        while first and first.next:\n            second = first.next          # Second node in the current pair\n            following_pair = second.next # First node in the next pair\n\n            # --- Perform the swap ---\n            second.next = first          # Point second -> first\n            first.next = following_pair  # First now points to next pair\n            previous.next = second       # Previous node connects to new head of this pair\n\n            # --- Move pointers forward ---\n            previous = first             # Previous moves to the end of swapped pair\n            first = following_pair       # Start next iteration from the next pair\n\n        # dummy.next is the new head of the list after swaps\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Copy List with Random Pointer",
      "difficulty": "Medium",
      "category": "Linked List",
      "link": "https://leetcode.com/problems/copy-list-with-random-pointer",
      "slug": "copy-list-with-random-pointer",
      "description": "A linked list of length \nn\n is given such that each node contains an additional random pointer, which could point to any node in the list, or \nnull\n.\n\n\nConstruct a \ndeep copy\n of the list. The deep copy should consist of exactly \nn\n \nbrand new\n nodes, where each new node has its value set to the value of its corresponding original node. Both the \nnext\n and \nrandom\n pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. \nNone of the pointers in the new list should point to nodes in the original list\n.\n\n\nFor example, if there are two nodes \nX\n and \nY\n in the original list, where \nX.random --> Y\n, then for the corresponding two nodes \nx\n and \ny\n in the copied list, \nx.random --> y\n.\n\n\nReturn \nthe head of the copied linked list\n.\n\n\nThe linked list is represented in the input/output as a list of \nn\n nodes. Each node is represented as a pair of \n[val, random_index]\n where:\n\n\n\n\nval\n: an integer representing \nNode.val\n\n\nrandom_index\n: the index of the node (range from \n0\n to \nn-1\n) that the \nrandom\n pointer points to, or \nnull\n if it does not point to any node.\n\n\n\n\nYour code will \nonly\n be given the \nhead\n of the original linked list.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n\nOutput:\n [[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [[1,1],[2,1]]\n\nOutput:\n [[1,1],[2,1]]\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n head = [[3,null],[3,0],[3,null]]\n\nOutput:\n [[3,null],[3,0],[3,null]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 1000\n\n\n-10\n4\n <= Node.val <= 10\n4\n\n\nNode.random\n is \nnull\n or is pointing to some node in the linked list.",
      "solution": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        old = {None: None}\n        curr = head\n\n        while curr:\n            old[curr] = Node(curr.val)\n            curr = curr.next\n        \n        curr = head\n        while curr:\n            copy = old[curr]\n            copy.next = old[curr.next]\n            copy.random = old[curr.random]\n            curr = curr.next\n        \n        return old[head]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Partition List",
      "difficulty": "Medium",
      "category": "Linked List",
      "link": "https://leetcode.com/problems/partition-list",
      "slug": "partition-list",
      "description": "Given the \nhead\n of a linked list and a value \nx\n, partition it such that all nodes \nless than\n \nx\n come before nodes \ngreater than or equal\n to \nx\n.\n\n\nYou should \npreserve\n the original relative order of the nodes in each of the two partitions.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,4,3,2,5,2], x = 3\n\nOutput:\n [1,2,2,4,3,5]\n\n\n\nExample 2:\n\n\n\n\nInput:\n head = [2,1], x = 2\n\nOutput:\n [1,2]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 200]\n.\n\n\n-100 <= Node.val <= 100\n\n\n-200 <= x <= 200",
      "solution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        # Dummy nodes for two separate lists\n        less_head = ListNode(0)     # List of nodes with values < x\n        greater_head = ListNode(0)  # List of nodes with values >= x\n\n        # Tail pointers for appending to the lists\n        less_tail = less_head\n        greater_tail = greater_head\n\n        current = head\n\n        while current:\n            if current.val < x:\n                # Append to 'less' list\n                less_tail.next = current\n                less_tail = less_tail.next\n            else:\n                # Append to 'greater or equal' list\n                greater_tail.next = current\n                greater_tail = greater_tail.next\n            current = current.next\n\n        # Important: end the greater list\n        greater_tail.next = None\n\n        # Connect both lists: less list -> greater list\n        less_tail.next = greater_head.next\n\n        return less_head.next",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Rotate List",
      "difficulty": "Medium",
      "category": "Linked List",
      "link": "https://leetcode.com/problems/rotate-list",
      "slug": "rotate-list",
      "description": "Given the \nhead\n of a linked list, rotate the list to the right by \nk\n places.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 2\n\nOutput:\n [4,5,1,2,3]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [0,1,2], k = 4\n\nOutput:\n [2,0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 500]\n.\n\n\n-100 <= Node.val <= 100\n\n\n0 <= k <= 2 * 10\n9",
      "solution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next or k == 0:\n            return head  # No rotation needed\n\n        # Step 1: Find the tail and calculate the total length of the list\n        tail = head\n        list_length = 1\n        while tail.next:\n            tail = tail.next\n            list_length += 1\n\n        # Step 2: Use modulo to handle rotations larger than length\n        k = k % list_length\n        if k == 0:\n            return head  # Rotation doesn't change the list\n\n        # Step 3: Find the new tail node (node before the new head)\n        steps_to_new_tail = list_length - k\n        new_tail = head\n        for _ in range(steps_to_new_tail - 1):\n            new_tail = new_tail.next\n\n        # Step 4: Cut the list and rearrange the pointers\n        new_head = new_tail.next\n        new_tail.next = None\n        tail.next = head  # old tail connects to old head to form a loop\n\n        return new_head",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Add Two Numbers",
      "difficulty": "Medium",
      "category": "Linked List",
      "link": "https://leetcode.com/problems/add-two-numbers",
      "slug": "add-two-numbers",
      "description": "You are given two \nnon-empty\n linked lists representing two non-negative integers. The digits are stored in \nreverse order\n, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n l1 = [2,4,3], l2 = [5,6,4]\n\nOutput:\n [7,0,8]\n\nExplanation:\n 342 + 465 = 807.\n\n\n\nExample 2:\n\n\n\n\nInput:\n l1 = [0], l2 = [0]\n\nOutput:\n [0]\n\n\n\nExample 3:\n\n\n\n\nInput:\n l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n\nOutput:\n [8,9,9,9,0,0,0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in each linked list is in the range \n[1, 100]\n.\n\n\n0 <= Node.val <= 9\n\n\nIt is guaranteed that the list represents a number that does not have leading zeros.",
      "solution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        # Dummy node to start the result list\n        dummy = ListNode()\n        current = dummy\n\n        carry = 0\n\n        # Loop continues while there's a node in either list or a carry remains\n        while l1 or l2 or carry:\n            # Safely extract values from the current nodes (0 if list is exhausted)\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n\n            # Compute the sum and carry\n            total = val1 + val2 + carry\n            carry = total // 10\n            digit = total % 10\n\n            # Create new node with the computed digit\n            current.next = ListNode(digit)\n\n            # Move pointers forward\n            current = current.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        # Return the next of dummy which is the actual head of the new list\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Flatten a Multilevel Doubly Linked List",
      "difficulty": "Medium",
      "category": "Linked List",
      "link": "https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list",
      "slug": "flatten-a-multilevel-doubly-linked-list",
      "description": "You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional \nchild pointer\n. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a \nmultilevel data structure\n as shown in the example below.\n\n\nGiven the \nhead\n of the first level of the list, \nflatten\n the list so that all the nodes appear in a single-level, doubly linked list. Let \ncurr\n be a node with a child list. The nodes in the child list should appear \nafter\n \ncurr\n and \nbefore\n \ncurr.next\n in the flattened list.\n\n\nReturn \nthe \nhead\n of the flattened list. The nodes in the list must have \nall\n of their child pointers set to \nnull\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n\nOutput:\n [1,2,3,7,8,11,12,9,10,4,5,6]\n\nExplanation:\n The multilevel linked list in the input is shown.\nAfter flattening the multilevel linked list it becomes:\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,null,3]\n\nOutput:\n [1,3,2]\n\nExplanation:\n The multilevel linked list in the input is shown.\nAfter flattening the multilevel linked list it becomes:\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = []\n\nOutput:\n []\n\nExplanation:\n There could be empty list in the input.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of Nodes will not exceed \n1000\n.\n\n\n1 <= Node.val <= 10\n5\n\n\n\n\n \n\n\nHow the multilevel linked list is represented in test cases:\n\n\nWe use the multilevel linked list from \nExample 1\n above:\n\n\n\n 1---2---3---4---5---6--NULL\n         |\n         7---8---9---10--NULL\n             |\n             11--12--NULL\n\n\nThe serialization of each level is as follows:\n\n\n\n[1,2,3,4,5,6,null]\n[7,8,9,10,null]\n[11,12,null]\n\n\n\nTo serialize all levels together, we will add nulls in each level to signify no node connects to the upper node of the previous level. The serialization becomes:\n\n\n\n[1,    2,    3, 4, 5, 6, null]\n             |\n[null, null, 7,    8, 9, 10, null]\n                   |\n[            null, 11, 12, null]\n\n\n\nMerging the serialization of each level and removing trailing nulls we obtain:\n\n\n\n[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]",
      "solution": "# Definition for a Node.\nclass Node:\n    def __init__(self, val, prev, next, child):\n        self.val = val\n        self.prev = prev\n        self.next = next\n        self.child = child\n\nclass Solution:\n    def flatten(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        if not head:\n            return head  # Empty list, nothing to flatten\n        \n        curr = head\n\n        while curr:\n            if not curr.child:\n                # No child at current node; just move to next\n                curr = curr.next\n                continue\n\n            # Find the tail of the child list\n            temp = curr.child\n            while temp.next:\n                temp = temp.next\n\n            # Connect child's tail to current node's next node\n            temp.next = curr.next\n            if curr.next:\n                curr.next.prev = temp\n\n            # Connect current node to its child\n            curr.next = curr.child\n            curr.child.prev = curr\n\n            # Remove the child pointer\n            curr.child = None\n        \n        return head",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    }
  ],
  "LinkedList In-place Reversal": [
    {
      "title": "Palindrome Linked List",
      "difficulty": "Easy",
      "category": "LinkedList In-place Reversal",
      "link": "https://leetcode.com/problems/palindrome-linked-list",
      "slug": "palindrome-linked-list",
      "description": "Given the \nhead\n of a singly linked list, return \ntrue\n if it is a \npalindrome\n or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,2,1]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[1, 10\n5\n]\n.\n\n\n0 <= Node.val <= 9\n\n\n\n\n \n\n\nFollow up:\n Could you do it in \nO(n)\n time and \nO(1)\n space?",
      "solution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\n        if not head or not head.next:\n            return True\n\n        # Step 1: Find middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # Step 2: Reverse second half\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n\n        # Step 3: Compare first and second half\n        left, right = head, prev\n        while right:  # only need to check right half\n            if left.val != right.val:\n                return False\n            left = left.next\n            right = right.next\n\n        return True",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Reverse Linked List",
      "difficulty": "Easy",
      "category": "LinkedList In-place Reversal",
      "link": "https://leetcode.com/problems/reverse-linked-list",
      "slug": "reverse-linked-list",
      "description": "Given the \nhead\n of a singly linked list, reverse the list, and return \nthe reversed list\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5]\n\nOutput:\n [5,4,3,2,1]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2]\n\nOutput:\n [2,1]\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is the range \n[0, 5000]\n.\n\n\n-5000 <= Node.val <= 5000\n\n\n\n\n \n\n\nFollow up:\n A linked list can be reversed either iteratively or recursively. Could you implement both?",
      "solution": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        node = None  # This will become the new head (initially empty)\n\n        while head:\n            temp = head.next      # Store next node\n            head.next = node      # Reverse current node's pointer\n            node = head           # Move `node` forward\n            head = temp           # Move to next node in original list\n        \n        return node               # `node` now points to the new head",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Reverse Linked List II",
      "difficulty": "Medium",
      "category": "LinkedList In-place Reversal",
      "link": "https://leetcode.com/problems/reverse-linked-list-ii",
      "slug": "reverse-linked-list-ii",
      "description": "Given the \nhead\n of a singly linked list and two integers \nleft\n and \nright\n where \nleft <= right\n, reverse the nodes of the list from position \nleft\n to position \nright\n, and return \nthe reversed list\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], left = 2, right = 4\n\nOutput:\n [1,4,3,2,5]\n\n\n\nExample 2:\n\n\n\n\nInput:\n head = [5], left = 1, right = 1\n\nOutput:\n [5]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is \nn\n.\n\n\n1 <= n <= 500\n\n\n-500 <= Node.val <= 500\n\n\n1 <= left <= right <= n\n\n\n\n\n \n\n\nFollow up:\n Could you do it in one pass?",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))class Solution(object):\n    # @param head, a ListNode\n    # @param m, an integer\n    # @param n, an integer\n    # @return a ListNode\n    def reverseBetween(self, head, m, n):\n        diff, dummy, cur = n - m + 1, ListNode(-1), head\n        dummy.next = head\n\n        last_unswapped = dummy\n        while cur and m > 1:\n            cur, last_unswapped, m = cur.next, cur, m - 1\n\n        prev, first_swapped = last_unswapped,  cur\n        while cur and diff > 0:\n            cur.next, prev, cur, diff = prev, cur, cur.next, diff - 1\n\n        last_unswapped.next, first_swapped.next = prev, cur\n\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Reverse Nodes in k-Group",
      "difficulty": "Hard",
      "category": "LinkedList In-place Reversal",
      "link": "https://leetcode.com/problems/reverse-nodes-in-k-group",
      "slug": "reverse-nodes-in-k-group",
      "description": "Given the \nhead\n of a linked list, reverse the nodes of the list \nk\n at a time, and return \nthe modified list\n.\n\n\nk\n is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of \nk\n then left-out nodes, in the end, should remain as it is.\n\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 2\n\nOutput:\n [2,1,4,3,5]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 3\n\nOutput:\n [3,2,1,4,5]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is \nn\n.\n\n\n1 <= k <= n <= 5000\n\n\n0 <= Node.val <= 1000\n\n\n\n\n \n\n\nFollow-up:\n Can you solve the problem in \nO(1)\n extra memory space?",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\nclass Solution(object):\n    # @param head, a ListNode\n    # @param k, an integer\n    # @return a ListNode\n    def reverseKGroup(self, head, k):\n        dummy = ListNode(-1)\n        dummy.next = head\n\n        cur, cur_dummy = head, dummy\n        length = 0\n\n        while cur:\n            next_cur = cur.next\n            length = (length + 1) % k\n\n            if length == 0:\n                next_dummy = cur_dummy.next\n                self.reverse(cur_dummy, cur.next)\n                cur_dummy = next_dummy\n\n            cur = next_cur\n\n        return dummy.next\n\n    def reverse(self, begin, end):\n            first = begin.next\n            cur = first.next\n\n            while cur != end:\n                first.next = cur.next\n                cur.next = begin.next\n                begin.next = cur\n                cur = first.next",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    }
  ],
  "Fast and Slow Pointers": [
    {
      "title": "Middle of the Linked List",
      "difficulty": "Easy",
      "category": "Fast and Slow Pointers",
      "link": "https://leetcode.com/problems/middle-of-the-linked-list",
      "slug": "middle-of-the-linked-list",
      "description": "Given the \nhead\n of a singly linked list, return \nthe middle node of the linked list\n.\n\n\nIf there are two middle nodes, return \nthe second middle\n node.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5]\n\nOutput:\n [3,4,5]\n\nExplanation:\n The middle node of the list is node 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5,6]\n\nOutput:\n [4,5,6]\n\nExplanation:\n Since the list has two middle nodes with values 3 and 4, we return the second one.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[1, 100]\n.\n\n\n1 <= Node.val <= 100",
      "solution": "class Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast = head        # Moves 2 steps at a time\n        slow = head        # Moves 1 step at a time\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Happy Number",
      "difficulty": "Easy",
      "category": "Fast and Slow Pointers",
      "link": "https://leetcode.com/problems/happy-number",
      "slug": "happy-number",
      "description": "Write an algorithm to determine if a number \nn\n is happy.\n\n\nA \nhappy number\n is a number defined by the following process:\n\n\n\n\nStarting with any positive integer, replace the number by the sum of the squares of its digits.\n\n\nRepeat the process until the number equals 1 (where it will stay), or it \nloops endlessly in a cycle\n which does not include 1.\n\n\nThose numbers for which this process \nends in 1\n are happy.\n\n\n\n\nReturn \ntrue\n \nif\n \nn\n \nis a happy number, and\n \nfalse\n \nif not\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 19\n\nOutput:\n true\n\nExplanation:\n\n1\n2\n + 9\n2\n = 82\n8\n2\n + 2\n2\n = 68\n6\n2\n + 8\n2\n = 100\n1\n2\n + 0\n2\n + 0\n2\n = 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2\n31\n - 1",
      "solution": "class Solution:\n    def isHappy(self, n: int) -> bool:\n\n        # Helper function to compute the sum of squares of digits of a number\n        def getNextNumber(n):\n            output = 0\n            while n:\n                digit = n % 10             # Extract the last digit\n                output += digit ** 2       # Add the square of the digit to output\n                n = n // 10                # Remove the last digit\n            return output\n\n        # Initialize slow and fast pointers using Floyd’s Cycle Detection method\n        slow = getNextNumber(n)                        # Move 1 step\n        fast = getNextNumber(getNextNumber(n))         # Move 2 steps\n\n        # Continue until slow and fast pointers meet (cycle detected)\n        while slow != fast:\n            if fast == 1:\n                return True                            # Found a happy number\n            slow = getNextNumber(slow)                 # Move slow one step\n            fast = getNextNumber(getNextNumber(fast))  # Move fast two steps\n\n        # Check if the cycle ended at number 1\n        return slow == 1",
      "explanation": "N/A",
      "time_complexity": "O(k), where k is the steps to be happy number",
      "space_complexity": "O(k)"
    },
    {
      "title": "Linked List Cycle II",
      "difficulty": "Medium",
      "category": "Fast and Slow Pointers",
      "link": "https://leetcode.com/problems/linked-list-cycle-ii",
      "slug": "linked-list-cycle-ii",
      "description": "Given the \nhead\n of a linked list, return \nthe node where the cycle begins. If there is no cycle, return \nnull\n.\n\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the \nnext\n pointer. Internally, \npos\n is used to denote the index of the node that tail's \nnext\n pointer is connected to (\n0-indexed\n). It is \n-1\n if there is no cycle. \nNote that\n \npos\n \nis not passed as a parameter\n.\n\n\nDo not modify\n the linked list.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [3,2,0,-4], pos = 1\n\nOutput:\n tail connects to node index 1\n\nExplanation:\n There is a cycle in the linked list, where tail connects to the second node.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2], pos = 0\n\nOutput:\n tail connects to node index 0\n\nExplanation:\n There is a cycle in the linked list, where tail connects to the first node.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n head = [1], pos = -1\n\nOutput:\n no cycle\n\nExplanation:\n There is no cycle in the linked list.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of the nodes in the list is in the range \n[0, 10\n4\n]\n.\n\n\n-10\n5\n <= Node.val <= 10\n5\n\n\npos\n is \n-1\n or a \nvalid index\n in the linked-list.\n\n\n\n\n \n\n\nFollow up:\n Can you solve it using \nO(1)\n (i.e. constant) memory?",
      "solution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow, fast = head, head\n\n        # Phase 1: Detect the cycle\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break\n        else:\n            return None  # No cycle found\n\n        # Phase 2: Find the start of the cycle\n        slow2 = head\n        while slow != slow2:\n            slow = slow.next\n            slow2 = slow2.next\n\n        return slow  # or return slow2",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    }
  ],
  "Stacks": [
    {
      "title": "Valid Parentheses",
      "difficulty": "Easy",
      "category": "Stacks",
      "link": "https://leetcode.com/problems/valid-parentheses",
      "slug": "valid-parentheses",
      "description": "Given a string \ns\n containing just the characters \n'('\n, \n')'\n, \n'{'\n, \n'}'\n, \n'['\n and \n']'\n, determine if the input string is valid.\n\n\nAn input string is valid if:\n\n\n\n\nOpen brackets must be closed by the same type of brackets.\n\n\nOpen brackets must be closed in the correct order.\n\n\nEvery close bracket has a corresponding open bracket of the same type.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"()\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"()[]{}\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"(]\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"([])\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"([)]\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of parentheses only \n'()[]{}'\n.",
      "solution": "class Solution(object):\n    # @return a boolean\n    def isValid(self, s):\n        stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        for parenthese in s:\n            if parenthese in lookup:\n                stack.append(parenthese)\n            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:\n                return False\n        return len(stack) == 0",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Remove All Adjacent Duplicates In String",
      "difficulty": "Easy",
      "category": "Stacks",
      "link": "https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string",
      "slug": "remove-all-adjacent-duplicates-in-string",
      "description": "You are given a string \ns\n consisting of lowercase English letters. A \nduplicate removal\n consists of choosing two \nadjacent\n and \nequal\n letters and removing them.\n\n\nWe repeatedly make \nduplicate removals\n on \ns\n until we no longer can.\n\n\nReturn \nthe final string after all such duplicate removals have been made\n. It can be proven that the answer is \nunique\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abbaca\"\n\nOutput:\n \"ca\"\n\nExplanation:\n \nFor example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"azxxzy\"\n\nOutput:\n \"ay\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns\n consists of lowercase English letters.",
      "solution": "class Solution(object):\n    def removeDuplicates(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n        result = []\n        for c in S:\n            if result and result[-1] == c:\n                result.pop()\n            else:\n                result.append(c)\n        return \"\".join(result)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Min Stack",
      "difficulty": "Medium",
      "category": "Stacks",
      "link": "https://leetcode.com/problems/min-stack",
      "slug": "min-stack",
      "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\n\nImplement the \nMinStack\n class:\n\n\n\n\nMinStack()\n initializes the stack object.\n\n\nvoid push(int val)\n pushes the element \nval\n onto the stack.\n\n\nvoid pop()\n removes the element on the top of the stack.\n\n\nint top()\n gets the top element of the stack.\n\n\nint getMin()\n retrieves the minimum element in the stack.\n\n\n\n\nYou must implement a solution with \nO(1)\n time complexity for each function.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n\nOutput\n\n[null,null,null,null,-3,null,0,-2]\n\n\nExplanation\n\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= val <= 2\n31\n - 1\n\n\nMethods \npop\n, \ntop\n and \ngetMin\n operations will always be called on \nnon-empty\n stacks.\n\n\nAt most \n3 * 10\n4\n calls will be made to \npush\n, \npop\n, \ntop\n, and \ngetMin\n.",
      "solution": "class MinStack(object):\n    def __init__(self):\n        self.min = None\n        self.stack = []\n\n    # @param x, an integer\n    # @return an integer\n    def push(self, x):\n        if not self.stack:\n            self.stack.append(0)\n            self.min = x\n        else:\n            self.stack.append(x - self.min)\n            if x < self.min:\n                self.min = x\n\n    # @return nothing\n    def pop(self):\n        x = self.stack.pop()\n        if x < 0:\n            self.min = self.min - x\n\n    # @return an integer\n    def top(self):\n        x = self.stack[-1]\n        if x > 0:\n            return x + self.min\n        else:\n            return self.min\n\n    # @return an integer\n    def getMin(self):\n        return self.min\nclass MinStack2(object):\n    def __init__(self):\n        self.stack, self.minStack = [], []\n    # @param x, an integer\n    # @return an integer\n    def push(self, x):\n        self.stack.append(x)\n        if len(self.minStack):\n            if x < self.minStack[-1][0]:\n                self.minStack.append([x, 1])\n            elif x == self.minStack[-1][0]:\n                self.minStack[-1][1] += 1\n        else:\n            self.minStack.append([x, 1])\n\n    # @return nothing\n    def pop(self):\n        x = self.stack.pop()\n        if x == self.minStack[-1][0]:\n            self.minStack[-1][1] -= 1\n            if self.minStack[-1][1] == 0:\n                self.minStack.pop()\n\n    # @return an integer\n    def top(self):\n        return self.stack[-1]\n\n    # @return an integer\n    def getMin(self):\n        return self.minStack[-1][0]\n\n# time: O(1)\n# space: O(n)\nclass MinStack3(object):\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x):\n        if self.stack:\n            current_min = min(x, self.stack[-1][0])\n            self.stack.append((current_min, x))\n        else:\n            self.stack.append((x, x))\n\n    def pop(self):\n        return self.stack.pop()[1]\n\n    def top(self):\n        return self.stack[-1][1]\n\n    def getMin(self):\n        return self.stack[-1][0]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Remove Duplicate Letters",
      "difficulty": "Medium",
      "category": "Stacks",
      "link": "https://leetcode.com/problems/remove-duplicate-letters",
      "slug": "remove-duplicate-letters",
      "description": "Given a string \ns\n, remove duplicate letters so that every letter appears once and only once. You must make sure your result is \nthe smallest in lexicographical order\n among all possible results.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"bcabc\"\n\nOutput:\n \"abc\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"cbacdcbc\"\n\nOutput:\n \"acdb\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of lowercase English letters.\n\n\n\n\n \n\n\nNote:\n This question is the same as 1081: \nhttps://leetcode.com/problems/smallest-subsequence-of-distinct-characters/",
      "solution": "\nfrom collections import Counter\n\nclass Solution(object):\n    def removeDuplicateLetters(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        remaining = Counter(s)\n\n        in_stack, stk = set(), []\n        for c in s:\n            if c not in in_stack:\n                while stk and stk[-1] > c and remaining[stk[-1]]:\n                    in_stack.remove(stk.pop())\n                stk += c\n                in_stack.add(c)\n            remaining[c] -= 1\n        return \"\".join(stk)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(k), k is size of the alphabet"
    },
    {
      "title": "Removing Stars From a String",
      "difficulty": "Medium",
      "category": "Stacks",
      "link": "https://leetcode.com/problems/removing-stars-from-a-string",
      "slug": "removing-stars-from-a-string",
      "description": "You are given a string \ns\n, which contains stars \n*\n.\n\n\nIn one operation, you can:\n\n\n\n\nChoose a star in \ns\n.\n\n\nRemove the closest \nnon-star\n character to its \nleft\n, as well as remove the star itself.\n\n\n\n\nReturn \nthe string after \nall\n stars have been removed\n.\n\n\nNote:\n\n\n\n\nThe input will be generated such that the operation is always possible.\n\n\nIt can be shown that the resulting string will always be unique.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"leet**cod*e\"\n\nOutput:\n \"lecoe\"\n\nExplanation:\n Performing the removals from left to right:\n- The closest character to the 1\nst\n star is 't' in \"lee\nt\n**cod*e\". s becomes \"lee*cod*e\".\n- The closest character to the 2\nnd\n star is 'e' in \"le\ne\n*cod*e\". s becomes \"lecod*e\".\n- The closest character to the 3\nrd\n star is 'd' in \"leco\nd\n*e\". s becomes \"lecoe\".\nThere are no more stars, so we return \"lecoe\".\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"erase*****\"\n\nOutput:\n \"\"\n\nExplanation:\n The entire string is removed, so we return an empty string.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns\n consists of lowercase English letters and stars \n*\n.\n\n\nThe operation above can be performed on \ns\n.",
      "solution": "\n# stackclass Solution(object):\n    def removeStars(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        result = []\n        for c in s:\n            if c == '*':\n                result.pop()\n            else:\n                result.append(c)\n        return \"\".join(result)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Evaluate Reverse Polish Notation",
      "difficulty": "Medium",
      "category": "Stacks",
      "link": "https://leetcode.com/problems/evaluate-reverse-polish-notation",
      "slug": "evaluate-reverse-polish-notation",
      "description": "You are given an array of strings \ntokens\n that represents an arithmetic expression in a \nReverse Polish Notation\n.\n\n\nEvaluate the expression. Return \nan integer that represents the value of the expression\n.\n\n\nNote\n that:\n\n\n\n\nThe valid operators are \n'+'\n, \n'-'\n, \n'*'\n, and \n'/'\n.\n\n\nEach operand may be an integer or another expression.\n\n\nThe division between two integers always \ntruncates toward zero\n.\n\n\nThere will not be any division by zero.\n\n\nThe input represents a valid arithmetic expression in a reverse polish notation.\n\n\nThe answer and all the intermediate calculations can be represented in a \n32-bit\n integer.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\n\nOutput:\n 9\n\nExplanation:\n ((2 + 1) * 3) = 9\n\n\n\nExample 2:\n\n\n\n\nInput:\n tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\n\nOutput:\n 6\n\nExplanation:\n (4 + (13 / 5)) = 6\n\n\n\nExample 3:\n\n\n\n\nInput:\n tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\n\nOutput:\n 22\n\nExplanation:\n ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= tokens.length <= 10\n4\n\n\ntokens[i]\n is either an operator: \n\"+\"\n, \n\"-\"\n, \n\"*\"\n, or \n\"/\"\n, or an integer in the range \n[-200, 200]\n.",
      "solution": "\nimport operator\nclass Solution(object):\n    # @param tokens, a list of string\n    # @return an integer\n    def evalRPN(self, tokens):\n        numerals, operators = [], {\"+\": operator.add, \"-\": operator.sub, \"*\": operator.mul, \"/\": operator.div}\n        for token in tokens:\n            if token not in operators:\n                numerals.append(int(token))\n            else:\n                y, x = numerals.pop(), numerals.pop()\n                numerals.append(int(operators[token](x * 1.0, y)))\n        return numerals.pop()",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Basic Calculator II",
      "difficulty": "Medium",
      "category": "Stacks",
      "link": "https://leetcode.com/problems/basic-calculator-ii",
      "slug": "basic-calculator-ii",
      "description": "Given a string \ns\n which represents an expression, \nevaluate this expression and return its value\n. \n\n\nThe integer division should truncate toward zero.\n\n\nYou may assume that the given expression is always valid. All intermediate results will be in the range of \n[-2\n31\n, 2\n31\n - 1]\n.\n\n\nNote:\n You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as \neval()\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"3+2*2\"\n\nOutput:\n 7\n\nExample 2:\n\n\nInput:\n s = \" 3/2 \"\n\nOutput:\n 1\n\nExample 3:\n\n\nInput:\n s = \" 3+5 / 2 \"\n\nOutput:\n 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 3 * 10\n5\n\n\ns\n consists of integers and operators \n('+', '-', '*', '/')\n separated by some number of spaces.\n\n\ns\n represents \na valid expression\n.\n\n\nAll the integers in the expression are non-negative integers in the range \n[0, 2\n31\n - 1]\n.\n\n\nThe answer is \nguaranteed\n to fit in a \n32-bit integer\n.",
      "solution": "\nimport operator\n\nclass Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def compute(operands, operators):\n            right, left = operands.pop(), operands.pop()\n            operands.append(ops[operators.pop()](left, right))\n\n        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}\n        precedence = {'+':0, '-':0, '*':1, '/':1}\n        operands, operators, operand = [], [], 0\n        for i in xrange(len(s)):\n            if s[i].isdigit():\n                operand = operand*10 + int(s[i])\n                if i == len(s)-1 or not s[i+1].isdigit():\n                    operands.append(operand)\n                    operand = 0\n            elif s[i] == '(':\n                operators.append(s[i])\n            elif s[i] == ')':\n                while operators[-1] != '(':\n                    compute(operands, operators)\n                operators.pop()\n            elif s[i] in precedence:\n                while operators and operators[-1] in precedence and \\\n                      precedence[operators[-1]] >= precedence[s[i]]:\n                    compute(operands, operators)\n                operators.append(s[i])\n        while operators:\n            compute(operands, operators)\n        return operands[-1]\n\nclass Solution2(object):\n    # @param {string} s\n    # @return {integer}\n    def calculate(self, s):\n        operands, operators = [], []\n        operand = \"\"\n        for i in reversed(xrange(len(s))):\n            if s[i].isdigit():\n                operand += s[i]\n                if i == 0 or not s[i-1].isdigit():\n                    operands.append(int(operand[::-1]))\n                    operand = \"\"\n            elif s[i] == ')' or s[i] == '*' or s[i] == '/':\n                operators.append(s[i])\n            elif s[i] == '+' or s[i] == '-':\n                while operators and \\\n                      (operators[-1] == '*' or operators[-1] == '/'):\n                    self.compute(operands, operators)\n                operators.append(s[i])\n            elif s[i] == '(':\n                while operators[-1] != ')':\n                    self.compute(operands, operators)\n                operators.pop()\n\n        while operators:\n            self.compute(operands, operators)\n\n        return operands[-1]\n\n    def compute(self, operands, operators):\n        left, right = operands.pop(), operands.pop()\n        op = operators.pop()\n        if op == '+':\n            operands.append(left + right)\n        elif op == '-':\n            operands.append(left - right)\n        elif op == '*':\n            operands.append(left * right)\n        elif op == '/':\n            operands.append(left / right)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Longest Valid Parentheses",
      "difficulty": "Hard",
      "category": "Stacks",
      "link": "https://leetcode.com/problems/longest-valid-parentheses",
      "slug": "longest-valid-parentheses",
      "description": "Given a string containing just the characters \n'('\n and \n')'\n, return \nthe length of the longest valid (well-formed) parentheses \nsubstring\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"(()\"\n\nOutput:\n 2\n\nExplanation:\n The longest valid parentheses substring is \"()\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \")()())\"\n\nOutput:\n 4\n\nExplanation:\n The longest valid parentheses substring is \"()()\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"\"\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 3 * 10\n4\n\n\ns[i]\n is \n'('\n, or \n')'\n.",
      "solution": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def length(it, start, c):\n            depth, longest = 0, 0\n            for i in it:\n                if s[i] == c:\n                    depth += 1\n                else:\n                    depth -= 1\n                    if depth < 0:\n                        start, depth = i, 0\n                    elif depth == 0:\n                        longest = max(longest, abs(i - start))\n            return longest\n\n        return max(length(xrange(len(s)), -1, '('), \\\n                   length(reversed(xrange(len(s))), len(s), ')'))\n\nclass Solution2(object):\n    # @param s, a string\n    # @return an integer\n    def longestValidParentheses(self, s):\n        longest, last, indices = 0, -1, []\n        for i in xrange(len(s)):\n            if s[i] == '(':\n                indices.append(i)\n            elif not indices:\n                last = i\n            else:\n                indices.pop()\n                if not indices:\n                    longest = max(longest, i - last)\n                else:\n                    longest = max(longest, i - indices[-1])\n        return longest",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    }
  ],
  "Monotonic Stack": [
    {
      "title": "Next Greater Element I",
      "difficulty": "Easy",
      "category": "Monotonic Stack",
      "link": "https://leetcode.com/problems/next-greater-element-i",
      "slug": "next-greater-element-i",
      "description": "The \nnext greater element\n of some element \nx\n in an array is the \nfirst greater\n element that is \nto the right\n of \nx\n in the same array.\n\n\nYou are given two \ndistinct 0-indexed\n integer arrays \nnums1\n and \nnums2\n, where \nnums1\n is a subset of \nnums2\n.\n\n\nFor each \n0 <= i < nums1.length\n, find the index \nj\n such that \nnums1[i] == nums2[j]\n and determine the \nnext greater element\n of \nnums2[j]\n in \nnums2\n. If there is no next greater element, then the answer for this query is \n-1\n.\n\n\nReturn \nan array \nans\n of length \nnums1.length\n such that \nans[i]\n is the \nnext greater element\n as described above.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [4,1,2], nums2 = [1,3,4,2]\n\nOutput:\n [-1,3,-1]\n\nExplanation:\n The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,\n4\n,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [\n1\n,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,\n2\n]. There is no next greater element, so the answer is -1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [2,4], nums2 = [1,2,3,4]\n\nOutput:\n [3,-1]\n\nExplanation:\n The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,\n2\n,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,\n4\n]. There is no next greater element, so the answer is -1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length <= nums2.length <= 1000\n\n\n0 <= nums1[i], nums2[i] <= 10\n4\n\n\nAll integers in \nnums1\n and \nnums2\n are \nunique\n.\n\n\nAll the integers of \nnums1\n also appear in \nnums2\n.\n\n\n\n\n \n\n\nFollow up:\n Could you find an \nO(nums1.length + nums2.length)\n solution?",
      "solution": "class Solution(object):\n    def nextGreaterElement(self, findNums, nums):\n        \"\"\"\n        :type findNums: List[int]\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        stk, lookup = [], {}\n        for num in nums:\n            while stk and num > stk[-1]:\n                lookup[stk.pop()] = num\n            stk.append(num)\n        while stk:\n            lookup[stk.pop()] = -1\n        return map(lambda x : lookup[x], findNums)",
      "explanation": "N/A",
      "time_complexity": "O(m + n)",
      "space_complexity": "O(m + n)"
    },
    {
      "title": "Daily Temperatures",
      "difficulty": "Medium",
      "category": "Monotonic Stack",
      "link": "https://leetcode.com/problems/daily-temperatures",
      "slug": "daily-temperatures",
      "description": "Given an array of integers \ntemperatures\n represents the daily temperatures, return \nan array\n \nanswer\n \nsuch that\n \nanswer[i]\n \nis the number of days you have to wait after the\n \ni\nth\n \nday to get a warmer temperature\n. If there is no future day for which this is possible, keep \nanswer[i] == 0\n instead.\n\n\n \n\n\nExample 1:\n\n\nInput:\n temperatures = [73,74,75,71,69,72,76,73]\n\nOutput:\n [1,1,4,2,1,1,0,0]\n\nExample 2:\n\n\nInput:\n temperatures = [30,40,50,60]\n\nOutput:\n [1,1,1,0]\n\nExample 3:\n\n\nInput:\n temperatures = [30,60,90]\n\nOutput:\n [1,1,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= temperatures.length <= 10\n5\n\n\n30 <= temperatures[i] <= 100",
      "solution": "class Solution(object):\n    def dailyTemperatures(self, temperatures):\n        \"\"\"\n        :type temperatures: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0] * len(temperatures)\n        stk = []\n        for i in xrange(len(temperatures)):\n            while stk and \\\n                  temperatures[stk[-1]] < temperatures[i]:\n                idx = stk.pop()\n                result[idx] = i-idx\n            stk.append(i)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Online Stock Span",
      "difficulty": "Medium",
      "category": "Monotonic Stack",
      "link": "https://leetcode.com/problems/online-stock-span",
      "slug": "online-stock-span",
      "description": "Design an algorithm that collects daily price quotes for some stock and returns \nthe span\n of that stock's price for the current day.\n\n\nThe \nspan\n of the stock's price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.\n\n\n\n\nFor example, if the prices of the stock in the last four days is \n[7,2,1,2]\n and the price of the stock today is \n2\n, then the span of today is \n4\n because starting from today, the price of the stock was less than or equal \n2\n for \n4\n consecutive days.\n\n\nAlso, if the prices of the stock in the last four days is \n[7,34,1,2]\n and the price of the stock today is \n8\n, then the span of today is \n3\n because starting from today, the price of the stock was less than or equal \n8\n for \n3\n consecutive days.\n\n\n\n\nImplement the \nStockSpanner\n class:\n\n\n\n\nStockSpanner()\n Initializes the object of the class.\n\n\nint next(int price)\n Returns the \nspan\n of the stock's price given that today's price is \nprice\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"StockSpanner\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\"]\n[[], [100], [80], [60], [70], [60], [75], [85]]\n\nOutput\n\n[null, 1, 1, 1, 2, 1, 4, 6]\n\n\nExplanation\n\nStockSpanner stockSpanner = new StockSpanner();\nstockSpanner.next(100); // return 1\nstockSpanner.next(80);  // return 1\nstockSpanner.next(60);  // return 1\nstockSpanner.next(70);  // return 2\nstockSpanner.next(60);  // return 1\nstockSpanner.next(75);  // return 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price.\nstockSpanner.next(85);  // return 6\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= price <= 10\n5\n\n\nAt most \n10\n4\n calls will be made to \nnext\n.",
      "solution": "class StockSpanner(object):\n\n    def __init__(self):\n        self.__s = []\n\n    def next(self, price):\n        \"\"\"\n        :type price: int\n        :rtype: int\n        \"\"\"\n        result = 1\n        while self.__s and self.__s[-1][0] <= price:\n            result += self.__s.pop()[1]\n        self.__s.append([price, result])\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "132 Pattern",
      "difficulty": "Medium",
      "category": "Monotonic Stack",
      "link": "https://leetcode.com/problems/132-pattern",
      "slug": "132-pattern",
      "description": "Given an array of \nn\n integers \nnums\n, a \n132 pattern\n is a subsequence of three integers \nnums[i]\n, \nnums[j]\n and \nnums[k]\n such that \ni < j < k\n and \nnums[i] < nums[k] < nums[j]\n.\n\n\nReturn \ntrue\n if there is a \n132 pattern\n in \nnums\n, otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,4]\n\nOutput:\n false\n\nExplanation:\n There is no 132 pattern in the sequence.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,1,4,2]\n\nOutput:\n true\n\nExplanation:\n There is a 132 pattern in the sequence: [1, 4, 2].\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [-1,3,2,0]\n\nOutput:\n true\n\nExplanation:\n There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 2 * 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9",
      "solution": "class Solution(object):\n    def find132pattern(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        ak = float(\"-inf\")\n        stk = []\n        for i in reversed(xrange(len(nums))):\n            if nums[i] < ak:\n                return True\n            while stk and stk[-1] < nums[i]:\n                ak = stk.pop()\n            stk.append(nums[i])\n        return False\n\nclass Solution_TLE(object):\n    def find132pattern(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for k in xrange(len(nums)):\n            valid = False\n            for j in xrange(k):\n                if nums[j] < nums[k]:\n                    valid = True\n                elif nums[j] > nums[k]:\n                    if valid:\n                        return True\n        return False",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Number of Visible People in a Queue",
      "difficulty": "Hard",
      "category": "Monotonic Stack",
      "link": "https://leetcode.com/problems/number-of-visible-people-in-a-queue",
      "slug": "number-of-visible-people-in-a-queue",
      "description": "There are \nn\n people standing in a queue, and they numbered from \n0\n to \nn - 1\n in \nleft to right\n order. You are given an array \nheights\n of \ndistinct\n integers where \nheights[i]\n represents the height of the \ni\nth\n person.\n\n\nA person can \nsee\n another person to their right in the queue if everybody in between is \nshorter\n than both of them. More formally, the \ni\nth\n person can see the \nj\nth\n person if \ni < j\n and \nmin(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1])\n.\n\n\nReturn \nan array \nanswer\n of length \nn\n where \nanswer[i]\n is the \nnumber of people\n the \ni\nth\n person can \nsee\n to their right in the queue\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [10,6,8,5,11,9]\n\nOutput:\n [3,1,2,1,1,0]\n\nExplanation:\n\nPerson 0 can see person 1, 2, and 4.\nPerson 1 can see person 2.\nPerson 2 can see person 3 and 4.\nPerson 3 can see person 4.\nPerson 4 can see person 5.\nPerson 5 can see no one since nobody is to the right of them.\n\n\n\nExample 2:\n\n\n\n\nInput:\n heights = [5,1,2,3,10]\n\nOutput:\n [4,1,1,1,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == heights.length\n\n\n1 <= n <= 10\n5\n\n\n1 <= heights[i] <= 10\n5\n\n\nAll the values of \nheights\n are \nunique\n.",
      "solution": "class Solution(object):\n    def canSeePersonsCount(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(heights)\n        stk = []\n        for i, h in enumerate(heights):\n            while stk and heights[stk[-1]] < h:\n                result[stk.pop()] += 1\n            if stk:\n                result[stk[-1]] += 1\n            if stk and heights[stk[-1]] == h:\n                stk.pop()\n            stk.append(i)\n        return result\n\nclass Solution2(object):\n    def canSeePersonsCount(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(heights)\n        stk = []\n        for i in reversed(xrange(len(heights))):\n            cnt = 0\n            while stk and heights[stk[-1]] < heights[i]:\n                stk.pop()\n                cnt += 1\n            result[i] = cnt+1 if stk else cnt\n            if stk and heights[stk[-1]] == heights[i]:\n                stk.pop()\n            stk.append(i)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Largest Rectangle in Histogram",
      "difficulty": "Hard",
      "category": "Monotonic Stack",
      "link": "https://leetcode.com/problems/largest-rectangle-in-histogram",
      "slug": "largest-rectangle-in-histogram",
      "description": "Given an array of integers \nheights\n representing the histogram's bar height where the width of each bar is \n1\n, return \nthe area of the largest rectangle in the histogram\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [2,1,5,6,2,3]\n\nOutput:\n 10\n\nExplanation:\n The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n heights = [2,4]\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= heights.length <= 10\n5\n\n\n0 <= heights[i] <= 10\n4",
      "solution": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stk, result = [-1], 0\n        for i in xrange(len(heights)+1):\n            while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):\n                result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))\n            stk.append(i) \n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    }
  ],
  "Queues": [
    {
      "title": "Number of Recent Calls",
      "difficulty": "Easy",
      "category": "Queues",
      "link": "https://leetcode.com/problems/number-of-recent-calls",
      "slug": "number-of-recent-calls",
      "description": "You have a \nRecentCounter\n class which counts the number of recent requests within a certain time frame.\n\n\nImplement the \nRecentCounter\n class:\n\n\n\n\nRecentCounter()\n Initializes the counter with zero recent requests.\n\n\nint ping(int t)\n Adds a new request at time \nt\n, where \nt\n represents some time in milliseconds, and returns the number of requests that has happened in the past \n3000\n milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range \n[t - 3000, t]\n.\n\n\n\n\nIt is \nguaranteed\n that every call to \nping\n uses a strictly larger value of \nt\n than the previous call.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"RecentCounter\", \"ping\", \"ping\", \"ping\", \"ping\"]\n[[], [1], [100], [3001], [3002]]\n\nOutput\n\n[null, 1, 2, 3, 3]\n\n\nExplanation\n\nRecentCounter recentCounter = new RecentCounter();\nrecentCounter.ping(1);     // requests = [\n1\n], range is [-2999,1], return 1\nrecentCounter.ping(100);   // requests = [\n1\n, \n100\n], range is [-2900,100], return 2\nrecentCounter.ping(3001);  // requests = [\n1\n, \n100\n, \n3001\n], range is [1,3001], return 3\nrecentCounter.ping(3002);  // requests = [1, \n100\n, \n3001\n, \n3002\n], range is [2,3002], return 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= t <= 10\n9\n\n\nEach test case will call \nping\n with \nstrictly increasing\n values of \nt\n.\n\n\nAt most \n10\n4\n calls will be made to \nping\n.",
      "solution": "\nimport collections\n\nclass RecentCounter(object):\n\n    def __init__(self):\n        self.__q = collections.deque()\n\n    def ping(self, t):\n        \"\"\"\n        :type t: int\n        :rtype: int\n        \"\"\"\n        self.__q.append(t)\n        while self.__q[0] < t-3000:\n            self.__q.popleft()\n        return len(self.__q)",
      "explanation": "N/A",
      "time_complexity": "O(1) on average",
      "space_complexity": "O(w), w means the size of the last milliseconds."
    },
    {
      "title": "Time Needed to Buy Tickets",
      "difficulty": "Easy",
      "category": "Queues",
      "link": "https://leetcode.com/problems/time-needed-to-buy-tickets",
      "slug": "time-needed-to-buy-tickets",
      "description": "There are \nn\n people in a line queuing to buy tickets, where the \n0\nth\n person is at the \nfront\n of the line and the \n(n - 1)\nth\n person is at the \nback\n of the line.\n\n\nYou are given a \n0-indexed\n integer array \ntickets\n of length \nn\n where the number of tickets that the \ni\nth\n person would like to buy is \ntickets[i]\n.\n\n\nEach person takes \nexactly 1 second\n to buy a ticket. A person can only buy \n1 ticket at a time\n and has to go back to \nthe end\n of the line (which happens \ninstantaneously\n) in order to buy more tickets. If a person does not have any tickets left to buy, the person will \nleave \nthe line.\n\n\nReturn the \ntime taken\n for the person \ninitially\n at position \nk\n \n(0-indexed) to finish buying tickets.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ntickets = [2,3,2], k = 2\n\n\nOutput:\n \n6\n\n\nExplanation:\n\n\n\n\nThe queue starts as [2,3,\n2\n], where the kth person is underlined.\n\n\nAfter the person at the front has bought a ticket, the queue becomes [3,\n2\n,1] at 1 second.\n\n\nContinuing this process, the queue becomes [\n2\n,1,2] at 2 seconds.\n\n\nContinuing this process, the queue becomes [1,2,\n1\n] at 3 seconds.\n\n\nContinuing this process, the queue becomes [2,\n1\n] at 4 seconds. Note: the person at the front left the queue.\n\n\nContinuing this process, the queue becomes [\n1\n,1] at 5 seconds.\n\n\nContinuing this process, the queue becomes [1] at 6 seconds. The kth person has bought all their tickets, so return 6.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ntickets = [5,1,1,1], k = 0\n\n\nOutput:\n \n8\n\n\nExplanation:\n\n\n\n\nThe queue starts as [\n5\n,1,1,1], where the kth person is underlined.\n\n\nAfter the person at the front has bought a ticket, the queue becomes [1,1,1,\n4\n] at 1 second.\n\n\nContinuing this process for 3 seconds, the queue becomes [\n4]\n at 4 seconds.\n\n\nContinuing this process for 4 seconds, the queue becomes [] at 8 seconds. The kth person has bought all their tickets, so return 8.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == tickets.length\n\n\n1 <= n <= 100\n\n\n1 <= tickets[i] <= 100\n\n\n0 <= k < n",
      "solution": "class Solution(object):\n    def timeRequiredToBuy(self, tickets, k):\n        \"\"\"\n        :type tickets: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return sum(min(x, tickets[k] if i <= k else tickets[k]-1) for i, x in enumerate(tickets))",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Reveal Cards In Increasing Order",
      "difficulty": "Medium",
      "category": "Queues",
      "link": "https://leetcode.com/problems/reveal-cards-in-increasing-order",
      "slug": "reveal-cards-in-increasing-order",
      "description": "You are given an integer array \ndeck\n. There is a deck of cards where every card has a unique integer. The integer on the \ni\nth\n card is \ndeck[i]\n.\n\n\nYou can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck.\n\n\nYou will do the following steps repeatedly until all cards are revealed:\n\n\n\n\nTake the top card of the deck, reveal it, and take it out of the deck.\n\n\nIf there are still cards in the deck then put the next top card of the deck at the bottom of the deck.\n\n\nIf there are still unrevealed cards, go back to step 1. Otherwise, stop.\n\n\n\n\nReturn \nan ordering of the deck that would reveal the cards in increasing order\n.\n\n\nNote\n that the first entry in the answer is considered to be the top of the deck.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n deck = [17,13,11,2,3,5,7]\n\nOutput:\n [2,13,3,11,5,17,7]\n\nExplanation:\n \nWe get the deck in the order [17,13,11,2,3,5,7] (this order does not matter), and reorder it.\nAfter reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.\nWe reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].\nWe reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].\nWe reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].\nWe reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].\nWe reveal 11, and move 17 to the bottom.  The deck is now [13,17].\nWe reveal 13, and move 17 to the bottom.  The deck is now [17].\nWe reveal 17.\nSince all the cards revealed are in increasing order, the answer is correct.\n\n\n\nExample 2:\n\n\n\n\nInput:\n deck = [1,1000]\n\nOutput:\n [1,1000]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= deck.length <= 1000\n\n\n1 <= deck[i] <= 10\n6\n\n\nAll the values of \ndeck\n are \nunique\n.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def deckRevealedIncreasing(self, deck):\n        \"\"\"\n        :type deck: List[int]\n        :rtype: List[int]\n        \"\"\"\n        d = collections.deque()\n        deck.sort(reverse=True)\n        for i in deck:\n            if d:\n                d.appendleft(d.pop())\n            d.appendleft(i)\n        return list(d)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    }
  ],
  "Monotonic Queue": [
    {
      "title": "Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit",
      "difficulty": "Medium",
      "category": "Monotonic Queue",
      "link": "https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit",
      "slug": "longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit",
      "description": "Given an array of integers \nnums\n and an integer \nlimit\n, return the size of the longest \nnon-empty\n subarray such that the absolute difference between any two elements of this subarray is less than or equal to \nlimit\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [8,2,4,7], limit = 4\n\nOutput:\n 2 \n\nExplanation:\n All subarrays are: \n[8] with maximum absolute diff |8-8| = 0 <= 4.\n[8,2] with maximum absolute diff |8-2| = 6 > 4. \n[8,2,4] with maximum absolute diff |8-2| = 6 > 4.\n[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.\n[2] with maximum absolute diff |2-2| = 0 <= 4.\n[2,4] with maximum absolute diff |2-4| = 2 <= 4.\n[2,4,7] with maximum absolute diff |2-7| = 5 > 4.\n[4] with maximum absolute diff |4-4| = 0 <= 4.\n[4,7] with maximum absolute diff |4-7| = 3 <= 4.\n[7] with maximum absolute diff |7-7| = 0 <= 4. \nTherefore, the size of the longest subarray is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [10,1,2,4,7,2], limit = 5\n\nOutput:\n 4 \n\nExplanation:\n The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [4,2,2,2,4,4,2,2], limit = 0\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n1 <= nums[i] <= 10\n9\n\n\n0 <= limit <= 10\n9",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def longestSubarray(self, nums, limit):\n        \"\"\"\n        :type nums: List[int]\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        max_dq, min_dq = collections.deque(), collections.deque()\n        left = 0\n        for right, num in enumerate(nums):\n            while max_dq and nums[max_dq[-1]] <= num:\n                max_dq.pop()\n            max_dq.append(right)\n            while min_dq and nums[min_dq[-1]] >= num:\n                min_dq.pop()\n            min_dq.append(right)\n            if nums[max_dq[0]]-nums[min_dq[0]] > limit:\n                if max_dq[0] == left:\n                    max_dq.popleft()\n                if min_dq[0] == left:\n                    min_dq.popleft()\n                left += 1  # advance left by one to not count in result\n        return len(nums)-left\n\n\nimport collections\n\nclass Solution2(object):\n    def longestSubarray(self, nums, limit):\n        \"\"\"\n        :type nums: List[int]\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        max_dq, min_dq = collections.deque(), collections.deque()\n        result, left = 0, 0\n        for right, num in enumerate(nums):\n            while max_dq and nums[max_dq[-1]] <= num:\n                max_dq.pop()\n            max_dq.append(right)\n            while min_dq and nums[min_dq[-1]] >= num:\n                min_dq.pop()\n            min_dq.append(right)\n            while nums[max_dq[0]]-nums[min_dq[0]] > limit:  # both always exist \"right\" element\n                if max_dq[0] == left:\n                    max_dq.popleft()\n                if min_dq[0] == left:\n                    min_dq.popleft()\n                left += 1\n            result = max(result, right-left+1)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Jump Game VI",
      "difficulty": "Medium",
      "category": "Monotonic Queue",
      "link": "https://leetcode.com/problems/jump-game-vi",
      "slug": "jump-game-vi",
      "description": "You are given a \n0-indexed\n integer array \nnums\n and an integer \nk\n.\n\n\nYou are initially standing at index \n0\n. In one move, you can jump at most \nk\n steps forward without going outside the boundaries of the array. That is, you can jump from index \ni\n to any index in the range \n[i + 1, min(n - 1, i + k)]\n \ninclusive\n.\n\n\nYou want to reach the last index of the array (index \nn - 1\n). Your \nscore\n is the \nsum\n of all \nnums[j]\n for each index \nj\n you visited in the array.\n\n\nReturn \nthe \nmaximum score\n you can get\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [\n1\n,\n-1\n,-2,\n4\n,-7,\n3\n], k = 2\n\nOutput:\n 7\n\nExplanation:\n You can choose your jumps forming the subsequence [1,-1,4,3] (underlined above). The sum is 7.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [\n10\n,-5,-2,\n4\n,0,\n3\n], k = 3\n\nOutput:\n 17\n\nExplanation:\n You can choose your jumps forming the subsequence [10,4,3] (underlined above). The sum is 17.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,-5,-20,4,-1,3,-6,-3], k = 2\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length, k <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def maxResult(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        score = 0\n        dq = collections.deque()\n        for i, num in enumerate(nums):\n            if dq and dq[0][0] == i-k-1:\n                dq.popleft()\n            score = num if not dq else dq[0][1]+num\n            while dq and dq[-1][1] <= score:\n                dq.pop()\n            dq.append((i, score))\n        return score",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Sliding Window Maximum",
      "difficulty": "Hard",
      "category": "Monotonic Queue",
      "link": "https://leetcode.com/problems/sliding-window-maximum",
      "slug": "sliding-window-maximum",
      "description": "You are given an array of integers \nnums\n, there is a sliding window of size \nk\n which is moving from the very left of the array to the very right. You can only see the \nk\n numbers in the window. Each time the sliding window moves right by one position.\n\n\nReturn \nthe max sliding window\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,-1,-3,5,3,6,7], k = 3\n\nOutput:\n [3,3,5,5,6,7]\n\nExplanation:\n \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       \n3\n\n 1 [3  -1  -3] 5  3  6  7       \n3\n\n 1  3 [-1  -3  5] 3  6  7      \n 5\n\n 1  3  -1 [-3  5  3] 6  7       \n5\n\n 1  3  -1  -3 [5  3  6] 7       \n6\n\n 1  3  -1  -3  5 [3  6  7]      \n7\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1], k = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n1 <= k <= nums.length",
      "solution": "\nfrom collections import deque\n\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result, dq = [], deque()\n        for i in xrange(len(nums)):\n            if dq and i-dq[0] == k:\n                dq.popleft()\n            while dq and nums[dq[-1]] <= nums[i]:\n                dq.pop()\n            dq.append(i)\n            if i >= k-1:\n                result.append(nums[dq[0]])\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Max Value of Equation",
      "difficulty": "Hard",
      "category": "Monotonic Queue",
      "link": "https://leetcode.com/problems/max-value-of-equation",
      "slug": "max-value-of-equation",
      "description": "You are given an array \npoints\n containing the coordinates of points on a 2D plane, sorted by the x-values, where \npoints[i] = [x\ni\n, y\ni\n]\n such that \nx\ni\n < x\nj\n for all \n1 <= i < j <= points.length\n. You are also given an integer \nk\n.\n\n\nReturn \nthe maximum value of the equation \ny\ni\n + y\nj\n + |x\ni\n - x\nj\n|\n where \n|x\ni\n - x\nj\n| <= k\n and \n1 <= i < j <= points.length\n.\n\n\nIt is guaranteed that there exists at least one pair of points that satisfy the constraint \n|x\ni\n - x\nj\n| <= k\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n points = [[1,3],[2,0],[5,10],[6,-10]], k = 1\n\nOutput:\n 4\n\nExplanation:\n The first two points satisfy the condition |x\ni\n - x\nj\n| <= 1 and if we calculate the equation we get 3 + 0 + |1 - 2| = 4. Third and fourth points also satisfy the condition and give a value of 10 + -10 + |5 - 6| = 1.\nNo other pairs satisfy the condition, so we return the max of 4 and 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[0,0],[3,0],[9,2]], k = 3\n\nOutput:\n 3\n\nExplanation: \nOnly the first two points have an absolute difference of 3 or less in the x-values, and give the value of 0 + 0 + |0 - 3| = 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= points.length <= 10\n5\n\n\npoints[i].length == 2\n\n\n-10\n8\n <= x\ni\n, y\ni\n <= 10\n8\n\n\n0 <= k <= 2 * 10\n8\n\n\nx\ni\n < x\nj\n for all \n1 <= i < j <= points.length\n\n\nx\ni\n form a strictly increasing sequence.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def findMaxValueOfEquation(self, points, k):\n        \"\"\"\n        :type points: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = float(\"-inf\")\n        dq = collections.deque()\n        for i, (x, y) in enumerate(points):\n            while dq and points[dq[0]][0] < x-k:\n                dq.popleft()\n            if dq:\n                result = max(result, (points[dq[0]][1]-points[dq[0]][0])+y+x)\n            while dq and points[dq[-1]][1]-points[dq[-1]][0] <= y-x:\n                dq.pop()\n            dq.append(i)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    }
  ],
  "Bucket Sort": [
    {
      "title": "Sort Characters By Frequency",
      "difficulty": "Medium",
      "category": "Bucket Sort",
      "link": "https://leetcode.com/problems/sort-characters-by-frequency",
      "slug": "sort-characters-by-frequency",
      "description": "Given a string \ns\n, sort it in \ndecreasing order\n based on the \nfrequency\n of the characters. The \nfrequency\n of a character is the number of times it appears in the string.\n\n\nReturn \nthe sorted string\n. If there are multiple answers, return \nany of them\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"tree\"\n\nOutput:\n \"eert\"\n\nExplanation:\n 'e' appears twice while 'r' and 't' both appear once.\nSo 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"cccaaa\"\n\nOutput:\n \"aaaccc\"\n\nExplanation:\n Both 'c' and 'a' appear three times, so both \"cccaaa\" and \"aaaccc\" are valid answers.\nNote that \"cacaca\" is incorrect, as the same characters must be together.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"Aabb\"\n\nOutput:\n \"bbAa\"\n\nExplanation:\n \"bbaA\" is also a valid answer, but \"Aabb\" is incorrect.\nNote that 'A' and 'a' are treated as two different characters.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 5 * 10\n5\n\n\ns\n consists of uppercase and lowercase English letters and digits.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def frequencySort(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        freq = collections.defaultdict(int)\n        for c in s:\n            freq[c] += 1\n\n        counts = [\"\"] * (len(s)+1)\n        for c in freq:\n            counts[freq[c]] += c\n\n        result = \"\"\n        for count in reversed(xrange(len(counts)-1)):\n            for c in counts[count]:\n                result += c * count\n\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Top K Frequent Words",
      "difficulty": "Medium",
      "category": "Bucket Sort",
      "link": "https://leetcode.com/problems/top-k-frequent-words",
      "slug": "top-k-frequent-words",
      "description": "Given an array of strings \nwords\n and an integer \nk\n, return \nthe \nk\n most frequent strings\n.\n\n\nReturn the answer \nsorted\n by \nthe frequency\n from highest to lowest. Sort the words with the same frequency by their \nlexicographical order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2\n\nOutput:\n [\"i\",\"love\"]\n\nExplanation:\n \"i\" and \"love\" are the two most frequent words.\nNote that \"i\" comes before \"love\" due to a lower alphabetical order.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4\n\nOutput:\n [\"the\",\"is\",\"sunny\",\"day\"]\n\nExplanation:\n \"the\", \"is\", \"sunny\" and \"day\" are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 500\n\n\n1 <= words[i].length <= 10\n\n\nwords[i]\n consists of lowercase English letters.\n\n\nk\n is in the range \n[1, The number of \nunique\n words[i]]\n\n\n\n\n \n\n\nFollow-up:\n Could you solve it in \nO(n log(k))\n time and \nO(n)\n extra space?",
      "solution": "\nimport collections\nimport heapq\nfrom random import randint\n\nclass Solution(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counts = collections.Counter(words)\n        p = []\n        for key, val in counts.iteritems():\n            p.append((-val, key))\n        self.kthElement(p, k-1)\n\n        result = []\n        sorted_p = sorted(p[:k])\n        for i in xrange(k):\n            result.append(sorted_p[i][1])\n        return result\n\n    def kthElement(self, nums, k):  # O(n) on average\n        def PartitionAroundPivot(left, right, pivot_idx, nums):\n            pivot_value = nums[pivot_idx]\n            new_pivot_idx = left\n            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n            for i in xrange(left, right):\n                if nums[i] < pivot_value:\n                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                    new_pivot_idx += 1\n\n            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n            return new_pivot_idx\n\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k:\n                return\n            elif new_pivot_idx > k:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k.\n                left = new_pivot_idx + 1\n\n\n# Heap Solutionclass Solution2(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        class MinHeapObj(object):\n            def __init__(self,val):\n                self.val = val\n            def __lt__(self,other):\n                return self.val[1] > other.val[1] if self.val[0] == other.val[0] else \\\n                       self.val < other.val\n            def __eq__(self,other):\n                return self.val == other.val\n            def __str__(self):\n                return str(self.val)\n\n        counts = collections.Counter(words)\n        min_heap = []\n        for word, count in counts.iteritems():\n            heapq.heappush(min_heap, MinHeapObj((count, word)))\n            if len(min_heap) == k+1:\n                heapq.heappop(min_heap)\n        result = []\n        while min_heap:\n            result.append(heapq.heappop(min_heap).val[1])\n        return result[::-1]\n\n\n# Bucket Sort Solutionclass Solution3(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counts = collections.Counter(words)\n        buckets = [[] for _ in xrange(len(words)+1)]\n        for word, count in counts.iteritems():\n            buckets[count].append(word)\n        pairs = []\n        for i in reversed(xrange(len(words))):\n            for word in buckets[i]:\n                pairs.append((-i, word))\n            if len(pairs) >= k:\n                break\n        pairs.sort()\n        return [pair[1] for pair in pairs[:k]]\n\n\n# time: O(nlogn)\n# space: O(n)\n\nfrom collections import Counter\n\nclass Solution4(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counter = Counter(words)\n        candidates = counter.keys()\n        candidates.sort(key=lambda w: (-counter[w], w))\n        return candidates[:k]",
      "explanation": "N/A",
      "time_complexity": "O(n + klogk) ~ O(n + nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Maximum Gap",
      "difficulty": "Medium",
      "category": "Bucket Sort",
      "link": "https://leetcode.com/problems/maximum-gap",
      "slug": "maximum-gap",
      "description": "Given an integer array \nnums\n, return \nthe maximum difference between two successive elements in its sorted form\n. If the array contains less than two elements, return \n0\n.\n\n\nYou must write an algorithm that runs in linear time and uses linear extra space.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,6,9,1]\n\nOutput:\n 3\n\nExplanation:\n The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [10]\n\nOutput:\n 0\n\nExplanation:\n The array contains less than 2 elements, therefore return 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n0 <= nums[i] <= 10\n9",
      "solution": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) < 2:\n            return 0\n\n        # Init bucket.\n        max_val, min_val = max(nums), min(nums)\n        gap = max(1, (max_val - min_val) / (len(nums) - 1))\n        bucket_size = (max_val - min_val) / gap + 1\n        bucket = [{'min':float(\"inf\"), 'max':float(\"-inf\")} \\\n                    for _ in xrange(bucket_size)]\n\n        # Find the bucket where the n should be put.\n        for n in nums:\n            # min_val / max_val is in the first / last bucket.\n            if n in (max_val, min_val):\n                continue\n            i = (n - min_val) / gap\n            bucket[i]['min'] = min(bucket[i]['min'], n)\n            bucket[i]['max'] = max(bucket[i]['max'], n)\n\n        # Count each bucket gap between the first and the last bucket.\n        max_gap, pre_bucket_max = 0, min_val\n        for i in xrange(bucket_size):\n            # Skip the bucket it empty.\n            if bucket[i]['min'] == float(\"inf\") and \\\n                bucket[i]['max'] == float(\"-inf\"):\n                continue\n            max_gap = max(max_gap, bucket[i]['min'] - pre_bucket_max)\n            pre_bucket_max = bucket[i]['max']\n        # Count the last bucket.\n        max_gap = max(max_gap, max_val - pre_bucket_max)\n\n        return max_gap\n\nclass Solution2(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n\n        if len(nums) < 2:\n            return 0\n\n        nums.sort()\n        pre = nums[0]\n        max_gap = float(\"-inf\")\n\n        for i in nums:\n            max_gap = max(max_gap, i - pre)\n            pre = i\n        return max_gap",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    }
  ],
  "Recursion": [
    {
      "title": "Merge Two Sorted Lists",
      "difficulty": "Easy",
      "category": "Recursion",
      "link": "https://leetcode.com/problems/merge-two-sorted-lists",
      "slug": "merge-two-sorted-lists",
      "description": "You are given the heads of two sorted linked lists \nlist1\n and \nlist2\n.\n\n\nMerge the two lists into one \nsorted\n list. The list should be made by splicing together the nodes of the first two lists.\n\n\nReturn \nthe head of the merged linked list\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n list1 = [1,2,4], list2 = [1,3,4]\n\nOutput:\n [1,1,2,3,4,4]\n\n\n\nExample 2:\n\n\n\n\nInput:\n list1 = [], list2 = []\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n list1 = [], list2 = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in both lists is in the range \n[0, 50]\n.\n\n\n-100 <= Node.val <= 100\n\n\nBoth \nlist1\n and \nlist2\n are sorted in \nnon-decreasing\n order.",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, self.next)\n\nclass Solution(object):\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        curr = dummy = ListNode(0)\n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        curr.next = l1 or l2\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Pow(x, n)",
      "difficulty": "Medium",
      "category": "Recursion",
      "link": "https://leetcode.com/problems/powx-n",
      "slug": "powx-n",
      "description": "Implement \npow(x, n)\n, which calculates \nx\n raised to the power \nn\n (i.e., \nx\nn\n).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 2.00000, n = 10\n\nOutput:\n 1024.00000\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = 2.10000, n = 3\n\nOutput:\n 9.26100\n\n\n\nExample 3:\n\n\n\n\nInput:\n x = 2.00000, n = -2\n\nOutput:\n 0.25000\n\nExplanation:\n 2\n-2\n = 1/2\n2\n = 1/4 = 0.25\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-100.0 < x < 100.0\n\n\n-2\n31\n <= n <= 2\n31\n-1\n\n\nn\n is an integer.\n\n\nEither \nx\n is not zero or \nn > 0\n.\n\n\n-10\n4\n <= x\nn\n <= 10\n4",
      "solution": "class Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        result = 1\n        abs_n = abs(n)\n        while abs_n:\n            if abs_n & 1:\n                result *= x\n            abs_n >>= 1\n            x *= x\n\n        return 1 / result if n < 0 else result\n\n\n# Recursive solution.class Solution2(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        if n < 0 and n != -n:\n            return 1.0 / self.myPow(x, -n)\n        if n == 0:\n            return 1\n        v = self.myPow(x, n / 2)\n        if n % 2 == 0:\n            return v * v\n        else:\n            return v * v * x",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(logn)"
    },
    {
      "title": "Decode String",
      "difficulty": "Medium",
      "category": "Recursion",
      "link": "https://leetcode.com/problems/decode-string",
      "slug": "decode-string",
      "description": "Given an encoded string, return its decoded string.\n\n\nThe encoding rule is: \nk[encoded_string]\n, where the \nencoded_string\n inside the square brackets is being repeated exactly \nk\n times. Note that \nk\n is guaranteed to be a positive integer.\n\n\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, \nk\n. For example, there will not be input like \n3a\n or \n2[4]\n.\n\n\nThe test cases are generated so that the length of the output will never exceed \n10\n5\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"3[a]2[bc]\"\n\nOutput:\n \"aaabcbc\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"3[a2[c]]\"\n\nOutput:\n \"accaccacc\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"2[abc]3[cd]ef\"\n\nOutput:\n \"abcabccdcdcdef\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 30\n\n\ns\n consists of lowercase English letters, digits, and square brackets \n'[]'\n.\n\n\ns\n is guaranteed to be \na valid\n input.\n\n\nAll the integers in \ns\n are in the range \n[1, 300]\n.",
      "solution": "class Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n, curr, nums, strs = 0, [], [], []\n        for c in s:\n            if c.isdigit():\n                n = n*10 + ord(c)-ord('0')\n            elif c.isalpha():\n                curr.append(c)\n            elif c == '[':\n                nums.append(n)\n                strs.append(curr)\n                n, curr = 0, []\n            elif c == ']':\n                strs[-1].extend(curr*nums.pop())\n                curr = strs.pop()\n        return \"\".join(curr)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    }
  ],
  "Divide and Conquer": [
    {
      "title": "Convert Sorted List to Binary Search Tree",
      "difficulty": "Medium",
      "category": "Divide and Conquer",
      "link": "https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree",
      "slug": "convert-sorted-list-to-binary-search-tree",
      "description": "Given the \nhead\n of a singly linked list where elements are sorted in \nascending order\n, convert \nit to a \nheight-balanced\n \nbinary search tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [-10,-3,0,5,9]\n\nOutput:\n [0,-3,9,-10,null,5]\n\nExplanation:\n One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.\n\n\n\nExample 2:\n\n\n\n\nInput:\n head = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in \nhead\n is in the range \n[0, 2 * 10\n4\n]\n.\n\n\n-10\n5\n <= Node.val <= 10\n5",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n#\n# Definition for singly-linked list.class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\nclass Solution(object):\n    head = None\n    # @param head, a list node\n    # @return a tree node\n    def sortedListToBST(self, head):\n        current, length = head, 0\n        while current is not None:\n            current, length = current.next, length + 1\n        self.head = head\n        return self.sortedListToBSTRecu(0, length)\n\n    def sortedListToBSTRecu(self, start, end):\n        if start == end:\n            return None\n        mid = start + (end - start) / 2\n        left = self.sortedListToBSTRecu(start, mid)\n        current = TreeNode(self.head.val)\n        current.left = left\n        self.head = self.head.next\n        current.right = self.sortedListToBSTRecu(mid + 1, end)\n        return current",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(logn)"
    },
    {
      "title": "Construct Quad Tree",
      "difficulty": "Medium",
      "category": "Divide and Conquer",
      "link": "https://leetcode.com/problems/construct-quad-tree",
      "slug": "construct-quad-tree",
      "description": "Given a \nn * n\n matrix \ngrid\n of \n0's\n and \n1's\n only. We want to represent \ngrid\n with a Quad-Tree.\n\n\nReturn \nthe root of the Quad-Tree representing \ngrid\n.\n\n\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\n\n\n\nval\n: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the \nval\n to True or False when \nisLeaf\n is False, and both are accepted in the answer.\n\n\nisLeaf\n: True if the node is a leaf node on the tree or False if the node has four children.\n\n\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\n\n\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\n\n\n\nIf the current grid has the same value (i.e all \n1's\n or all \n0's\n) set \nisLeaf\n True and set \nval\n to the value of the grid and set the four children to Null and stop.\n\n\nIf the current grid has different values, set \nisLeaf\n to False and set \nval\n to any value and divide the current grid into four sub-grids as shown in the photo.\n\n\nRecurse for each of the children with the proper sub-grid.\n\n\n\n\n\n\nIf you want to know more about the Quad-Tree, you can refer to the \nwiki\n.\n\n\nQuad-Tree format:\n\n\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where \nnull\n signifies a path terminator where no node exists below.\n\n\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list \n[isLeaf, val]\n.\n\n\nIf the value of \nisLeaf\n or \nval\n is True we represent it as \n1\n in the list \n[isLeaf, val]\n and if the value of \nisLeaf\n or \nval\n is False we represent it as \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,1],[1,0]]\n\nOutput:\n [[0,1],[1,0],[1,1],[1,1],[1,0]]\n\nExplanation:\n The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\n\nOutput:\n [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n\nExplanation:\n All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length == grid[i].length\n\n\nn == 2\nx\n where \n0 <= x <= 6",
      "solution": "class Node(object):\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\nclass Solution(object):\n    def construct(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: Node\n        \"\"\"\n        def dfs(grid, x, y, l):\n            if l == 1:\n                return Node(grid[x][y] == 1, True, None, None, None, None)\n            half = l // 2\n            topLeftNode = dfs(grid, x, y, half)\n            topRightNode = dfs(grid, x, y+half, half)\n            bottomLeftNode = dfs(grid, x+half, y, half)\n            bottomRightNode = dfs(grid, x+half, y+half, half)\n            if topLeftNode.isLeaf and topRightNode.isLeaf and \\\n               bottomLeftNode.isLeaf and bottomRightNode.isLeaf and \\\n               topLeftNode.val == topRightNode.val == bottomLeftNode.val == bottomRightNode.val:\n                return Node(topLeftNode.val, True, None, None, None, None)\n            return Node(True, False, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode)\n        \n        if not grid:\n            return None\n        return dfs(grid, 0, 0, len(grid))",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Maximum Binary Tree",
      "difficulty": "Medium",
      "category": "Divide and Conquer",
      "link": "https://leetcode.com/problems/maximum-binary-tree",
      "slug": "maximum-binary-tree",
      "description": "You are given an integer array \nnums\n with no duplicates. A \nmaximum binary tree\n can be built recursively from \nnums\n using the following algorithm:\n\n\n\n\nCreate a root node whose value is the maximum value in \nnums\n.\n\n\nRecursively build the left subtree on the \nsubarray prefix\n to the \nleft\n of the maximum value.\n\n\nRecursively build the right subtree on the \nsubarray suffix\n to the \nright\n of the maximum value.\n\n\n\n\nReturn \nthe \nmaximum binary tree\n built from \nnums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [3,2,1,6,0,5]\n\nOutput:\n [6,3,5,null,2,0,null,null,1]\n\nExplanation:\n The recursive calls are as follow:\n- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].\n    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].\n        - Empty array, so no child.\n        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].\n            - Empty array, so no child.\n            - Only one element, so child is a node with value 1.\n    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].\n        - Only one element, so child is a node with value 0.\n        - Empty array, so no child.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [3,2,1]\n\nOutput:\n [3,null,2,null,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n0 <= nums[i] <= 1000\n\n\nAll integers in \nnums\n are \nunique\n.",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def constructMaximumBinaryTree(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        # https://github.com/kamyu104/LintCode/blob/master/C++/max-tree.cpp\n        nodeStack = []\n        for num in nums:\n            node = TreeNode(num)\n            while nodeStack and num > nodeStack[-1].val:\n                node.left = nodeStack.pop()\n            if nodeStack:\n                nodeStack[-1].right = node\n            nodeStack.append(node)\n        return nodeStack[0]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    }
  ],
  "Merge Sort": [
    {
      "title": "Sort List",
      "difficulty": "Medium",
      "category": "Merge Sort",
      "link": "https://leetcode.com/problems/sort-list",
      "slug": "sort-list",
      "description": "Given the \nhead\n of a linked list, return \nthe list after sorting it in \nascending order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [4,2,1,3]\n\nOutput:\n [1,2,3,4]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [-1,5,3,4,0]\n\nOutput:\n [-1,0,3,4,5]\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[0, 5 * 10\n4\n]\n.\n\n\n-10\n5\n <= Node.val <= 10\n5\n\n\n\n\n \n\n\nFollow up:\n Can you sort the linked list in \nO(n logn)\n time and \nO(1)\n memory (i.e. constant space)?",
      "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\nclass Solution(object):\n    # @param head, a ListNode\n    # @return a ListNode\n    def sortList(self, head):\n        if head == None or head.next == None:\n            return head\n\n        fast, slow, prev = head, head, None\n        while fast != None and fast.next != None:\n            prev, fast, slow = slow, fast.next.next, slow.next\n        prev.next = None\n\n        sorted_l1 = self.sortList(head)\n        sorted_l2 = self.sortList(slow)\n\n        return self.mergeTwoLists(sorted_l1, sorted_l2)\n\n    def mergeTwoLists(self, l1, l2):\n        dummy = ListNode(0)\n\n        cur = dummy\n        while l1 != None and l2 != None:\n            if l1.val <= l2.val:\n                cur.next, cur, l1 = l1, l1, l1.next\n            else:\n                cur.next, cur, l2 = l2, l2, l2.next\n\n        if l1 != None:\n            cur.next = l1\n        if l2 != None:\n            cur.next = l2\n\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(logn) for stack call"
    },
    {
      "title": "Reverse Pairs",
      "difficulty": "Hard",
      "category": "Merge Sort",
      "link": "https://leetcode.com/problems/reverse-pairs",
      "slug": "reverse-pairs",
      "description": "Given an integer array \nnums\n, return \nthe number of \nreverse pairs\n in the array\n.\n\n\nA \nreverse pair\n is a pair \n(i, j)\n where:\n\n\n\n\n0 <= i < j < nums.length\n and\n\n\nnums[i] > 2 * nums[j]\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,2,3,1]\n\nOutput:\n 2\n\nExplanation:\n The reverse pairs are:\n(1, 4) --> nums[1] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 3, nums[4] = 1, 3 > 2 * 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,4,3,5,1]\n\nOutput:\n 3\n\nExplanation:\n The reverse pairs are:\n(1, 4) --> nums[1] = 4, nums[4] = 1, 4 > 2 * 1\n(2, 4) --> nums[2] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 5, nums[4] = 1, 5 > 2 * 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 5 * 10\n4\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1",
      "solution": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def merge(nums, start, mid, end):\n            r = mid + 1\n            tmp = []\n            for i in xrange(start, mid + 1):\n                while r <= end and nums[i] > nums[r]:\n                    tmp.append(nums[r])\n                    r += 1\n                tmp.append(nums[i])\n            nums[start:start+len(tmp)] = tmp\n\n        def countAndMergeSort(nums, start, end):\n            if end - start <= 0:\n                return 0\n\n            mid = start + (end - start) / 2\n            count = countAndMergeSort(nums, start, mid) + countAndMergeSort(nums, mid + 1, end)\n            r = mid + 1\n            for i in xrange(start, mid + 1):\n                while r <= end and nums[i] > nums[r] * 2:\n                    r += 1\n                count += r - (mid + 1)\n            merge(nums, start, mid, end)\n            return count\n\n        return countAndMergeSort(nums, 0, len(nums) - 1)",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    }
  ],
  "QuickSort / QuickSelect": [
    {
      "title": "Sort Colors",
      "difficulty": "Medium",
      "category": "QuickSort / QuickSelect",
      "link": "https://leetcode.com/problems/sort-colors",
      "slug": "sort-colors",
      "description": "Given an array \nnums\n with \nn\n objects colored red, white, or blue, sort them \nin-place\n \nso that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\n\nWe will use the integers \n0\n, \n1\n, and \n2\n to represent the color red, white, and blue, respectively.\n\n\nYou must solve this problem without using the library's sort function.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,0,2,1,1,0]\n\nOutput:\n [0,0,1,1,2,2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,0,1]\n\nOutput:\n [0,1,2]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 300\n\n\nnums[i]\n is either \n0\n, \n1\n, or \n2\n.\n\n\n\n\n \n\n\nFollow up:\n Could you come up with a one-pass algorithm using only constant extra space?",
      "solution": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        def triPartition(nums, target):\n            i, left, right = 0, 0, len(nums)-1\n            while i <= right:\n                if nums[i] > target:\n                    nums[i], nums[right] = nums[right], nums[i]\n                    right -= 1\n                else:\n                    if nums[i] < target:\n                        nums[left], nums[i] = nums[i], nums[left]\n                        left += 1\n                    i += 1\n\n        triPartition(nums, 1)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Kth Largest Element in an Array",
      "difficulty": "Medium",
      "category": "QuickSort / QuickSelect",
      "link": "https://leetcode.com/problems/kth-largest-element-in-an-array",
      "slug": "kth-largest-element-in-an-array",
      "description": "Given an integer array \nnums\n and an integer \nk\n, return \nthe\n \nk\nth\n \nlargest element in the array\n.\n\n\nNote that it is the \nk\nth\n largest element in the sorted order, not the \nk\nth\n distinct element.\n\n\nCan you solve it without sorting?\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [3,2,1,5,6,4], k = 2\n\nOutput:\n 5\n\nExample 2:\n\n\nInput:\n nums = [3,2,3,1,2,4,5,5,6], k = 4\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4",
      "solution": "\nfrom random import randint\n\n\n# optimized for duplicated numsclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        nth_element(nums, k-1, compare=lambda a, b: a > b)\n        return nums[k-1]\n\nclass Solution2(object):\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = self.PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k - 1:\n                return nums[new_pivot_idx]\n            elif new_pivot_idx > k - 1:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k - 1.\n                left = new_pivot_idx + 1\n\n    def PartitionAroundPivot(self, left, right, pivot_idx, nums):\n        pivot_value = nums[pivot_idx]\n        new_pivot_idx = left\n        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n        for i in xrange(left, right):\n            if nums[i] > pivot_value:\n                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                new_pivot_idx += 1\n\n        nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n        return new_pivot_idx",
      "explanation": "N/A",
      "time_complexity": "O(n) on average, using Median of Medians could achieve O(n) (Intro Select)",
      "space_complexity": "O(1)"
    }
  ],
  "Binary Search": [
    {
      "title": "Search Insert Position",
      "difficulty": "Easy",
      "category": "Binary Search",
      "link": "https://leetcode.com/problems/search-insert-position",
      "slug": "search-insert-position",
      "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 5\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 2\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 7\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nnums\n contains \ndistinct\n values sorted in \nascending\n order.\n\n\n-10\n4\n <= target <= 10\n4",
      "solution": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if nums[mid] >= target:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return left",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Find First and Last Position of Element in Sorted Array",
      "difficulty": "Medium",
      "category": "Binary Search",
      "link": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array",
      "slug": "find-first-and-last-position-of-element-in-sorted-array",
      "description": "Given an array of integers \nnums\n sorted in non-decreasing order, find the starting and ending position of a given \ntarget\n value.\n\n\nIf \ntarget\n is not found in the array, return \n[-1, -1]\n.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [5,7,7,8,8,10], target = 8\n\nOutput:\n [3,4]\n\nExample 2:\n\n\nInput:\n nums = [5,7,7,8,8,10], target = 6\n\nOutput:\n [-1,-1]\n\nExample 3:\n\n\nInput:\n nums = [], target = 0\n\nOutput:\n [-1,-1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\nnums\n is a non-decreasing array.\n\n\n-10\n9\n <= target <= 10\n9",
      "solution": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        l, r = 0, len(nums) - 1\n        if not nums: return [-1, -1]\n        while l < r:\n            mid = l + (r-l) // 2\n            if nums[mid] >= target:\n                r = mid\n            else:\n                l = mid + 1\n        start = l\n        if nums[start] != target: return [-1, -1]\n        l, r = start, len(nums) - 1\n        while l < r:\n            mid = l + (r - l + 1) // 2\n            if nums[mid] <= target:\n                l = mid\n            else:\n                r = mid - 1\n        \n        return [start, r]",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Search in Rotated Sorted Array",
      "difficulty": "Medium",
      "category": "Binary Search",
      "link": "https://leetcode.com/problems/search-in-rotated-sorted-array",
      "slug": "search-in-rotated-sorted-array",
      "description": "There is an integer array \nnums\n sorted in ascending order (with \ndistinct\n values).\n\n\nPrior to being passed to your function, \nnums\n is \npossibly rotated\n at an unknown pivot index \nk\n (\n1 <= k < nums.length\n) such that the resulting array is \n[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]\n (\n0-indexed\n). For example, \n[0,1,2,4,5,6,7]\n might be rotated at pivot index \n3\n and become \n[4,5,6,7,0,1,2]\n.\n\n\nGiven the array \nnums\n \nafter\n the possible rotation and an integer \ntarget\n, return \nthe index of \ntarget\n if it is in \nnums\n, or \n-1\n if it is not in \nnums\n.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [4,5,6,7,0,1,2], target = 0\n\nOutput:\n 4\n\nExample 2:\n\n\nInput:\n nums = [4,5,6,7,0,1,2], target = 3\n\nOutput:\n -1\n\nExample 3:\n\n\nInput:\n nums = [1], target = 0\n\nOutput:\n -1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 5000\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nAll values of \nnums\n are \nunique\n.\n\n\nnums\n is an ascending array that is possibly rotated.\n\n\n-10\n4\n <= target <= 10\n4",
      "solution": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) / 2\n\n            if nums[mid] == target:\n                return mid\n            elif (nums[mid] >= nums[left] and nums[left] <= target < nums[mid]) or \\\n                 (nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])):\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return -1",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Find Peak Element",
      "difficulty": "Medium",
      "category": "Binary Search",
      "link": "https://leetcode.com/problems/find-peak-element",
      "slug": "find-peak-element",
      "description": "A peak element is an element that is strictly greater than its neighbors.\n\n\nGiven a \n0-indexed\n integer array \nnums\n, find a peak element, and return its index. If the array contains multiple peaks, return the index to \nany of the peaks\n.\n\n\nYou may imagine that \nnums[-1] = nums[n] = -∞\n. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\n\nYou must write an algorithm that runs in \nO(log n)\n time.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,1]\n\nOutput:\n 2\n\nExplanation:\n 3 is a peak element and your function should return the index number 2.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,1,3,5,6,4]\n\nOutput:\n 5\n\nExplanation:\n Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\nnums[i] != nums[i + 1]\n for all valid \ni\n.",
      "solution": "class Solution(object):\n    def findPeakElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            mid = left + (right - left) / 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Random Pick with Weight",
      "difficulty": "Medium",
      "category": "Binary Search",
      "link": "https://leetcode.com/problems/random-pick-with-weight",
      "slug": "random-pick-with-weight",
      "description": "You are given a \n0-indexed\n array of positive integers \nw\n where \nw[i]\n describes the \nweight\n of the \ni\nth\n index.\n\n\nYou need to implement the function \npickIndex()\n, which \nrandomly\n picks an index in the range \n[0, w.length - 1]\n (\ninclusive\n) and returns it. The \nprobability\n of picking an index \ni\n is \nw[i] / sum(w)\n.\n\n\n\n\nFor example, if \nw = [1, 3]\n, the probability of picking index \n0\n is \n1 / (1 + 3) = 0.25\n (i.e., \n25%\n), and the probability of picking index \n1\n is \n3 / (1 + 3) = 0.75\n (i.e., \n75%\n).\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"Solution\",\"pickIndex\"]\n[[[1]],[]]\n\nOutput\n\n[null,0]\n\n\nExplanation\n\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.\n\n\n\nExample 2:\n\n\n\n\nInput\n\n[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]\n[[[1,3]],[],[],[],[],[]]\n\nOutput\n\n[null,1,1,1,1,0]\n\n\nExplanation\n\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.\n\nSince this is a randomization problem, multiple answers are allowed.\nAll of the following outputs can be considered correct:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\nand so on.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= w.length <= 10\n4\n\n\n1 <= w[i] <= 10\n5\n\n\npickIndex\n will be called at most \n10\n4\n times.",
      "solution": "#        pickIndex: O(logn)\n\nimport random\nimport bisect\n\nclass Solution(object):\n\n    def __init__(self, w):\n        \"\"\"\n        :type w: List[int]\n        \"\"\"\n        self.__prefix_sum = list(w)\n        for i in xrange(1, len(w)):\n            self.__prefix_sum[i] += self.__prefix_sum[i-1]\n\n    def pickIndex(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        target = random.randint(0, self.__prefix_sum[-1]-1)\n        return bisect.bisect_right(self.__prefix_sum, target)",
      "explanation": "N/A",
      "time_complexity": "ctor: O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Koko Eating Bananas",
      "difficulty": "Medium",
      "category": "Binary Search",
      "link": "https://leetcode.com/problems/koko-eating-bananas",
      "slug": "koko-eating-bananas",
      "description": "Koko loves to eat bananas. There are \nn\n piles of bananas, the \ni\nth\n pile has \npiles[i]\n bananas. The guards have gone and will come back in \nh\n hours.\n\n\nKoko can decide her bananas-per-hour eating speed of \nk\n. Each hour, she chooses some pile of bananas and eats \nk\n bananas from that pile. If the pile has less than \nk\n bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\n\nReturn \nthe minimum integer\n \nk\n \nsuch that she can eat all the bananas within\n \nh\n \nhours\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n piles = [3,6,7,11], h = 8\n\nOutput:\n 4\n\n\n\nExample 2:\n\n\n\n\nInput:\n piles = [30,11,23,4,20], h = 5\n\nOutput:\n 30\n\n\n\nExample 3:\n\n\n\n\nInput:\n piles = [30,11,23,4,20], h = 6\n\nOutput:\n 23\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= piles.length <= 10\n4\n\n\npiles.length <= h <= 10\n9\n\n\n1 <= piles[i] <= 10\n9",
      "solution": "class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        \n        def feasible(capacity):\n            hours = sum([math.ceil(pile/capacity) for pile in piles])\n            return hours <= h\n\n        l = 1\n        r = max(piles)\n        while l < r:\n            mid = l + (r-l) // 2\n            if feasible(mid):\n                r = mid\n            else:\n                l = mid + 1\n        \n        return l",
      "explanation": "N/A",
      "time_complexity": "O(nlogr)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Find Minimum in Rotated Sorted Array",
      "difficulty": "Medium",
      "category": "Binary Search",
      "link": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array",
      "slug": "find-minimum-in-rotated-sorted-array",
      "description": "Suppose an array of length \nn\n sorted in ascending order is \nrotated\n between \n1\n and \nn\n times. For example, the array \nnums = [0,1,2,4,5,6,7]\n might become:\n\n\n\n\n[4,5,6,7,0,1,2]\n if it was rotated \n4\n times.\n\n\n[0,1,2,4,5,6,7]\n if it was rotated \n7\n times.\n\n\n\n\nNotice that \nrotating\n an array \n[a[0], a[1], a[2], ..., a[n-1]]\n 1 time results in the array \n[a[n-1], a[0], a[1], a[2], ..., a[n-2]]\n.\n\n\nGiven the sorted rotated array \nnums\n of \nunique\n elements, return \nthe minimum element of this array\n.\n\n\nYou must write an algorithm that runs in \nO(log n) time\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,4,5,1,2]\n\nOutput:\n 1\n\nExplanation:\n The original array was [1,2,3,4,5] rotated 3 times.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [4,5,6,7,0,1,2]\n\nOutput:\n 0\n\nExplanation:\n The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [11,13,15,17]\n\nOutput:\n 11\n\nExplanation:\n The original array was [11,13,15,17] and it was rotated 4 times. \n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 5000\n\n\n-5000 <= nums[i] <= 5000\n\n\nAll the integers of \nnums\n are \nunique\n.\n\n\nnums\n is sorted and rotated between \n1\n and \nn\n times.",
      "solution": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums)\n        target = nums[-1]\n\n        while left < right:\n            mid = left + (right - left) / 2\n\n            if nums[mid] <= target:\n                right = mid\n            else:\n                left = mid + 1\n\n        return nums[left]\n\nclass Solution2(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] >= nums[right]:\n            mid = left + (right - left) / 2\n\n            if nums[mid] < nums[left]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return nums[left]",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Search a 2D Matrix",
      "difficulty": "Medium",
      "category": "Binary Search",
      "link": "https://leetcode.com/problems/search-a-2d-matrix",
      "slug": "search-a-2d-matrix",
      "description": "You are given an \nm x n\n integer matrix \nmatrix\n with the following two properties:\n\n\n\n\nEach row is sorted in non-decreasing order.\n\n\nThe first integer of each row is greater than the last integer of the previous row.\n\n\n\n\nGiven an integer \ntarget\n, return \ntrue\n \nif\n \ntarget\n \nis in\n \nmatrix\n \nor\n \nfalse\n \notherwise\n.\n\n\nYou must write a solution in \nO(log(m * n))\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 100\n\n\n-10\n4\n <= matrix[i][j], target <= 10\n4",
      "solution": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not matrix:\n            return False\n\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n\n        while left < right:\n            mid = left + (right - left) / 2\n            if matrix[mid / n][mid % n] >= target:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left < m * n and matrix[left / n][left % n] == target",
      "explanation": "N/A",
      "time_complexity": "O(logm + logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Find in Mountain Array",
      "difficulty": "Hard",
      "category": "Binary Search",
      "link": "https://leetcode.com/problems/find-in-mountain-array",
      "slug": "find-in-mountain-array",
      "description": "(This problem is an \ninteractive problem\n.)\n\n\nYou may recall that an array \narr\n is a \nmountain array\n if and only if:\n\n\n\n\narr.length >= 3\n\n\nThere exists some \ni\n with \n0 < i < arr.length - 1\n such that:\n\t\n\n\narr[0] < arr[1] < ... < arr[i - 1] < arr[i]\n\n\narr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n\n\n\n\n\n\n\n\nGiven a mountain array \nmountainArr\n, return the \nminimum\n \nindex\n such that \nmountainArr.get(index) == target\n. If such an \nindex\n does not exist, return \n-1\n.\n\n\nYou cannot access the mountain array directly.\n You may only access the array using a \nMountainArray\n interface:\n\n\n\n\nMountainArray.get(k)\n returns the element of the array at index \nk\n (0-indexed).\n\n\nMountainArray.length()\n returns the length of the array.\n\n\n\n\nSubmissions making more than \n100\n calls to \nMountainArray.get\n will be judged \nWrong Answer\n. Also, any solutions that attempt to circumvent the judge will result in disqualification.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n mountainArr = [1,2,3,4,5,3,1], target = 3\n\nOutput:\n 2\n\nExplanation:\n 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2.\n\n\nExample 2:\n\n\n\n\nInput:\n mountainArr = [0,1,2,4,2,1], target = 3\n\nOutput:\n -1\n\nExplanation:\n 3 does not exist in \nthe array,\n so we return -1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= mountainArr.length() <= 10\n4\n\n\n0 <= target <= 10\n9\n\n\n0 <= mountainArr.get(index) <= 10\n9",
      "solution": "\n# \"\"\"\n# This is MountainArray's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"class MountainArray(object):\n   def get(self, index):\n       \"\"\"\n       :type index: int\n       :rtype int\n       \"\"\"\n       pass\n\n   def length(self):\n       \"\"\"\n       :rtype int\n       \"\"\"\n       pass\n\nclass Solution(object):\n    def findInMountainArray(self, target, mountain_arr):\n        \"\"\"\n        :type target: integer\n        :type mountain_arr: MountainArray\n        :rtype: integer\n        \"\"\"\n        def binarySearch(A, left, right, check):\n            while left <= right:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n        \n        peak = binarySearch(mountain_arr, 0, mountain_arr.length()-1,\n                            lambda x: mountain_arr.get(x) >= mountain_arr.get(x+1))\n        left = binarySearch(mountain_arr, 0, peak,\n                            lambda x: mountain_arr.get(x) >= target)\n        if left <= peak and mountain_arr.get(left) == target:\n            return left\n        right = binarySearch(mountain_arr, peak, mountain_arr.length()-1,\n                             lambda x: mountain_arr.get(x) <= target)\n        if right <= mountain_arr.length()-1 and mountain_arr.get(right) == target:\n            return right\n        return -1",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Median of Two Sorted Arrays",
      "difficulty": "Hard",
      "category": "Binary Search",
      "link": "https://leetcode.com/problems/median-of-two-sorted-arrays",
      "slug": "median-of-two-sorted-arrays",
      "description": "Given two sorted arrays \nnums1\n and \nnums2\n of size \nm\n and \nn\n respectively, return \nthe median\n of the two sorted arrays.\n\n\nThe overall run time complexity should be \nO(log (m+n))\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,3], nums2 = [2]\n\nOutput:\n 2.00000\n\nExplanation:\n merged array = [1,2,3] and median is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1,2], nums2 = [3,4]\n\nOutput:\n 2.50000\n\nExplanation:\n merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m\n\n\nnums2.length == n\n\n\n0 <= m <= 1000\n\n\n0 <= n <= 1000\n\n\n1 <= m + n <= 2000\n\n\n-10\n6\n <= nums1[i], nums2[i] <= 10\n6",
      "solution": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(A, B, k):\n            m, n = len(A), len(B)\n            if m > n:\n                m, n = n, m\n                A, B = B, A\n            i = binary_search(max(k-n, 0), min(m, k)-1, lambda i: A[i] >= B[k-1-i])\n            return max(A[i-1] if i-1 >= 0 else float(\"-inf\"), B[k-1-i] if k-1-i >= 0 else float(\"-inf\"))\n\n        len1, len2 = len(nums1), len(nums2)\n        if (len1+len2) % 2 == 1:\n            return getKth(nums1, nums2, (len1+len2)//2+1)\n        else:\n            return (getKth(nums1, nums2, (len1+len2)//2)+getKth(nums1, nums2, (len1+len2)//2+1))*0.5    \n\n\n# Generic solution.class Solution_Generic(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(arrays, k):\n            def check(num):\n                # count the number of values which are less or equal to num\n                return sum(binary_search(0, len(arr)-1, lambda x: arr[x] > num) for arr in arrays) >= k\n    \n            return binary_search(min(arr[0] for arr in arrays if arr), max(arr[-1] for arr in arrays if arr), check)\n\n        array = [nums1, nums2]\n        total = sum(len(nums) for nums in array)\n        if total % 2 == 1:\n            return getKth(array, total//2+1)\n        else:\n            return (getKth(array, total//2)+getKth(array, total//2+1))*0.5",
      "explanation": "N/A",
      "time_complexity": "O(log(max(m, n)) * log(max_val - min_val))",
      "space_complexity": "O(1)"
    }
  ],
  "Backtracking": [
    {
      "title": "Generate Parentheses",
      "difficulty": "Medium",
      "category": "Backtracking",
      "link": "https://leetcode.com/problems/generate-parentheses",
      "slug": "generate-parentheses",
      "description": "Given \nn\n pairs of parentheses, write a function to \ngenerate all combinations of well-formed parentheses\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n n = 3\n\nOutput:\n [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n\nExample 2:\n\n\nInput:\n n = 1\n\nOutput:\n [\"()\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 8",
      "solution": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        res = []  # Stores all valid combinations of parentheses\n\n        def backtrack(left, right, brackets):\n            \"\"\"\n            left  -> number of '(' added so far\n            right -> number of ')' added so far\n            brackets -> current parenthesis string being built\n            \"\"\"\n            idx = len(brackets)  # Current length of the string\n\n            # Base case: when the string is of length 2*n, it's a valid combination\n            if idx == 2 * n:\n                res.append(brackets)  # Add completed valid sequence\n                return \n            \n            # Add '(' if we still have some left to add (must not exceed n)\n            if left < n:\n                backtrack(left + 1, right, brackets + '(')\n            \n            # Add ')' if it won't break validity (more '(' must have been used before ')')\n            if right < left:\n                backtrack(left, right + 1, brackets + ')')\n\n        # Start recursion with no parentheses\n        backtrack(0, 0, '')\n\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(4^n / n^(3/2)) ~= Catalan numbers",
      "space_complexity": "O(n)"
    },
    {
      "title": "Permutations",
      "difficulty": "Medium",
      "category": "Backtracking",
      "link": "https://leetcode.com/problems/permutations",
      "slug": "permutations",
      "description": "Given an array \nnums\n of distinct integers, return all the possible \npermutations\n. You can return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\nExample 2:\n\n\nInput:\n nums = [0,1]\n\nOutput:\n [[0,1],[1,0]]\n\nExample 3:\n\n\nInput:\n nums = [1]\n\nOutput:\n [[1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 6\n\n\n-10 <= nums[i] <= 10\n\n\nAll the integers of \nnums\n are \nunique\n.",
      "solution": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        n = len(nums)  # Number of elements in the input list\n\n        # Base case: if nums has 0 or 1 elements, only one permutation exists\n        if n <= 1:\n            return [nums]\n\n        res = []  # Stores all permutations\n\n        def backtrack(sol, visited):\n            # If current solution length equals n, we found a valid permutation\n            if len(sol) == n:\n                res.append(sol[:])  # Append a copy of the solution\n                return \n            \n            # Try every number as the next element in the permutation\n            for i in range(n):\n                if not visited[i]:  # Only pick numbers not yet used\n                    sol.append(nums[i])  # Choose\n                    visited[i] = True    # Mark as used\n                    \n                    backtrack(sol, visited)  # Explore further\n                    \n                    sol.pop()  # Undo choice (backtrack)\n                    visited[i] = False  # Mark as unused\n        \n        # Start with an empty solution and all elements unvisited\n        backtrack([], [False] * n)\n        \n        return res\n\n\nfrom typing import List\nfrom collections import Counter\n\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Generate all unique permutations of a list of numbers.\n\n        Uses backtracking with a Counter to avoid duplicate permutations\n        by tracking how many times each number is still available.\n        \"\"\"\n        n = len(nums)                # Total length of input list\n        res = []                      # Stores the final list of unique permutations\n\n        # Edge case: if there's only one or zero elements, return as-is\n        if n <= 1:\n            return [nums]\n\n        def backtrack(sol: List[int], count: Counter):\n            \"\"\"\n            sol: Current partial permutation being built\n            count: Remaining available numbers with their counts\n            \"\"\"\n            # Base case: if the current solution length equals input length\n            if len(sol) == n:\n                res.append(sol[:])   # Append a copy of the current solution\n                return\n\n            # Try each number that is still available\n            for num in count:\n                if count[num] > 0:\n                    # 1️⃣ Choose the current number\n                    sol.append(num)\n                    count[num] -= 1\n\n                    # 2️⃣ Explore further with the updated state\n                    backtrack(sol, count)\n\n                    # 3️⃣ Undo choice for backtracking\n                    sol.pop()\n                    count[num] += 1\n\n        # Initialize recursion with empty solution and frequency counter\n        backtrack([], Counter(nums))\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(n^2 * n!)",
      "space_complexity": "O(n^2)"
    },
    {
      "title": "Subsets",
      "difficulty": "Medium",
      "category": "Backtracking",
      "link": "https://leetcode.com/problems/subsets",
      "slug": "subsets",
      "description": "Given an integer array \nnums\n of \nunique\n elements, return \nall possible\n \nsubsets\n \n(the power set)\n.\n\n\nThe solution set \nmust not\n contain duplicate subsets. Return the solution in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0]\n\nOutput:\n [[],[0]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n\n\n-10 <= nums[i] <= 10\n\n\nAll the numbers of \nnums\n are \nunique\n.",
      "solution": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        # Result list to store all subsets\n        res = []\n        n = len(nums)\n\n        # Backtracking function\n        def backtrack(idx, sol):\n            # Base case: if we've considered all elements\n            if idx == n:\n                res.append(sol[:])  # Append a copy of the current subset\n                return \n            \n            # Include the current element\n            sol.append(nums[idx])\n            backtrack(idx + 1, sol)\n\n            # Exclude the current element (backtrack)\n            sol.pop()\n            while idx + 1 < n and nums[idx] == nums[idx+1]: idx+= 1\n            backtrack(idx + 1, sol)\n\n        # Start backtracking from index 0 with an empty subset\n        backtrack(0, [])\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(n * 2^n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Combination Sum",
      "difficulty": "Medium",
      "category": "Backtracking",
      "link": "https://leetcode.com/problems/combination-sum",
      "slug": "combination-sum",
      "description": "Given an array of \ndistinct\n integers \ncandidates\n and a target integer \ntarget\n, return \na list of all \nunique combinations\n of \ncandidates\n where the chosen numbers sum to \ntarget\n.\n You may return the combinations in \nany order\n.\n\n\nThe \nsame\n number may be chosen from \ncandidates\n an \nunlimited number of times\n. Two combinations are unique if the \nfrequency\n of at least one of the chosen numbers is different.\n\n\nThe test cases are generated such that the number of unique combinations that sum up to \ntarget\n is less than \n150\n combinations for the given input.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n candidates = [2,3,6,7], target = 7\n\nOutput:\n [[2,2,3],[7]]\n\nExplanation:\n\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n\n\n\nExample 2:\n\n\n\n\nInput:\n candidates = [2,3,5], target = 8\n\nOutput:\n [[2,2,2,2],[2,3,3],[3,5]]\n\n\n\nExample 3:\n\n\n\n\nInput:\n candidates = [2], target = 1\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= candidates.length <= 30\n\n\n2 <= candidates[i] <= 40\n\n\nAll elements of \ncandidates\n are \ndistinct\n.\n\n\n1 <= target <= 40",
      "solution": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        res = []\n        candidates.sort()  # Sort to handle duplicates and allow pruning\n        n = len(candidates)\n\n        def backtrack(idx, need, path):\n            # ✅ If we hit the target exactly, save the current path\n            if need == target:\n                res.append(path[:])  # Use path[:] to copy\n                return \n            \n            # ❌ If index is out of range OR sum exceeded target → stop\n            if idx + 1 > n or need > target:\n                return \n            \n            # Include current number\n            path.append(candidates[idx])\n            # ⛔ Here you're doing idx+1, which means you **cannot reuse the same number**\n            backtrack(idx + 1, need + candidates[idx], path)\n            path.pop()  # Backtrack: remove the last number\n            \n            # Skip over duplicates\n            while idx + 1 < n and candidates[idx] == candidates[idx + 1]:\n                idx += 1\n            \n            # Exclude current number and move forward\n            backtrack(idx + 1, need, path)\n\n        backtrack(0, 0, [])\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(k * n^k)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Combination Sum II",
      "difficulty": "Medium",
      "category": "Backtracking",
      "link": "https://leetcode.com/problems/combination-sum-ii",
      "slug": "combination-sum-ii",
      "description": "Given a collection of candidate numbers (\ncandidates\n) and a target number (\ntarget\n), find all unique combinations in \ncandidates\n where the candidate numbers sum to \ntarget\n.\n\n\nEach number in \ncandidates\n may only be used \nonce\n in the combination.\n\n\nNote:\n The solution set must not contain duplicate combinations.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n candidates = [10,1,2,7,6,1,5], target = 8\n\nOutput:\n \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\n\n\nExample 2:\n\n\n\n\nInput:\n candidates = [2,5,2,1,2], target = 5\n\nOutput:\n \n[\n[1,2,2],\n[5]\n]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= candidates.length <= 100\n\n\n1 <= candidates[i] <= 50\n\n\n1 <= target <= 30",
      "solution": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        res = []\n        candidates.sort()  # Sort to handle duplicates and allow pruning\n        n = len(candidates)\n\n        def backtrack(idx, need, path):\n            # ✅ If we hit the target exactly, save the current path\n            if need == target:\n                res.append(path[:])  # Use path[:] to copy\n                return \n            \n            # ❌ If index is out of range OR sum exceeded target → stop\n            if idx + 1 > n or need > target:\n                return \n            \n            # Include current number\n            path.append(candidates[idx])\n            # ⛔ Here you're doing idx+1, which means you **cannot reuse the same number**\n            backtrack(idx + 1, need + candidates[idx], path)\n            path.pop()  # Backtrack: remove the last number\n            \n            # Skip over duplicates\n            while idx + 1 < n and candidates[idx] == candidates[idx + 1]:\n                idx += 1\n            \n            # Exclude current number and move forward\n            backtrack(idx + 1, need, path)\n\n        backtrack(0, 0, [])\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(k * C(n, k))",
      "space_complexity": "O(k)"
    },
    {
      "title": "Letter Combinations of a Phone Number",
      "difficulty": "Medium",
      "category": "Backtracking",
      "link": "https://leetcode.com/problems/letter-combinations-of-a-phone-number",
      "slug": "letter-combinations-of-a-phone-number",
      "description": "Given a string containing digits from \n2-9\n inclusive, return all possible letter combinations that the number could represent. Return the answer in \nany order\n.\n\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n digits = \"23\"\n\nOutput:\n [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n\n\n\nExample 2:\n\n\n\n\nInput:\n digits = \"\"\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n digits = \"2\"\n\nOutput:\n [\"a\",\"b\",\"c\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= digits.length <= 4\n\n\ndigits[i]\n is a digit in the range \n['2', '9']\n.",
      "solution": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        n = len(digits)  # Total number of digits in the input\n        res = []  # Stores all possible combinations\n\n        # If input is empty, no combinations can be formed\n        if not digits: \n            return []\n\n        # Mapping from digit to corresponding letters on a phone keypad\n        digit_to_letters = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz',\n        }\n\n        # Backtracking function to explore all letter combinations\n        def backtrack(idx, comb):\n            # Base case: If the current index reaches the length of digits,\n            # a full combination is formed, so we add it to the results\n            if idx == n:\n                res.append(comb[:])  # Append a copy of the current combination\n                return \n            \n            # Iterate over all possible letters mapped from the current digit\n            for letter in digit_to_letters[digits[idx]]:\n                # Add the letter to the current combination and move to the next digit\n                backtrack(idx + 1, comb + letter)\n        \n        # Start backtracking from index 0 with an empty combination\n        backtrack(0, \"\")\n\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(n * 4^n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Palindrome Partitioning",
      "difficulty": "Medium",
      "category": "Backtracking",
      "link": "https://leetcode.com/problems/palindrome-partitioning",
      "slug": "palindrome-partitioning",
      "description": "Given a string \ns\n, partition \ns\n such that every \nsubstring\n of the partition is a \npalindrome\n. Return \nall possible palindrome partitioning of \ns\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"aab\"\n\nOutput:\n [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n\nExample 2:\n\n\nInput:\n s = \"a\"\n\nOutput:\n [[\"a\"]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 16\n\n\ns\n contains only lowercase English letters.",
      "solution": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res = []       # Stores all possible palindrome partitions\n        part = []      # Current partition path\n        n = len(s)     # Length of the string\n\n        def backtrack(idx):\n            # Base case: If we've reached beyond the last character,\n            # it means the current path 'part' is a valid partition\n            if idx + 1 > n:\n                res.append(part[:])  # Append a copy of current partition\n                return\n\n            # Try all possible substrings starting at idx\n            for j in range(idx, n):\n                # If substring s[idx:j+1] is a palindrome\n                if self.pali(s, idx, j):\n                    part.append(s[idx:j+1])  # Choose\n                    backtrack(j + 1)         # Explore\n                    part.pop()               # Un-choose (backtrack)\n\n        # Start from the first index\n        backtrack(0)\n        return res\n\n    def pali(self, s, l, r):\n        # Check if s[l:r+1] is a palindrome\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l += 1\n            r -= 1\n        return True",
      "explanation": "N/A",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "N-Queens",
      "difficulty": "Hard",
      "category": "Backtracking",
      "link": "https://leetcode.com/problems/n-queens",
      "slug": "n-queens",
      "description": "The \nn-queens\n puzzle is the problem of placing \nn\n queens on an \nn x n\n chessboard such that no two queens attack each other.\n\n\nGiven an integer \nn\n, return \nall distinct solutions to the \nn-queens puzzle\n. You may return the answer in \nany order\n.\n\n\nEach solution contains a distinct board configuration of the n-queens' placement, where \n'Q'\n and \n'.'\n both indicate a queen and an empty space, respectively.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4\n\nOutput:\n [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n\nExplanation:\n There exist two distinct solutions to the 4-queens puzzle as shown above\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n [[\"Q\"]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 9",
      "solution": "from typing import List\n\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        # Boolean arrays to mark attacked columns and diagonals\n        col = [False] * n               # marks if a column has a queen\n        positiveDiag = [False] * (2*n)  # r+c index range [0 .. 2n-2]\n        negativeDiag = [False] * (2*n)  # r-c+n index range [0 .. 2n-2]\n\n        grid = [[\".\"] * n for _ in range(n)]  # chessboard\n        res = []  # final result list of solutions\n\n        def backtrack(r: int):\n            # Base case: placed queens in all rows\n            if r == n:\n                res.append([\"\".join(row) for row in grid])\n                return\n\n            # Try placing a queen in each column of row r\n            for c in range(n):\n                if col[c] or positiveDiag[r+c] or negativeDiag[r-c+n]:\n                    continue  # skip if column/diagonal is already attacked\n\n                # Place queen\n                col[c] = positiveDiag[r+c] = negativeDiag[r-c+n] = True\n                grid[r][c] = \"Q\"\n\n                # Recurse to next row\n                backtrack(r+1)\n\n                # Backtrack: remove queen\n                col[c] = positiveDiag[r+c] = negativeDiag[r-c+n] = False\n                grid[r][c] = \".\"\n\n        backtrack(0)\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(n^2 * n!)",
      "space_complexity": "O(n)"
    }
  ],
  "Tree Traversal - Level Order": [
    {
      "title": "Binary Tree Level Order Traversal",
      "difficulty": "Medium",
      "category": "Tree Traversal - Level Order",
      "link": "https://leetcode.com/problems/binary-tree-level-order-traversal",
      "slug": "binary-tree-level-order-traversal",
      "description": "Given the \nroot\n of a binary tree, return \nthe level order traversal of its nodes' values\n. (i.e., from left to right, level by level).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n [[3],[9,20],[15,7]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n [[1]]\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 2000]\n.\n\n\n-1000 <= Node.val <= 1000",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return a list of lists of integers\n    def levelOrder(self, root):\n        if root is None:\n            return []\n        result, current = [], [root]\n        while current:\n            next_level, vals = [], []\n            for node in current:\n                vals.append(node.val)\n                if node.left:\n                    next_level.append(node.left)\n                if node.right:\n                    next_level.append(node.right)\n            current = next_level\n            result.append(vals)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Binary Tree Right Side View",
      "difficulty": "Medium",
      "category": "Tree Traversal - Level Order",
      "link": "https://leetcode.com/problems/binary-tree-right-side-view",
      "slug": "binary-tree-right-side-view",
      "description": "Given the \nroot\n of a binary tree, imagine yourself standing on the \nright side\n of it, return \nthe values of the nodes you can see ordered from top to bottom\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nroot = [1,2,3,null,5,null,4]\n\n\nOutput:\n \n[1,3,4]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nroot = [1,2,3,4,null,null,null,5]\n\n\nOutput:\n \n[1,3,4,5]\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nroot = [1,null,3]\n\n\nOutput:\n \n[1,3]\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nroot = []\n\n\nOutput:\n \n[]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return a list of integers\n    def rightSideView(self, root):\n        result = []\n        self.rightSideViewDFS(root, 1, result)\n        return result\n\n    def rightSideViewDFS(self, node, depth, result):\n        if not node:\n            return\n\n        if depth > len(result):\n            result.append(node.val)\n\n        self.rightSideViewDFS(node.right, depth+1, result)\n        self.rightSideViewDFS(node.left, depth+1, result)\n\n\n# BFS solutionclass Solution2(object):\n    # @param root, a tree node\n    # @return a list of integers\n    def rightSideView(self, root):\n        if root is None:\n            return []\n\n        result, current = [], [root]\n        while current:\n            next_level = []\n            for node in current:\n                if node.left:\n                    next_level.append(node.left)\n                if node.right:\n                    next_level.append(node.right)                \n            result.append(node.val)\n            current = next_level\n\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Binary Tree Zigzag Level Order Traversal",
      "difficulty": "Medium",
      "category": "Tree Traversal - Level Order",
      "link": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal",
      "slug": "binary-tree-zigzag-level-order-traversal",
      "description": "Given the \nroot\n of a binary tree, return \nthe zigzag level order traversal of its nodes' values\n. (i.e., from left to right, then right to left for the next level and alternate between).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n [[3],[20,9],[15,7]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n [[1]]\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 2000]\n.\n\n\n-100 <= Node.val <= 100",
      "solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom collections import deque\nfrom typing import Optional, List\n\nclass Solution:\n    def zigzagLevelOrder(self, root: Optional['TreeNode']) -> List[List[int]]:\n        \"\"\"\n        LeetCode Pattern/Category: \n          - BFS (Breadth-First Search), Level-Order Traversal variant\n          - Also known as \"Zigzag Level Order Traversal\" or \"Alternating Level Order\"\n        \n        Intuition:\n          - Regular level-order traversal (BFS) visits nodes level by level from left to right.\n          - To produce a zigzag order, we alternate the reading direction on each level:\n              * Level 0: left -> right\n              * Level 1: right -> left\n              * Level 2: left -> right\n              * ... and so on.\n          - We can still process children in the normal left-to-right manner for BFS,\n            and only adjust how we *collect* values for the current level.\n          - Using a deque for the current level's values lets us append on the right for\n            left-to-right levels, and append on the left for right-to-left levels—avoiding\n            a post-processing reverse step and keeping the code clean.\n\n        Why this works:\n          - BFS guarantees that we process nodes in level order.\n          - Toggling the direction per level controls how we record values, matching the zigzag pattern.\n          - Children are always enqueued in the natural order (left, then right), ensuring correctness.\n\n        Time Complexity:\n          - O(N), where N is the number of nodes.\n            Each node is visited exactly once, and each value is appended once to a deque.\n        Space Complexity:\n          - O(W) for the queue on the widest level of the tree (W = max width).\n          - The result list also takes O(N) space to store all values.\n        \"\"\"\n        # Edge case: empty tree -> empty traversal.\n        if not root:\n            return []\n\n        # 'q' is the BFS queue holding nodes to process.\n        q = deque([root])\n\n        # 'left_to_right' tracks the output direction for the current level.\n        # Start with True to read the first level left -> right.\n        left_to_right = True\n\n        # Final result: list of lists, one inner list per tree level.\n        result: List[List[int]] = []\n\n        # Standard BFS loop: process until there are no more nodes.\n        while q:\n            # Process exactly one level at a time by snapshotting the current queue size.\n            level_size = len(q)\n\n            # We'll collect this level's values in a deque so we can push left or right\n            # depending on the required direction for the zigzag pattern.\n            level_vals = deque()\n\n            # Traverse all nodes currently in the queue (i.e., the current level).\n            for _ in range(level_size):\n                node = q.popleft()\n\n                # Insert the value according to the current direction:\n                # - If left_to_right: append to the right (normal order).\n                # - Else: append to the left (reverse order for this level).\n                if left_to_right:\n                    level_vals.append(node.val)\n                else:\n                    level_vals.appendleft(node.val)\n\n                # Enqueue children for the next level (always left first, then right).\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n\n            # Convert the deque to a list and store it in the result.\n            result.append(list(level_vals))\n\n            # Flip the direction for the next level to achieve the zigzag effect.\n            left_to_right = not left_to_right\n\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Populating Next Right Pointers in Each Node II",
      "difficulty": "Medium",
      "category": "Tree Traversal - Level Order",
      "link": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii",
      "slug": "populating-next-right-pointers-in-each-node-ii",
      "description": "Given a binary tree\n\n\n\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n\n\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to \nNULL\n.\n\n\nInitially, all next pointers are set to \nNULL\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,null,7]\n\nOutput:\n [1,#,2,3,#,4,5,7,#]\n\nExplanation: \nGiven the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 6000]\n.\n\n\n-100 <= Node.val <= 100\n\n\n\n\n \n\n\nFollow-up:\n\n\n\n\nYou may only use constant extra space.\n\n\nThe recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.",
      "solution": "\"\"\"\nLeetCode Problem: Populating Next Right Pointers in Each Node (Perfect Binary Tree)\n\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def connectI(self, root: 'Optional[Node]') -> 'Optional[Node]':\n        \"\"\"\n        LeetCode Pattern/Category:\n          - BFS / Level Traversal but optimized using constant space\n          - Works because the tree is a **perfect binary tree** (every parent has 2 children, and all leaves are at the same level).\n\n        Intuition:\n          - Since the tree is perfect, every node at a level has both left and right children.\n          - We can directly connect:\n              1. `curr.left.next = curr.right` (link left child to right child of the same parent).\n              2. If `curr.next` exists, then connect `curr.right.next = curr.next.left` \n                 (link right child to left child of the neighbor node).\n          - Once a level is fully processed, we move down to the next level by setting `curr = nxt` \n            (the leftmost node of the next level).\n\n        Why this works:\n          - Perfect binary tree structure guarantees:\n              * Each node has both left and right children.\n              * Nodes are fully aligned level by level.\n          - We don’t need a queue (as in normal BFS). \n          - By moving level by level and linking children directly, we achieve O(1) extra space.\n\n        Time Complexity:\n          - O(N), since every node is visited once and linked.\n        Space Complexity:\n          - O(1), as we only use pointers (`curr` and `nxt`).\n        \"\"\"\n        # Edge case: if root is None, just return None\n        if not root:\n            return root\n\n        # 'curr' will traverse nodes in the current level\n        # 'nxt' will always point to the leftmost node of the next level\n        curr, nxt = root, root.left if root.left else None\n\n        # Process level by level until no next level exists\n        while curr and nxt:\n            # Connect the left child to the right child\n            curr.left.next = curr.right\n\n            # If there is a neighbor node to the right of curr,\n            # connect curr's right child to curr.next's left child\n            if curr.next:\n                curr.right.next = curr.next.left\n\n            # Move to the next node on the current level\n            curr = curr.next\n\n            # If we've finished this level, move down to the next level\n            if not curr:\n                curr = nxt\n                nxt = curr.left if curr.left else None\n\n        # Return the root with next pointers connected\n        return root\n    \n    def connectII(self, root: 'Node') -> 'Node':\n        \"\"\"\n        LeetCode Pattern/Category:\n          - BFS / Level Order Traversal (but optimized with \"Linked List across levels\")\n          - Uses O(1) extra space (excluding recursion stack).\n\n        Intuition:\n          - We need to connect each node's \"next\" pointer to its right neighbor on the same level.\n          - Normally, BFS with a queue solves this easily, but that requires O(N) space.\n          - Instead, we reuse the `next` pointers themselves to traverse each level.\n          - For each level, we build the \"next\" chain for the level below it.\n          - Use a dummy node to simplify building the chain for the next level.\n\n        Why this works:\n          - `curr` traverses the current level using already established `next` pointers.\n          - `dummy` acts as the start of the new level, and `head` is used to link children together.\n          - At the end of processing one level, `curr = dummy.next` moves down to the first node\n            of the next level and repeats.\n          - This eliminates the need for a queue and ensures O(1) extra space.\n\n        Time Complexity:\n          - O(N), since every node is visited once.\n        Space Complexity:\n          - O(1), only pointers are used (no additional queue).\n        \"\"\"\n        # Edge case: If tree is empty, just return None.\n        if not root:\n            return root\n\n        # 'curr' will point to the current node of the current level.\n        curr = root\n\n        # Outer loop: traverse level by level until there are no more nodes.\n        while curr:\n            # Create a dummy node to act as the head of the next level.\n            dummy = Node(0)\n            # 'head' is the moving pointer to connect children nodes of 'curr' level.\n            head = dummy\n\n            # Inner loop: traverse the current level using next pointers.\n            while curr:\n                # If left child exists, connect it to the chain for next level.\n                if curr.left:\n                    head.next = curr.left\n                    head = head.next\n\n                # If right child exists, connect it to the chain for next level.\n                if curr.right:\n                    head.next = curr.right\n                    head = head.next\n\n                # Move to the next node in the current level (already linked by 'next').\n                curr = curr.next\n\n            # After finishing current level, move to the first node of the next level.\n            curr = dummy.next\n\n        # Return the root after connecting all next pointers.\n        return root",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Maximum Width of Binary Tree",
      "difficulty": "Medium",
      "category": "Tree Traversal - Level Order",
      "link": "https://leetcode.com/problems/maximum-width-of-binary-tree",
      "slug": "maximum-width-of-binary-tree",
      "description": "Given the \nroot\n of a binary tree, return \nthe \nmaximum width\n of the given tree\n.\n\n\nThe \nmaximum width\n of a tree is the maximum \nwidth\n among all levels.\n\n\nThe \nwidth\n of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation.\n\n\nIt is \nguaranteed\n that the answer will in the range of a \n32-bit\n signed integer.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,3,2,5,3,null,9]\n\nOutput:\n 4\n\nExplanation:\n The maximum width exists in the third level with length 4 (5,3,null,9).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,3,2,5,null,null,9,6,null,7]\n\nOutput:\n 7\n\nExplanation:\n The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [1,3,2,5]\n\nOutput:\n 2\n\nExplanation:\n The maximum width exists in the second level with length 2 (3,2).\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 3000]\n.\n\n\n-100 <= Node.val <= 100",
      "solution": "class Solution(object):\n    def widthOfBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(node, i, depth, leftmosts):\n            if not node:\n                return 0\n            if depth >= len(leftmosts):\n                leftmosts.append(i)\n            return max(i-leftmosts[depth]+1, \\\n                       dfs(node.left, i*2, depth+1, leftmosts), \\\n                       dfs(node.right, i*2+1, depth+1, leftmosts))\n\n        leftmosts = []\n        return dfs(root, 1, 0, leftmosts)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    }
  ],
  "Tree Traversal - Pre Order": [
    {
      "title": "Binary Tree Preorder Traversal",
      "difficulty": "Easy",
      "category": "Tree Traversal - Pre Order",
      "link": "https://leetcode.com/problems/binary-tree-preorder-traversal",
      "slug": "binary-tree-preorder-traversal",
      "description": "Given the \nroot\n of a binary tree, return \nthe preorder traversal of its nodes' values\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nroot = [1,null,2,3]\n\n\nOutput:\n \n[1,2,3]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nroot = [1,2,3,4,5,null,8,null,null,6,7,9]\n\n\nOutput:\n \n[1,2,4,5,6,7,3,8,9]\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nroot = []\n\n\nOutput:\n \n[]\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nroot = [1]\n\n\nOutput:\n \n[1]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100\n\n\n\n\n \n\n\nFollow up:\n Recursive solution is trivial, could you do it iteratively?",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n# Morris Traversal Solutionclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        result, curr = [], root\n        while curr:\n            if curr.left is None:\n                result.append(curr.val)\n                curr = curr.right\n            else:\n                node = curr.left\n                while node.right and node.right != curr:\n                    node = node.right\n\n                if node.right is None:\n                    result.append(curr.val)\n                    node.right = curr\n                    curr = curr.left\n                else:\n                    node.right = None\n                    curr = curr.right\n\n        return result\n\n\n# Stack Solutionclass Solution2(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        result, stack = [], [(root, False)]\n        while stack:\n            root, is_visited = stack.pop()\n            if root is None:\n                continue\n            if is_visited:\n                result.append(root.val)\n            else:\n                stack.append((root.right, False))\n                stack.append((root.left, False))\n                stack.append((root, True))\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Same Tree",
      "difficulty": "Easy",
      "category": "Tree Traversal - Pre Order",
      "link": "https://leetcode.com/problems/same-tree",
      "slug": "same-tree",
      "description": "Given the roots of two binary trees \np\n and \nq\n, write a function to check if they are the same or not.\n\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n p = [1,2,3], q = [1,2,3]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n p = [1,2], q = [1,null,2]\n\nOutput:\n false\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n p = [1,2,1], q = [1,1,2]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in both trees is in the range \n[0, 100]\n.\n\n\n-10\n4\n <= Node.val <= 10\n4",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\nclass Solution(object):\n    # @param p, a tree node\n    # @param q, a tree node\n    # @return a boolean\n    def isSameTree(self, p, q):\n        if p is None and q is None:\n            return True\n\n        if p is not None and q is not None:\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n        return False",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h), h is height of binary tree"
    },
    {
      "title": "Symmetric Tree",
      "difficulty": "Easy",
      "category": "Tree Traversal - Pre Order",
      "link": "https://leetcode.com/problems/symmetric-tree",
      "slug": "symmetric-tree",
      "description": "Given the \nroot\n of a binary tree, \ncheck whether it is a mirror of itself\n (i.e., symmetric around its center).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,2,3,4,4,3]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,2,null,3,null,3]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\n-100 <= Node.val <= 100\n\n\n\n\n \n\n\nFollow up:\n Could you solve it both recursively and iteratively?",
      "solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n        def dfs(p, q):\n            # If both nodes are None, it's symmetric at this branch\n            if not p and not q:\n                return True\n            # If only one is None, it's not symmetric\n            if not p or not q:\n                return False\n            # Values must match AND\n            # Left subtree of p == Right subtree of q\n            # Right subtree of p == Left subtree of q\n            return (\n                p.val == q.val \n                and dfs(p.left, q.right)   # compare outer children\n                and dfs(p.right, q.left)   # compare inner children\n            )\n        \n        # Start comparing left and right subtrees of root\n        return dfs(root.left, root.right)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h), h is height of binary tree"
    },
    {
      "title": "Binary Tree Paths",
      "difficulty": "Easy",
      "category": "Tree Traversal - Pre Order",
      "link": "https://leetcode.com/problems/binary-tree-paths",
      "slug": "binary-tree-paths",
      "description": "Given the \nroot\n of a binary tree, return \nall root-to-leaf paths in \nany order\n.\n\n\nA \nleaf\n is a node with no children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,null,5]\n\nOutput:\n [\"1->2->5\",\"1->3\"]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n [\"1\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 100]\n.\n\n\n-100 <= Node.val <= 100",
      "solution": "class Solution(object):\n    # @param {TreeNode} root\n    # @return {string[]}\n    def binaryTreePaths(self, root):\n        result, path = [], []\n        self.binaryTreePathsRecu(root, path, result)\n        return result\n\n    def binaryTreePathsRecu(self, node, path, result):\n        if node is None:\n            return\n\n        if node.left is node.right is None:\n            ans = \"\"\n            for n in path:\n                ans += str(n.val) + \"->\"\n            result.append(ans + str(node.val))\n\n        if node.left:\n            path.append(node)\n            self.binaryTreePathsRecu(node.left, path, result)\n            path.pop()\n\n        if node.right:\n            path.append(node)\n            self.binaryTreePathsRecu(node.right, path, result)\n            path.pop()",
      "explanation": "N/A",
      "time_complexity": "O(n * h)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Convert Sorted Array to Binary Search Tree",
      "difficulty": "Easy",
      "category": "Tree Traversal - Pre Order",
      "link": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree",
      "slug": "convert-sorted-array-to-binary-search-tree",
      "description": "Given an integer array \nnums\n where the elements are sorted in \nascending order\n, convert \nit to a \nheight-balanced\n \nbinary search tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n nums = [-10,-3,0,5,9]\n\nOutput:\n [0,-3,9,-10,null,5]\n\nExplanation:\n [0,-10,5,null,-3,null,9] is also accepted:\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n nums = [1,3]\n\nOutput:\n [3,1]\n\nExplanation:\n [1,null,3] and [3,1] are both height-balanced BSTs.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nnums\n is sorted in a \nstrictly increasing\n order.",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        return self.sortedArrayToBSTRecu(nums, 0, len(nums))\n\n    def sortedArrayToBSTRecu(self, nums, start, end):\n        if start == end:\n            return None\n        mid = start + self.perfect_tree_pivot(end - start)\n        node = TreeNode(nums[mid])\n        node.left = self.sortedArrayToBSTRecu(nums, start, mid)\n        node.right = self.sortedArrayToBSTRecu(nums, mid + 1, end)\n        return node\n\n    def perfect_tree_pivot(self, n):\n        \"\"\"\n        Find the point to partition n keys for a perfect binary search tree\n        \"\"\"\n        x = 1\n        # find a power of 2 <= n//2\n        # while x <= n//2:  # this loop could probably be written more elegantly :)\n        #     x *= 2\n        x = 1 << (n.bit_length() - 1)  # use the left bit shift, same as multiplying x by 2**n-1\n\n        if x // 2 - 1 <= (n - x):\n            return x - 1  # case 1: the left subtree of the root is perfect and the right subtree has less nodes\n        else:\n            return n - x // 2  # case 2 == n - (x//2 - 1) - 1 : the left subtree of the root\n                               # has more nodes and the right subtree is perfect.\nclass Solution2(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        self.iterator = iter(nums)\n        return self.helper(0, len(nums))\n    \n    def helper(self, start, end):\n        if start == end:\n            return None\n        \n        mid = (start + end) // 2\n        left = self.helper(start, mid)\n        current = TreeNode(next(self.iterator))\n        current.left = left\n        current.right = self.helper(mid+1, end)\n        return current",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(logn)"
    },
    {
      "title": "Count Complete Tree Nodes",
      "difficulty": "Easy",
      "category": "Tree Traversal - Pre Order",
      "link": "https://leetcode.com/problems/count-complete-tree-nodes",
      "slug": "count-complete-tree-nodes",
      "description": "Given the \nroot\n of a \ncomplete\n binary tree, return the number of the nodes in the tree.\n\n\nAccording to \nWikipedia\n, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between \n1\n and \n2\nh\n nodes inclusive at the last level \nh\n.\n\n\nDesign an algorithm that runs in less than \nO(n)\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,6]\n\nOutput:\n 6\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = []\n\nOutput:\n 0\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 5 * 10\n4\n]\n.\n\n\n0 <= Node.val <= 5 * 10\n4\n\n\nThe tree is guaranteed to be \ncomplete\n.",
      "solution": "\n# Definition for a binary tree node.class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def height(root):\n            h = -1\n            while root:\n                h += 1\n                root = root.left\n            return h\n\n        result, h = 0, height(root)\n        while root:\n            if height(root.right) == h-1:\n                result += 2**h\n                root = root.right\n            else:\n                result += 2**(h-1)\n                root = root.left\n            h -= 1\n        return result\n\n    class Solution2(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def check(node, n):\n            base = 1\n            while base <= n:\n                base <<= 1\n            base >>= 2\n\n            while base:\n                if (n & base) == 0:\n                    node = node.left\n                else:\n                    node = node.right\n                base >>= 1\n            return bool(node)\n\n        if not root:\n            return 0\n\n        node, level = root, 0\n        while node.left:\n            node = node.left\n            level += 1\n\n        left, right = 2**level, 2**(level+1)-1\n        while left <= right:\n            mid = left+(right-left)//2\n            if not check(root, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right",
      "explanation": "N/A",
      "time_complexity": "O(h * logn) = O((logn)^2)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Path Sum III",
      "difficulty": "Medium",
      "category": "Tree Traversal - Pre Order",
      "link": "https://leetcode.com/problems/path-sum-iii",
      "slug": "path-sum-iii",
      "description": "Given the \nroot\n of a binary tree and an integer \ntargetSum\n, return \nthe number of paths where the sum of the values along the path equals\n \ntargetSum\n.\n\n\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n\nOutput:\n 3\n\nExplanation:\n The paths that sum to 8 are shown.\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 1000]\n.\n\n\n-10\n9\n <= Node.val <= 10\n9\n\n\n-1000 <= targetSum <= 1000",
      "solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def pathSumII(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        \"\"\"\n        LeetCode Pattern/Category:\n          - DFS (Depth-First Search) + Backtracking\n          - Tree Path Problems\n\n        Intuition:\n          - We need to find all root-to-leaf paths where the sum of node values equals `targetSum`.\n          - DFS is a natural fit for exploring all possible paths in a tree.\n          - At each node, we:\n              1. Subtract the node's value from the remaining `targetSum`.\n              2. Add the node’s value to the current path.\n              3. If we reach a leaf node and the remaining sum is 0, we save the path.\n              4. Backtrack: remove the node's value before returning to explore other paths.\n\n        Why this works:\n          - DFS ensures we explore every possible path.\n          - Backtracking ensures we don’t carry incorrect path values when returning up the tree.\n          - Copying `path[:]` ensures we store a snapshot of the current path (since `path` is mutable).\n\n        Time Complexity:\n          - O(N) to visit all nodes, but in the worst case, each path can be O(H) long,\n            where H = tree height. So overall ~O(N * H).\n        Space Complexity:\n          - O(H) for recursion stack + O(H) for the current path storage.\n          - Result list stores all valid paths.\n        \"\"\"\n        # This will hold all the valid paths we find\n        paths = []\n\n        # Helper function for DFS + backtracking\n        def dfs(root, targetSum, path):\n            # Base case: if node is None, stop\n            if not root:\n                return\n            \n            # Include the current node in the path and update remaining sum\n            targetSum -= root.val\n            path.append(root.val)\n\n            # If it's a leaf node, check if the remaining sum is zero\n            if not root.left and not root.right:\n                if targetSum == 0:\n                    # Found a valid path, make a copy and add it\n                    paths.append(path[:])\n            else:\n                # Continue DFS on left and right children\n                dfs(root.left, targetSum, path)\n                dfs(root.right, targetSum, path)\n\n            # Backtrack: remove the last added node value before returning\n            path.pop()\n        \n        # Start DFS from the root with an empty path\n        dfs(root, targetSum, [])\n\n        return paths\n      \n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def pathSumIII(self, root: Optional[TreeNode], targetSum: int) -> int:\n        \"\"\"\n        LeetCode Pattern/Category:\n          - DFS (Depth-First Search)\n          - Prefix Sum in Trees (HashMap technique similar to Subarray Sum Equals K)\n        \n        Intuition:\n          - Any path sum can be represented as:\n              current_prefix_sum - old_prefix_sum = targetSum\n          - If we track all prefix sums seen so far in a hash map,\n            we can quickly check how many valid paths end at the current node.\n          - This avoids recomputing sums for all subpaths repeatedly.\n        \n        Why this works:\n          - As we DFS through the tree, we keep track of the running sum (prefix sum).\n          - For each node:\n              * Compute current prefix sum.\n              * Check if (curr_sum - targetSum) exists in the prefix map.\n                → If yes, it means there’s a path ending here with sum = targetSum.\n              * Add curr_sum to prefix map, recurse left and right, then backtrack.\n        \n        Time Complexity:\n          - O(N), since each node is processed once.\n        Space Complexity:\n          - O(H) recursion stack + O(N) for the prefix sum map in the worst case.\n        \"\"\"\n\n        def dfs(node, curr_sum, prefix_map):\n            if not node:\n                return 0\n\n            # Update running prefix sum\n            curr_sum += node.val\n\n            # Count paths that end at this node and sum to targetSum\n            count = prefix_map.get(curr_sum - targetSum, 0)\n\n            # Add current prefix sum to map\n            prefix_map[curr_sum] = prefix_map.get(curr_sum, 0) + 1\n\n            # Recurse into children\n            count += dfs(node.left, curr_sum, prefix_map)\n            count += dfs(node.right, curr_sum, prefix_map)\n\n            # Backtrack: remove current prefix sum before returning up\n            prefix_map[curr_sum] -= 1\n            if prefix_map[curr_sum] == 0:\n                del prefix_map[curr_sum]\n\n            return count\n\n        # Start DFS with prefix_sum=0 already counted once (empty path)\n        return dfs(root, 0, {0: 1})",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Maximum Difference Between Node and Ancestor",
      "difficulty": "Medium",
      "category": "Tree Traversal - Pre Order",
      "link": "https://leetcode.com/problems/maximum-difference-between-node-and-ancestor",
      "slug": "maximum-difference-between-node-and-ancestor",
      "description": "Given the \nroot\n of a binary tree, find the maximum value \nv\n for which there exist \ndifferent\n nodes \na\n and \nb\n where \nv = |a.val - b.val|\n and \na\n is an ancestor of \nb\n.\n\n\nA node \na\n is an ancestor of \nb\n if either: any child of \na\n is equal to \nb\n or any child of \na\n is an ancestor of \nb\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [8,3,10,1,6,null,14,null,null,4,7,13]\n\nOutput:\n 7\n\nExplanation: \nWe have various ancestor-node differences, some of which are given below :\n|8 - 3| = 5\n|3 - 7| = 4\n|8 - 1| = 7\n|10 - 13| = 3\nAmong all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,null,2,null,0,3]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 5000]\n.\n\n\n0 <= Node.val <= 10\n5",
      "solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        def dfs(root, maxV, minV):\n            # Base case: if we reach a leaf's child (None),\n            # return the difference between max and min ancestor values\n            if not root:\n                return maxV - minV\n            \n            # Update the max and min values seen so far in the path\n            maxV = max(maxV, root.val)\n            minV = min(minV, root.val)\n\n            # Recurse down both left and right subtrees,\n            # taking the maximum difference found\n            left = dfs(root.left, maxV, minV)\n            right = dfs(root.right, maxV, minV)\n\n            return max(left, right)\n        \n        # Start DFS with root's value as both initial max and min\n        return dfs(root, root.val, root.val)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Construct Binary Tree from Preorder and Inorder Traversal",
      "difficulty": "Medium",
      "category": "Tree Traversal - Pre Order",
      "link": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal",
      "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
      "description": "Given two integer arrays \npreorder\n and \ninorder\n where \npreorder\n is the preorder traversal of a binary tree and \ninorder\n is the inorder traversal of the same tree, construct and return \nthe binary tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n\nOutput:\n [3,9,20,null,null,15,7]\n\n\n\nExample 2:\n\n\n\n\nInput:\n preorder = [-1], inorder = [-1]\n\nOutput:\n [-1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= preorder.length <= 3000\n\n\ninorder.length == preorder.length\n\n\n-3000 <= preorder[i], inorder[i] <= 3000\n\n\npreorder\n and \ninorder\n consist of \nunique\n values.\n\n\nEach value of \ninorder\n also appears in \npreorder\n.\n\n\npreorder\n is \nguaranteed\n to be the preorder traversal of the tree.\n\n\ninorder\n is \nguaranteed\n to be the inorder traversal of the tree.",
      "solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        if not preorder or not inorder:\n            return None\n\n        # The first element in preorder is always the root\n        root = TreeNode(preorder[0])\n\n        # Find the root's index in inorder (splits left and right subtrees)\n        mid = inorder.index(preorder[0])\n\n        # Left subtree:\n        # preorder[1:mid+1] → next 'mid' nodes (all nodes belonging to left subtree)\n        # inorder[:mid]     → everything before 'mid' in inorder\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n\n        # Right subtree:\n        # preorder[mid+1:]  → remaining nodes (after left subtree in preorder)\n        # inorder[mid+1:]   → everything after 'mid' in inorder\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n\n        return root",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Construct Binary Tree from Inorder and Postorder Traversal",
      "difficulty": "Medium",
      "category": "Tree Traversal - Pre Order",
      "link": "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal",
      "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
      "description": "Given two integer arrays \ninorder\n and \npostorder\n where \ninorder\n is the inorder traversal of a binary tree and \npostorder\n is the postorder traversal of the same tree, construct and return \nthe binary tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n\nOutput:\n [3,9,20,null,null,15,7]\n\n\n\nExample 2:\n\n\n\n\nInput:\n inorder = [-1], postorder = [-1]\n\nOutput:\n [-1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= inorder.length <= 3000\n\n\npostorder.length == inorder.length\n\n\n-3000 <= inorder[i], postorder[i] <= 3000\n\n\ninorder\n and \npostorder\n consist of \nunique\n values.\n\n\nEach value of \npostorder\n also appears in \ninorder\n.\n\n\ninorder\n is \nguaranteed\n to be the inorder traversal of the tree.\n\n\npostorder\n is \nguaranteed\n to be the postorder traversal of the tree.",
      "solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        if not inorder or not postorder:\n            return None\n\n        # The last element in postorder is always the root\n        root_val = postorder.pop()\n        root = TreeNode(root_val)\n\n        # Find the root's index in inorder\n        # inorder = [Left Subtree | Root | Right Subtree]\n        mid = inorder.index(root_val)\n\n        # IMPORTANT: Build right subtree first\n        # Because we are popping from the end of postorder:\n        # postorder = [Left Subtree | Right Subtree | Root]\n        # After removing root, the *last part* corresponds to right subtree\n        root.right = self.buildTree(inorder[mid+1:], postorder)\n\n        # Then build left subtree\n        root.left = self.buildTree(inorder[:mid], postorder)\n\n        return root",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Serialize and Deserialize Binary Tree",
      "difficulty": "Hard",
      "category": "Tree Traversal - Pre Order",
      "link": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree",
      "slug": "serialize-and-deserialize-binary-tree",
      "description": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\n\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n\n\nClarification:\n The input/output format is the same as \nhow LeetCode serializes a binary tree\n. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,null,null,4,5]\n\nOutput:\n [1,2,3,null,null,4,5]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 10\n4\n]\n.\n\n\n-1000 <= Node.val <= 1000",
      "solution": "from collections import deque\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"\n        Encodes a tree to a single string using preorder traversal.\n        \"\"\"\n        def doit(node):\n            if node:\n                # Save the current node value\n                vals.append(str(node.val))\n                # Recurse left and right\n                doit(node.left)\n                doit(node.right)\n            else:\n                # Use '#' to represent a null pointer\n                vals.append('#')\n\n        vals = []\n        doit(root)\n        # Join all values into a single string\n        return ' '.join(vals)\n\n    def deserialize(self, data):\n        \"\"\"\n        Decodes the encoded string back to a tree.\n        Uses deque so we can pop values from the left efficiently (O(1)).\n        \"\"\"\n        vals = deque(data.split())  # split string into list and wrap in deque\n\n        def doit():\n            # Take the next value from the queue\n            val = vals.popleft()\n\n            if val == '#':\n                # Null marker means no node here\n                return None\n\n            # Create a new TreeNode\n            node = TreeNode(int(val))\n\n            # Build its left and right children recursively\n            node.left = doit()\n            node.right = doit()\n            return node\n\n        return doit()",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    }
  ],
  "Tree Traversal - In Order": [
    {
      "title": "Binary Tree Inorder Traversal",
      "difficulty": "Easy",
      "category": "Tree Traversal - In Order",
      "link": "https://leetcode.com/problems/binary-tree-inorder-traversal",
      "slug": "binary-tree-inorder-traversal",
      "description": "Given the \nroot\n of a binary tree, return \nthe inorder traversal of its nodes' values\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nroot = [1,null,2,3]\n\n\nOutput:\n \n[1,3,2]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nroot = [1,2,3,4,5,null,8,null,null,6,7,9]\n\n\nOutput:\n \n[4,2,6,5,7,1,3,9,8]\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nroot = []\n\n\nOutput:\n \n[]\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nroot = [1]\n\n\nOutput:\n \n[1]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100\n\n\n\n\n \n\n\nFollow up:\n Recursive solution is trivial, could you do it iteratively?",
      "solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n\n        def dfs(node):\n            if not node:\n                return\n            # 1. Visit left subtree\n            dfs(node.left)\n            # 2. Visit current node\n            res.append(node.val)\n            # 3. Visit right subtree\n            dfs(node.right)\n\n        dfs(root)\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Minimum Distance Between BST Nodes",
      "difficulty": "Easy",
      "category": "Tree Traversal - In Order",
      "link": "https://leetcode.com/problems/minimum-distance-between-bst-nodes",
      "slug": "minimum-distance-between-bst-nodes",
      "description": "Given the \nroot\n of a Binary Search Tree (BST), return \nthe minimum difference between the values of any two different nodes in the tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,2,6,1,3]\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,0,48,null,null,12,49]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 100]\n.\n\n\n0 <= Node.val <= 10\n5\n\n\n\n\n \n\n\nNote:\n This question is the same as 530: \nhttps://leetcode.com/problems/minimum-absolute-difference-in-bst/",
      "solution": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    # Class-level variables to track previous node value and minimum difference\n    pre = -float('inf')   # Previous visited node in inorder traversal\n    res = float('inf')    # Minimum difference found so far\n\n    def minDiffInBST(self, root):\n        # Inorder traversal ensures sorted order of BST values\n        if root.left:\n            self.minDiffInBST(root.left)\n\n        # Compute difference with previous node and update result\n        self.res = min(self.res, root.val - self.pre)\n        # Update previous node value\n        self.pre = root.val\n\n        if root.right:\n            self.minDiffInBST(root.right)\n\n        return self.res",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Minimum Absolute Difference in BST",
      "difficulty": "Easy",
      "category": "Tree Traversal - In Order",
      "link": "https://leetcode.com/problems/minimum-absolute-difference-in-bst",
      "slug": "minimum-absolute-difference-in-bst",
      "description": "Given the \nroot\n of a Binary Search Tree (BST), return \nthe minimum absolute difference between the values of any two different nodes in the tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,2,6,1,3]\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,0,48,null,null,12,49]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 10\n4\n]\n.\n\n\n0 <= Node.val <= 10\n5\n\n\n\n\n \n\n\nNote:\n This question is the same as 783: \nhttps://leetcode.com/problems/minimum-distance-between-bst-nodes/",
      "solution": "class Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def inorderTraversal(root, prev, result):\n            if not root:\n                return (result, prev)\n\n            result, prev = inorderTraversal(root.left, prev, result)\n            if prev: result = min(result, root.val - prev.val)\n            return inorderTraversal(root.right, root, result)\n\n        return inorderTraversal(root, None, float(\"inf\"))[0]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Validate Binary Search Tree",
      "difficulty": "Medium",
      "category": "Tree Traversal - In Order",
      "link": "https://leetcode.com/problems/validate-binary-search-tree",
      "slug": "validate-binary-search-tree",
      "description": "Given the \nroot\n of a binary tree, \ndetermine if it is a valid binary search tree (BST)\n.\n\n\nA \nvalid BST\n is defined as follows:\n\n\n\n\nThe left \nsubtree\n of a node contains only nodes with keys \nstrictly less than\n the node's key.\n\n\nThe right subtree of a node contains only nodes with keys \nstrictly greater than\n the node's key.\n\n\nBoth the left and right subtrees must also be binary search trees.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [2,1,3]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,1,4,null,null,3,6]\n\nOutput:\n false\n\nExplanation:\n The root node's value is 5 but its right child's value is 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-2\n31\n <= Node.val <= 2\n31\n - 1",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# Morris Traversal Solutionclass Solution(object):\n    # @param root, a tree node\n    # @return a list of integers\n    def isValidBST(self, root):\n        prev, cur = None, root\n        while cur:\n            if cur.left is None:\n                if prev and prev.val >= cur.val:\n                    return False\n                prev = cur\n                cur = cur.right\n            else:\n                node = cur.left\n                while node.right and node.right != cur:\n                    node = node.right\n\n                if node.right is None:\n                    node.right = cur\n                    cur = cur.left\n                else:\n                    if prev and prev.val >= cur.val:\n                        return False\n                    node.right = None\n                    prev = cur\n                    cur = cur.right\n\n        return True\n\nclass Solution2(object):\n    # @param root, a tree node\n    # @return a boolean\n    def isValidBST(self, root):\n        return self.isValidBSTRecu(root, float(\"-inf\"), float(\"inf\"))\n\n    def isValidBSTRecu(self, root, low, high):\n        if root is None:\n            return True\n\n        return low < root.val and root.val < high \\\n            and self.isValidBSTRecu(root.left, low, root.val) \\\n            and self.isValidBSTRecu(root.right, root.val, high)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Kth Smallest Element in a BST",
      "difficulty": "Medium",
      "category": "Tree Traversal - In Order",
      "link": "https://leetcode.com/problems/kth-smallest-element-in-a-bst",
      "slug": "kth-smallest-element-in-a-bst",
      "description": "Given the \nroot\n of a binary search tree, and an integer \nk\n, return \nthe\n \nk\nth\n \nsmallest value (\n1-indexed\n) of all the values of the nodes in the tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,1,4,null,2], k = 1\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,3,6,2,4,null,null,1], k = 3\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is \nn\n.\n\n\n1 <= k <= n <= 10\n4\n\n\n0 <= Node.val <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?",
      "solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        # Counter for number of nodes visited so far\n        self.count = 0\n        self.result = None\n\n        def inorder(node):\n            if not node or self.result is not None:\n                return\n\n            inorder(node.left)\n\n            # Process current node\n            self.count += 1\n            if self.count == k:\n                self.result = node.val\n                return\n\n            inorder(node.right)\n\n        inorder(root)\n        return self.result",
      "explanation": "N/A",
      "time_complexity": "O(max(h, k))",
      "space_complexity": "O(h)"
    },
    {
      "title": "Binary Search Tree Iterator",
      "difficulty": "Medium",
      "category": "Tree Traversal - In Order",
      "link": "https://leetcode.com/problems/binary-search-tree-iterator",
      "slug": "binary-search-tree-iterator",
      "description": "Implement the \nBSTIterator\n class that represents an iterator over the \nin-order traversal\n of a binary search tree (BST):\n\n\n\n\nBSTIterator(TreeNode root)\n Initializes an object of the \nBSTIterator\n class. The \nroot\n of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\n\n\nboolean hasNext()\n Returns \ntrue\n if there exists a number in the traversal to the right of the pointer, otherwise returns \nfalse\n.\n\n\nint next()\n Moves the pointer to the right, then returns the number at the pointer.\n\n\n\n\nNotice that by initializing the pointer to a non-existent smallest number, the first call to \nnext()\n will return the smallest element in the BST.\n\n\nYou may assume that \nnext()\n calls will always be valid. That is, there will be at least a next number in the in-order traversal when \nnext()\n is called.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput\n\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n\nOutput\n\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n\nExplanation\n\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n5\n]\n.\n\n\n0 <= Node.val <= 10\n6\n\n\nAt most \n10\n5\n calls will be made to \nhasNext\n, and \nnext\n.\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nCould you implement \nnext()\n and \nhasNext()\n to run in average \nO(1)\n time and use \nO(h)\n memory, where \nh\n is the height of the tree?",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass BSTIterator(object):\n    # @param root, a binary search tree's root node\n    def __init__(self, root):\n        self.__stk = []\n        self.__traversalLeft(root)\n\n    # @return a boolean, whether we have a next smallest number\n    def hasNext(self):\n        return self.__stk\n\n    # @return an integer, the next smallest number\n    def next(self):\n        node = self.__stk.pop()\n        self.__traversalLeft(node.right)\n        return node.val\n    \n    def __traversalLeft(self, node):\n        while node is not None:\n            self.__stk.append(node)\n            node = node.left",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(h), h is height of binary tree"
    }
  ],
  "Tree Traversal - Post-Order": [
    {
      "title": "Binary Tree Postorder Traversal",
      "difficulty": "Easy",
      "category": "Tree Traversal - Post-Order",
      "link": "https://leetcode.com/problems/binary-tree-postorder-traversal",
      "slug": "binary-tree-postorder-traversal",
      "description": "Given the \nroot\n of a binary tree, return \nthe postorder traversal of its nodes' values\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nroot = [1,null,2,3]\n\n\nOutput:\n \n[3,2,1]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nroot = [1,2,3,4,5,null,8,null,null,6,7,9]\n\n\nOutput:\n \n[4,6,7,5,2,9,8,3,1]\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nroot = []\n\n\nOutput:\n \n[]\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nroot = [1]\n\n\nOutput:\n \n[1]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of the nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100\n\n\n\n\n \n\n\nFollow up:\n Recursive solution is trivial, could you do it iteratively?",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n# Morris Traversal Solutionclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        dummy = TreeNode(0)\n        dummy.left = root\n        result, cur = [], dummy\n        while cur:\n            if cur.left is None:\n                cur = cur.right\n            else:\n                node = cur.left\n                while node.right and node.right != cur:\n                    node = node.right\n\n                if node.right is None:\n                    node.right = cur\n                    cur = cur.left\n                else:\n                    result += self.traceBack(cur.left, node)\n                    node.right = None\n                    cur = cur.right\n\n        return result\n\n    def traceBack(self, frm, to):\n        result, cur = [], frm\n        while cur is not to:\n            result.append(cur.val)\n            cur = cur.right\n        result.append(to.val)\n        result.reverse()\n        return result\n\n\n# Stack Solutionclass Solution2(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        result, stack = [], [(root, False)]\n        while stack:\n            root, is_visited = stack.pop()\n            if root is None:\n                continue\n            if is_visited:\n                result.append(root.val)\n            else:\n                stack.append((root, True))\n                stack.append((root.right, False))\n                stack.append((root.left, False))\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Invert Binary Tree",
      "difficulty": "Easy",
      "category": "Tree Traversal - Post-Order",
      "link": "https://leetcode.com/problems/invert-binary-tree",
      "slug": "invert-binary-tree",
      "description": "Given the \nroot\n of a binary tree, invert the tree, and return \nits root\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [4,2,7,1,3,6,9]\n\nOutput:\n [4,7,2,9,6,3,1]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [2,1,3]\n\nOutput:\n [2,3,1]\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100",
      "solution": "\nimport collections\n\n\n# BFS solution.class Queue(object):\n    def __init__(self):\n        self.data = collections.deque()\n\n    def push(self, x):\n        self.data.append(x)\n\n    def peek(self):\n        return self.data[0]\n\n    def pop(self):\n        return self.data.popleft()\n\n    def size(self):\n        return len(self.data)\n\n    def empty(self):\n        return len(self.data) == 0\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\nclass Solution(object):\n    # @param {TreeNode} root\n    # @return {TreeNode}\n    def invertTree(self, root):\n        if root is not None:\n            nodes = Queue()\n            nodes.push(root)\n            while not nodes.empty():\n                node = nodes.pop()\n                node.left, node.right = node.right, node.left\n                if node.left is not None:\n                    nodes.push(node.left)\n                if node.right is not None:\n                    nodes.push(node.right)\n\n        return root\n\n# Stack solution.class Solution2(object):\n    # @param {TreeNode} root\n    # @return {TreeNode}\n    def invertTree(self, root):\n        if root is not None:\n            nodes = []\n            nodes.append(root)\n            while nodes:\n                node = nodes.pop()\n                node.left, node.right = node.right, node.left\n                if node.left is not None:\n                    nodes.append(node.left)\n                if node.right is not None:\n                    nodes.append(node.right)\n\n        return root\n\n# DFS, Recursive solution.class Solution3(object):\n    # @param {TreeNode} root\n    # @return {TreeNode}\n    def invertTree(self, root):\n        if root is not None:\n            root.left, root.right = self.invertTree(root.right), \\\n                                    self.invertTree(root.left)\n\n        return root",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Diameter of Binary Tree",
      "difficulty": "Easy",
      "category": "Tree Traversal - Post-Order",
      "link": "https://leetcode.com/problems/diameter-of-binary-tree",
      "slug": "diameter-of-binary-tree",
      "description": "Given the \nroot\n of a binary tree, return \nthe length of the \ndiameter\n of the tree\n.\n\n\nThe \ndiameter\n of a binary tree is the \nlength\n of the longest path between any two nodes in a tree. This path may or may not pass through the \nroot\n.\n\n\nThe \nlength\n of a path between two nodes is represented by the number of edges between them.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5]\n\nOutput:\n 3\n\nExplanation:\n 3 is the length of the path [4,2,1,3] or [5,2,1,3].\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1,2]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-100 <= Node.val <= 100",
      "solution": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def diameterOfBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def iter_dfs(node):\n            result = 0\n            stk = [(1, [node, [0]])]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, ret = params\n                    if not node:\n                        continue\n                    ret1, ret2 = [0], [0]\n                    stk.append((2, [node, ret1, ret2, ret]))\n                    stk.append((1, [node.right, ret2]))\n                    stk.append((1, [node.left, ret1]))\n                elif step == 2:\n                    node, ret1, ret2, ret = params\n                    result = max(result, ret1[0]+ret2[0])\n                    ret[0] = 1+max(ret1[0], ret2[0])\n            return result\n        \n        return iter_dfs(root)\n\nclass Solution2(object):\n    def diameterOfBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(root):\n            if not root: \n                return 0, 0\n            left_d, left_h = dfs(root.left)\n            right_d, right_h = dfs(root.right)\n            return max(left_d, right_d, left_h+right_h), 1+max(left_h, right_h)\n \n        return dfs(root)[0]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Delete Nodes And Return Forest",
      "difficulty": "Medium",
      "category": "Tree Traversal - Post-Order",
      "link": "https://leetcode.com/problems/delete-nodes-and-return-forest",
      "slug": "delete-nodes-and-return-forest",
      "description": "Given the \nroot\n of a binary tree, each node in the tree has a distinct value.\n\n\nAfter deleting all nodes with a value in \nto_delete\n, we are left with a forest (a disjoint union of trees).\n\n\nReturn the roots of the trees in the remaining forest. You may return the result in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,6,7], to_delete = [3,5]\n\nOutput:\n [[1,2,null,4],[6],[7]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1,2,4,null,3], to_delete = [3]\n\nOutput:\n [[1,2,4]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the given tree is at most \n1000\n.\n\n\nEach node has a distinct value between \n1\n and \n1000\n.\n\n\nto_delete.length <= 1000\n\n\nto_delete\n contains distinct values between \n1\n and \n1000\n.",
      "solution": "def delNodes(self, root, to_delete):\n    to_delete_set = set(to_delete)   # for O(1) lookup\n    res = []                         # will store roots of resulting forest\n\n    def helper(root, is_root):\n        if not root:\n            return None\n\n        # check if this node should be deleted\n        root_deleted = root.val in to_delete_set\n\n        # If this node is a root AND not deleted -> add to result\n        if is_root and not root_deleted:\n            res.append(root)\n\n        # Recurse for children.\n        # If current node is deleted, its children become \"new roots\".\n        root.left = helper(root.left, root_deleted)\n        root.right = helper(root.right, root_deleted)\n\n        # return None if deleted (cut this node out), otherwise keep it\n        return None if root_deleted else root\n\n    helper(root, True)\n    return res",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h + d), d is the number of to_delete"
    },
    {
      "title": "Lowest Common Ancestor of a Binary Tree",
      "difficulty": "Medium",
      "category": "Tree Traversal - Post-Order",
      "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree",
      "slug": "lowest-common-ancestor-of-a-binary-tree",
      "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\n\nAccording to the \ndefinition of LCA on Wikipedia\n: “The lowest common ancestor is defined between two nodes \np\n and \nq\n as the lowest node in \nT\n that has both \np\n and \nq\n as descendants (where we allow \na node to be a descendant of itself\n).”\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n\nOutput:\n 3\n\nExplanation:\n The LCA of nodes 5 and 1 is 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n\nOutput:\n 5\n\nExplanation:\n The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [1,2], p = 1, q = 2\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 10\n5\n]\n.\n\n\n-10\n9\n <= Node.val <= 10\n9\n\n\nAll \nNode.val\n are \nunique\n.\n\n\np != q\n\n\np\n and \nq\n will exist in the tree.",
      "solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        # Base case:\n        # 1. If root is None → no ancestor here.\n        # 2. If root is p or q → this node might be the LCA.\n        if not root or root == p or root == q:\n            return root\n        \n        # Search in the left and right subtrees\n        l = self.lowestCommonAncestor(root.left, p, q)\n        r = self.lowestCommonAncestor(root.right, p, q)\n        \n        # Case 1: If we found p in one side and q in the other,\n        #         then root is their lowest common ancestor.\n        if l and r:\n            return root\n        \n        # Case 2: Otherwise, return whichever side is non-null:\n        # - If only left side returned a node → p and q are in left subtree.\n        # - If only right side returned a node → p and q are in right subtree.\n        return l or r",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Find Duplicate Subtrees",
      "difficulty": "Medium",
      "category": "Tree Traversal - Post-Order",
      "link": "https://leetcode.com/problems/find-duplicate-subtrees",
      "slug": "find-duplicate-subtrees",
      "description": "Given the \nroot\n of a binary tree, return all \nduplicate subtrees\n.\n\n\nFor each kind of duplicate subtrees, you only need to return the root node of any \none\n of them.\n\n\nTwo trees are \nduplicate\n if they have the \nsame structure\n with the \nsame node values\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,null,2,4,null,null,4]\n\nOutput:\n [[2,4],[4]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [2,1,1]\n\nOutput:\n [[1]]\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [2,2,2,3,null,3,null]\n\nOutput:\n [[2,3],[3]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of the nodes in the tree will be in the range \n[1, 5000]\n\n\n-200 <= Node.val <= 200",
      "solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\n        \n        def structure(root):\n            # Base case: return a placeholder for null nodes\n            if not root:\n                return \"null\"\n\n            # Serialize the current subtree in the form:\n            # \"rootVal,leftSubtree,rightSubtree\"\n            tree_path = f\"{root.val},{structure(root.left)},{structure(root.right)}\"\n\n            # Store the root node corresponding to this serialized subtree\n            nodes[tree_path].append(root)\n\n            # Return the serialization so parent nodes can build theirs\n            return tree_path\n        \n        # Dictionary where:\n        #   key   = serialized subtree string\n        #   value = list of root nodes that share this structure\n        nodes = defaultdict(list)\n\n        # Start DFS traversal & serialization from the root\n        structure(root)\n\n        # Collect one representative node for each duplicate subtree\n        return [nodes[path][0] for path in nodes if len(nodes[path]) > 1]",
      "explanation": "N/A",
      "time_complexity": "O(n * h)",
      "space_complexity": "O(n * h)"
    },
    {
      "title": "Flatten Binary Tree to Linked List",
      "difficulty": "Medium",
      "category": "Tree Traversal - Post-Order",
      "link": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list",
      "slug": "flatten-binary-tree-to-linked-list",
      "description": "Given the \nroot\n of a binary tree, flatten the tree into a \"linked list\":\n\n\n\n\nThe \"linked list\" should use the same \nTreeNode\n class where the \nright\n child pointer points to the next node in the list and the \nleft\n child pointer is always \nnull\n.\n\n\nThe \"linked list\" should be in the same order as a \npre-order\n traversal\n of the binary tree.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,5,3,4,null,6]\n\nOutput:\n [1,null,2,null,3,null,4,null,5,null,6]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 2000]\n.\n\n\n-100 <= Node.val <= 100\n\n\n\n\n \n\n\nFollow up:\n Can you flatten the tree in-place (with \nO(1)\n extra space)?",
      "solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def flatten(self, root: Optional[TreeNode]) -> None:\n        \"\"\"\n        Flattens the binary tree to a linked list in-place following preorder traversal.\n        \"\"\"\n        curr = root\n\n        # Traverse through the tree using the right pointer\n        while curr:\n            if curr.left:\n                # Find the rightmost node of the left subtree\n                p = curr.left\n                while p.right:\n                    p = p.right\n                \n                # Attach the original right subtree to this rightmost node\n                p.right = curr.right\n\n                # Move the left subtree to the right\n                curr.right = curr.left\n                curr.left = None   # Clear the left pointer\n            \n            # Move to the next right node (linked list style)\n            curr = curr.right",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h), h is height of binary tree"
    },
    {
      "title": "Distribute Coins in Binary Tree",
      "difficulty": "Medium",
      "category": "Tree Traversal - Post-Order",
      "link": "https://leetcode.com/problems/distribute-coins-in-binary-tree",
      "slug": "distribute-coins-in-binary-tree",
      "description": "You are given the \nroot\n of a binary tree with \nn\n nodes where each \nnode\n in the tree has \nnode.val\n coins. There are \nn\n coins in total throughout the whole tree.\n\n\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.\n\n\nReturn \nthe \nminimum\n number of moves required to make every node have \nexactly\n one coin\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,0,0]\n\nOutput:\n 2\n\nExplanation: \nFrom the root of the tree, we move one coin to its left child, and one coin to its right child.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [0,3,0]\n\nOutput:\n 3\n\nExplanation: \nFrom the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is \nn\n.\n\n\n1 <= n <= 100\n\n\n0 <= Node.val <= n\n\n\nThe sum of all \nNode.val\n is \nn\n.",
      "solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def distributeCoins(self, root: Optional[TreeNode]) -> int:\n        self.moves = 0\n\n        def dfs(node):\n            if not node:\n                return 0\n\n            # Postorder: process left and right first\n            left_balance = dfs(node.left)\n            right_balance = dfs(node.right)\n\n            # Add moves: abs(coins moved in left) + abs(coins moved in right)\n            self.moves += abs(left_balance) + abs(right_balance)\n\n            # Net balance for this node = total coins in subtree - total nodes in subtree\n            return node.val + left_balance + right_balance - 1\n\n        dfs(root)\n        return self.moves",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Binary Tree Maximum Path Sum",
      "difficulty": "Hard",
      "category": "Tree Traversal - Post-Order",
      "link": "https://leetcode.com/problems/binary-tree-maximum-path-sum",
      "slug": "binary-tree-maximum-path-sum",
      "description": "A \npath\n in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence \nat most once\n. Note that the path does not need to pass through the root.\n\n\nThe \npath sum\n of a path is the sum of the node's values in the path.\n\n\nGiven the \nroot\n of a binary tree, return \nthe maximum \npath sum\n of any \nnon-empty\n path\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3]\n\nOutput:\n 6\n\nExplanation:\n The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [-10,9,20,null,null,15,7]\n\nOutput:\n 42\n\nExplanation:\n The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 3 * 10\n4\n]\n.\n\n\n-1000 <= Node.val <= 1000",
      "solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        # Global result to track the maximum path sum found so far\n        res = float('-inf')  \n\n        def dfs(root):\n            nonlocal res\n            if not root:\n                return 0  # Base case: null node contributes 0\n\n            # Recursively get the max path sum from left and right children\n            maxLeft = dfs(root.left)\n            maxRight = dfs(root.right)\n\n            # If a side is negative, ignore it (better to not include that path)\n            maxLeft = max(maxLeft, 0)\n            maxRight = max(maxRight, 0)\n\n            # Case 1: Path passes *through* this node \n            # (root + best left + best right)\n            res = max(res, root.val + maxLeft + maxRight)\n\n            # Case 2: Return the best single path upward \n            # (root + max(left, right)) → usable by parent\n            return root.val + max(maxLeft, maxRight)\n\n        dfs(root)\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h), h is height of binary tree"
    }
  ],
  "BST / Ordered Set": [
    {
      "title": "Trim a Binary Search Tree",
      "difficulty": "Medium",
      "category": "BST / Ordered Set",
      "link": "https://leetcode.com/problems/trim-a-binary-search-tree",
      "slug": "trim-a-binary-search-tree",
      "description": "Given the \nroot\n of a binary search tree and the lowest and highest boundaries as \nlow\n and \nhigh\n, trim the tree so that all its elements lies in \n[low, high]\n. Trimming the tree should \nnot\n change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a \nunique answer\n.\n\n\nReturn \nthe root of the trimmed binary search tree\n. Note that the root may change depending on the given bounds.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,0,2], low = 1, high = 2\n\nOutput:\n [1,null,2]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,0,4,null,2,null,null,1], low = 1, high = 3\n\nOutput:\n [3,2,null,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n0 <= Node.val <= 10\n4\n\n\nThe value of each node in the tree is \nunique\n.\n\n\nroot\n is guaranteed to be a valid binary search tree.\n\n\n0 <= low <= high <= 10\n4",
      "solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:\n        # Base case: If the current node is None, simply return None.\n        # This handles leaf boundaries.\n        if not root:\n            return None \n        \n        # If the current node's value is greater than 'high',\n        # this node and its right subtree are invalid (too large).\n        # Therefore, we only recurse into the left subtree.\n        if root.val > high:\n            return self.trimBST(root.left, low, high)\n\n        # If the current node's value is smaller than 'low',\n        # this node and its left subtree are invalid (too small).\n        # Therefore, we only recurse into the right subtree.\n        if root.val < low:\n            return self.trimBST(root.right, low, high)\n\n        # Otherwise, the current node's value is within [low, high].\n        # Recursively trim its left and right subtrees to ensure they also satisfy the condition.\n        root.left = self.trimBST(root.left, low, high)\n        root.right = self.trimBST(root.right, low, high)\n\n        # Return the current node, which is valid and properly trimmed.\n        return root",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "My Calendar I",
      "difficulty": "Medium",
      "category": "BST / Ordered Set",
      "link": "https://leetcode.com/problems/my-calendar-i",
      "slug": "my-calendar-i",
      "description": "You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a \ndouble booking\n.\n\n\nA \ndouble booking\n happens when two events have some non-empty intersection (i.e., some moment is common to both events.).\n\n\nThe event can be represented as a pair of integers \nstartTime\n and \nendTime\n that represents a booking on the half-open interval \n[startTime, endTime)\n, the range of real numbers \nx\n such that \nstartTime <= x < endTime\n.\n\n\nImplement the \nMyCalendar\n class:\n\n\n\n\nMyCalendar()\n Initializes the calendar object.\n\n\nboolean book(int startTime, int endTime)\n Returns \ntrue\n if the event can be added to the calendar successfully without causing a \ndouble booking\n. Otherwise, return \nfalse\n and do not add the event to the calendar.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"MyCalendar\", \"book\", \"book\", \"book\"]\n[[], [10, 20], [15, 25], [20, 30]]\n\nOutput\n\n[null, true, false, true]\n\n\nExplanation\n\nMyCalendar myCalendar = new MyCalendar();\nmyCalendar.book(10, 20); // return True\nmyCalendar.book(15, 25); // return False, It can not be booked because time 15 is already booked by another event.\nmyCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20.\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= start < end <= 10\n9\n\n\nAt most \n1000\n calls will be made to \nbook\n.",
      "solution": "from sortedcontainers import SortedList\n\nclass MyCalendar:\n    def __init__(self):\n        # Maintain all booked intervals in a sorted order (by start time).\n        self.calendar = SortedList()\n\n    def book(self, start: int, end: int) -> bool:\n        # Find the index where (start, end) would be inserted while keeping the list sorted.\n        idx = self.calendar.bisect_right((start, end))\n\n        # Check overlap with the previous interval:\n        # If the previous interval ends after 'start', they overlap → reject.\n        if idx > 0 and self.calendar[idx-1][1] > start:\n            return False\n\n        # Check overlap with the next interval:\n        # If the next interval starts before 'end', they overlap → reject.\n        if idx < len(self.calendar) and self.calendar[idx][0] < end:\n            return False\n\n        # If no overlap, safely add the interval to the calendar.\n        self.calendar.add((start, end))\n        return True",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n)"
    },
    {
      "title": "My Calendar II",
      "difficulty": "Medium",
      "category": "BST / Ordered Set",
      "link": "https://leetcode.com/problems/my-calendar-ii",
      "slug": "my-calendar-ii",
      "description": "You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a \ntriple booking\n.\n\n\nA \ntriple booking\n happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.).\n\n\nThe event can be represented as a pair of integers \nstartTime\n and \nendTime\n that represents a booking on the half-open interval \n[startTime, endTime)\n, the range of real numbers \nx\n such that \nstartTime <= x < endTime\n.\n\n\nImplement the \nMyCalendarTwo\n class:\n\n\n\n\nMyCalendarTwo()\n Initializes the calendar object.\n\n\nboolean book(int startTime, int endTime)\n Returns \ntrue\n if the event can be added to the calendar successfully without causing a \ntriple booking\n. Otherwise, return \nfalse\n and do not add the event to the calendar.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"]\n[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]\n\nOutput\n\n[null, true, true, true, false, true, true]\n\n\nExplanation\n\nMyCalendarTwo myCalendarTwo = new MyCalendarTwo();\nmyCalendarTwo.book(10, 20); // return True, The event can be booked. \nmyCalendarTwo.book(50, 60); // return True, The event can be booked. \nmyCalendarTwo.book(10, 40); // return True, The event can be double booked. \nmyCalendarTwo.book(5, 15);  // return False, The event cannot be booked, because it would result in a triple booking.\nmyCalendarTwo.book(5, 10); // return True, The event can be booked, as it does not use time 10 which is already double booked.\nmyCalendarTwo.book(25, 55); // return True, The event can be booked, as the time in [25, 40) will be double booked with the third event, the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= start < end <= 10\n9\n\n\nAt most \n1000\n calls will be made to \nbook\n.",
      "solution": "class MyCalendarTwo:\n\n    def __init__(self):\n        # Stores all booked intervals (can overlap once)\n        self.calendar = []\n        # Stores intervals that are already double-booked\n        # If a new booking overlaps with these, it becomes a triple-booking → not allowed\n        self.overlap = []\n\n    def book(self, startTime: int, endTime: int) -> bool:\n        \n        # Step 1: Check if new booking causes a triple booking\n        for os, oe in self.overlap:\n            # If new interval overlaps with an already double-booked interval → triple booking\n            if startTime < oe and endTime > os:\n                return False\n        \n        # Step 2: Check overlaps with existing single bookings\n        for bs, be in self.calendar:\n            # If new interval overlaps with an existing booking\n            if startTime < be and endTime > bs:\n                # Record the overlapping portion as a \"double-booked\" interval\n                # (intersection of the two intervals)\n                self.overlap.append((max(startTime, bs), min(endTime, be)))\n        \n        # Step 3: Add the new booking to the calendar\n        self.calendar.append((startTime, endTime))\n\n        return True",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Stock Price Fluctuation",
      "difficulty": "Medium",
      "category": "BST / Ordered Set",
      "link": "https://leetcode.com/problems/stock-price-fluctuation",
      "slug": "stock-price-fluctuation",
      "description": "You are given a stream of \nrecords\n about a particular stock. Each record contains a \ntimestamp\n and the corresponding \nprice\n of the stock at that timestamp.\n\n\nUnfortunately due to the volatile nature of the stock market, the records do not come in order. Even worse, some records may be incorrect. Another record with the same timestamp may appear later in the stream \ncorrecting\n the price of the previous wrong record.\n\n\nDesign an algorithm that:\n\n\n\n\nUpdates\n the price of the stock at a particular timestamp, \ncorrecting\n the price from any previous records at the timestamp.\n\n\nFinds the \nlatest price\n of the stock based on the current records. The \nlatest price\n is the price at the latest timestamp recorded.\n\n\nFinds the \nmaximum price\n the stock has been based on the current records.\n\n\nFinds the \nminimum price\n the stock has been based on the current records.\n\n\n\n\nImplement the \nStockPrice\n class:\n\n\n\n\nStockPrice()\n Initializes the object with no price records.\n\n\nvoid update(int timestamp, int price)\n Updates the \nprice\n of the stock at the given \ntimestamp\n.\n\n\nint current()\n Returns the \nlatest price\n of the stock.\n\n\nint maximum()\n Returns the \nmaximum price\n of the stock.\n\n\nint minimum()\n Returns the \nminimum price\n of the stock.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"StockPrice\", \"update\", \"update\", \"current\", \"maximum\", \"update\", \"maximum\", \"update\", \"minimum\"]\n[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]\n\nOutput\n\n[null, null, null, 5, 10, null, 5, null, 2]\n\n\nExplanation\n\nStockPrice stockPrice = new StockPrice();\nstockPrice.update(1, 10); // Timestamps are [1] with corresponding prices [10].\nstockPrice.update(2, 5);  // Timestamps are [1,2] with corresponding prices [10,5].\nstockPrice.current();     // return 5, the latest timestamp is 2 with the price being 5.\nstockPrice.maximum();     // return 10, the maximum price is 10 at timestamp 1.\nstockPrice.update(1, 3);  // The previous timestamp 1 had the wrong price, so it is updated to 3.\n                          // Timestamps are [1,2] with corresponding prices [3,5].\nstockPrice.maximum();     // return 5, the maximum price is 5 after the correction.\nstockPrice.update(4, 2);  // Timestamps are [1,2,4] with corresponding prices [3,5,2].\nstockPrice.minimum();     // return 2, the minimum price is 2 at timestamp 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= timestamp, price <= 10\n9\n\n\nAt most \n10\n5\n calls will be made \nin total\n to \nupdate\n, \ncurrent\n, \nmaximum\n, and \nminimum\n.\n\n\ncurrent\n, \nmaximum\n, and \nminimum\n will be called \nonly after\n \nupdate\n has been called \nat least once\n.",
      "solution": "#        update:  O(logn)\n#        current: O(1)\n#        max:     O(1)\n#        min:     O(1)\n\nfrom sortedcontainers import SortedList\n\nclass StockPrice(object):\n\n    def __init__(self):\n        self.__curr = 0\n        self.__lookup = {}\n        self.__sl_by_price = SortedList()\n\n    def update(self, timestamp, price):\n        \"\"\"\n        :type timestamp: int\n        :type price: int\n        :rtype: None\n        \"\"\"\n        if timestamp > self.__curr:\n            self.__curr = timestamp\n        if timestamp in self.__lookup:\n            self.__sl_by_price.remove(self.__lookup[timestamp])\n        self.__lookup[timestamp] = price\n        self.__sl_by_price.add(price)\n\n    def current(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.__lookup[self.__curr]\n\n    def maximum(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return next(reversed(self.__sl_by_price))\n\n    def minimum(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return next(iter(self.__sl_by_price))\n\n\n#        update:  O(logn)\n#        current: O(1)\n#        max:     O(logn) on average\n#        min:     O(logn) on average\nimport heapq\n\nclass StockPrice2(object):\n\n    def __init__(self):\n        self.__curr = 0\n        self.__lookup = {}\n        self.__min_heap = []\n        self.__max_heap = []\n\n    def update(self, timestamp, price):\n        \"\"\"\n        :type timestamp: int\n        :type price: int\n        :rtype: None\n        \"\"\"\n        def full_delete(heap, sign):  # Time: O(n), Space: O(n)\n            heap[:] = [x for x in set(heap) if sign*x[0] == self.__lookup[x[1]]]\n            heapq.heapify(heap)\n\n        if timestamp > self.__curr:\n            self.__curr = timestamp\n        self.__lookup[timestamp] = price\n        heapq.heappush(self.__min_heap, (price, timestamp))\n        heapq.heappush(self.__max_heap, (-price, timestamp))\n        if len(self.__min_heap) > 2*len(self.__lookup):  # avoid too much expired or duplicated data\n            full_delete(self.__min_heap, 1)\n            full_delete(self.__max_heap, -1)\n\n    def current(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.__lookup[self.__curr]\n\n    def maximum(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while self.__max_heap and self.__lookup[self.__max_heap[0][1]] != -self.__max_heap[0][0]:  # lazy delete\n            heapq.heappop(self.__max_heap)\n        return -self.__max_heap[0][0]\n\n    def minimum(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while self.__min_heap and self.__lookup[self.__min_heap[0][1]] != self.__min_heap[0][0]:  # lazy delete\n            heapq.heappop(self.__min_heap)\n        return self.__min_heap[0][0]",
      "explanation": "N/A",
      "time_complexity": "ctor:    O(1)",
      "space_complexity": "O(n)"
    }
  ],
  "Tries": [
    {
      "title": "Implement Trie (Prefix Tree)",
      "difficulty": "Medium",
      "category": "Tries",
      "link": "https://leetcode.com/problems/implement-trie-prefix-tree",
      "slug": "implement-trie-prefix-tree",
      "description": "A \ntrie\n (pronounced as \"try\") or \nprefix tree\n is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\n\n\nImplement the Trie class:\n\n\n\n\nTrie()\n Initializes the trie object.\n\n\nvoid insert(String word)\n Inserts the string \nword\n into the trie.\n\n\nboolean search(String word)\n Returns \ntrue\n if the string \nword\n is in the trie (i.e., was inserted before), and \nfalse\n otherwise.\n\n\nboolean startsWith(String prefix)\n Returns \ntrue\n if there is a previously inserted string \nword\n that has the prefix \nprefix\n, and \nfalse\n otherwise.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\n\nOutput\n\n[null, null, true, false, true, null, true]\n\n\nExplanation\n\nTrie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // return True\ntrie.search(\"app\");     // return False\ntrie.startsWith(\"app\"); // return True\ntrie.insert(\"app\");\ntrie.search(\"app\");     // return True\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word.length, prefix.length <= 2000\n\n\nword\n and \nprefix\n consist only of lowercase English letters.\n\n\nAt most \n3 * 10\n4\n calls \nin total\n will be made to \ninsert\n, \nsearch\n, and \nstartsWith\n.",
      "solution": "class TrieNode(object):\n    # Initialize your data structure here.\n    def __init__(self):\n        self.is_string = False\n        self.leaves = {}\n\nclass Trie(object):\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    # @param {string} word\n    # @return {void}\n    # Inserts a word into the trie.\n    def insert(self, word):\n        cur = self.root\n        for c in word:\n            if not c in cur.leaves:\n                cur.leaves[c] = TrieNode()\n            cur = cur.leaves[c]\n        cur.is_string = True\n\n    # @param {string} word\n    # @return {boolean}\n    # Returns if the word is in the trie.\n    def search(self, word):\n        node = self.childSearch(word)\n        if node:\n            return node.is_string\n        return False\n\n    # @param {string} prefix\n    # @return {boolean}\n    # Returns if there is any word in the trie\n    # that starts with the given prefix.\n    def startsWith(self, prefix):\n        return self.childSearch(prefix) is not None\n\n    def childSearch(self, word):\n        cur = self.root\n        for c in word:\n            if c in cur.leaves:\n                cur = cur.leaves[c]\n            else:\n                return None\n        return cur",
      "explanation": "N/A",
      "time_complexity": "O(n), per operation",
      "space_complexity": "O(1)"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "difficulty": "Medium",
      "category": "Tries",
      "link": "https://leetcode.com/problems/design-add-and-search-words-data-structure",
      "slug": "design-add-and-search-words-data-structure",
      "description": "Design a data structure that supports adding new words and finding if a string matches any previously added string.\n\n\nImplement the \nWordDictionary\n class:\n\n\n\n\nWordDictionary()\n Initializes the object.\n\n\nvoid addWord(word)\n Adds \nword\n to the data structure, it can be matched later.\n\n\nbool search(word)\n Returns \ntrue\n if there is any string in the data structure that matches \nword\n or \nfalse\n otherwise. \nword\n may contain dots \n'.'\n where dots can be matched with any letter.\n\n\n\n\n \n\n\nExample:\n\n\n\n\nInput\n\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\n\nOutput\n\n[null,null,null,null,false,true,true,true]\n\n\nExplanation\n\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\"bad\");\nwordDictionary.addWord(\"dad\");\nwordDictionary.addWord(\"mad\");\nwordDictionary.search(\"pad\"); // return False\nwordDictionary.search(\"bad\"); // return True\nwordDictionary.search(\".ad\"); // return True\nwordDictionary.search(\"b..\"); // return True\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word.length <= 25\n\n\nword\n in \naddWord\n consists of lowercase English letters.\n\n\nword\n in \nsearch\n consist of \n'.'\n or lowercase English letters.\n\n\nThere will be at most \n2\n dots in \nword\n for \nsearch\n queries.\n\n\nAt most \n10\n4\n calls will be made to \naddWord\n and \nsearch\n.",
      "solution": "# Solution not found in kamyu104 repository",
      "explanation": "N/A",
      "time_complexity": "N/A",
      "space_complexity": "N/A"
    },
    {
      "title": "Search Suggestions System",
      "difficulty": "Medium",
      "category": "Tries",
      "link": "https://leetcode.com/problems/search-suggestions-system",
      "slug": "search-suggestions-system",
      "description": "You are given an array of strings \nproducts\n and a string \nsearchWord\n.\n\n\nDesign a system that suggests at most three product names from \nproducts\n after each character of \nsearchWord\n is typed. Suggested products should have common prefix with \nsearchWord\n. If there are more than three products with a common prefix return the three lexicographically minimums products.\n\n\nReturn \na list of lists of the suggested products after each character of \nsearchWord\n is typed\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n products = [\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"], searchWord = \"mouse\"\n\nOutput:\n [[\"mobile\",\"moneypot\",\"monitor\"],[\"mobile\",\"moneypot\",\"monitor\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"]]\n\nExplanation:\n products sorted lexicographically = [\"mobile\",\"moneypot\",\"monitor\",\"mouse\",\"mousepad\"].\nAfter typing m and mo all products match and we show user [\"mobile\",\"moneypot\",\"monitor\"].\nAfter typing mou, mous and mouse the system suggests [\"mouse\",\"mousepad\"].\n\n\n\nExample 2:\n\n\n\n\nInput:\n products = [\"havana\"], searchWord = \"havana\"\n\nOutput:\n [[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"]]\n\nExplanation:\n The only word \"havana\" will be always suggested while typing the search word.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= products.length <= 1000\n\n\n1 <= products[i].length <= 3000\n\n\n1 <= sum(products[i].length) <= 2 * 10\n4\n\n\nAll the strings of \nproducts\n are \nunique\n.\n\n\nproducts[i]\n consists of lowercase English letters.\n\n\n1 <= searchWord.length <= 1000\n\n\nsearchWord\n consists of lowercase English letters.",
      "solution": "#                      , l is the average length of product name\n#        suggest: O(l^2)\n\nimport collections\n\nclass TrieNode(object):\n\n    def __init__(self):\n        self.__TOP_COUNT = 3\n        self.leaves = collections.defaultdict(TrieNode)\n        self.infos = []\n\n    def insert(self, words, i):\n        curr = self\n        for c in words[i]:\n            curr = curr.leaves[c]\n            curr.add_info(words, i)\n\n    def add_info(self, words, i):\n        self.infos.append(i)\n        self.infos.sort(key=lambda x: words[x])\n        if len(self.infos) > self.__TOP_COUNT:\n            self.infos.pop()\n\nclass Solution(object):\n    def suggestedProducts(self, products, searchWord):\n        \"\"\"\n        :type products: List[str]\n        :type searchWord: str\n        :rtype: List[List[str]]\n        \"\"\"\n        trie = TrieNode()\n        for i in xrange(len(products)):\n            trie.insert(products, i)\n        result = [[] for _ in xrange(len(searchWord))]\n        for i, c in enumerate(searchWord):\n            if c not in trie.leaves:\n                break\n            trie = trie.leaves[c]\n            result[i] = map(lambda x: products[x], trie.infos)\n        return result\n\n\n#                                   , l is the average length of product name\n#        suggest: O(l^2)class TrieNode2(object):\n\n    def __init__(self):\n        self.__TOP_COUNT = 3\n        self.leaves = collections.defaultdict(TrieNode2)\n        self.infos = []\n\n    def insert(self, words, i):\n        curr = self\n        for c in words[i]:\n            curr = curr.leaves[c]\n            curr.add_info(i)\n\n    def add_info(self, i):\n        if len(self.infos) == self.__TOP_COUNT:\n            return\n        self.infos.append(i)\n\nclass Solution2(object):\n    def suggestedProducts(self, products, searchWord):\n        \"\"\"\n        :type products: List[str]\n        :type searchWord: str\n        :rtype: List[List[str]]\n        \"\"\"\n        products.sort()\n        trie = TrieNode2()\n        for i in xrange(len(products)):\n            trie.insert(products, i)\n        result = [[] for _ in xrange(len(searchWord))]\n        for i, c in enumerate(searchWord):\n            if c not in trie.leaves:\n                break\n            trie = trie.leaves[c]\n            result[i] = map(lambda x: products[x], trie.infos)\n        return result\n\n\n#                                   , l is the average length of product name\n#        suggest: O(l^2 * n)\nimport bisect\n\nclass Solution3(object):\n    def suggestedProducts(self, products, searchWord):\n        \"\"\"\n        :type products: List[str]\n        :type searchWord: str\n        :rtype: List[List[str]]\n        \"\"\"\n        products.sort()  # Time: O(n * l * log(n * l))\n        result = []\n        prefix = \"\"\n        for i, c in enumerate(searchWord):  # Time: O(l)\n            prefix += c\n            start = bisect.bisect_left(products, prefix)  # Time: O(log(n * l))\n            new_products = []\n            for j in xrange(start, len(products)):  # Time: O(n * l)\n                if not (i < len(products[j]) and products[j][i] == c):\n                    break\n                new_products.append(products[j])\n            products = new_products\n            result.append(products[:3])\n        return result",
      "explanation": "N/A",
      "time_complexity": "ctor: O(n * l * log(n * l)), n is the number of products",
      "space_complexity": "O(n * l)"
    },
    {
      "title": "Longest Word in Dictionary",
      "difficulty": "Medium",
      "category": "Tries",
      "link": "https://leetcode.com/problems/longest-word-in-dictionary",
      "slug": "longest-word-in-dictionary",
      "description": "Given an array of strings \nwords\n representing an English Dictionary, return \nthe longest word in\n \nwords\n \nthat can be built one character at a time by other words in\n \nwords\n.\n\n\nIf there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.\n\n\nNote that the word should be built from left to right with each additional character being added to the end of a previous word. \n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"w\",\"wo\",\"wor\",\"worl\",\"world\"]\n\nOutput:\n \"world\"\n\nExplanation:\n The word \"world\" can be built one character at a time by \"w\", \"wo\", \"wor\", and \"worl\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"]\n\nOutput:\n \"apple\"\n\nExplanation:\n Both \"apply\" and \"apple\" can be built from other words in the dictionary. However, \"apple\" is lexicographically smaller than \"apply\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 1000\n\n\n1 <= words[i].length <= 30\n\n\nwords[i]\n consists of lowercase English letters.",
      "solution": "\nfrom collections import defaultdict\nfrom operator import getitem\n\nclass Solution(object):\n    def longestWord(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: str\n        \"\"\"\n        _trie = lambda: defaultdict(_trie)\n        trie = _trie()\n        for i, word in enumerate(words):\n            reduce(getitem, word, trie)[\"_end\"] = i\n\n        # DFS\n        stack = trie.values()\n        result = \"\"\n        while stack:\n            curr = stack.pop()\n            if \"_end\" in curr:\n                word = words[curr[\"_end\"]]\n                if len(word) > len(result) or (len(word) == len(result) and word < result):\n                    result = word\n                stack += [curr[letter] for letter in curr if letter != \"_end\"]\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n), n is the total sum of the lengths of words",
      "space_complexity": "O(t), t is the number of nodes in trie"
    },
    {
      "title": "Maximum XOR of Two Numbers in an Array",
      "difficulty": "Medium",
      "category": "Tries",
      "link": "https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array",
      "slug": "maximum-xor-of-two-numbers-in-an-array",
      "description": "Given an integer array \nnums\n, return \nthe maximum result of \nnums[i] XOR nums[j]\n, where \n0 <= i <= j < n\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,10,5,25,2,8]\n\nOutput:\n 28\n\nExplanation:\n The maximum result is 5 XOR 25 = 28.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [14,70,53,83,49,91,36,80,92,51,66,70]\n\nOutput:\n 127\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2 * 10\n5\n\n\n0 <= nums[i] <= 2\n31\n - 1",
      "solution": "class Solution(object):\n    def findMaximumXOR(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        class Trie(object):\n            def __init__(self, bit_length):\n                self.__nodes = []\n                self.__new_node()\n                self.__bit_length = bit_length\n            \n            def __new_node(self):\n                self.__nodes.append([-1]*2)\n                return len(self.__nodes)-1\n\n            def insert(self, num):\n                curr = 0\n                for i in reversed(xrange(self.__bit_length)):\n                    x = num>>i\n                    if self.__nodes[curr][x&1] == -1:\n                        self.__nodes[curr][x&1] = self.__new_node()\n                    curr = self.__nodes[curr][x&1]\n                        \n            def query(self, num):\n                result = curr = 0\n                for i in reversed(xrange(self.__bit_length)):\n                    result <<= 1\n                    x = num>>i\n                    if self.__nodes[curr][1^(x&1)] != -1:\n                        curr = self.__nodes[curr][1^(x&1)]\n                        result |= 1\n                    else:\n                        curr = self.__nodes[curr][x&1]\n                return result\n\n        trie = Trie(max(nums).bit_length())\n        result = 0\n        for num in nums:\n            trie.insert(num)\n            result = max(result, trie.query(num))\n        return result\n\nclass Solution2(object):\n    def findMaximumXOR(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in reversed(xrange(max(nums).bit_length())):\n            result <<= 1\n            prefixes = set()\n            for n in nums:\n                prefixes.add(n >> i)\n            for p in prefixes:\n                if (result | 1) ^ p in prefixes:\n                    result |= 1\n                    break\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogr), r = max(nums)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Word Search II",
      "difficulty": "Hard",
      "category": "Tries",
      "link": "https://leetcode.com/problems/word-search-ii",
      "slug": "word-search-ii",
      "description": "Given an \nm x n\n \nboard\n of characters and a list of strings \nwords\n, return \nall words on the board\n.\n\n\nEach word must be constructed from letters of sequentially adjacent cells, where \nadjacent cells\n are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n\nOutput:\n [\"eat\",\"oath\"]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == board.length\n\n\nn == board[i].length\n\n\n1 <= m, n <= 12\n\n\nboard[i][j]\n is a lowercase English letter.\n\n\n1 <= words.length <= 3 * 10\n4\n\n\n1 <= words[i].length <= 10\n\n\nwords[i]\n consists of lowercase English letters.\n\n\nAll the strings of \nwords\n are unique.",
      "solution": "class TrieNode(object):\n    # Initialize your data structure here.\n    def __init__(self):\n        self.is_string = False\n        self.leaves = {}\n\n    # Inserts a word into the trie.\n    def insert(self, word):\n        cur = self\n        for c in word:\n            if not c in cur.leaves:\n                cur.leaves[c] = TrieNode()\n            cur = cur.leaves[c]\n        cur.is_string = True\n\nclass Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        visited = [[False for j in xrange(len(board[0]))] for i in xrange(len(board))]\n        result = {}\n        trie = TrieNode()\n        for word in words:\n            trie.insert(word)\n\n        for i in xrange(len(board)):\n            for j in xrange(len(board[0])):\n                self.findWordsRecu(board, trie, 0, i, j, visited, [], result)\n\n        return result.keys()\n\n    def findWordsRecu(self, board, trie, cur, i, j, visited, cur_word, result):\n        if not trie or i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j]:\n            return\n\n        if board[i][j] not in trie.leaves:\n            return\n\n        cur_word.append(board[i][j])\n        next_node = trie.leaves[board[i][j]]\n        if next_node.is_string:\n            result[\"\".join(cur_word)] = True\n\n        visited[i][j] = True\n        self.findWordsRecu(board, next_node, cur + 1, i + 1, j, visited, cur_word, result)\n        self.findWordsRecu(board, next_node, cur + 1, i - 1, j, visited, cur_word, result)\n        self.findWordsRecu(board, next_node, cur + 1, i, j + 1, visited, cur_word, result)\n        self.findWordsRecu(board, next_node, cur + 1, i, j - 1, visited, cur_word, result)\n        visited[i][j] = False\n        cur_word.pop()",
      "explanation": "N/A",
      "time_complexity": "O(m * n * 4 * 3^(h - 1)) ~= O(m * n * 3^h), h is the height of trie",
      "space_complexity": "O(t), t is the number of nodes in trie"
    }
  ],
  "Heaps": [
    {
      "title": "Furthest Building You Can Reach",
      "difficulty": "Medium",
      "category": "Heaps",
      "link": "https://leetcode.com/problems/furthest-building-you-can-reach",
      "slug": "furthest-building-you-can-reach",
      "description": "You are given an integer array \nheights\n representing the heights of buildings, some \nbricks\n, and some \nladders\n.\n\n\nYou start your journey from building \n0\n and move to the next building by possibly using bricks or ladders.\n\n\nWhile moving from building \ni\n to building \ni+1\n (\n0-indexed\n),\n\n\n\n\nIf the current building's height is \ngreater than or equal\n to the next building's height, you do \nnot\n need a ladder or bricks.\n\n\nIf the current building's height is \nless than\n the next building's height, you can either use \none ladder\n or \n(h[i+1] - h[i])\n \nbricks\n.\n\n\n\n\nReturn the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1\n\nOutput:\n 4\n\nExplanation:\n Starting at building 0, you can follow these steps:\n- Go to building 1 without using ladders nor bricks since 4 >= 2.\n- Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.\n- Go to building 3 without using ladders nor bricks since 7 >= 6.\n- Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.\nIt is impossible to go beyond building 4 because you do not have any more bricks or ladders.\n\n\n\nExample 2:\n\n\n\n\nInput:\n heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2\n\nOutput:\n 7\n\n\n\nExample 3:\n\n\n\n\nInput:\n heights = [14,3,19,3], bricks = 17, ladders = 0\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= heights.length <= 10\n5\n\n\n1 <= heights[i] <= 10\n6\n\n\n0 <= bricks <= 10\n9\n\n\n0 <= ladders <= heights.length",
      "solution": "\nimport heapq\n\nclass Solution(object):\n    def furthestBuilding(self, heights, bricks, ladders):\n        \"\"\"\n        :type heights: List[int]\n        :type bricks: int\n        :type ladders: int\n        :rtype: int\n        \"\"\"\n        min_heap = []\n        for i in xrange(len(heights)-1):\n            diff = heights[i+1]-heights[i]\n            if diff > 0:\n                heapq.heappush(min_heap, diff)\n            if len(min_heap) <= ladders:  # ladders are reserved for largest diffs\n                continue\n            bricks -= heapq.heappop(min_heap)  # use bricks if ladders are not enough\n            if bricks < 0:  # not enough bricks\n                return i\n        return len(heights)-1",
      "explanation": "N/A",
      "time_complexity": "O(nlogk)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Single-Threaded CPU",
      "difficulty": "Medium",
      "category": "Heaps",
      "link": "https://leetcode.com/problems/single-threaded-cpu",
      "slug": "single-threaded-cpu",
      "description": "You are given \nn\n​​​​​​ tasks labeled from \n0\n to \nn - 1\n represented by a 2D integer array \ntasks\n, where \ntasks[i] = [enqueueTime\ni\n, processingTime\ni\n]\n means that the \ni\n​​​​​​th\n​​​​ task will be available to process at \nenqueueTime\ni\n and will take \nprocessingTime\ni\n \nto finish processing.\n\n\nYou have a single-threaded CPU that can process \nat most one\n task at a time and will act in the following way:\n\n\n\n\nIf the CPU is idle and there are no available tasks to process, the CPU remains idle.\n\n\nIf the CPU is idle and there are available tasks, the CPU will choose the one with the \nshortest processing time\n. If multiple tasks have the same shortest processing time, it will choose the task with the smallest index.\n\n\nOnce a task is started, the CPU will \nprocess the entire task\n without stopping.\n\n\nThe CPU can finish a task then start a new one instantly.\n\n\n\n\nReturn \nthe order in which the CPU will process the tasks.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n tasks = [[1,2],[2,4],[3,2],[4,1]]\n\nOutput:\n [0,2,3,1]\n\nExplanation: \nThe events go as follows: \n- At time = 1, task 0 is available to process. Available tasks = {0}.\n- Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.\n- At time = 2, task 1 is available to process. Available tasks = {1}.\n- At time = 3, task 2 is available to process. Available tasks = {1, 2}.\n- Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.\n- At time = 4, task 3 is available to process. Available tasks = {1, 3}.\n- At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.\n- At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.\n- At time = 10, the CPU finishes task 1 and becomes idle.\n\n\n\nExample 2:\n\n\n\n\nInput:\n tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]\n\nOutput:\n [4,3,2,0,1]\n\nExplanation\n: \nThe events go as follows:\n- At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.\n- Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.\n- At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.\n- At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.\n- At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.\n- At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.\n- At time = 40, the CPU finishes task 1 and becomes idle.\n\n\n\n \n\n\nConstraints:\n\n\n\n\ntasks.length == n\n\n\n1 <= n <= 10\n5\n\n\n1 <= enqueueTime\ni\n, processingTime\ni\n <= 10\n9",
      "solution": "\nimport heapq\n\nclass Solution(object):\n    def getOrder(self, tasks):\n        \"\"\"\n        :type tasks: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        idx = range(len(tasks))\n        idx.sort(key=lambda x: tasks[x][0])\n        result, min_heap = [], []\n        i, time = 0, tasks[idx[0]][0]\n        while i < len(idx) or min_heap:\n            while i < len(idx) and tasks[idx[i]][0] <= time:\n                heapq.heappush(min_heap, (tasks[idx[i]][1], idx[i]))\n                i += 1\n            if not min_heap:\n                time = tasks[idx[i]][0]\n                continue\n            t, j = heapq.heappop(min_heap)\n            time += t\n            result.append(j)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Process Tasks Using Servers",
      "difficulty": "Medium",
      "category": "Heaps",
      "link": "https://leetcode.com/problems/process-tasks-using-servers",
      "slug": "process-tasks-using-servers",
      "description": "You are given two \n0-indexed\n integer arrays \nservers\n and \ntasks\n of lengths \nn\n​​​​​​ and \nm\n​​​​​​ respectively. \nservers[i]\n is the \nweight\n of the \ni\n​​​​​​th\n​​​​ server, and \ntasks[j]\n is the \ntime needed\n to process the \nj\n​​​​​​th\n​​​​ task \nin seconds\n.\n\n\nTasks are assigned to the servers using a \ntask queue\n. Initially, all servers are free, and the queue is \nempty\n.\n\n\nAt second \nj\n, the \nj\nth\n task is \ninserted\n into the queue (starting with the \n0\nth\n task being inserted at second \n0\n). As long as there are free servers and the queue is not empty, the task in the front of the queue will be assigned to a free server with the \nsmallest weight\n, and in case of a tie, it is assigned to a free server with the \nsmallest index\n.\n\n\nIf there are no free servers and the queue is not empty, we wait until a server becomes free and immediately assign the next task. If multiple servers become free at the same time, then multiple tasks from the queue will be assigned \nin order of insertion\n following the weight and index priorities above.\n\n\nA server that is assigned task \nj\n at second \nt\n will be free again at second \nt + tasks[j]\n.\n\n\nBuild an array \nans\n​​​​ of length \nm\n, where \nans[j]\n is the \nindex\n of the server the \nj\n​​​​​​th\n task will be assigned to.\n\n\nReturn \nthe array \nans\n​​​​.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n servers = [3,3,2], tasks = [1,2,3,2,1,2]\n\nOutput:\n [2,2,0,2,1,2]\n\nExplanation: \nEvents in chronological order go as follows:\n- At second 0, task 0 is added and processed using server 2 until second 1.\n- At second 1, server 2 becomes free. Task 1 is added and processed using server 2 until second 3.\n- At second 2, task 2 is added and processed using server 0 until second 5.\n- At second 3, server 2 becomes free. Task 3 is added and processed using server 2 until second 5.\n- At second 4, task 4 is added and processed using server 1 until second 5.\n- At second 5, all servers become free. Task 5 is added and processed using server 2 until second 7.\n\n\nExample 2:\n\n\n\n\nInput:\n servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1]\n\nOutput:\n [1,4,1,4,1,3,2]\n\nExplanation: \nEvents in chronological order go as follows: \n- At second 0, task 0 is added and processed using server 1 until second 2.\n- At second 1, task 1 is added and processed using server 4 until second 2.\n- At second 2, servers 1 and 4 become free. Task 2 is added and processed using server 1 until second 4. \n- At second 3, task 3 is added and processed using server 4 until second 7.\n- At second 4, server 1 becomes free. Task 4 is added and processed using server 1 until second 9. \n- At second 5, task 5 is added and processed using server 3 until second 7.\n- At second 6, task 6 is added and processed using server 2 until second 7.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nservers.length == n\n\n\ntasks.length == m\n\n\n1 <= n, m <= 2 * 10\n5\n\n\n1 <= servers[i], tasks[j] <= 2 * 10\n5",
      "solution": "\nimport heapq\n\nclass Solution(object):\n    def assignTasks(self, servers, tasks):\n        \"\"\"\n        :type servers: List[int]\n        :type tasks: List[int]\n        :rtype: List[int]\n        \"\"\"\n        idle = [(servers[i], i) for i in xrange(len(servers))]\n        working = []\n        heapq.heapify(idle)\n        result = []\n        t = 0\n        for i in xrange(len(tasks)):\n            t = max(t, i) if idle else working[0][0]\n            while working and working[0][0] <= t:\n                _, w, idx = heapq.heappop(working)\n                heapq.heappush(idle, (w, idx))\n            w, idx = heapq.heappop(idle)\n            heapq.heappush(working, (t+tasks[i], w, idx))\n            result.append(idx)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n + mlogn)",
      "space_complexity": "O(n)"
    }
  ],
  "Two Heaps": [
    {
      "title": "Find Median from Data Stream",
      "difficulty": "Hard",
      "category": "Two Heaps",
      "link": "https://leetcode.com/problems/find-median-from-data-stream",
      "slug": "find-median-from-data-stream",
      "description": "The \nmedian\n is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\n\n\n\nFor example, for \narr = [2,3,4]\n, the median is \n3\n.\n\n\nFor example, for \narr = [2,3]\n, the median is \n(2 + 3) / 2 = 2.5\n.\n\n\n\n\nImplement the MedianFinder class:\n\n\n\n\nMedianFinder()\n initializes the \nMedianFinder\n object.\n\n\nvoid addNum(int num)\n adds the integer \nnum\n from the data stream to the data structure.\n\n\ndouble findMedian()\n returns the median of all elements so far. Answers within \n10\n-5\n of the actual answer will be accepted.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\n\nOutput\n\n[null, null, null, 1.5, null, 2.0]\n\n\nExplanation\n\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-10\n5\n <= num <= 10\n5\n\n\nThere will be at least one element in the data structure before calling \nfindMedian\n.\n\n\nAt most \n5 * 10\n4\n calls will be made to \naddNum\n and \nfindMedian\n.\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nIf all integer numbers from the stream are in the range \n[0, 100]\n, how would you optimize your solution?\n\n\nIf \n99%\n of all integer numbers from the stream are in the range \n[0, 100]\n, how would you optimize your solution?",
      "solution": "\nfrom heapq import heappush, heappop\nclass MedianFinder(object):\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__max_heap = []\n        self.__min_heap = []\n\n    def addNum(self, num):\n        \"\"\"\n        Adds a num into the data structure.\n        :type num: int\n        :rtype: void\n        \"\"\"\n        # Balance smaller half and larger half.\n        if not self.__max_heap or num > -self.__max_heap[0]:\n            heappush(self.__min_heap, num)\n            if len(self.__min_heap) > len(self.__max_heap) + 1:\n                heappush(self.__max_heap, -heappop(self.__min_heap))\n        else:\n            heappush(self.__max_heap, -num)\n            if len(self.__max_heap) > len(self.__min_heap):\n                heappush(self.__min_heap, -heappop(self.__max_heap))\n\n    def findMedian(self):\n        \"\"\"\n        Returns the median of current data stream\n        :rtype: float\n        \"\"\"\n        return (-self.__max_heap[0] + self.__min_heap[0]) / 2.0 \\\n               if len(self.__min_heap) == len(self.__max_heap) \\\n               else self.__min_heap[0]",
      "explanation": "N/A",
      "time_complexity": "O(nlogn) for total n addNums, O(logn) per addNum, O(1) per findMedian.",
      "space_complexity": "O(n), total space"
    },
    {
      "title": "IPO",
      "difficulty": "Hard",
      "category": "Two Heaps",
      "link": "https://leetcode.com/problems/ipo",
      "slug": "ipo",
      "description": "Suppose LeetCode will start its \nIPO\n soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the \nIPO\n. Since it has limited resources, it can only finish at most \nk\n distinct projects before the \nIPO\n. Help LeetCode design the best way to maximize its total capital after finishing at most \nk\n distinct projects.\n\n\nYou are given \nn\n projects where the \ni\nth\n project has a pure profit \nprofits[i]\n and a minimum capital of \ncapital[i]\n is needed to start it.\n\n\nInitially, you have \nw\n capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n\n\nPick a list of \nat most\n \nk\n distinct projects from given projects to \nmaximize your final capital\n, and return \nthe final maximized capital\n.\n\n\nThe answer is guaranteed to fit in a 32-bit signed integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\n\nOutput:\n 4\n\nExplanation:\n Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\n\nOutput:\n 6\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= 10\n5\n\n\n0 <= w <= 10\n9\n\n\nn == profits.length\n\n\nn == capital.length\n\n\n1 <= n <= 10\n5\n\n\n0 <= profits[i] <= 10\n4\n\n\n0 <= capital[i] <= 10\n9",
      "solution": "\nimport heapq\n\nclass Solution(object):\n    def findMaximizedCapital(self, k, W, Profits, Capital):\n        \"\"\"\n        :type k: int\n        :type W: int\n        :type Profits: List[int]\n        :type Capital: List[int]\n        :rtype: int\n        \"\"\"\n        curr = []\n        future = sorted(zip(Capital, Profits), reverse=True)\n        for _ in xrange(k):\n            while future and future[-1][0] <= W:\n                heapq.heappush(curr, -future.pop()[1])\n            if curr:\n                W -= heapq.heappop(curr)\n        return W",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Sliding Window Median",
      "difficulty": "Hard",
      "category": "Two Heaps",
      "link": "https://leetcode.com/problems/sliding-window-median",
      "slug": "sliding-window-median",
      "description": "The \nmedian\n is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\n\n\n\nFor examples, if \narr = [2,\n3\n,4]\n, the median is \n3\n.\n\n\nFor examples, if \narr = [1,\n2,3\n,4]\n, the median is \n(2 + 3) / 2 = 2.5\n.\n\n\n\n\nYou are given an integer array \nnums\n and an integer \nk\n. There is a sliding window of size \nk\n which is moving from the very left of the array to the very right. You can only see the \nk\n numbers in the window. Each time the sliding window moves right by one position.\n\n\nReturn \nthe median array for each window in the original array\n. Answers within \n10\n-5\n of the actual value will be accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,-1,-3,5,3,6,7], k = 3\n\nOutput:\n [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\n\nExplanation:\n \nWindow position                Median\n---------------                -----\n[\n1  3  -1\n] -3  5  3  6  7        1\n 1 [\n3  -1  -3\n] 5  3  6  7       -1\n 1  3 [\n-1  -3  5\n] 3  6  7       -1\n 1  3  -1 [\n-3  5  3\n] 6  7        3\n 1  3  -1  -3 [\n5  3  6\n] 7        5\n 1  3  -1  -3  5 [\n3  6  7\n]       6\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,3,4,2,3,1,4,2], k = 3\n\nOutput:\n [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= nums.length <= 10\n5\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1",
      "solution": "\nfrom sortedcontainers import SortedList\n\nclass Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        sl = SortedList(float(nums[i])for i in xrange(k))\n        result = [(sl[k//2]+sl[k//2-(1-k%2)])/2]\n        for i in xrange(k, len(nums)):\n            sl.add(float(nums[i]))\n            sl.remove(nums[i-k])\n            result.append((sl[k//2]+sl[k//2-(1-k%2)])/2)\n        return result\n\n\nimport collections\nimport heapq\n\nclass Solution2(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        def lazy_delete(heap, to_remove, sign):\n            while heap and sign*heap[0] in to_remove:\n                to_remove[sign*heap[0]] -= 1\n                if not to_remove[sign*heap[0]]:\n                    del to_remove[sign*heap[0]]\n                heapq.heappop(heap)\n\n        def full_delete(heap, to_remove, sign):  # Time: O(k), Space: O(k)\n            result = []\n            for x in heap:\n                if sign*x not in to_remove:\n                    result.append(x)\n                    continue\n                to_remove[sign*x] -= 1\n                if not to_remove[sign*x]:\n                    del to_remove[sign*x]\n            heap[:] = result\n            heapq.heapify(heap)\n\n        min_heap, max_heap = [], []\n        for i in xrange(k):\n            if i%2 == 0:\n                heapq.heappush(min_heap, -heapq.heappushpop(max_heap, -nums[i]))\n            else:\n                heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))\n        result = [float(min_heap[0])] if k%2 else [(min_heap[0]-max_heap[0])/2.0]\n        to_remove = collections.defaultdict(int)\n        for i in xrange(k, len(nums)):\n            heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))\n            if nums[i-k] > -max_heap[0]:\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n            to_remove[nums[i-k]] += 1\n            lazy_delete(max_heap, to_remove, -1)\n            lazy_delete(min_heap, to_remove, 1)\n            if len(min_heap)+len(max_heap) > 2*k:\n                full_delete(max_heap, to_remove, -1)\n                full_delete(min_heap, to_remove, 1)\n            result.append(float(min_heap[0]) if k%2 else (min_heap[0]-max_heap[0])/2.0)\n        return result\n\n\nimport collections\nimport heapq\n\nclass Solution3(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        def lazy_delete(heap, to_remove, sign):\n            while heap and sign*heap[0] in to_remove:\n                to_remove[sign*heap[0]] -= 1\n                if not to_remove[sign*heap[0]]:\n                    del to_remove[sign*heap[0]]\n                heapq.heappop(heap)\n\n        min_heap, max_heap = [], []\n        for i in xrange(k):\n            if i%2 == 0:\n                heapq.heappush(min_heap, -heapq.heappushpop(max_heap, -nums[i]))\n            else:\n                heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))\n        result = [float(min_heap[0])] if k%2 else [(min_heap[0]-max_heap[0])/2.0]\n        to_remove = collections.defaultdict(int)\n        for i in xrange(k, len(nums)):\n            heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))\n            if nums[i-k] > -max_heap[0]:\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n            to_remove[nums[i-k]] += 1\n            lazy_delete(max_heap, to_remove, -1)\n            lazy_delete(min_heap, to_remove, 1)\n            result.append(float(min_heap[0]) if k%2 else (min_heap[0]-max_heap[0])/2.0)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn) due to lazy delete",
      "space_complexity": "O(n)"
    }
  ],
  "Top K Elements": [
    {
      "title": "Kth Largest Element in a Stream",
      "difficulty": "Easy",
      "category": "Top K Elements",
      "link": "https://leetcode.com/problems/kth-largest-element-in-a-stream",
      "slug": "kth-largest-element-in-a-stream",
      "description": "You are part of a university admissions office and need to keep track of the \nkth\n highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores.\n\n\nYou are tasked to implement a class which, for a given integer \nk\n, maintains a stream of test scores and continuously returns the \nk\nth highest test score \nafter\n a new score has been submitted. More specifically, we are looking for the \nk\nth highest score in the sorted list of all scores.\n\n\nImplement the \nKthLargest\n class:\n\n\n\n\nKthLargest(int k, int[] nums)\n Initializes the object with the integer \nk\n and the stream of test scores \nnums\n.\n\n\nint add(int val)\n Adds a new test score \nval\n to the stream and returns the element representing the \nk\nth\n largest element in the pool of test scores so far.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n\n\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n\n\nOutput:\n \n[null, 4, 5, 5, 8, 8]\n\n\nExplanation:\n\n\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\n\nkthLargest.add(3); // return 4\n\nkthLargest.add(5); // return 5\n\nkthLargest.add(10); // return 5\n\nkthLargest.add(9); // return 8\n\nkthLargest.add(4); // return 8\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n\n\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"]\n\n[[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]\n\n\nOutput:\n \n[null, 7, 7, 7, 8]\n\n\nExplanation:\n\nKthLargest kthLargest = new KthLargest(4, [7, 7, 7, 7, 8, 3]);\n\nkthLargest.add(2); // return 7\n\nkthLargest.add(10); // return 7\n\nkthLargest.add(9); // return 7\n\nkthLargest.add(9); // return 8\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= nums.length <= 10\n4\n\n\n1 <= k <= nums.length + 1\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n-10\n4\n <= val <= 10\n4\n\n\nAt most \n10\n4\n calls will be made to \nadd\n.",
      "solution": "\nimport heapq\n\nclass KthLargest(object):\n\n    def __init__(self, k, nums):\n        \"\"\"\n        :type k: int\n        :type nums: List[int]\n        \"\"\"\n        self.__k = k\n        self.__min_heap = []\n        for n in nums:\n            self.add(n)\n        \n\n    def add(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: int\n        \"\"\"\n        heapq.heappush(self.__min_heap, val)\n        if len(self.__min_heap) > self.__k:\n            heapq.heappop(self.__min_heap)\n        return self.__min_heap[0]",
      "explanation": "N/A",
      "time_complexity": "O(nlogk)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Top K Frequent Elements",
      "difficulty": "Medium",
      "category": "Top K Elements",
      "link": "https://leetcode.com/problems/top-k-frequent-elements",
      "slug": "top-k-frequent-elements",
      "description": "Given an integer array \nnums\n and an integer \nk\n, return \nthe\n \nk\n \nmost frequent elements\n. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,1,1,2,2,3], k = 2\n\nOutput:\n [1,2]\n\nExample 2:\n\n\nInput:\n nums = [1], k = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nk\n is in the range \n[1, the number of unique elements in the array]\n.\n\n\nIt is \nguaranteed\n that the answer is \nunique\n.\n\n\n\n\n \n\n\nFollow up:\n Your algorithm's time complexity must be better than \nO(n log n)\n, where n is the array's size.",
      "solution": "class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        # count = Counter(nums)\n\n        # min_heap = []\n\n        # for num, freq in count.items():\n        #     heapq.heappush(min_heap, (freq, num))\n        #     if len(min_heap) > k:\n        #         heapq.heappop(min_heap)\n\n        # return [num for freq, num in min_heap]\n\n        count = Counter(nums)\n        freq = defaultdict(list) # bucket sort\n        for val, freq1 in count.items():\n            freq[freq1].append(val)\n        res = []\n        for idx in range(len(nums), 0, -1):\n            for n in freq[idx]:\n                res.append(n)\n                if len(res) >= k:\n                    return res",
      "explanation": "N/A",
      "time_complexity": "O(nlogk)",
      "space_complexity": "O(n)"
    },
    {
      "title": "K Closest Points to Origin",
      "difficulty": "Medium",
      "category": "Top K Elements",
      "link": "https://leetcode.com/problems/k-closest-points-to-origin",
      "slug": "k-closest-points-to-origin",
      "description": "Given an array of \npoints\n where \npoints[i] = [x\ni\n, y\ni\n]\n represents a point on the \nX-Y\n plane and an integer \nk\n, return the \nk\n closest points to the origin \n(0, 0)\n.\n\n\nThe distance between two points on the \nX-Y\n plane is the Euclidean distance (i.e., \n√(x\n1\n - x\n2\n)\n2\n + (y\n1\n - y\n2\n)\n2\n).\n\n\nYou may return the answer in \nany order\n. The answer is \nguaranteed\n to be \nunique\n (except for the order that it is in).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[1,3],[-2,2]], k = 1\n\nOutput:\n [[-2,2]]\n\nExplanation:\n\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[3,3],[5,-1],[-2,4]], k = 2\n\nOutput:\n [[3,3],[-2,4]]\n\nExplanation:\n The answer [[-2,4],[3,3]] would also be accepted.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= points.length <= 10\n4\n\n\n-10\n4\n <= x\ni\n, y\ni\n <= 10\n4",
      "solution": "\n# quick select solution\nfrom random import randint\n\nclass Solution(object):\n    def kClosest(self, points, K):\n        \"\"\"\n        :type points: List[List[int]]\n        :type K: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def dist(point):\n            return point[0]**2 + point[1]**2\n        \n        def kthElement(nums, k, compare):\n            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):\n                new_pivot_idx = left\n                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                for i in xrange(left, right):\n                    if compare(nums[i], nums[right]):\n                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                        new_pivot_idx += 1\n\n                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                return new_pivot_idx\n\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)\n                if new_pivot_idx == k:\n                    return\n                elif new_pivot_idx > k:\n                    right = new_pivot_idx - 1\n                else:  # new_pivot_idx < k.\n                    left = new_pivot_idx + 1\n                    \n        kthElement(points, K-1, lambda a, b: dist(a) < dist(b))\n        return points[:K]\n\n    \nimport heapq\n\nclass Solution2(object):\n    def kClosest(self, points, K):\n        \"\"\"\n        :type points: List[List[int]]\n        :type K: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def dist(point):\n            return point[0]**2 + point[1]**2\n        \n        max_heap = []\n        for point in points:\n            heapq.heappush(max_heap, (-dist(point), point))\n            if len(max_heap) > K:\n                heapq.heappop(max_heap)\n        return [heapq.heappop(max_heap)[1] for _ in xrange(len(max_heap))]",
      "explanation": "N/A",
      "time_complexity": "O(nlogk)",
      "space_complexity": "O(k)"
    }
  ],
  "Intervals": [
    {
      "title": "Merge Intervals",
      "difficulty": "Medium",
      "category": "Intervals",
      "link": "https://leetcode.com/problems/merge-intervals",
      "slug": "merge-intervals",
      "description": "Given an array of \nintervals\n where \nintervals[i] = [start\ni\n, end\ni\n]\n, merge all overlapping intervals, and return \nan array of the non-overlapping intervals that cover all the intervals in the input\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n intervals = [[1,3],[2,6],[8,10],[15,18]]\n\nOutput:\n [[1,6],[8,10],[15,18]]\n\nExplanation:\n Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\n\n\nExample 2:\n\n\n\n\nInput:\n intervals = [[1,4],[4,5]]\n\nOutput:\n [[1,5]]\n\nExplanation:\n Intervals [1,4] and [4,5] are considered overlapping.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= intervals.length <= 10\n4\n\n\nintervals[i].length == 2\n\n\n0 <= start\ni\n <= end\ni\n <= 10\n4",
      "solution": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort()\n        previous = 0\n        for idx in range(1, len(intervals)):\n            if intervals[previous][1] >= intervals[idx][0]:\n                intervals[previous] = [intervals[previous][0], max(intervals[previous][1], intervals[idx][1])]\n            else:\n                previous += 1\n                intervals[previous] = intervals[idx]\n        return intervals[:previous+1]",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Insert Interval",
      "difficulty": "Medium",
      "category": "Intervals",
      "link": "https://leetcode.com/problems/insert-interval",
      "slug": "insert-interval",
      "description": "You are given an array of non-overlapping intervals \nintervals\n where \nintervals[i] = [start\ni\n, end\ni\n]\n represent the start and the end of the \ni\nth\n interval and \nintervals\n is sorted in ascending order by \nstart\ni\n. You are also given an interval \nnewInterval = [start, end]\n that represents the start and end of another interval.\n\n\nInsert \nnewInterval\n into \nintervals\n such that \nintervals\n is still sorted in ascending order by \nstart\ni\n and \nintervals\n still does not have any overlapping intervals (merge overlapping intervals if necessary).\n\n\nReturn \nintervals\n after the insertion\n.\n\n\nNote\n that you don't need to modify \nintervals\n in-place. You can make a new array and return it.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n intervals = [[1,3],[6,9]], newInterval = [2,5]\n\nOutput:\n [[1,5],[6,9]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n\nOutput:\n [[1,2],[3,10],[12,16]]\n\nExplanation:\n Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= intervals.length <= 10\n4\n\n\nintervals[i].length == 2\n\n\n0 <= start\ni\n <= end\ni\n <= 10\n5\n\n\nintervals\n is sorted by \nstart\ni\n in \nascending\n order.\n\n\nnewInterval.length == 2\n\n\n0 <= start <= end <= 10\n5",
      "solution": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        res = []\n\n        for interval in intervals:\n            # case 1 befoe\n            if interval[1] < newInterval[0]:\n                res.append(interval)\n            # case 2 after \n            elif interval[0] > newInterval[1]:\n                res.append(newInterval)\n                newInterval = interval \n            # case 3 overlap\n            else:\n                newInterval[0] = min(newInterval[0], interval[0])\n                newInterval[1] = max(newInterval[1], interval[1])    \n        \n        res.append(newInterval)\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Minimum Number of Arrows to Burst Balloons",
      "difficulty": "Medium",
      "category": "Intervals",
      "link": "https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons",
      "slug": "minimum-number-of-arrows-to-burst-balloons",
      "description": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array \npoints\n where \npoints[i] = [x\nstart\n, x\nend\n]\n denotes a balloon whose \nhorizontal diameter\n stretches between \nx\nstart\n and \nx\nend\n. You do not know the exact y-coordinates of the balloons.\n\n\nArrows can be shot up \ndirectly vertically\n (in the positive y-direction) from different points along the x-axis. A balloon with \nx\nstart\n and \nx\nend\n is \nburst\n by an arrow shot at \nx\n if \nx\nstart\n <= x <= x\nend\n. There is \nno limit\n to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\n\n\nGiven the array \npoints\n, return \nthe \nminimum\n number of arrows that must be shot to burst all balloons\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n points = [[10,16],[2,8],[1,6],[7,12]]\n\nOutput:\n 2\n\nExplanation:\n The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].\n- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].\n\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[1,2],[3,4],[5,6],[7,8]]\n\nOutput:\n 4\n\nExplanation:\n One arrow needs to be shot for each balloon for a total of 4 arrows.\n\n\n\nExample 3:\n\n\n\n\nInput:\n points = [[1,2],[2,3],[3,4],[4,5]]\n\nOutput:\n 2\n\nExplanation:\n The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].\n- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= points.length <= 10\n5\n\n\npoints[i].length == 2\n\n\n-2\n31\n <= x\nstart\n < x\nend\n <= 2\n31\n - 1",
      "solution": "class Solution(object):\n    def findMinArrowShots(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not points:\n            return 0\n\n        points.sort()\n\n        result = 0\n        i = 0\n        while i < len(points):\n            j = i + 1\n            right_bound = points[i][1]\n            while j < len(points) and points[j][0] <= right_bound:\n                right_bound = min(right_bound, points[j][1])\n                j += 1\n            result += 1\n            i = j\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Maximum Number of Events That Can Be Attended",
      "difficulty": "Medium",
      "category": "Intervals",
      "link": "https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended",
      "slug": "maximum-number-of-events-that-can-be-attended",
      "description": "You are given an array of \nevents\n where \nevents[i] = [startDay\ni\n, endDay\ni\n]\n. Every event \ni\n starts at \nstartDay\ni\n \nand ends at \nendDay\ni\n.\n\n\nYou can attend an event \ni\n at any day \nd\n where \nstartDay\ni\n <= d <= endDay\ni\n. You can only attend one event at any time \nd\n.\n\n\nReturn \nthe maximum number of events you can attend\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n events = [[1,2],[2,3],[3,4]]\n\nOutput:\n 3\n\nExplanation:\n You can attend all the three events.\nOne way to attend them all is as shown.\nAttend the first event on day 1.\nAttend the second event on day 2.\nAttend the third event on day 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n events= [[1,2],[2,3],[3,4],[1,2]]\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= events.length <= 10\n5\n\n\nevents[i].length == 2\n\n\n1 <= startDay\ni\n <= endDay\ni\n <= 10\n5",
      "solution": "\nimport heapq\n\nclass Solution(object):\n    def maxEvents(self, events):\n        \"\"\"\n        :type events: List[List[int]]\n        :rtype: int\n        \"\"\"\n        events.sort(reverse=True)\n        min_heap = []\n        result = 0\n        for d in xrange(1, max(events, key=lambda x:x[1])[1]+1):\n            while events and events[-1][0] == d:\n                heapq.heappush(min_heap, events.pop()[1])\n            while min_heap and min_heap[0] == d-1:\n                heapq.heappop(min_heap)\n            if not min_heap:\n                continue\n            heapq.heappop(min_heap)\n            result += 1       \n        return result",
      "explanation": "N/A",
      "time_complexity": "O(r + nlogn), r is the max end day of events",
      "space_complexity": "O(n)"
    },
    {
      "title": "Non-overlapping Intervals",
      "difficulty": "Medium",
      "category": "Intervals",
      "link": "https://leetcode.com/problems/non-overlapping-intervals",
      "slug": "non-overlapping-intervals",
      "description": "Given an array of intervals \nintervals\n where \nintervals[i] = [start\ni\n, end\ni\n]\n, return \nthe minimum number of intervals you need to remove to make the rest of the intervals non-overlapping\n.\n\n\nNote\n that intervals which only touch at a point are \nnon-overlapping\n. For example, \n[1, 2]\n and \n[2, 3]\n are non-overlapping.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n intervals = [[1,2],[2,3],[3,4],[1,3]]\n\nOutput:\n 1\n\nExplanation:\n [1,3] can be removed and the rest of the intervals are non-overlapping.\n\n\n\nExample 2:\n\n\n\n\nInput:\n intervals = [[1,2],[1,2],[1,2]]\n\nOutput:\n 2\n\nExplanation:\n You need to remove two [1,2] to make the rest of the intervals non-overlapping.\n\n\n\nExample 3:\n\n\n\n\nInput:\n intervals = [[1,2],[2,3]]\n\nOutput:\n 0\n\nExplanation:\n You don't need to remove any of the intervals since they're already non-overlapping.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= intervals.length <= 10\n5\n\n\nintervals[i].length == 2\n\n\n-5 * 10\n4\n <= start\ni\n < end\ni\n <= 5 * 10\n4",
      "solution": "class Solution(object):\n    def eraseOverlapIntervals(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        intervals.sort(key=lambda interval: interval[1])\n        result, right = 0, float(\"-inf\")\n        for l, r in intervals:\n            if l < right:\n                result += 1\n            else:\n                right = r\n        return result\n\nclass Solution2(object):\n    def eraseOverlapIntervals(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        intervals.sort(key=lambda interval: interval[0])\n        result, prev = 0, 0\n        for i in xrange(1, len(intervals)):\n            if intervals[i][0] < intervals[prev][1]:\n                if intervals[i][1] < intervals[prev][1]:\n                    prev = i\n                result += 1\n            else:\n                prev = i\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(1)"
    }
  ],
  "K-Way Merge": [
    {
      "title": "Find K Pairs with Smallest Sums",
      "difficulty": "Medium",
      "category": "K-Way Merge",
      "link": "https://leetcode.com/problems/find-k-pairs-with-smallest-sums",
      "slug": "find-k-pairs-with-smallest-sums",
      "description": "You are given two integer arrays \nnums1\n and \nnums2\n sorted in \nnon-decreasing order\n and an integer \nk\n.\n\n\nDefine a pair \n(u, v)\n which consists of one element from the first array and one element from the second array.\n\n\nReturn \nthe\n \nk\n \npairs\n \n(u\n1\n, v\n1\n), (u\n2\n, v\n2\n), ..., (u\nk\n, v\nk\n)\n \nwith the smallest sums\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n\nOutput:\n [[1,2],[1,4],[1,6]]\n\nExplanation:\n The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1,1,2], nums2 = [1,2,3], k = 2\n\nOutput:\n [[1,1],[1,1]]\n\nExplanation:\n The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length, nums2.length <= 10\n5\n\n\n-10\n9\n <= nums1[i], nums2[i] <= 10\n9\n\n\nnums1\n and \nnums2\n both are sorted in \nnon-decreasing order\n.\n\n\n1 <= k <= 10\n4\n\n\nk <= nums1.length * nums2.length",
      "solution": "\nfrom heapq import heappush, heappop\nclass Solution(object):\n    def kSmallestPairs(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        pairs = []\n        if len(nums1) > len(nums2):\n            tmp = self.kSmallestPairs(nums2, nums1, k)\n            for pair in tmp:\n                pairs.append([pair[1], pair[0]])\n            return pairs\n\n        min_heap = []\n        def push(i, j):\n            if i < len(nums1) and j < len(nums2):\n                heappush(min_heap, [nums1[i] + nums2[j], i, j])\n\n        push(0, 0)\n        while min_heap and len(pairs) < k:\n            _, i, j = heappop(min_heap)\n            pairs.append([nums1[i], nums2[j]])\n            push(i, j + 1)\n            if j == 0:\n                push(i + 1, 0)  # at most queue min(n, m) space\n        return pairs\n\n\n# time: O(mn * log k)\n# space: O(k)\nfrom heapq import nsmallest\nfrom itertools import product\n\nclass Solution2(object):\n    def kSmallestPairs(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        return nsmallest(k, product(nums1, nums2), key=sum)",
      "explanation": "N/A",
      "time_complexity": "O(k * log(min(n, m, k))), where n is the size of num1, and m is the size of num2.",
      "space_complexity": "O(min(n, m, k))"
    },
    {
      "title": "Kth Smallest Element in a Sorted Matrix",
      "difficulty": "Medium",
      "category": "K-Way Merge",
      "link": "https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix",
      "slug": "kth-smallest-element-in-a-sorted-matrix",
      "description": "Given an \nn x n\n \nmatrix\n where each of the rows and columns is sorted in ascending order, return \nthe\n \nk\nth\n \nsmallest element in the matrix\n.\n\n\nNote that it is the \nk\nth\n smallest element \nin the sorted order\n, not the \nk\nth\n \ndistinct\n element.\n\n\nYou must find a solution with a memory complexity better than \nO(n\n2\n)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n\nOutput:\n 13\n\nExplanation:\n The elements in the matrix are [1,5,9,10,11,12,13,\n13\n,15], and the 8\nth\n smallest number is 13\n\n\n\nExample 2:\n\n\n\n\nInput:\n matrix = [[-5]], k = 1\n\nOutput:\n -5\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 300\n\n\n-10\n9\n <= matrix[i][j] <= 10\n9\n\n\nAll the rows and columns of \nmatrix\n are \nguaranteed\n to be sorted in \nnon-decreasing order\n.\n\n\n1 <= k <= n\n2\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nCould you solve the problem with a constant memory (i.e., \nO(1)\n memory complexity)?\n\n\nCould you solve the problem in \nO(n)\n time complexity? The solution may be too advanced for an interview but you may find reading \nthis paper\n fun.",
      "solution": "\nfrom heapq import heappush, heappop\nclass Solution(object):\n    def kthSmallest(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        kth_smallest = 0\n        min_heap = []\n\n        def push(i, j):\n            if len(matrix) > len(matrix[0]):\n                if i < len(matrix[0]) and j < len(matrix):\n                    heappush(min_heap, [matrix[j][i], i, j])\n            else:\n                if i < len(matrix) and j < len(matrix[0]):\n                    heappush(min_heap, [matrix[i][j], i, j])\n\n        push(0, 0)\n        while min_heap and k > 0:\n            kth_smallest, i, j = heappop(min_heap)\n            push(i, j + 1)\n            if j == 0:\n                push(i + 1, 0)\n            k -= 1\n\n        return kth_smallest",
      "explanation": "N/A",
      "time_complexity": "O(k * log(min(n, m, k))), with n x m matrix",
      "space_complexity": "O(min(n, m, k))"
    },
    {
      "title": "Merge k Sorted Lists",
      "difficulty": "Hard",
      "category": "K-Way Merge",
      "link": "https://leetcode.com/problems/merge-k-sorted-lists",
      "slug": "merge-k-sorted-lists",
      "description": "You are given an array of \nk\n linked-lists \nlists\n, each linked-list is sorted in ascending order.\n\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n lists = [[1,4,5],[1,3,4],[2,6]]\n\nOutput:\n [1,1,2,3,4,4,5,6]\n\nExplanation:\n The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted linked list:\n1->1->2->3->4->4->5->6\n\n\n\nExample 2:\n\n\n\n\nInput:\n lists = []\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n lists = [[]]\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nk == lists.length\n\n\n0 <= k <= 10\n4\n\n\n0 <= lists[i].length <= 500\n\n\n-10\n4\n <= lists[i][j] <= 10\n4\n\n\nlists[i]\n is sorted in \nascending order\n.\n\n\nThe sum of \nlists[i].length\n will not exceed \n10\n4\n.",
      "solution": "# Definition for singly-linked list node\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        # If the list of linked lists is empty, return None\n        if not lists:\n            return None\n        \n        min_heap = []\n        \n        # Step 1: Initialize the heap with the head node of each non-empty list\n        for idx, node in enumerate(lists):\n            if node:\n                # We push a tuple of (node value, list index, node) to handle duplicate values properly\n                heapq.heappush(min_heap, (node.val, idx, node))\n        \n        # Step 2: Create a dummy node to act as the starting point of the merged list\n        dummy = ListNode()\n        current = dummy  # Pointer to build the merged list\n        \n        # Step 3: Pop the smallest node from the heap and push its next node (if any)\n        while min_heap:\n            # Pop the node with the smallest value\n            _, idx, node = heapq.heappop(min_heap)\n\n            # Append the node to the merged list\n            current.next = node\n            current = current.next  # Move the pointer forward\n\n            # If there's a next node in the same list, push it into the heap\n            if node.next:\n                heapq.heappush(min_heap, (node.next.val, idx, node.next))\n        \n        # Return the merged list, skipping the dummy head\n        return dummy.next",
      "explanation": "N/A",
      "time_complexity": "O(nlogk)",
      "space_complexity": "O(k)"
    },
    {
      "title": "Smallest Range Covering Elements from K Lists",
      "difficulty": "Hard",
      "category": "K-Way Merge",
      "link": "https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists",
      "slug": "smallest-range-covering-elements-from-k-lists",
      "description": "You have \nk\n lists of sorted integers in \nnon-decreasing order\n. Find the \nsmallest\n range that includes at least one number from each of the \nk\n lists.\n\n\nWe define the range \n[a, b]\n is smaller than range \n[c, d]\n if \nb - a < d - c\n \nor\n \na < c\n if \nb - a == d - c\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\n\nOutput:\n [20,24]\n\nExplanation: \n\nList 1: [4, 10, 15, 24,26], 24 is in range [20,24].\nList 2: [0, 9, 12, 20], 20 is in range [20,24].\nList 3: [5, 18, 22, 30], 22 is in range [20,24].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [[1,2,3],[1,2,3],[1,2,3]]\n\nOutput:\n [1,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums.length == k\n\n\n1 <= k <= 3500\n\n\n1 <= nums[i].length <= 50\n\n\n-10\n5\n <= nums[i][j] <= 10\n5\n\n\nnums[i]\n is sorted in \nnon-decreasing\n order.",
      "solution": "# Solution not found in kamyu104 repository",
      "explanation": "N/A",
      "time_complexity": "N/A",
      "space_complexity": "N/A"
    }
  ],
  "Data Structure Design": [
    {
      "title": "Design Browser History",
      "difficulty": "Medium",
      "category": "Data Structure Design",
      "link": "https://leetcode.com/problems/design-browser-history",
      "slug": "design-browser-history",
      "description": "You have a \nbrowser\n of one tab where you start on the \nhomepage\n and you can visit another \nurl\n, get back in the history number of \nsteps\n or move forward in the history number of \nsteps\n.\n\n\nImplement the \nBrowserHistory\n class:\n\n\n\n\nBrowserHistory(string homepage)\n Initializes the object with the \nhomepage\n of the browser.\n\n\nvoid visit(string url)\n Visits \nurl\n from the current page. It clears up all the forward history.\n\n\nstring back(int steps)\n Move \nsteps\n back in history. If you can only return \nx\n steps in the history and \nsteps > x\n, you will return only \nx\n steps. Return the current \nurl\n after moving back in history \nat most\n \nsteps\n.\n\n\nstring forward(int steps)\n Move \nsteps\n forward in history. If you can only forward \nx\n steps in the history and \nsteps > x\n, you will forward only \nx\n steps. Return the current \nurl\n after forwarding in history \nat most\n \nsteps\n.\n\n\n\n\n \n\n\nExample:\n\n\n\n\nInput:\n\n[\"BrowserHistory\",\"visit\",\"visit\",\"visit\",\"back\",\"back\",\"forward\",\"visit\",\"forward\",\"back\",\"back\"]\n[[\"leetcode.com\"],[\"google.com\"],[\"facebook.com\"],[\"youtube.com\"],[1],[1],[1],[\"linkedin.com\"],[2],[2],[7]]\n\nOutput:\n\n[null,null,null,null,\"facebook.com\",\"google.com\",\"facebook.com\",null,\"linkedin.com\",\"google.com\",\"leetcode.com\"]\n\n\nExplanation:\n\nBrowserHistory browserHistory = new BrowserHistory(\"leetcode.com\");\nbrowserHistory.visit(\"google.com\");       // You are in \"leetcode.com\". Visit \"google.com\"\nbrowserHistory.visit(\"facebook.com\");     // You are in \"google.com\". Visit \"facebook.com\"\nbrowserHistory.visit(\"youtube.com\");      // You are in \"facebook.com\". Visit \"youtube.com\"\nbrowserHistory.back(1);                   // You are in \"youtube.com\", move back to \"facebook.com\" return \"facebook.com\"\nbrowserHistory.back(1);                   // You are in \"facebook.com\", move back to \"google.com\" return \"google.com\"\nbrowserHistory.forward(1);                // You are in \"google.com\", move forward to \"facebook.com\" return \"facebook.com\"\nbrowserHistory.visit(\"linkedin.com\");     // You are in \"facebook.com\". Visit \"linkedin.com\"\nbrowserHistory.forward(2);                // You are in \"linkedin.com\", you cannot move forward any steps.\nbrowserHistory.back(2);                   // You are in \"linkedin.com\", move back two steps to \"facebook.com\" then to \"google.com\". return \"google.com\"\nbrowserHistory.back(7);                   // You are in \"google.com\", you can move back only one step to \"leetcode.com\". return \"leetcode.com\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= homepage.length <= 20\n\n\n1 <= url.length <= 20\n\n\n1 <= steps <= 100\n\n\nhomepage\n and \nurl\n consist of  '.' or lower case English letters.\n\n\nAt most \n5000\n calls will be made to \nvisit\n, \nback\n, and \nforward\n.",
      "solution": "#        visit : O(n)\n#        back  : O(1)\n#        foward: O(1)\nclass BrowserHistory(object):\n\n    def __init__(self, homepage):\n        \"\"\"\n        :type homepage: str\n        \"\"\"\n        self.__history = [homepage]\n        self.__curr = 0        \n\n    def visit(self, url):\n        \"\"\"\n        :type url: str\n        :rtype: None\n        \"\"\"\n        while len(self.__history) > self.__curr+1:\n            self.__history.pop()\n        self.__history.append(url)\n        self.__curr += 1\n\n    def back(self, steps):\n        \"\"\"\n        :type steps: int\n        :rtype: str\n        \"\"\"\n        self.__curr = max(self.__curr-steps, 0)\n        return self.__history[self.__curr]\n\n    def forward(self, steps):\n        \"\"\"\n        :type steps: int\n        :rtype: str\n        \"\"\"\n        self.__curr = min(self.__curr+steps, len(self.__history)-1)\n        return self.__history[self.__curr]",
      "explanation": "N/A",
      "time_complexity": "ctor  : O(1)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Time Based Key-Value Store",
      "difficulty": "Medium",
      "category": "Data Structure Design",
      "link": "https://leetcode.com/problems/time-based-key-value-store",
      "slug": "time-based-key-value-store",
      "description": "Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\n\n\nImplement the \nTimeMap\n class:\n\n\n\n\nTimeMap()\n Initializes the object of the data structure.\n\n\nvoid set(String key, String value, int timestamp)\n Stores the key \nkey\n with the value \nvalue\n at the given time \ntimestamp\n.\n\n\nString get(String key, int timestamp)\n Returns a value such that \nset\n was called previously, with \ntimestamp_prev <= timestamp\n. If there are multiple such values, it returns the value associated with the largest \ntimestamp_prev\n. If there are no values, it returns \n\"\"\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"]\n[[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]\n\nOutput\n\n[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]\n\n\nExplanation\n\nTimeMap timeMap = new TimeMap();\ntimeMap.set(\"foo\", \"bar\", 1);  // store the key \"foo\" and value \"bar\" along with timestamp = 1.\ntimeMap.get(\"foo\", 1);         // return \"bar\"\ntimeMap.get(\"foo\", 3);         // return \"bar\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \"bar\".\ntimeMap.set(\"foo\", \"bar2\", 4); // store the key \"foo\" and value \"bar2\" along with timestamp = 4.\ntimeMap.get(\"foo\", 4);         // return \"bar2\"\ntimeMap.get(\"foo\", 5);         // return \"bar2\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= key.length, value.length <= 100\n\n\nkey\n and \nvalue\n consist of lowercase English letters and digits.\n\n\n1 <= timestamp <= 10\n7\n\n\nAll the timestamps \ntimestamp\n of \nset\n are strictly increasing.\n\n\nAt most \n2 * 10\n5\n calls will be made to \nset\n and \nget\n.",
      "solution": "from collections import defaultdict\nfrom bisect import bisect_right\n\nclass TimeMap:\n\n    def __init__(self):\n        # For each key: store two parallel lists [timestamps], [values]\n        self.timestamps = defaultdict(list)\n        self.values = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        # Just append since timestamps are always non-decreasing\n        self.timestamps[key].append(timestamp)\n        self.values[key].append(value)\n\n    def get(self, key: str, timestamp: int) -> str:\n        if key not in self.timestamps:\n            return \"\"\n        \n        ts = self.timestamps[key]   # list of timestamps for this key\n        idx = bisect_right(ts, timestamp)  # O(log n)\n        \n        if idx == 0:\n            return \"\"  # all timestamps are > given\n        \n        return self.values[key][idx - 1]   # value at latest timestamp <= target",
      "explanation": "N/A",
      "time_complexity": "set: O(1)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Snapshot Array",
      "difficulty": "Medium",
      "category": "Data Structure Design",
      "link": "https://leetcode.com/problems/snapshot-array",
      "slug": "snapshot-array",
      "description": "Implement a SnapshotArray that supports the following interface:\n\n\n\n\nSnapshotArray(int length)\n initializes an array-like data structure with the given length. \nInitially, each element equals 0\n.\n\n\nvoid set(index, val)\n sets the element at the given \nindex\n to be equal to \nval\n.\n\n\nint snap()\n takes a snapshot of the array and returns the \nsnap_id\n: the total number of times we called \nsnap()\n minus \n1\n.\n\n\nint get(index, snap_id)\n returns the value at the given \nindex\n, at the time we took the snapshot with the given \nsnap_id\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n [\"SnapshotArray\",\"set\",\"snap\",\"set\",\"get\"]\n[[3],[0,5],[],[0,6],[0,0]]\n\nOutput:\n [null,null,0,null,5]\n\nExplanation: \n\nSnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3\nsnapshotArr.set(0,5);  // Set array[0] = 5\nsnapshotArr.snap();  // Take a snapshot, return snap_id = 0\nsnapshotArr.set(0,6);\nsnapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= length <= 5 * 10\n4\n\n\n0 <= index < length\n\n\n0 <= val <= 10\n9\n\n\n0 <= snap_id < \n(the total number of times we call \nsnap()\n)\n\n\nAt most \n5 * 10\n4\n calls will be made to \nset\n, \nsnap\n, and \nget\n.",
      "solution": "#        get: O(logn), n is the total number of set\n\nimport collections\nimport bisect\n\nclass SnapshotArray(object):\n\n    def __init__(self, length):\n        \"\"\"\n        :type length: int\n        \"\"\"\n        self.__A = collections.defaultdict(lambda: [[0, 0]])\n        self.__snap_id = 0\n\n\n    def set(self, index, val):\n        \"\"\"\n        :type index: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        if self.__A[index][-1][0] == self.__snap_id:\n            self.__A[index][-1][1] = val\n        else:\n            self.__A[index].append([self.__snap_id, val])\n\n\n    def snap(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        self.__snap_id += 1\n        return self.__snap_id - 1\n\n\n    def get(self, index, snap_id):\n        \"\"\"\n        :type index: int\n        :type snap_id: int\n        :rtype: int\n        \"\"\"\n        i = bisect.bisect_left(self.__A[index], [snap_id+1, float(\"-inf\")]) - 1\n        return self.__A[index][i][1]",
      "explanation": "N/A",
      "time_complexity": "set: O(1)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Design Twitter",
      "difficulty": "Medium",
      "category": "Data Structure Design",
      "link": "https://leetcode.com/problems/design-twitter",
      "slug": "design-twitter",
      "description": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the \n10\n most recent tweets in the user's news feed.\n\n\nImplement the \nTwitter\n class:\n\n\n\n\nTwitter()\n Initializes your twitter object.\n\n\nvoid postTweet(int userId, int tweetId)\n Composes a new tweet with ID \ntweetId\n by the user \nuserId\n. Each call to this function will be made with a unique \ntweetId\n.\n\n\nList<Integer> getNewsFeed(int userId)\n Retrieves the \n10\n most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be \nordered from most recent to least recent\n.\n\n\nvoid follow(int followerId, int followeeId)\n The user with ID \nfollowerId\n started following the user with ID \nfolloweeId\n.\n\n\nvoid unfollow(int followerId, int followeeId)\n The user with ID \nfollowerId\n started unfollowing the user with ID \nfolloweeId\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"]\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\n\nOutput\n\n[null, null, [5], null, null, [6, 5], null, [5]]\n\n\nExplanation\n\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\ntwitter.follow(1, 2);    // User 1 follows user 2.\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= userId, followerId, followeeId <= 500\n\n\n0 <= tweetId <= 10\n4\n\n\nAll the tweets have \nunique\n IDs.\n\n\nAt most \n3 * 10\n4\n calls will be made to \npostTweet\n, \ngetNewsFeed\n, \nfollow\n, and \nunfollow\n.\n\n\nA user cannot follow himself.",
      "solution": "#                      u is the number of the user's following.\n#                  f is the total number of followings.\n\nimport collections\nimport heapq\nimport random\n\nclass Twitter(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__number_of_most_recent_tweets = 10\n        self.__followings = collections.defaultdict(set)\n        self.__messages = collections.defaultdict(list)\n        self.__time = 0\n\n    def postTweet(self, userId, tweetId):\n        \"\"\"\n        Compose a new tweet.\n        :type userId: int\n        :type tweetId: int\n        :rtype: void\n        \"\"\"\n        self.__time += 1\n        self.__messages[userId].append((self.__time, tweetId))\n\n    def getNewsFeed(self, userId):\n        \"\"\"\n        Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\n        :type userId: int\n        :rtype: List[int]\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        candidates = []\n        if self.__messages[userId]:\n            candidates.append((-self.__messages[userId][-1][0], userId, 0))\n        for uid in self.__followings[userId]:\n            if self.__messages[uid]:\n                candidates.append((-self.__messages[uid][-1][0], uid, 0))\n        nth_element(candidates, self.__number_of_most_recent_tweets-1)\n        max_heap = candidates[:self.__number_of_most_recent_tweets]\n        heapq.heapify(max_heap)\n        result = []\n        while max_heap and len(result) < self.__number_of_most_recent_tweets:\n            t, uid, curr = heapq.heappop(max_heap)\n            nxt = curr + 1\n            if nxt != len(self.__messages[uid]):\n                heapq.heappush(max_heap, (-self.__messages[uid][-(nxt+1)][0], uid, nxt))\n            result.append(self.__messages[uid][-(curr+1)][1])\n        return result\n\n    def follow(self, followerId, followeeId):\n        \"\"\"\n        Follower follows a followee. If the operation is invalid, it should be a no-op.\n        :type followerId: int\n        :type followeeId: int\n        :rtype: void\n        \"\"\"\n        if followerId != followeeId:\n            self.__followings[followerId].add(followeeId)\n\n    def unfollow(self, followerId, followeeId):\n        \"\"\"\n        Follower unfollows a followee. If the operation is invalid, it should be a no-op.\n        :type followerId: int\n        :type followeeId: int\n        :rtype: void\n        \"\"\"\n        self.__followings[followerId].discard(followeeId)",
      "explanation": "N/A",
      "time_complexity": "O(u + klogk), k is most recently number of tweets,",
      "space_complexity": "O(t + f), t is the total number of tweets,"
    },
    {
      "title": "LRU Cache",
      "difficulty": "Medium",
      "category": "Data Structure Design",
      "link": "https://leetcode.com/problems/lru-cache",
      "slug": "lru-cache",
      "description": "Design a data structure that follows the constraints of a \nLeast Recently Used (LRU) cache\n.\n\n\nImplement the \nLRUCache\n class:\n\n\n\n\nLRUCache(int capacity)\n Initialize the LRU cache with \npositive\n size \ncapacity\n.\n\n\nint get(int key)\n Return the value of the \nkey\n if the key exists, otherwise return \n-1\n.\n\n\nvoid put(int key, int value)\n Update the value of the \nkey\n if the \nkey\n exists. Otherwise, add the \nkey-value\n pair to the cache. If the number of keys exceeds the \ncapacity\n from this operation, \nevict\n the least recently used key.\n\n\n\n\nThe functions \nget\n and \nput\n must each run in \nO(1)\n average time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n\nOutput\n\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n\nExplanation\n\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= capacity <= 3000\n\n\n0 <= key <= 10\n4\n\n\n0 <= value <= 10\n5\n\n\nAt most \n2 * 10\n5\n calls will be made to \nget\n and \nput\n.",
      "solution": "class Node:\n    def __init__(self, key, val):\n        self.key, self.val = key, val \n        self.prev = self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n\n        self.right, self.left = Node(0, 0), Node(0, 0)\n        self.right.prev, self.left.next = self.left, self.right\n\n    def remove(self, node):\n        nxt, prev = node.next, node.prev\n        nxt.prev = prev\n        prev.next = nxt\n\n    def insert(self, node): \n        nxt, prev = self.right, self.right.prev\n        nxt.prev = prev.next = node\n        node.next, node.prev = nxt, prev\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.remove(self.cache[key])\n            self.insert(self.cache[key])\n            return self.cache[key].val\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.remove(self.cache[key])\n        self.cache[key] = Node(key, value)\n        self.insert(self.cache[key])\n\n        if len(self.cache) > self.capacity:\n            lru = self.left.next\n            self.remove(lru)\n            del self.cache[lru.key]",
      "explanation": "N/A",
      "time_complexity": "O(1), per operation.",
      "space_complexity": "O(k), k is the capacity of cache."
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "difficulty": "Medium",
      "category": "Data Structure Design",
      "link": "https://leetcode.com/problems/insert-delete-getrandom-o1",
      "slug": "insert-delete-getrandom-o1",
      "description": "Implement the \nRandomizedSet\n class:\n\n\n\n\nRandomizedSet()\n Initializes the \nRandomizedSet\n object.\n\n\nbool insert(int val)\n Inserts an item \nval\n into the set if not present. Returns \ntrue\n if the item was not present, \nfalse\n otherwise.\n\n\nbool remove(int val)\n Removes an item \nval\n from the set if present. Returns \ntrue\n if the item was present, \nfalse\n otherwise.\n\n\nint getRandom()\n Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the \nsame probability\n of being returned.\n\n\n\n\nYou must implement the functions of the class such that each function works in \naverage\n \nO(1)\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], [], [1], [2], []]\n\nOutput\n\n[null, true, false, true, 2, true, false, 2]\n\n\nExplanation\n\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= val <= 2\n31\n - 1\n\n\nAt most \n2 * \n10\n5\n calls will be made to \ninsert\n, \nremove\n, and \ngetRandom\n.\n\n\nThere will be \nat least one\n element in the data structure when \ngetRandom\n is called.",
      "solution": "\nfrom random import randint\nclass RandomizedSet(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__set = []\n        self.__used = {}\n\n\n    def insert(self, val):\n        \"\"\"\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        if val in self.__used:\n            return False\n\n        self.__set += val,\n        self.__used[val] = len(self.__set)-1\n\n        return True\n\n\n    def remove(self, val):\n        \"\"\"\n        Removes a value from the set. Returns true if the set contained the specified element.\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        if val not in self.__used:\n            return False\n\n        self.__used[self.__set[-1]] = self.__used[val]\n        self.__set[self.__used[val]], self.__set[-1] = self.__set[-1], self.__set[self.__used[val]]\n\n        self.__used.pop(val)\n        self.__set.pop()\n\n        return True\n\n    def getRandom(self):\n        \"\"\"\n        Get a random element from the set.\n        :rtype: int\n        \"\"\"\n        return self.__set[randint(0, len(self.__set)-1)]",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Design a Food Rating System",
      "difficulty": "Medium",
      "category": "Data Structure Design",
      "link": "https://leetcode.com/problems/design-a-food-rating-system",
      "slug": "design-a-food-rating-system",
      "description": "Design a food rating system that can do the following:\n\n\n\n\nModify\n the rating of a food item listed in the system.\n\n\nReturn the highest-rated food item for a type of cuisine in the system.\n\n\n\n\nImplement the \nFoodRatings\n class:\n\n\n\n\nFoodRatings(String[] foods, String[] cuisines, int[] ratings)\n Initializes the system. The food items are described by \nfoods\n, \ncuisines\n and \nratings\n, all of which have a length of \nn\n.\n\n\t\n\n\nfoods[i]\n is the name of the \ni\nth\n food,\n\n\ncuisines[i]\n is the type of cuisine of the \ni\nth\n food, and\n\n\nratings[i]\n is the initial rating of the \ni\nth\n food.\n\n\n\n\n\n\nvoid changeRating(String food, int newRating)\n Changes the rating of the food item with the name \nfood\n.\n\n\nString highestRated(String cuisine)\n Returns the name of the food item that has the highest rating for the given type of \ncuisine\n. If there is a tie, return the item with the \nlexicographically smaller\n name.\n\n\n\n\nNote that a string \nx\n is lexicographically smaller than string \ny\n if \nx\n comes before \ny\n in dictionary order, that is, either \nx\n is a prefix of \ny\n, or if \ni\n is the first position such that \nx[i] != y[i]\n, then \nx[i]\n comes before \ny[i]\n in alphabetic order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"FoodRatings\", \"highestRated\", \"highestRated\", \"changeRating\", \"highestRated\", \"changeRating\", \"highestRated\"]\n[[[\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]], [\"korean\"], [\"japanese\"], [\"sushi\", 16], [\"japanese\"], [\"ramen\", 16], [\"japanese\"]]\n\nOutput\n\n[null, \"kimchi\", \"ramen\", null, \"sushi\", null, \"ramen\"]\n\n\nExplanation\n\nFoodRatings foodRatings = new FoodRatings([\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]);\nfoodRatings.highestRated(\"korean\"); // return \"kimchi\"\n                                    // \"kimchi\" is the highest rated korean food with a rating of 9.\nfoodRatings.highestRated(\"japanese\"); // return \"ramen\"\n                                      // \"ramen\" is the highest rated japanese food with a rating of 14.\nfoodRatings.changeRating(\"sushi\", 16); // \"sushi\" now has a rating of 16.\nfoodRatings.highestRated(\"japanese\"); // return \"sushi\"\n                                      // \"sushi\" is the highest rated japanese food with a rating of 16.\nfoodRatings.changeRating(\"ramen\", 16); // \"ramen\" now has a rating of 16.\nfoodRatings.highestRated(\"japanese\"); // return \"ramen\"\n                                      // Both \"sushi\" and \"ramen\" have a rating of 16.\n                                      // However, \"ramen\" is lexicographically smaller than \"sushi\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2 * 10\n4\n\n\nn == foods.length == cuisines.length == ratings.length\n\n\n1 <= foods[i].length, cuisines[i].length <= 10\n\n\nfoods[i]\n, \ncuisines[i]\n consist of lowercase English letters.\n\n\n1 <= ratings[i] <= 10\n8\n\n\nAll the strings in \nfoods\n are \ndistinct\n.\n\n\nfood\n will be the name of a food item in the system across all calls to \nchangeRating\n.\n\n\ncuisine\n will be a type of cuisine of \nat least one\n food item in the system across all calls to \nhighestRated\n.\n\n\nAt most \n2 * 10\n4\n calls \nin total\n will be made to \nchangeRating\n and \nhighestRated\n.",
      "solution": "#        changeRating: O(logn)\n#        highestRated: O(1)\n\nimport collections\nimport itertools\nfrom sortedcontainers import SortedList\n\n\n# sorted listclass FoodRatings(object):\n\n    def __init__(self, foods, cuisines, ratings):\n        \"\"\"\n        :type foods: List[str]\n        :type cuisines: List[str]\n        :type ratings: List[int]\n        \"\"\"\n        self.__food_to_cuisine = {}\n        self.__food_to_rating = {}\n        self.__cusine_to_rating_foods = collections.defaultdict(SortedList)\n        for food, cuisine, rating in itertools.izip(foods, cuisines, ratings):\n            self.__food_to_cuisine[food] = cuisine\n            self.__food_to_rating[food] = rating\n            self.__cusine_to_rating_foods[cuisine].add((-rating, food))\n\n    def changeRating(self, food, newRating):\n        \"\"\"\n        :type food: str\n        :type newRating: int\n        :rtype: None\n        \"\"\"\n        old_rating = self.__food_to_rating[food]\n        cuisine = self.__food_to_cuisine[food]\n        self.__cusine_to_rating_foods[cuisine].remove((-old_rating, food))\n        self.__food_to_rating[food] = newRating\n        self.__cusine_to_rating_foods[cuisine].add((-newRating, food))\n\n    def highestRated(self, cuisine):\n        \"\"\"\n        :type cuisine: str\n        :rtype: str\n        \"\"\"\n        return self.__cusine_to_rating_foods[cuisine][0][1]",
      "explanation": "N/A",
      "time_complexity": "ctor:         O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Maximum Frequency Stack",
      "difficulty": "Hard",
      "category": "Data Structure Design",
      "link": "https://leetcode.com/problems/maximum-frequency-stack",
      "slug": "maximum-frequency-stack",
      "description": "Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\n\n\nImplement the \nFreqStack\n class:\n\n\n\n\nFreqStack()\n constructs an empty frequency stack.\n\n\nvoid push(int val)\n pushes an integer \nval\n onto the top of the stack.\n\n\nint pop()\n removes and returns the most frequent element in the stack.\n\t\n\n\nIf there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.\n\n\n\n\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\n\nOutput\n\n[null, null, null, null, null, null, null, 5, 7, 5, 4]\n\n\nExplanation\n\nFreqStack freqStack = new FreqStack();\nfreqStack.push(5); // The stack is [5]\nfreqStack.push(7); // The stack is [5,7]\nfreqStack.push(5); // The stack is [5,7,5]\nfreqStack.push(7); // The stack is [5,7,5,7]\nfreqStack.push(4); // The stack is [5,7,5,7,4]\nfreqStack.push(5); // The stack is [5,7,5,7,4,5]\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].\nfreqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].\nfreqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= val <= 10\n9\n\n\nAt most \n2 * 10\n4\n calls will be made to \npush\n and \npop\n.\n\n\nIt is guaranteed that there will be at least one element in the stack before calling \npop\n.",
      "solution": "\nimport collections\n\nclass FreqStack(object):\n\n    def __init__(self):\n        self.__freq = collections.Counter()\n        self.__group = collections.defaultdict(list)\n        self.__maxfreq = 0\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: void\n        \"\"\"\n        self.__freq[x] += 1\n        if self.__freq[x] > self.__maxfreq:\n            self.__maxfreq = self.__freq[x]\n        self.__group[self.__freq[x]].append(x)   \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        x = self.__group[self.__maxfreq].pop()\n        if not self.__group[self.__maxfreq]:\n            self.__group.pop(self.__maxfreq)\n            self.__maxfreq -= 1\n        self.__freq[x] -= 1\n        if not self.__freq[x]:\n            self.__freq.pop(x)\n        return x",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(n)"
    }
  ],
  "Greedy": [
    {
      "title": "Jump Game II",
      "difficulty": "Medium",
      "category": "Greedy",
      "link": "https://leetcode.com/problems/jump-game-ii",
      "slug": "jump-game-ii",
      "description": "You are given a \n0-indexed\n array of integers \nnums\n of length \nn\n. You are initially positioned at \nnums[0]\n.\n\n\nEach element \nnums[i]\n represents the maximum length of a forward jump from index \ni\n. In other words, if you are at \nnums[i]\n, you can jump to any \nnums[i + j]\n where:\n\n\n\n\n0 <= j <= nums[i]\n and\n\n\ni + j < n\n\n\n\n\nReturn \nthe minimum number of jumps to reach \nnums[n - 1]\n. The test cases are generated such that you can reach \nnums[n - 1]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,3,1,1,4]\n\nOutput:\n 2\n\nExplanation:\n The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,3,0,1,4]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n0 <= nums[i] <= 1000\n\n\nIt's guaranteed that you can reach \nnums[n - 1]\n.",
      "solution": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        # max_jump: the farthest index we can currently reach\n        # jumps: number of jumps made so far\n        # curr_end: the farthest index we can reach in the current jump window\n        max_jump, jumps, curr_end = 0, 0, 0\n\n        # Loop through all indices except the last one\n        # (since we don't need to jump from the last index)\n        for i in range(len(nums) - 1):\n            # Update the farthest index we can reach so far\n            max_jump = max(max_jump, i + nums[i])\n\n            # If we reach the end of the current jump window,\n            # it means we must make a jump to continue\n            if i == curr_end:\n                jumps += 1\n                # Extend the current jump window to the farthest reachable index\n                curr_end = max_jump\n        \n        # Return the total number of jumps needed to reach the end\n        return jumps",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Minimum Add to Make Parentheses Valid",
      "difficulty": "Medium",
      "category": "Greedy",
      "link": "https://leetcode.com/problems/minimum-add-to-make-parentheses-valid",
      "slug": "minimum-add-to-make-parentheses-valid",
      "description": "A parentheses string is valid if and only if:\n\n\n\n\nIt is the empty string,\n\n\nIt can be written as \nAB\n (\nA\n concatenated with \nB\n), where \nA\n and \nB\n are valid strings, or\n\n\nIt can be written as \n(A)\n, where \nA\n is a valid string.\n\n\n\n\nYou are given a parentheses string \ns\n. In one move, you can insert a parenthesis at any position of the string.\n\n\n\n\nFor example, if \ns = \"()))\"\n, you can insert an opening parenthesis to be \n\"(\n(\n)))\"\n or a closing parenthesis to be \n\"())\n)\n)\"\n.\n\n\n\n\nReturn \nthe minimum number of moves required to make \ns\n valid\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"())\"\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"(((\"\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns[i]\n is either \n'('\n or \n')'\n.",
      "solution": "class Solution(object):\n    def minAddToMakeValid(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: int\n        \"\"\"\n        add, bal, = 0, 0\n        for c in S:\n            bal += 1 if c == '(' else -1\n            if bal == -1:\n                add += 1\n                bal += 1\n        return add + bal",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Gas Station",
      "difficulty": "Medium",
      "category": "Greedy",
      "link": "https://leetcode.com/problems/gas-station",
      "slug": "gas-station",
      "description": "There are \nn\n gas stations along a circular route, where the amount of gas at the \ni\nth\n station is \ngas[i]\n.\n\n\nYou have a car with an unlimited gas tank and it costs \ncost[i]\n of gas to travel from the \ni\nth\n station to its next \n(i + 1)\nth\n station. You begin the journey with an empty tank at one of the gas stations.\n\n\nGiven two integer arrays \ngas\n and \ncost\n, return \nthe starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return\n \n-1\n. If there exists a solution, it is \nguaranteed\n to be \nunique\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n\nOutput:\n 3\n\nExplanation:\n\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n\n\n\nExample 2:\n\n\n\n\nInput:\n gas = [2,3,4], cost = [3,4,3]\n\nOutput:\n -1\n\nExplanation:\n\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == gas.length == cost.length\n\n\n1 <= n <= 10\n5\n\n\n0 <= gas[i], cost[i] <= 10\n4\n\n\nThe input is generated such that the answer is unique.",
      "solution": "class Solution(object):\n    # @param gas, a list of integers\n    # @param cost, a list of integers\n    # @return an integer\n    def canCompleteCircuit(self, gas, cost):\n        start, total_sum, current_sum = 0, 0, 0\n        for i in xrange(len(gas)):\n            diff = gas[i] - cost[i]\n            current_sum += diff\n            total_sum += diff\n            if current_sum < 0:\n                start = i + 1\n                current_sum = 0\n        if total_sum >= 0:\n            return start\n\n        return -1",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Task Scheduler",
      "difficulty": "Medium",
      "category": "Greedy",
      "link": "https://leetcode.com/problems/task-scheduler",
      "slug": "task-scheduler",
      "description": "You are given an array of CPU \ntasks\n, each labeled with a letter from A to Z, and a number \nn\n. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a constraint: there has to be a gap of \nat least\n \nn\n intervals between two tasks with the same label.\n\n\nReturn the \nminimum\n number of CPU intervals required to complete all tasks.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ntasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\n\n\nOutput:\n \n8\n\n\nExplanation:\n A possible sequence is: A -> B -> idle -> A -> B -> idle -> A -> B.\n\n\nAfter completing task A, you must wait two intervals before doing A again. The same applies to task B. In the 3\nrd\n interval, neither A nor B can be done, so you idle. By the 4\nth\n interval, you can do A again as 2 intervals have passed.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ntasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1\n\n\nOutput:\n \n6\n\n\nExplanation:\n A possible sequence is: A -> B -> C -> D -> A -> B.\n\n\nWith a cooling interval of 1, you can repeat a task after just one other task.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ntasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3\n\n\nOutput:\n \n10\n\n\nExplanation:\n A possible sequence is: A -> B -> idle -> idle -> A -> B -> idle -> idle -> A -> B.\n\n\nThere are only two types of tasks, A and B, which need to be separated by 3 intervals. This leads to idling twice between repetitions of these tasks.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= tasks.length <= 10\n4\n\n\ntasks[i]\n is an uppercase English letter.\n\n\n0 <= n <= 100",
      "solution": "\nfrom collections import Counter\n\nclass Solution(object):\n    def leastInterval(self, tasks, n):\n        \"\"\"\n        :type tasks: List[str]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        counter = Counter(tasks)\n        _, max_count = counter.most_common(1)[0]\n        return max((max_count-1) * (n+1) + counter.values().count(max_count), len(tasks))",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(26) = O(1)"
    },
    {
      "title": "Minimum Cost to Hire K Workers",
      "difficulty": "Hard",
      "category": "Greedy",
      "link": "https://leetcode.com/problems/minimum-cost-to-hire-k-workers",
      "slug": "minimum-cost-to-hire-k-workers",
      "description": "There are \nn\n workers. You are given two integer arrays \nquality\n and \nwage\n where \nquality[i]\n is the quality of the \ni\nth\n worker and \nwage[i]\n is the minimum wage expectation for the \ni\nth\n worker.\n\n\nWe want to hire exactly \nk\n workers to form a \npaid group\n. To hire a group of \nk\n workers, we must pay them according to the following rules:\n\n\n\n\nEvery worker in the paid group must be paid at least their minimum wage expectation.\n\n\nIn the group, each worker's pay must be directly proportional to their quality. This means if a worker’s quality is double that of another worker in the group, then they must be paid twice as much as the other worker.\n\n\n\n\nGiven the integer \nk\n, return \nthe least amount of money needed to form a paid group satisfying the above conditions\n. Answers within \n10\n-5\n of the actual answer will be accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n quality = [10,20,5], wage = [70,50,30], k = 2\n\nOutput:\n 105.00000\n\nExplanation:\n We pay 70 to 0\nth\n worker and 35 to 2\nnd\n worker.\n\n\n\nExample 2:\n\n\n\n\nInput:\n quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3\n\nOutput:\n 30.66667\n\nExplanation:\n We pay 4 to 0\nth\n worker, 13.33333 to 2\nnd\n and 3\nrd\n workers separately.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == quality.length == wage.length\n\n\n1 <= k <= n <= 10\n4\n\n\n1 <= quality[i], wage[i] <= 10\n4",
      "solution": "# Space : O(n)\n\nimport itertools\nimport heapq\n\nclass Solution(object):\n    def mincostToHireWorkers(self, quality, wage, K):\n        \"\"\"\n        :type quality: List[int]\n        :type wage: List[int]\n        :type K: int\n        :rtype: float\n        \"\"\"\n        result, qsum = float(\"inf\"), 0\n        max_heap = []\n        for r, q in sorted([float(w)/q, q] for w, q in itertools.izip(wage, quality)):\n            qsum += q\n            heapq.heappush(max_heap, -q)\n            if len(max_heap) > K:\n                qsum -= -heapq.heappop(max_heap)\n            if len(max_heap) == K:\n                result = min(result, qsum*r)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "N/A"
    },
    {
      "title": "Candy",
      "difficulty": "Hard",
      "category": "Greedy",
      "link": "https://leetcode.com/problems/candy",
      "slug": "candy",
      "description": "There are \nn\n children standing in a line. Each child is assigned a rating value given in the integer array \nratings\n.\n\n\nYou are giving candies to these children subjected to the following requirements:\n\n\n\n\nEach child must have at least one candy.\n\n\nChildren with a higher rating get more candies than their neighbors.\n\n\n\n\nReturn \nthe minimum number of candies you need to have to distribute the candies to the children\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n ratings = [1,0,2]\n\nOutput:\n 5\n\nExplanation:\n You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\n\n\nExample 2:\n\n\n\n\nInput:\n ratings = [1,2,2]\n\nOutput:\n 4\n\nExplanation:\n You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == ratings.length\n\n\n1 <= n <= 2 * 10\n4\n\n\n0 <= ratings[i] <= 2 * 10\n4",
      "solution": "class Solution(object):\n    # @param ratings, a list of integer\n    # @return an integer\n    def candy(self, ratings):\n        candies = [1 for _ in xrange(len(ratings))]\n        for i in xrange(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        for i in reversed(xrange(1, len(ratings))):\n            if ratings[i - 1] > ratings[i] and candies[i - 1] <= candies[i]:\n                candies[i - 1] = candies[i] + 1\n\n        return sum(candies)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Minimum Number of Refueling Stops",
      "difficulty": "Hard",
      "category": "Greedy",
      "link": "https://leetcode.com/problems/minimum-number-of-refueling-stops",
      "slug": "minimum-number-of-refueling-stops",
      "description": "A car travels from a starting position to a destination which is \ntarget\n miles east of the starting position.\n\n\nThere are gas stations along the way. The gas stations are represented as an array \nstations\n where \nstations[i] = [position\ni\n, fuel\ni\n]\n indicates that the \ni\nth\n gas station is \nposition\ni\n miles east of the starting position and has \nfuel\ni\n liters of gas.\n\n\nThe car starts with an infinite tank of gas, which initially has \nstartFuel\n liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.\n\n\nReturn \nthe minimum number of refueling stops the car must make in order to reach its destination\n. If it cannot reach the destination, return \n-1\n.\n\n\nNote that if the car reaches a gas station with \n0\n fuel left, the car can still refuel there. If the car reaches the destination with \n0\n fuel left, it is still considered to have arrived.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n target = 1, startFuel = 1, stations = []\n\nOutput:\n 0\n\nExplanation:\n We can reach the target without refueling.\n\n\n\nExample 2:\n\n\n\n\nInput:\n target = 100, startFuel = 1, stations = [[10,100]]\n\nOutput:\n -1\n\nExplanation:\n We can not reach the target (or even the first gas station).\n\n\n\nExample 3:\n\n\n\n\nInput:\n target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]\n\nOutput:\n 2\n\nExplanation:\n We start with 10 liters of fuel.\nWe drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\nThen, we drive from position 10 to position 60 (expending 50 liters of fuel),\nand refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\nWe made 2 refueling stops along the way, so we return 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= target, startFuel <= 10\n9\n\n\n0 <= stations.length <= 500\n\n\n1 <= position\ni\n < position\ni+1\n < target\n\n\n1 <= fuel\ni\n < 10\n9",
      "solution": "\nimport heapq\n\nclass Solution(object):\n    def minRefuelStops(self, target, startFuel, stations):\n        \"\"\"\n        :type target: int\n        :type startFuel: int\n        :type stations: List[List[int]]\n        :rtype: int\n        \"\"\"\n        max_heap = []\n        stations.append((target, float(\"inf\")))\n\n        result = prev = 0\n        for location, capacity in stations:\n            startFuel -= location - prev\n            while max_heap and startFuel < 0:\n                startFuel += -heapq.heappop(max_heap)\n                result += 1\n            if startFuel < 0:\n                return -1\n            heapq.heappush(max_heap, -capacity)\n            prev = location\n\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    }
  ],
  "Depth First Search (DFS)": [
    {
      "title": "Number of Islands",
      "difficulty": "Medium",
      "category": "Depth First Search (DFS)",
      "link": "https://leetcode.com/problems/number-of-islands",
      "slug": "number-of-islands",
      "description": "Given an \nm x n\n 2D binary grid \ngrid\n which represents a map of \n'1'\ns (land) and \n'0'\ns (water), return \nthe number of islands\n.\n\n\nAn \nisland\n is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 300\n\n\ngrid[i][j]\n is \n'0'\n or \n'1'\n.",
      "solution": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        directions = {(1, 0), (-1, 0), (0, 1), (0, -1)}\n        rows, cols = len(grid), len(grid[0])\n\n        def dfs(r, c):\n            if (\n                not (0 <= r < rows) or\n                not (0 <= c < cols) or\n                grid[r][c] != \"1\"\n            ):\n                return \n\n            grid[r][c] = \"0\"\n            for dr, dc in directions:\n                dfs(r + dr, c + dc)\n            \n        islands = 0\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == \"1\":\n                    islands += 1\n                    dfs(r, c)\n\n        return islands \n\n        # def bfs(r, c):\n        #     q = deque()\n        #     grid[r][c] = \"0\"\n        #     q.append((r, c))\n\n        #     while q:\n        #         row, col = q.popleft()\n        #         for dr, dc in directions:\n        #             nr, nc = dr + row, dc + col\n        #             if ( not (0 <= nr < rows) \n        #                 or not (0 <= nc < cols)\n        #                 or grid[nr][nc] == \"0\"):\n        #                 continue\n        #             q.append((nr,nc))\n        #             grid[nr][nc] = \"0\"\n            \n        # for r in range(rows):\n        #     for c in range(cols):\n        #         if grid[r][c] == \"1\":\n        #             bfs(r,c)\n        #             island += 1\n        # return island",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "Time Needed to Inform All Employees",
      "difficulty": "Medium",
      "category": "Depth First Search (DFS)",
      "link": "https://leetcode.com/problems/time-needed-to-inform-all-employees",
      "slug": "time-needed-to-inform-all-employees",
      "description": "A company has \nn\n employees with a unique ID for each employee from \n0\n to \nn - 1\n. The head of the company is the one with \nheadID\n.\n\n\nEach employee has one direct manager given in the \nmanager\n array where \nmanager[i]\n is the direct manager of the \ni-th\n employee, \nmanager[headID] = -1\n. Also, it is guaranteed that the subordination relationships have a tree structure.\n\n\nThe head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.\n\n\nThe \ni-th\n employee needs \ninformTime[i]\n minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news).\n\n\nReturn \nthe number of minutes\n needed to inform all the employees about the urgent news.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 1, headID = 0, manager = [-1], informTime = [0]\n\nOutput:\n 0\n\nExplanation:\n The head of the company is the only employee in the company.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]\n\nOutput:\n 1\n\nExplanation:\n The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.\nThe tree structure of the employees in the company is shown.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5\n\n\n0 <= headID < n\n\n\nmanager.length == n\n\n\n0 <= manager[i] < n\n\n\nmanager[headID] == -1\n\n\ninformTime.length == n\n\n\n0 <= informTime[i] <= 1000\n\n\ninformTime[i] == 0\n if employee \ni\n has no subordinates.\n\n\nIt is \nguaranteed\n that all the employees can be informed.",
      "solution": "\nimport collections\n\n\n# dfs solution with stackclass Solution(object):\n    def numOfMinutes(self, n, headID, manager, informTime):\n        \"\"\"\n        :type n: int\n        :type headID: int\n        :type manager: List[int]\n        :type informTime: List[int]\n        :rtype: int\n        \"\"\"\n        children = collections.defaultdict(list)\n        for child, parent in enumerate(manager):\n            if parent != -1:\n                children[parent].append(child)\n\n        result = 0\n        stk = [(headID, 0)]\n        while stk:\n            node, curr = stk.pop()\n            curr += informTime[node]\n            result = max(result, curr)\n            if node not in children:\n                continue\n            for c in children[node]:\n                stk.append((c, curr))\n        return result\n\n    \n# dfs solution with recursionclass Solution2(object):\n    def numOfMinutes(self, n, headID, manager, informTime):\n        \"\"\"\n        :type n: int\n        :type headID: int\n        :type manager: List[int]\n        :type informTime: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(informTime, children, node):\n            return (max(dfs(informTime, children, c)\n                        for c in children[node])\n                    if node in children\n                    else 0) + informTime[node]\n\n        children = collections.defaultdict(list)\n        for child, parent in enumerate(manager):\n            if parent != -1:\n                children[parent].append(child)\n        return dfs(informTime, children, headID)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "All Paths From Source to Target",
      "difficulty": "Medium",
      "category": "Depth First Search (DFS)",
      "link": "https://leetcode.com/problems/all-paths-from-source-to-target",
      "slug": "all-paths-from-source-to-target",
      "description": "Given a directed acyclic graph (\nDAG\n) of \nn\n nodes labeled from \n0\n to \nn - 1\n, find all possible paths from node \n0\n to node \nn - 1\n and return them in \nany order\n.\n\n\nThe graph is given as follows: \ngraph[i]\n is a list of all nodes you can visit from node \ni\n (i.e., there is a directed edge from node \ni\n to node \ngraph[i][j]\n).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n graph = [[1,2],[3],[3],[]]\n\nOutput:\n [[0,1,3],[0,2,3]]\n\nExplanation:\n There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n graph = [[4,3,1],[3,2,4],[3],[4],[]]\n\nOutput:\n [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == graph.length\n\n\n2 <= n <= 15\n\n\n0 <= graph[i][j] < n\n\n\ngraph[i][j] != i\n (i.e., there will be no self-loops).\n\n\nAll the elements of \ngraph[i]\n are \nunique\n.\n\n\nThe input graph is \nguaranteed\n to be a \nDAG\n.",
      "solution": "#                      r is the count of the result.\nclass Solution(object):\n    def allPathsSourceTarget(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        def dfs(graph, curr, path, result):\n            if curr == len(graph)-1:\n                result.append(path[:])\n                return\n            for node in graph[curr]:\n                path.append(node)\n                dfs(graph, node, path, result)\n                path.pop()\n\n        result = []\n        dfs(graph, 0, [0], result)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(p + r * n), p is the count of all the possible paths in graph,",
      "space_complexity": "O(n)"
    },
    {
      "title": "Clone Graph",
      "difficulty": "Medium",
      "category": "Depth First Search (DFS)",
      "link": "https://leetcode.com/problems/clone-graph",
      "slug": "clone-graph",
      "description": "Given a reference of a node in a \nconnected\n undirected graph.\n\n\nReturn a \ndeep copy\n (clone) of the graph.\n\n\nEach node in the graph contains a value (\nint\n) and a list (\nList[Node]\n) of its neighbors.\n\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n\n\n\n \n\n\nTest case format:\n\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with \nval == 1\n, the second node with \nval == 2\n, and so on. The graph is represented in the test case using an adjacency list.\n\n\nAn adjacency list\n is a collection of unordered \nlists\n used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\n\nThe given node will always be the first node with \nval = 1\n. You must return the \ncopy of the given node\n as a reference to the cloned graph.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n adjList = [[2,4],[1,3],[2,4],[1,3]]\n\nOutput:\n [[2,4],[1,3],[2,4],[1,3]]\n\nExplanation:\n There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n adjList = [[]]\n\nOutput:\n [[]]\n\nExplanation:\n Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n\n\n\nExample 3:\n\n\n\n\nInput:\n adjList = []\n\nOutput:\n []\n\nExplanation:\n This an empty graph, it does not have any nodes.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the graph is in the range \n[0, 100]\n.\n\n\n1 <= Node.val <= 100\n\n\nNode.val\n is unique for each node.\n\n\nThere are no repeated edges and no self-loops in the graph.\n\n\nThe Graph is connected and all nodes can be visited starting from the given node.",
      "solution": "class UndirectedGraphNode(object):\n    def __init__(self, x):\n        self.label = x\n        self.neighbors = []\nclass Solution(object):\n    # @param node, a undirected graph node\n    # @return a undirected graph node\n    def cloneGraph(self, node):\n        if node is None:\n            return None\n        cloned_node = UndirectedGraphNode(node.label)\n        cloned, queue = {node:cloned_node}, [node]\n\n        while queue:\n            current = queue.pop()\n            for neighbor in current.neighbors:\n                if neighbor not in cloned:\n                    queue.append(neighbor)\n                    cloned_neighbor = UndirectedGraphNode(neighbor.label)\n                    cloned[neighbor] = cloned_neighbor\n                cloned[current].neighbors.append(cloned[neighbor])\n        return cloned[node]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Is Graph Bipartite?",
      "difficulty": "Medium",
      "category": "Depth First Search (DFS)",
      "link": "https://leetcode.com/problems/is-graph-bipartite",
      "slug": "is-graph-bipartite",
      "description": "There is an \nundirected\n graph with \nn\n nodes, where each node is numbered between \n0\n and \nn - 1\n. You are given a 2D array \ngraph\n, where \ngraph[u]\n is an array of nodes that node \nu\n is adjacent to. More formally, for each \nv\n in \ngraph[u]\n, there is an undirected edge between node \nu\n and node \nv\n. The graph has the following properties:\n\n\n\n\nThere are no self-edges (\ngraph[u]\n does not contain \nu\n).\n\n\nThere are no parallel edges (\ngraph[u]\n does not contain duplicate values).\n\n\nIf \nv\n is in \ngraph[u]\n, then \nu\n is in \ngraph[v]\n (the graph is undirected).\n\n\nThe graph may not be connected, meaning there may be two nodes \nu\n and \nv\n such that there is no path between them.\n\n\n\n\nA graph is \nbipartite\n if the nodes can be partitioned into two independent sets \nA\n and \nB\n such that \nevery\n edge in the graph connects a node in set \nA\n and a node in set \nB\n.\n\n\nReturn \ntrue\n if and only if it is \nbipartite\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n\nOutput:\n false\n\nExplanation:\n There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n graph = [[1,3],[0,2],[1,3],[0,2]]\n\nOutput:\n true\n\nExplanation:\n We can partition the nodes into two sets: {0, 2} and {1, 3}.\n\n\n \n\n\nConstraints:\n\n\n\n\ngraph.length == n\n\n\n1 <= n <= 100\n\n\n0 <= graph[u].length < n\n\n\n0 <= graph[u][i] <= n - 1\n\n\ngraph[u]\n does not contain \nu\n.\n\n\nAll the values of \ngraph[u]\n are \nunique\n.\n\n\nIf \ngraph[u]\n contains \nv\n, then \ngraph[v]\n contains \nu\n.",
      "solution": "class Solution(object):\n    def isBipartite(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        color = {}\n        for node in xrange(len(graph)):\n            if node in color:\n                continue\n            stack = [node]\n            color[node] = 0\n            while stack:\n                curr = stack.pop()\n                for neighbor in graph[curr]:\n                    if neighbor not in color:\n                        stack.append(neighbor)\n                        color[neighbor] = color[curr] ^ 1\n                    elif color[neighbor] == color[curr]:\n                        return False\n        return True",
      "explanation": "N/A",
      "time_complexity": "O(|V| + |E|)",
      "space_complexity": "O(|V|)"
    },
    {
      "title": "All Nodes Distance K in Binary Tree",
      "difficulty": "Medium",
      "category": "Depth First Search (DFS)",
      "link": "https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree",
      "slug": "all-nodes-distance-k-in-binary-tree",
      "description": "Given the \nroot\n of a binary tree, the value of a target node \ntarget\n, and an integer \nk\n, return \nan array of the values of all nodes that have a distance \nk\n from the target node.\n\n\nYou can return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2\n\nOutput:\n [7,4,1]\nExplanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1], target = 1, k = 3\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 500]\n.\n\n\n0 <= Node.val <= 500\n\n\nAll the values \nNode.val\n are \nunique\n.\n\n\ntarget\n is the value of one of the nodes in the tree.\n\n\n0 <= k <= 1000",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def distanceK(self, root, target, K):\n        \"\"\"\n        :type root: TreeNode\n        :type target: TreeNode\n        :type K: int\n        :rtype: List[int]\n        \"\"\"\n        def dfs(parent, child, neighbors):\n            if not child:\n                return\n            if parent:\n                neighbors[parent.val].append(child.val)\n                neighbors[child.val].append(parent.val)\n            dfs(child, child.left, neighbors)\n            dfs(child, child.right, neighbors)\n\n        neighbors = collections.defaultdict(list)\n        dfs(None, root, neighbors)\n        bfs = [target.val]\n        lookup = set(bfs)\n        for _ in xrange(K):\n            bfs = [nei for node in bfs\n                   for nei in neighbors[node]\n                   if nei not in lookup]\n            lookup |= set(bfs)\n        return bfs",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Employee Importance",
      "difficulty": "Medium",
      "category": "Depth First Search (DFS)",
      "link": "https://leetcode.com/problems/employee-importance",
      "slug": "employee-importance",
      "description": "You have a data structure of employee information, including the employee's unique ID, importance value, and direct subordinates' IDs.\n\n\nYou are given an array of employees \nemployees\n where:\n\n\n\n\nemployees[i].id\n is the ID of the \ni\nth\n employee.\n\n\nemployees[i].importance\n is the importance value of the \ni\nth\n employee.\n\n\nemployees[i].subordinates\n is a list of the IDs of the direct subordinates of the \ni\nth\n employee.\n\n\n\n\nGiven an integer \nid\n that represents an employee's ID, return \nthe \ntotal\n importance value of this employee and all their direct and indirect subordinates\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n employees = [[1,5,[2,3]],[2,3,[]],[3,3,[]]], id = 1\n\nOutput:\n 11\n\nExplanation:\n Employee 1 has an importance value of 5 and has two direct subordinates: employee 2 and employee 3.\nThey both have an importance value of 3.\nThus, the total importance value of employee 1 is 5 + 3 + 3 = 11.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n employees = [[1,2,[5]],[5,-3,[]]], id = 5\n\nOutput:\n -3\n\nExplanation:\n Employee 5 has an importance value of -3 and has no direct subordinates.\nThus, the total importance value of employee 5 is -3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= employees.length <= 2000\n\n\n1 <= employees[i].id <= 2000\n\n\nAll \nemployees[i].id\n are \nunique\n.\n\n\n-100 <= employees[i].importance <= 100\n\n\nOne employee has at most one direct leader and may have several subordinates.\n\n\nThe IDs in \nemployees[i].subordinates\n are valid IDs.",
      "solution": "\nimport collections\n\n\n\"\"\"\n# Employee infoclass Employee(object):\n    def __init__(self, id, importance, subordinates):\n        # It's the unique id of each node.\n        # unique id of this employee\n        self.id = id\n        # the importance value of this employee\n        self.importance = importance\n        # the id of direct subordinates\n        self.subordinates = subordinates\n\"\"\"class Solution(object):\n    def getImportance(self, employees, id):\n        \"\"\"\n        :type employees: Employee\n        :type id: int\n        :rtype: int\n        \"\"\"\n        if employees[id-1] is None:\n            return 0\n        result = employees[id-1].importance\n        for id in employees[id-1].subordinates:\n            result += self.getImportance(employees, id)\n        return result\n\nclass Solution2(object):\n    def getImportance(self, employees, id):\n        \"\"\"\n        :type employees: Employee\n        :type id: int\n        :rtype: int\n        \"\"\"\n        result, q = 0, collections.deque([id])\n        while q:\n            curr = q.popleft()\n            employee = employees[curr-1]\n            result += employee.importance\n            for id in employee.subordinates:\n                q.append(id)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(w), w is the max number of nodes in the levels of the tree"
    },
    {
      "title": "Surrounded Regions",
      "difficulty": "Medium",
      "category": "Depth First Search (DFS)",
      "link": "https://leetcode.com/problems/surrounded-regions",
      "slug": "surrounded-regions",
      "description": "You are given an \nm x n\n matrix \nboard\n containing \nletters\n \n'X'\n and \n'O'\n, \ncapture regions\n that are \nsurrounded\n:\n\n\n\n\nConnect\n: A cell is connected to adjacent cells horizontally or vertically.\n\n\nRegion\n: To form a region \nconnect every\n \n'O'\n cell.\n\n\nSurround\n: The region is surrounded with \n'X'\n cells if you can \nconnect the region \nwith \n'X'\n cells and none of the region cells are on the edge of the \nboard\n.\n\n\n\n\nTo capture a \nsurrounded region\n, replace all \n'O'\ns with \n'X'\ns \nin-place\n within the original board. You do not need to return anything.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nboard = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n\n\nOutput:\n \n[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n\n\nExplanation:\n\n\n\n\nIn the above diagram, the bottom region is not captured because it is on the edge of the board and cannot be surrounded.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nboard = [[\"X\"]]\n\n\nOutput:\n \n[[\"X\"]]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == board.length\n\n\nn == board[i].length\n\n\n1 <= m, n <= 200\n\n\nboard[i][j]\n is \n'X'\n or \n'O'\n.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: void Do not return anything, modify board in-place instead.\n        \"\"\"\n        if not board:\n            return\n\n        q = collections.deque()\n\n        for i in xrange(len(board)):\n            if board[i][0] == 'O':\n                board[i][0] = 'V'\n                q.append((i, 0))\n            if board[i][len(board[0])-1] == 'O':\n                board[i][len(board[0])-1] = 'V'\n                q.append((i, len(board[0])-1))\n\n        for j in xrange(1, len(board[0])-1):\n            if board[0][j] == 'O':\n                board[0][j] = 'V'\n                q.append((0, j))\n            if board[len(board)-1][j] == 'O':\n                board[len(board)-1][j] = 'V'\n                q.append((len(board)-1, j))\n\n        while q:\n            i, j = q.popleft()\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < len(board) and 0 <= y < len(board[0]) and \\\n                   board[x][y] == 'O':\n                    board[x][y] = 'V'\n                    q.append((x, y))\n\n        for i in xrange(len(board)):\n            for j in xrange(len(board[0])):\n                if board[i][j] != 'V':\n                    board[i][j] = 'X'\n                else:\n                    board[i][j] = 'O'",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m + n)"
    },
    {
      "title": "Pacific Atlantic Water Flow",
      "difficulty": "Medium",
      "category": "Depth First Search (DFS)",
      "link": "https://leetcode.com/problems/pacific-atlantic-water-flow",
      "slug": "pacific-atlantic-water-flow",
      "description": "There is an \nm x n\n rectangular island that borders both the \nPacific Ocean\n and \nAtlantic Ocean\n. The \nPacific Ocean\n touches the island's left and top edges, and the \nAtlantic Ocean\n touches the island's right and bottom edges.\n\n\nThe island is partitioned into a grid of square cells. You are given an \nm x n\n integer matrix \nheights\n where \nheights[r][c]\n represents the \nheight above sea level\n of the cell at coordinate \n(r, c)\n.\n\n\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is \nless than or equal to\n the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\n\n\nReturn \na \n2D list\n of grid coordinates \nresult\n where \nresult[i] = [r\ni\n, c\ni\n]\n denotes that rain water can flow from cell \n(r\ni\n, c\ni\n)\n to \nboth\n the Pacific and Atlantic oceans\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\n\nOutput:\n [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n\nExplanation:\n The following cells can flow to the Pacific and Atlantic oceans, as shown below:\n[0,4]: [0,4] -> Pacific Ocean \n       [0,4] -> Atlantic Ocean\n[1,3]: [1,3] -> [0,3] -> Pacific Ocean \n       [1,3] -> [1,4] -> Atlantic Ocean\n[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \n       [1,4] -> Atlantic Ocean\n[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \n       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\n[3,0]: [3,0] -> Pacific Ocean \n       [3,0] -> [4,0] -> Atlantic Ocean\n[3,1]: [3,1] -> [3,0] -> Pacific Ocean \n       [3,1] -> [4,1] -> Atlantic Ocean\n[4,0]: [4,0] -> Pacific Ocean \n       [4,0] -> Atlantic Ocean\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\n\n\n\nExample 2:\n\n\n\n\nInput:\n heights = [[1]]\n\nOutput:\n [[0,0]]\n\nExplanation:\n The water can flow from the only cell to the Pacific and Atlantic oceans.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == heights.length\n\n\nn == heights[r].length\n\n\n1 <= m, n <= 200\n\n\n0 <= heights[r][c] <= 10\n5",
      "solution": "class Solution(object):\n    def pacificAtlantic(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        PACIFIC, ATLANTIC = 1, 2\n\n        def pacificAtlanticHelper(matrix, x, y, prev_height, prev_val, visited, res):\n            if (not 0 <= x < len(matrix)) or \\\n               (not 0 <= y < len(matrix[0])) or \\\n               matrix[x][y] < prev_height or \\\n               (visited[x][y] | prev_val) == visited[x][y]:\n                return\n\n            visited[x][y] |= prev_val\n            if visited[x][y] == (PACIFIC | ATLANTIC):\n                res.append((x, y))\n\n            for d in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                pacificAtlanticHelper(matrix, x + d[0], y + d[1], matrix[x][y], visited[x][y], visited, res)\n\n        if not matrix:\n            return []\n\n        res = []\n        m, n = len(matrix),len(matrix[0])\n        visited = [[0 for _ in xrange(n)] for _ in xrange(m)]\n\n        for i in xrange(m):\n            pacificAtlanticHelper(matrix, i, 0, float(\"-inf\"), PACIFIC, visited, res)\n            pacificAtlanticHelper(matrix, i, n - 1, float(\"-inf\"), ATLANTIC, visited, res)\n        for j in xrange(n):\n            pacificAtlanticHelper(matrix, 0, j, float(\"-inf\"), PACIFIC, visited, res)\n            pacificAtlanticHelper(matrix, m - 1, j, float(\"-inf\"), ATLANTIC, visited, res)\n\n        return res",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "Making A Large Island",
      "difficulty": "Hard",
      "category": "Depth First Search (DFS)",
      "link": "https://leetcode.com/problems/making-a-large-island",
      "slug": "making-a-large-island",
      "description": "You are given an \nn x n\n binary matrix \ngrid\n. You are allowed to change \nat most one\n \n0\n to be \n1\n.\n\n\nReturn \nthe size of the largest \nisland\n in\n \ngrid\n \nafter applying this operation\n.\n\n\nAn \nisland\n is a 4-directionally connected group of \n1\ns.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n grid = [[1,0],[0,1]]\n\nOutput:\n 3\n\nExplanation:\n Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[1,1],[1,0]]\n\nOutput:\n 4\n\nExplanation: \nChange the 0 to 1 and make the island bigger, only one island with area = 4.\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[1,1],[1,1]]\n\nOutput:\n 4\n\nExplanation:\n Can't change any 0 to 1, only one island with area = 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\nn == grid[i].length\n\n\n1 <= n <= 500\n\n\ngrid[i][j]\n is either \n0\n or \n1\n.",
      "solution": "\nclass Solution(object):\n    def largestIsland(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n        def dfs(r, c, index, grid):\n            if not (0 <= r < len(grid) and\n                    0 <= c < len(grid[0]) and\n                    grid[r][c] == 1):\n                return 0\n            result = 1\n            grid[r][c] = index\n            for d in directions:\n                result += dfs(r+d[0], c+d[1], index, grid)\n            return result\n\n        area = {}\n        index = 2\n        for r in xrange(len(grid)):\n            for c in xrange(len(grid[r])):\n                if grid[r][c] == 1:\n                    area[index] = dfs(r, c, index, grid)\n                    index += 1\n\n        result = max(area.values() or [0])\n        for r in xrange(len(grid)):\n            for c in xrange(len(grid[r])):\n                if grid[r][c] == 0:\n                    seen = set()\n                    for d in directions:\n                        nr, nc = r+d[0], c+d[1]\n                        if not (0 <= nr < len(grid) and\n                                0 <= nc < len(grid[0]) and\n                                grid[nr][nc] > 1):\n                            continue\n                        seen.add(grid[nr][nc])\n                    result = max(result, 1 + sum(area[i] for i in seen))\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n^2)"
    }
  ],
  "Breadth First Search (BFS)": [
    {
      "title": "Rotting Oranges",
      "difficulty": "Medium",
      "category": "Breadth First Search (BFS)",
      "link": "https://leetcode.com/problems/rotting-oranges",
      "slug": "rotting-oranges",
      "description": "You are given an \nm x n\n \ngrid\n where each cell can have one of three values:\n\n\n\n\n0\n representing an empty cell,\n\n\n1\n representing a fresh orange, or\n\n\n2\n representing a rotten orange.\n\n\n\n\nEvery minute, any fresh orange that is \n4-directionally adjacent\n to a rotten orange becomes rotten.\n\n\nReturn \nthe minimum number of minutes that must elapse until no cell has a fresh orange\n. If \nthis is impossible, return\n \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[2,1,1],[1,1,0],[0,1,1]]\n\nOutput:\n 4\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[2,1,1],[0,1,1],[1,0,1]]\n\nOutput:\n -1\n\nExplanation:\n The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[0,2]]\n\nOutput:\n 0\n\nExplanation:\n Since there are already no fresh oranges at minute 0, the answer is just 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 10\n\n\ngrid[i][j]\n is \n0\n, \n1\n, or \n2\n.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def orangesRotting(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        count = 0\n        q = collections.deque()\n        for r, row in enumerate(grid):\n            for c, val in enumerate(row):\n                if val == 2:\n                    q.append((r, c, 0))\n                elif val == 1:\n                    count += 1\n\n        result = 0\n        while q:\n            r, c, result = q.popleft()\n            for d in directions:\n                nr, nc = r+d[0], c+d[1]\n                if not (0 <= nr < len(grid) and \\\n                        0 <= nc < len(grid[r])):\n                    continue\n                if grid[nr][nc] == 1:\n                    count -= 1\n                    grid[nr][nc] = 2\n                    q.append((nr, nc, result+1))\n        return result if count == 0 else -1",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "01 Matrix",
      "difficulty": "Medium",
      "category": "Breadth First Search (BFS)",
      "link": "https://leetcode.com/problems/01-matrix",
      "slug": "01-matrix",
      "description": "Given an \nm x n\n binary matrix \nmat\n, return \nthe distance of the nearest \n0\n for each cell\n.\n\n\nThe distance between two cells sharing a common edge is \n1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[0,0,0],[0,1,0],[0,0,0]]\n\nOutput:\n [[0,0,0],[0,1,0],[0,0,0]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n mat = [[0,0,0],[0,1,0],[1,1,1]]\n\nOutput:\n [[0,0,0],[0,1,0],[1,2,1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n1 <= m, n <= 10\n4\n\n\n1 <= m * n <= 10\n4\n\n\nmat[i][j]\n is either \n0\n or \n1\n.\n\n\nThere is at least one \n0\n in \nmat\n.\n\n\n\n\n \n\n\nNote:\n This question is the same as 1765: \nhttps://leetcode.com/problems/map-of-highest-peak/",
      "solution": "\n# dp solutionclass Solution(object):\n    def updateMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[i])):\n                if not matrix[i][j]:\n                    continue\n                matrix[i][j] = float(\"inf\")\n                if i > 0:\n                    matrix[i][j] = min(matrix[i][j], matrix[i-1][j]+1)\n                if j > 0:\n                    matrix[i][j] = min(matrix[i][j], matrix[i][j-1]+1)\n        for i in reversed(xrange(len(matrix))):\n            for j in reversed(xrange(len(matrix[i]))):\n                if not matrix[i][j]:\n                    continue\n                if i < len(matrix)-1:\n                    matrix[i][j] = min(matrix[i][j], matrix[i+1][j]+1)\n                if j < len(matrix[i])-1:\n                    matrix[i][j] = min(matrix[i][j], matrix[i][j+1]+1)\n        return matrix\n\n\n# dp solutionclass Solution2(object):\n    def updateMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        dp = [[float(\"inf\")]*len(matrix[0]) for _ in xrange(len(matrix))]\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[i])):\n                if matrix[i][j] == 0:\n                    dp[i][j] = 0\n                else:\n                    if i > 0:\n                        dp[i][j] = min(dp[i][j], dp[i-1][j]+1)\n                    if j > 0:\n                        dp[i][j] = min(dp[i][j], dp[i][j-1]+1)\n        for i in reversed(xrange(len(matrix))):\n            for j in reversed(xrange(len(matrix[i]))):\n                if matrix[i][j] == 0:\n                    dp[i][j] = 0\n                else:\n                    if i < len(matrix)-1:\n                        dp[i][j] = min(dp[i][j], dp[i+1][j]+1)\n                    if j < len(matrix[i])-1:\n                        dp[i][j] = min(dp[i][j], dp[i][j+1]+1)\n        return dp\n\n\nimport collections\n\nclass Solution3(object):\n    def updateMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        queue = collections.deque()\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    queue.append((i, j))\n                else:\n                    matrix[i][j] = float(\"inf\")\n\n        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        while queue:\n            cell = queue.popleft()\n            for dir in dirs:\n                i, j = cell[0]+dir[0], cell[1]+dir[1]\n                if not (0 <= i < len(matrix) and\n                        0 <= j < len(matrix[0]) and\n                        matrix[i][j] > matrix[cell[0]][cell[1]]+1):\n                    continue\n                queue.append((i, j))\n                matrix[i][j] = matrix[cell[0]][cell[1]]+1\n\n        return matrix",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "Open the Lock",
      "difficulty": "Medium",
      "category": "Breadth First Search (BFS)",
      "link": "https://leetcode.com/problems/open-the-lock",
      "slug": "open-the-lock",
      "description": "You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: \n'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n. The wheels can rotate freely and wrap around: for example we can turn \n'9'\n to be \n'0'\n, or \n'0'\n to be \n'9'\n. Each move consists of turning one wheel one slot.\n\n\nThe lock initially starts at \n'0000'\n, a string representing the state of the 4 wheels.\n\n\nYou are given a list of \ndeadends\n dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\n\n\nGiven a \ntarget\n representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n\nOutput:\n 6\n\nExplanation:\n \nA sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\".\nNote that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid,\nbecause the wheels of the lock become stuck after the display becomes the dead end \"0102\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n deadends = [\"8888\"], target = \"0009\"\n\nOutput:\n 1\n\nExplanation:\n We can turn the last wheel in reverse to move from \"0000\" -> \"0009\".\n\n\n\nExample 3:\n\n\n\n\nInput:\n deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\n\nOutput:\n -1\n\nExplanation:\n We cannot reach the target without getting stuck.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= deadends.length <= 500\n\n\ndeadends[i].length == 4\n\n\ntarget.length == 4\n\n\ntarget \nwill not be\n in the list \ndeadends\n.\n\n\ntarget\n and \ndeadends[i]\n consist of digits only.",
      "solution": "#                        k is the length of target,\n#                        d is the size of deadends\nclass Solution(object):\n    def openLock(self, deadends, target):\n        \"\"\"\n        :type deadends: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        dead = set(deadends)\n        q = [\"0000\"]\n        lookup = {\"0000\"}\n        depth = 0\n        while q:\n            next_q = []\n            for node in q:\n                if node == target: return depth\n                if node in dead: continue\n                for i in xrange(4):\n                    n = int(node[i])\n                    for d in (-1, 1):\n                        nn = (n+d) % 10\n                        neighbor = node[:i] + str(nn) + node[i+1:]\n                        if neighbor not in lookup:\n                            lookup.add(neighbor)\n                            next_q.append(neighbor)\n            q = next_q\n            depth += 1\n        return -1",
      "explanation": "N/A",
      "time_complexity": "O(k * n^k + d), n is the number of alphabets,",
      "space_complexity": "O(k * n^k + d)"
    },
    {
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "difficulty": "Hard",
      "category": "Breadth First Search (BFS)",
      "link": "https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination",
      "slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "description": "You are given an \nm x n\n integer matrix \ngrid\n where each cell is either \n0\n (empty) or \n1\n (obstacle). You can move up, down, left, or right from and to an empty cell in \none step\n.\n\n\nReturn \nthe minimum number of \nsteps\n to walk from the upper left corner \n(0, 0)\n to the lower right corner \n(m - 1, n - 1)\n given that you can eliminate \nat most\n \nk\n obstacles\n. If it is not possible to find such walk return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1\n\nOutput:\n 6\n\nExplanation:\n \nThe shortest path without eliminating any obstacle is 10.\nThe shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> \n(3,2)\n -> (4,2).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1\n\nOutput:\n -1\n\nExplanation:\n We need to eliminate at least two obstacles to find such a walk.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 40\n\n\n1 <= k <= m * n\n\n\ngrid[i][j]\n is either \n0\n \nor\n \n1\n.\n\n\ngrid[0][0] == grid[m - 1][n - 1] == 0",
      "solution": "\n# A* Search Algorithm without heapclass Solution(object):\n    def shortestPath(self, grid, k):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def dot(a, b):\n            return a[0]*b[0]+a[1]*b[1]\n\n        def g(a, b):\n            return abs(a[0]-b[0])+abs(a[1]-b[1])\n        \n        def a_star(grid, b, t, k):\n            f, dh = g(b, t), 2\n            closer, detour = [(b, k)], []\n            lookup = {}\n            while closer or detour:\n                if not closer:\n                    f += dh\n                    closer, detour = detour, closer\n                b, k = closer.pop()\n                if b == t:\n                    return f\n                if b in lookup and lookup[b] >= k:\n                    continue\n                lookup[b] = k\n                for dx, dy in directions:\n                    nb = (b[0]+dx, b[1]+dy)\n                    if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and\n                            (grid[nb[0]][nb[1]] == 0 or k > 0) and\n                            (nb not in lookup or lookup[nb] < k)):\n                        continue\n                    (closer if dot((dx, dy), (t[0]-b[0], t[1]-b[1])) > 0 else detour).append((nb, k-int(grid[nb[0]][nb[1]] == 1)))\n            return -1\n\n        return a_star(grid, (0, 0), (len(grid)-1, len(grid[0])-1), k)",
      "explanation": "N/A",
      "time_complexity": "O(m * n * k)",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "Bus Routes",
      "difficulty": "Hard",
      "category": "Breadth First Search (BFS)",
      "link": "https://leetcode.com/problems/bus-routes",
      "slug": "bus-routes",
      "description": "You are given an array \nroutes\n representing bus routes where \nroutes[i]\n is a bus route that the \ni\nth\n bus repeats forever.\n\n\n\n\nFor example, if \nroutes[0] = [1, 5, 7]\n, this means that the \n0\nth\n bus travels in the sequence \n1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...\n forever.\n\n\n\n\nYou will start at the bus stop \nsource\n (You are not on any bus initially), and you want to go to the bus stop \ntarget\n. You can travel between bus stops by buses only.\n\n\nReturn \nthe least number of buses you must take to travel from \nsource\n to \ntarget\n. Return \n-1\n if it is not possible.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n routes = [[1,2,7],[3,6,7]], source = 1, target = 6\n\nOutput:\n 2\n\nExplanation:\n The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12\n\nOutput:\n -1\n\n\n\n \n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= routes.length <= 500\n.\n\n\n1 <= routes[i].length <= 10\n5\n\n\nAll the values of \nroutes[i]\n are \nunique\n.\n\n\nsum(routes[i].length) <= 10\n5\n\n\n0 <= routes[i][j] < 10\n6\n\n\n0 <= source, target < 10\n6",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def numBusesToDestination(self, routes, S, T):\n        \"\"\"\n        :type routes: List[List[int]]\n        :type S: int\n        :type T: int\n        :rtype: int\n        \"\"\"\n        if S == T:\n            return 0\n\n        to_route = collections.defaultdict(set)\n        for i, route in enumerate(routes):\n            for stop in route:\n                to_route[stop].add(i)\n\n        result = 1\n        q = [S]\n        lookup = set([S])\n        while q:\n            next_q = []\n            for stop in q:\n                for i in to_route[stop]:\n                    for next_stop in routes[i]:\n                        if next_stop in lookup:\n                            continue\n                        if next_stop == T:\n                            return result\n                        next_q.append(next_stop)\n                        to_route[next_stop].remove(i)\n                        lookup.add(next_stop)\n            q = next_q\n            result += 1\n\n        return -1",
      "explanation": "N/A",
      "time_complexity": "O(|V| + |E|)",
      "space_complexity": "O(|V| + |E|)"
    },
    {
      "title": "Word Ladder",
      "difficulty": "Hard",
      "category": "Breadth First Search (BFS)",
      "link": "https://leetcode.com/problems/word-ladder",
      "slug": "word-ladder",
      "description": "A \ntransformation sequence\n from word \nbeginWord\n to word \nendWord\n using a dictionary \nwordList\n is a sequence of words \nbeginWord -> s\n1\n -> s\n2\n -> ... -> s\nk\n such that:\n\n\n\n\nEvery adjacent pair of words differs by a single letter.\n\n\nEvery \ns\ni\n for \n1 <= i <= k\n is in \nwordList\n. Note that \nbeginWord\n does not need to be in \nwordList\n.\n\n\ns\nk\n == endWord\n\n\n\n\nGiven two words, \nbeginWord\n and \nendWord\n, and a dictionary \nwordList\n, return \nthe \nnumber of words\n in the \nshortest transformation sequence\n from\n \nbeginWord\n \nto\n \nendWord\n, or \n0\n if no such sequence exists.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\nOutput:\n 5\n\nExplanation:\n One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\n\n\n\nExample 2:\n\n\n\n\nInput:\n beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n\nOutput:\n 0\n\nExplanation:\n The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= beginWord.length <= 10\n\n\nendWord.length == beginWord.length\n\n\n1 <= wordList.length <= 5000\n\n\nwordList[i].length == beginWord.length\n\n\nbeginWord\n, \nendWord\n, and \nwordList[i]\n consist of lowercase English letters.\n\n\nbeginWord != endWord\n\n\nAll the words in \nwordList\n are \nunique\n.",
      "solution": "\nfrom string import ascii_lowercase\n\n\n# two-end bfsclass Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        words = set(wordList)\n        if endWord not in words:\n            return 0\n        left, right = {beginWord}, {endWord}\n        ladder = 2\n        while left:\n            words -= left\n            new_left = set()\n            for word in left:\n                for new_word in (word[:i]+c+word[i+1:] for i in xrange(len(beginWord)) for c in ascii_lowercase):\n                    if new_word not in words:\n                        continue\n                    if new_word in right: \n                        return ladder\n                    new_left.add(new_word)\n            left = new_left\n            ladder += 1\n            if len(left) > len(right): \n                left, right = right, left\n        return 0\n\nclass Solution2(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        lookup = set(wordList)\n        if endWord not in lookup:\n            return 0\n        ladder = 2\n        q = [beginWord]\n        while q:\n            new_q = []\n            for word in q:\n                for i in xrange(len(word)):\n                    for j in ascii_lowercase:\n                        new_word = word[:i] + j + word[i+1:]\n                        if new_word == endWord:\n                            return ladder\n                        if new_word in lookup:\n                            lookup.remove(new_word)\n                            new_q.append(new_word)\n            q = new_q\n            ladder += 1\n        return 0",
      "explanation": "N/A",
      "time_complexity": "O(b^d), b is the branch factor of bfs, d is the result depth",
      "space_complexity": "O(w * l), w is the number of words, l is the max length of words"
    }
  ],
  "Topological Sort": [
    {
      "title": "Course Schedule II",
      "difficulty": "Medium",
      "category": "Topological Sort",
      "link": "https://leetcode.com/problems/course-schedule-ii",
      "slug": "course-schedule-ii",
      "description": "There are a total of \nnumCourses\n courses you have to take, labeled from \n0\n to \nnumCourses - 1\n. You are given an array \nprerequisites\n where \nprerequisites[i] = [a\ni\n, b\ni\n]\n indicates that you \nmust\n take course \nb\ni\n first if you want to take course \na\ni\n.\n\n\n\n\nFor example, the pair \n[0, 1]\n, indicates that to take course \n0\n you have to first take course \n1\n.\n\n\n\n\nReturn \nthe ordering of courses you should take to finish all courses\n. If there are many valid answers, return \nany\n of them. If it is impossible to finish all courses, return \nan empty array\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [[1,0]]\n\nOutput:\n [0,1]\n\nExplanation:\n There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n\nOutput:\n [0,2,1,3]\n\nExplanation:\n There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n\n\n\nExample 3:\n\n\n\n\nInput:\n numCourses = 1, prerequisites = []\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numCourses <= 2000\n\n\n0 <= prerequisites.length <= numCourses * (numCourses - 1)\n\n\nprerequisites[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < numCourses\n\n\na\ni\n != b\ni\n\n\nAll the pairs \n[a\ni\n, b\ni\n]\n are \ndistinct\n.",
      "solution": "\nimport collections\n\n\n# Khan's algorithm (bfs solution)class Solution(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        q = [u for u in xrange(numCourses) if u not in in_degree]\n        while q:\n            new_q = []\n            for u in q:\n                result.append(u)\n                for v in adj[u]:\n                    in_degree[v] -= 1\n                    if in_degree[v] == 0:\n                        new_q.append(v)\n            q = new_q\n        return result if len(result) == numCourses else []\n\n\nimport collections\n\n\n# dfs solutionclass Solution2(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        stk = [u for u in xrange(numCourses) if u not in in_degree]\n        while stk:\n            u = stk.pop()\n            result.append(u)\n            for v in adj[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    stk.append(v)\n        return result if len(result) == numCourses else []\n\n\nimport collections\n\n\n# dfs solutionclass Solution3(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        WHITE, GRAY, BLACK = range(3)\n        def dfs(u):\n            if lookup[u] != WHITE:\n                return lookup[u] == BLACK\n            lookup[u] = GRAY\n            if any(not dfs(v) for v in adj[u]):\n                return False\n            lookup[u] = BLACK\n            result.append(u)  # should be postorder\n            return True\n\n        result = []\n        adj = collections.defaultdict(list)\n        for u, v in prerequisites:\n            adj[u].append(v)\n        lookup = collections.defaultdict(lambda:WHITE)\n        for u in xrange(numCourses):\n            if not dfs(u):\n                return []\n        return result\n\n    \nimport collections\n\n\n# dfs solutionclass Solution4(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        WHITE, GRAY, BLACK = range(3)\n        def dfs(u):\n            if lookup[u] != WHITE:\n                return lookup[u] == BLACK\n            lookup[u] = GRAY\n            if any(not dfs(v) for v in adj[u]):\n                return False\n            lookup[u] = BLACK\n            result.append(u)  # should be postorder\n            return True\n\n        result = []\n        adj = collections.defaultdict(list)\n        for u, v in prerequisites:\n            adj[v].append(u)\n        lookup = collections.defaultdict(lambda:WHITE)\n        for u in xrange(numCourses):\n            if not dfs(u):\n                return []\n        result.reverse()\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(|V| + |E|)",
      "space_complexity": "O(|E|)"
    },
    {
      "title": "Find Eventual Safe States",
      "difficulty": "Medium",
      "category": "Topological Sort",
      "link": "https://leetcode.com/problems/find-eventual-safe-states",
      "slug": "find-eventual-safe-states",
      "description": "There is a directed graph of \nn\n nodes with each node labeled from \n0\n to \nn - 1\n. The graph is represented by a \n0-indexed\n 2D integer array \ngraph\n where \ngraph[i]\n is an integer array of nodes adjacent to node \ni\n, meaning there is an edge from node \ni\n to each node in \ngraph[i]\n.\n\n\nA node is a \nterminal node\n if there are no outgoing edges. A node is a \nsafe node\n if every possible path starting from that node leads to a \nterminal node\n (or another safe node).\n\n\nReturn \nan array containing all the \nsafe nodes\n of the graph\n. The answer should be sorted in \nascending\n order.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n graph = [[1,2],[2,3],[5],[0],[5],[],[]]\n\nOutput:\n [2,4,5,6]\n\nExplanation:\n The given graph is shown above.\nNodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.\nEvery path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.\n\n\nExample 2:\n\n\n\n\nInput:\n graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\n\nOutput:\n [4]\n\nExplanation:\n\nOnly node 4 is a terminal node, and every path starting at node 4 leads to node 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == graph.length\n\n\n1 <= n <= 10\n4\n\n\n0 <= graph[i].length <= n\n\n\n0 <= graph[i][j] <= n - 1\n\n\ngraph[i]\n is sorted in a strictly increasing order.\n\n\nThe graph may contain self-loops.\n\n\nThe number of edges in the graph will be in the range \n[1, 4 * 10\n4\n]\n.",
      "solution": "class Solution(object):\n    def eventualSafeNodes(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        WHITE, GRAY, BLACK = range(3)\n\n        def dfs(graph, node, lookup):\n            if lookup[node] != WHITE:\n                return lookup[node] == BLACK\n            lookup[node] = GRAY\n            if any(not dfs(graph, child, lookup) for child in graph[node]):\n                return False\n            lookup[node] = BLACK\n            return True\n\n        lookup = [WHITE]*len(graph)\n        return filter(lambda node: dfs(graph, node, lookup), xrange(len(graph)))",
      "explanation": "N/A",
      "time_complexity": "O(|V| + |E|)",
      "space_complexity": "O(|V|)"
    },
    {
      "title": "Minimum Height Trees",
      "difficulty": "Medium",
      "category": "Topological Sort",
      "link": "https://leetcode.com/problems/minimum-height-trees",
      "slug": "minimum-height-trees",
      "description": "A tree is an undirected graph in which any two vertices are connected by \nexactly\n one path. In other words, any connected graph without simple cycles is a tree.\n\n\nGiven a tree of \nn\n nodes labelled from \n0\n to \nn - 1\n, and an array of \nn - 1\n \nedges\n where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an undirected edge between the two nodes \na\ni\n and \nb\ni\n in the tree, you can choose any node of the tree as the root. When you select a node \nx\n as the root, the result tree has height \nh\n. Among all possible rooted trees, those with minimum height (i.e. \nmin(h)\n)  are called \nminimum height trees\n (MHTs).\n\n\nReturn \na list of all \nMHTs'\n root labels\n. You can return the answer in \nany order\n.\n\n\nThe \nheight\n of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[1,0],[1,2],[1,3]]\n\nOutput:\n [1]\n\nExplanation:\n As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\n\nOutput:\n [3,4]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2 * 10\n4\n\n\nedges.length == n - 1\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\na\ni\n != b\ni\n\n\nAll the pairs \n(a\ni\n, b\ni\n)\n are distinct.\n\n\nThe given input is \nguaranteed\n to be a tree and there will be \nno repeated\n edges.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def findMinHeightTrees(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if n == 1:\n            return [0]\n\n        neighbors = collections.defaultdict(set)\n        for u, v in edges:\n            neighbors[u].add(v)\n            neighbors[v].add(u)\n\n        pre_level, unvisited = [], set()\n        for i in xrange(n):\n            if len(neighbors[i]) == 1:  # A leaf.\n                pre_level.append(i)\n            unvisited.add(i)\n\n        # A graph can have 2 MHTs at most.\n        # BFS from the leaves until the number\n        # of the unvisited nodes is less than 3.\n        while len(unvisited) > 2:\n            cur_level = []\n            for u in pre_level:\n                unvisited.remove(u)\n                for v in neighbors[u]:\n                    if v in unvisited:\n                        neighbors[v].remove(u)\n                        if len(neighbors[v]) == 1:\n                            cur_level.append(v)\n            pre_level = cur_level\n\n        return list(unvisited)",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Sort Items by Groups Respecting Dependencies",
      "difficulty": "Hard",
      "category": "Topological Sort",
      "link": "https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies",
      "slug": "sort-items-by-groups-respecting-dependencies",
      "description": "There are \nn\n items each belonging to zero or one of \nm\n groups where \ngroup[i]\n is the group that the \ni\n-th item belongs to and it's equal to \n-1\n if the \ni\n-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.\n\n\nReturn a sorted list of the items such that:\n\n\n\n\nThe items that belong to the same group are next to each other in the sorted list.\n\n\nThere are some relations between these items where \nbeforeItems[i]\n is a list containing all the items that should come before the \ni\n-th item in the sorted array (to the left of the \ni\n-th item).\n\n\n\n\nReturn any solution if there is more than one solution and return an \nempty list\n if there is no solution.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]\n\nOutput:\n [6,3,4,1,5,2,0,7]\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]\n\nOutput:\n []\n\nExplanation:\n This is the same as example 1 except that 4 needs to be before 6 in the sorted list.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m <= n <= 3 * 10\n4\n\n\ngroup.length == beforeItems.length == n\n\n\n-1 <= group[i] <= m - 1\n\n\n0 <= beforeItems[i].length <= n - 1\n\n\n0 <= beforeItems[i][j] <= n - 1\n\n\ni != beforeItems[i][j]\n\n\nbeforeItems[i] \ndoes not contain duplicates elements.",
      "solution": "\nimport collections\n\nclass Topo(object):\n    def __init__(self):\n        self.__nodes = set()\n        self.__in_degree = collections.defaultdict(set)\n        self.__out_degree = collections.defaultdict(set)\n        \n    def add_node(self, node):\n        self.__nodes.add(node)\n    \n    def add_edge(self, src, dst):\n        self.add_node(src), self.add_node(dst)\n        self.__in_degree[dst].add(src)\n        self.__out_degree[src].add(dst)\n    \n    def sort(self):\n        q = collections.deque()\n        result = []\n        for node in self.__nodes:\n            if node not in self.__in_degree:\n                q.append(node)\n        while q:\n            node = q.popleft()\n            result.append(node)\n            for nei in self.__out_degree[node]:\n                self.__in_degree[nei].remove(node)\n                if not self.__in_degree[nei]:\n                    self.__in_degree.pop(nei)\n                    q.append(nei)\n        if len(result) < len(self.__nodes):\n            return\n        return result\n\nclass Solution(object):\n    def sortItems(self, n, m, group, beforeItems):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :type group: List[int]\n        :type beforeItems: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        for i in xrange(n):\n            if group[i] == -1:\n                group[i] = m\n                m += 1    \n        global_group = Topo()\n        for i in xrange(m):\n            global_group.add_node(i)\n        local_groups = collections.defaultdict(Topo)\n        for i in xrange(n):\n            local_groups[group[i]].add_node(i)\n        for i in xrange(n):\n            for j in beforeItems[i]:\n                if group[i] == group[j]:\n                    local_groups[group[i]].add_edge(j, i)\n                else:\n                    global_group.add_edge(group[j], group[i])\n        result = []\n        global_order = global_group.sort()\n        if global_order is None:\n            return []\n        for i in global_order:\n            local_order = local_groups[i].sort()\n            if local_order is None:\n                return []\n            for x in local_order:\n                result.append(x)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n + e)",
      "space_complexity": "O(n + e)"
    }
  ],
  "Union Find": [
    {
      "title": "Number of Provinces",
      "difficulty": "Medium",
      "category": "Union Find",
      "link": "https://leetcode.com/problems/number-of-provinces",
      "slug": "number-of-provinces",
      "description": "There are \nn\n cities. Some of them are connected, while some are not. If city \na\n is connected directly with city \nb\n, and city \nb\n is connected directly with city \nc\n, then city \na\n is connected indirectly with city \nc\n.\n\n\nA \nprovince\n is a group of directly or indirectly connected cities and no other cities outside of the group.\n\n\nYou are given an \nn x n\n matrix \nisConnected\n where \nisConnected[i][j] = 1\n if the \ni\nth\n city and the \nj\nth\n city are directly connected, and \nisConnected[i][j] = 0\n otherwise.\n\n\nReturn \nthe total number of \nprovinces\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 200\n\n\nn == isConnected.length\n\n\nn == isConnected[i].length\n\n\nisConnected[i][j]\n is \n1\n or \n0\n.\n\n\nisConnected[i][i] == 1\n\n\nisConnected[i][j] == isConnected[j][i]",
      "solution": "# Solution not found in kamyu104 repository",
      "explanation": "N/A",
      "time_complexity": "N/A",
      "space_complexity": "N/A"
    },
    {
      "title": "Redundant Connection",
      "difficulty": "Medium",
      "category": "Union Find",
      "link": "https://leetcode.com/problems/redundant-connection",
      "slug": "redundant-connection",
      "description": "In this problem, a tree is an \nundirected graph\n that is connected and has no cycles.\n\n\nYou are given a graph that started as a tree with \nn\n nodes labeled from \n1\n to \nn\n, with one additional edge added. The added edge has two \ndifferent\n vertices chosen from \n1\n to \nn\n, and was not an edge that already existed. The graph is represented as an array \nedges\n of length \nn\n where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the graph.\n\n\nReturn \nan edge that can be removed so that the resulting graph is a tree of \nn\n nodes\n. If there are multiple answers, return the answer that occurs last in the input.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n edges = [[1,2],[1,3],[2,3]]\n\nOutput:\n [2,3]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\n\nOutput:\n [1,4]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == edges.length\n\n\n3 <= n <= 1000\n\n\nedges[i].length == 2\n\n\n1 <= a\ni\n < b\ni\n <= edges.length\n\n\na\ni\n != b\ni\n\n\nThere are no repeated edges.\n\n\nThe given graph is connected.",
      "solution": "class UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        return True\n\nclass Solution(object):\n    def findRedundantConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        union_find = UnionFind(len(edges)+1)\n        for edge in edges:\n            if not union_find.union_set(*edge):\n                return edge\n        return []",
      "explanation": "N/A",
      "time_complexity": "O(nlog*n) ~= O(n), n is the length of the positions",
      "space_complexity": "O(n)"
    },
    {
      "title": "Accounts Merge",
      "difficulty": "Medium",
      "category": "Union Find",
      "link": "https://leetcode.com/problems/accounts-merge",
      "slug": "accounts-merge",
      "description": "Given a list of \naccounts\n where each element \naccounts[i]\n is a list of strings, where the first element \naccounts[i][0]\n is a name, and the rest of the elements are \nemails\n representing emails of the account.\n\n\nNow, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\n\n\nAfter merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails \nin sorted order\n. The accounts themselves can be returned in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\n\nOutput:\n [[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\n\nExplanation:\n\nThe first and second John's are the same person as they have the common email \"johnsmith@mail.com\".\nThe third John and Mary are different people as none of their email addresses are used by other accounts.\nWe could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], \n['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.\n\n\n\nExample 2:\n\n\n\n\nInput:\n accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]\n\nOutput:\n [[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= accounts.length <= 1000\n\n\n2 <= accounts[i].length <= 10\n\n\n1 <= accounts[i][j].length <= 30\n\n\naccounts[i][0]\n consists of English letters.\n\n\naccounts[i][j] (for j > 0)\n is a valid email.",
      "solution": "#                  and the max length ofemail is 320, p.s. {64}@{255}\n\nimport collections\n\nclass UnionFind(object):\n    def __init__(self):\n        self.set = []\n\n    def get_id(self):\n        self.set.append(len(self.set))\n        return len(self.set)-1\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root != y_root:\n            self.set[min(x_root, y_root)] = max(x_root, y_root)\n\nclass Solution(object):\n    def accountsMerge(self, accounts):\n        \"\"\"\n        :type accounts: List[List[str]]\n        :rtype: List[List[str]]\n        \"\"\"\n        union_find = UnionFind()\n        email_to_name = {}\n        email_to_id = {}\n        for account in accounts:\n            name = account[0]\n            for i in xrange(1, len(account)):\n                if account[i] not in email_to_id:\n                    email_to_name[account[i]] = name\n                    email_to_id[account[i]] = union_find.get_id()\n                union_find.union_set(email_to_id[account[1]],\n                                     email_to_id[account[i]])\n\n        result = collections.defaultdict(list)\n        for email in email_to_name.keys():\n            result[union_find.find_set(email_to_id[email])].append(email)\n        for emails in result.values():\n            emails.sort()\n        return [[email_to_name[emails[0]]] + emails\n                for emails in result.values()]",
      "explanation": "N/A",
      "time_complexity": "O(nlogn), n is the number of total emails,",
      "space_complexity": "O(n)"
    },
    {
      "title": "Minimize Malware Spread",
      "difficulty": "Hard",
      "category": "Union Find",
      "link": "https://leetcode.com/problems/minimize-malware-spread",
      "slug": "minimize-malware-spread",
      "description": "You are given a network of \nn\n nodes represented as an \nn x n\n adjacency matrix \ngraph\n, where the \ni\nth\n node is directly connected to the \nj\nth\n node if \ngraph[i][j] == 1\n.\n\n\nSome nodes \ninitial\n are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\n\n\nSuppose \nM(initial)\n is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove \nexactly one node\n from \ninitial\n.\n\n\nReturn the node that, if removed, would minimize \nM(initial)\n. If multiple nodes could be removed to minimize \nM(initial)\n, return such a node with \nthe smallest index\n.\n\n\nNote that if a node was removed from the \ninitial\n list of infected nodes, it might still be infected later due to the malware spread.\n\n\n \n\n\nExample 1:\n\n\nInput:\n graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\n\nOutput:\n 0\n\nExample 2:\n\n\nInput:\n graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]\n\nOutput:\n 0\n\nExample 3:\n\n\nInput:\n graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == graph.length\n\n\nn == graph[i].length\n\n\n2 <= n <= 300\n\n\ngraph[i][j]\n is \n0\n or \n1\n.\n\n\ngraph[i][j] == graph[j][i]\n\n\ngraph[i][i] == 1\n\n\n1 <= initial.length <= n\n\n\n0 <= initial[i] <= n - 1\n\n\nAll the integers in \ninitial\n are \nunique\n.",
      "solution": "\nimport collections\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        return True\n\nclass Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        \"\"\"\n        :type graph: List[List[int]]\n        :type initial: List[int]\n        :rtype: int\n        \"\"\"\n        union_find = UnionFind(len(graph))\n        for i in xrange(len(graph)):\n            for j in xrange(i+1, len(graph)):\n                if graph[i][j] == 1:\n                    union_find.union_set(i, j)\n        union_size = collections.Counter(union_find.find_set(i) for i in xrange(len(graph)))\n        malware_count = collections.Counter(union_find.find_set(i) for i in initial)\n        return min(initial, key=lambda x: [malware_count[union_find.find_set(x)] > 1,\n                                           -union_size[union_find.find_set(x)],\n                                           x])",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n)"
    }
  ],
  "Minimum Spanning Tree": [
    {
      "title": "Min Cost to Connect All Points",
      "difficulty": "Medium",
      "category": "Minimum Spanning Tree",
      "link": "https://leetcode.com/problems/min-cost-to-connect-all-points",
      "slug": "min-cost-to-connect-all-points",
      "description": "You are given an array \npoints\n representing integer coordinates of some points on a 2D-plane, where \npoints[i] = [x\ni\n, y\ni\n]\n.\n\n\nThe cost of connecting two points \n[x\ni\n, y\ni\n]\n and \n[x\nj\n, y\nj\n]\n is the \nmanhattan distance\n between them: \n|x\ni\n - x\nj\n| + |y\ni\n - y\nj\n|\n, where \n|val|\n denotes the absolute value of \nval\n.\n\n\nReturn \nthe minimum cost to make all points connected.\n All points are connected if there is \nexactly one\n simple path between any two points.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\n\nOutput:\n 20\n\nExplanation:\n \n\n\nWe can connect the points as shown above to get the minimum cost of 20.\nNotice that there is a unique path between every pair of points.\n\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[3,12],[-2,5],[-4,1]]\n\nOutput:\n 18\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= points.length <= 1000\n\n\n-10\n6\n <= x\ni\n, y\ni\n <= 10\n6\n\n\nAll pairs \n(x\ni\n, y\ni\n)\n are distinct.",
      "solution": "class Solution(object):\n    def minCostConnectPoints(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        result, u = 0, 0  # we can start from any node as u\n        dist = [float(\"inf\")]*len(points)\n        lookup = set()\n        for _ in xrange(len(points)-1):\n            x0, y0 = points[u]\n            lookup.add(u)\n            for v, (x, y) in enumerate(points):\n                if v in lookup:\n                    continue\n                dist[v] = min(dist[v], abs(x-x0) + abs(y-y0))\n            val, u = min((val, v) for v, val in enumerate(dist)) \n            dist[u] = float(\"inf\")  # used\n            result += val\n        return result\n\n\n\n# kruskal's algorithmclass UnionFind(object):  # Time: O(n * α(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        if self.rank[x_root] < self.rank[y_root]:  # union by rank\n            self.set[x_root] = y_root\n        elif self.rank[x_root] > self.rank[y_root]:\n            self.set[y_root] = x_root\n        else:\n            self.set[y_root] = x_root\n            self.rank[x_root] += 1\n        return True\n\nclass Solution2(object):\n    def minCostConnectPoints(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        edges = []\n        for u in xrange(len(points)):\n            for v in xrange(u+1, len(points)):\n                edges.append((u, v, abs(points[v][0]-points[u][0]) + abs(points[v][1]-points[u][1])))\n        edges.sort(key=lambda x: x[2])\n        result = 0\n        union_find = UnionFind(len(points))\n        for u, v, val in edges:\n            if union_find.union_set(u, v):\n                result += val\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(eloge) = O(n^2 * logn)",
      "space_complexity": "O(e) = O(n^2)"
    }
  ],
  "Shortest Path": [
    {
      "title": "Network Delay Time",
      "difficulty": "Medium",
      "category": "Shortest Path",
      "link": "https://leetcode.com/problems/network-delay-time",
      "slug": "network-delay-time",
      "description": "You are given a network of \nn\n nodes, labeled from \n1\n to \nn\n. You are also given \ntimes\n, a list of travel times as directed edges \ntimes[i] = (u\ni\n, v\ni\n, w\ni\n)\n, where \nu\ni\n is the source node, \nv\ni\n is the target node, and \nw\ni\n is the time it takes for a signal to travel from source to target.\n\n\nWe will send a signal from a given node \nk\n. Return \nthe \nminimum\n time it takes for all the\n \nn\n \nnodes to receive the signal\n. If it is impossible for all the \nn\n nodes to receive the signal, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n times = [[1,2,1]], n = 2, k = 1\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\nInput:\n times = [[1,2,1]], n = 2, k = 2\n\nOutput:\n -1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= n <= 100\n\n\n1 <= times.length <= 6000\n\n\ntimes[i].length == 3\n\n\n1 <= u\ni\n, v\ni\n <= n\n\n\nu\ni\n != v\ni\n\n\n0 <= w\ni\n <= 100\n\n\nAll the pairs \n(u\ni\n, v\ni\n)\n are \nunique\n. (i.e., no multiple edges.)",
      "solution": "#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)\n\nimport collections\nimport heapq\n\n# Dijkstra's algorithmclass Solution(object):\n    def networkDelayTime(self, times, N, K):\n        \"\"\"\n        :type times: List[List[int]]\n        :type N: int\n        :type K: int\n        :rtype: int\n        \"\"\"\n        adj = [[] for _ in xrange(N)]\n        for u, v, w in times:\n            adj[u-1].append((v-1, w))\n\n        result = 0\n        lookup = set()\n        best = collections.defaultdict(lambda: float(\"inf\"))\n        best[K-1] = 0\n        min_heap = [(0, K-1)]\n        while min_heap and len(lookup) != N:\n            result, u = heapq.heappop(min_heap)\n            lookup.add(u)\n            if best[u] < result:\n                continue\n            for v, w in adj[u]:\n                if v in lookup: continue\n                if result+w < best[v]:\n                    best[v] = result+w\n                    heapq.heappush(min_heap, (result+w, v))\n        return result if len(lookup) == N else -1",
      "explanation": "N/A",
      "time_complexity": "O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,",
      "space_complexity": "O(|E| + |V|) = O(|E|)"
    },
    {
      "title": "Cheapest Flights Within K Stops",
      "difficulty": "Medium",
      "category": "Shortest Path",
      "link": "https://leetcode.com/problems/cheapest-flights-within-k-stops",
      "slug": "cheapest-flights-within-k-stops",
      "description": "There are \nn\n cities connected by some number of flights. You are given an array \nflights\n where \nflights[i] = [from\ni\n, to\ni\n, price\ni\n]\n indicates that there is a flight from city \nfrom\ni\n to city \nto\ni\n with cost \nprice\ni\n.\n\n\nYou are also given three integers \nsrc\n, \ndst\n, and \nk\n, return \nthe cheapest price\n from \nsrc\n to \ndst\n with at most \nk\n stops. \nIf there is no such route, return\n \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1\n\nOutput:\n 700\n\nExplanation:\n\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\nNote that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1\n\nOutput:\n 200\n\nExplanation:\n\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0\n\nOutput:\n 500\n\nExplanation:\n\nThe graph is shown above.\nThe optimal path with no stops from city 0 to 2 is marked in red and has cost 500.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100\n\n\n0 <= flights.length <= (n * (n - 1) / 2)\n\n\nflights[i].length == 3\n\n\n0 <= from\ni\n, to\ni\n < n\n\n\nfrom\ni\n != to\ni\n\n\n1 <= price\ni\n <= 10\n4\n\n\nThere will not be any multiple flights between two cities.\n\n\n0 <= src, dst, k < n\n\n\nsrc != dst",
      "solution": "#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)\n\nimport collections\nimport heapq\n\nclass Solution(object):\n    def findCheapestPrice(self, n, flights, src, dst, K):\n        \"\"\"\n        :type n: int\n        :type flights: List[List[int]]\n        :type src: int\n        :type dst: int\n        :type K: int\n        :rtype: int\n        \"\"\"\n        adj = collections.defaultdict(list)\n        for u, v, w in flights:\n            adj[u].append((v, w))\n        best = collections.defaultdict(lambda: collections.defaultdict(lambda: float(\"inf\")))\n        best[src][K+1] = 0\n        min_heap = [(0, src, K+1)]\n        while min_heap:\n            result, u, k = heapq.heappop(min_heap)\n            if k < 0 or best[u][k] < result:\n                continue\n            if u == dst:\n                return result\n            for v, w in adj[u]:\n                if result+w < best[v][k-1]:\n                    best[v][k-1] = result+w                    \n                    heapq.heappush(min_heap, (result+w, v, k-1))\n        return -1",
      "explanation": "N/A",
      "time_complexity": "O((|E| + |V|) * log|V|) = O(|E| * log|V|),",
      "space_complexity": "O(|E| + |V|) = O(|E|)"
    },
    {
      "title": "Path with Maximum Probability",
      "difficulty": "Medium",
      "category": "Shortest Path",
      "link": "https://leetcode.com/problems/path-with-maximum-probability",
      "slug": "path-with-maximum-probability",
      "description": "You are given an undirected weighted graph of \nn\n nodes (0-indexed), represented by an edge list where \nedges[i] = [a, b]\n is an undirected edge connecting the nodes \na\n and \nb\n with a probability of success of traversing that edge \nsuccProb[i]\n.\n\n\nGiven two nodes \nstart\n and \nend\n, find the path with the maximum probability of success to go from \nstart\n to \nend\n and return its success probability.\n\n\nIf there is no path from \nstart\n to \nend\n, \nreturn 0\n. Your answer will be accepted if it differs from the correct answer by at most \n1e-5\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2\n\nOutput:\n 0.25000\n\nExplanation:\n There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2\n\nOutput:\n 0.30000\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2\n\nOutput:\n 0.00000\n\nExplanation:\n There is no path between 0 and 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10^4\n\n\n0 <= start, end < n\n\n\nstart != end\n\n\n0 <= a, b < n\n\n\na != b\n\n\n0 <= succProb.length == edges.length <= 2*10^4\n\n\n0 <= succProb[i] <= 1\n\n\nThere is at most one edge between every two nodes.",
      "solution": "#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)\n\nimport collections\nimport itertools\nimport heapq\n\nclass Solution(object):\n    def maxProbability(self, n, edges, succProb, start, end):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type succProb: List[float]\n        :type start: int\n        :type end: int\n        :rtype: float\n        \"\"\"\n        adj = collections.defaultdict(list)\n        for (u, v), p in itertools.izip(edges, succProb):\n            adj[u].append((v, p))\n            adj[v].append((u, p))\n        max_heap = [(-1.0, start)]\n        result, lookup = collections.defaultdict(float), set()\n        result[start] = 1.0\n        while max_heap and len(lookup) != len(adj):\n            curr, u = heapq.heappop(max_heap)\n            if u in lookup:\n                continue\n            lookup.add(u)\n            for v, w in adj[u]:\n                if v in lookup:\n                    continue\n                if v in result and result[v] >= -curr*w:\n                    continue\n                result[v] = -curr*w\n                heapq.heappush(max_heap, (-result[v], v))\n        return result[end]",
      "explanation": "N/A",
      "time_complexity": "O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,",
      "space_complexity": "O(|E| + |V|) = O(|E|)"
    },
    {
      "title": "Path With Minimum Effort",
      "difficulty": "Medium",
      "category": "Shortest Path",
      "link": "https://leetcode.com/problems/path-with-minimum-effort",
      "slug": "path-with-minimum-effort",
      "description": "You are a hiker preparing for an upcoming hike. You are given \nheights\n, a 2D array of size \nrows x columns\n, where \nheights[row][col]\n represents the height of cell \n(row, col)\n. You are situated in the top-left cell, \n(0, 0)\n, and you hope to travel to the bottom-right cell, \n(rows-1, columns-1)\n (i.e., \n0-indexed\n). You can move \nup\n, \ndown\n, \nleft\n, or \nright\n, and you wish to find a route that requires the minimum \neffort\n.\n\n\nA route's \neffort\n is the \nmaximum absolute difference\n \nin heights between two consecutive cells of the route.\n\n\nReturn \nthe minimum \neffort\n required to travel from the top-left cell to the bottom-right cell.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [[1,2,2],[3,8,2],[5,3,5]]\n\nOutput:\n 2\n\nExplanation:\n The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.\nThis is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n heights = [[1,2,3],[3,8,4],[5,3,5]]\n\nOutput:\n 1\n\nExplanation:\n The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]\n\nOutput:\n 0\n\nExplanation:\n This route does not require any effort.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nrows == heights.length\n\n\ncolumns == heights[i].length\n\n\n1 <= rows, columns <= 100\n\n\n1 <= heights[i][j] <= 10\n6",
      "solution": "\nimport heapq\n\n\n# Dijkstra algorithm solutionclass Solution(object):\n    def minimumEffortPath(self, heights):\n        \"\"\"\n        :type heights: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dst = (len(heights)-1, len(heights[0])-1)\n        dist = [[float(\"inf\")]*len(heights[0]) for _ in xrange(len(heights))]\n        dist[0][0] = 0\n        min_heap = [(0, 0, 0)]\n        lookup = [[False]*len(heights[0]) for _ in xrange(len(heights))]\n        while min_heap:\n            d, r, c = heapq.heappop(min_heap)\n            if lookup[r][c]:\n                continue\n            lookup[r][c] = True\n            if (r, c) == dst:\n                return d\n            for dr, dc in directions:\n                nr, nc = r+dr, c+dc\n                if not (0 <= nr < len(heights) and 0 <= nc < len(heights[0]) and not lookup[nr][nc]):\n                    continue\n                nd = max(d, abs(heights[nr][nc]-heights[r][c]))\n                if nd < dist[nr][nc]:\n                    dist[nr][nc] = nd\n                    heapq.heappush(min_heap, (nd, nr, nc))\n        return -1\n\n\nimport collections\n\nclass UnionFind(object):  # Time: O(n * α(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        if self.rank[x_root] < self.rank[y_root]:  # union by rank\n            self.set[x_root] = y_root\n        elif self.rank[x_root] > self.rank[y_root]:\n            self.set[y_root] = x_root\n        else:\n            self.set[y_root] = x_root\n            self.rank[x_root] += 1\n        return True\n\n\n# union find solutionclass Solution2(object):\n    def minimumEffortPath(self, heights):\n        \"\"\"\n        :type heights: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def index(n, i, j):\n            return i*n + j\n    \n        diffs = []\n        for i in xrange(len(heights)):\n            for j in xrange(len(heights[0])):\n                if i > 0:\n                    diffs.append((abs(heights[i][j]-heights[i-1][j]), index(len(heights[0]), i-1, j), index(len(heights[0]), i, j)))\n                if j > 0:\n                    diffs.append((abs(heights[i][j]-heights[i][j-1]), index(len(heights[0]), i, j-1), index(len(heights[0]), i, j)))\n        diffs.sort()\n        union_find = UnionFind(len(heights)*len(heights[0]))\n        for d, i, j in diffs:\n            if union_find.union_set(i, j):\n                if union_find.find_set(index(len(heights[0]), 0, 0)) == \\\n                   union_find.find_set(index(len(heights[0]), len(heights)-1, len(heights[0])-1)):\n                    return d\n        return 0\n\n\n# bi-bfs solutionclass Solution3(object):\n    def minimumEffortPath(self, heights):\n        \"\"\"\n        :type heights: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def check(heights, x):  # bi-bfs\n            lookup = [[False]*len(heights[0]) for _ in xrange(len(heights))]\n            left, right = {(0, 0)}, {(len(heights)-1, len(heights[0])-1)}\n            while left:\n                for r, c in left:\n                    lookup[r][c] = True\n                new_left = set()\n                for r, c in left:\n                    if (r, c) in right: \n                        return True\n                    for dr, dc in directions:\n                        nr, nc = r+dr, c+dc\n                        if not (0 <= nr < len(heights) and\n                                0 <= nc < len(heights[0]) and\n                                abs(heights[nr][nc]-heights[r][c]) <= x and\n                                not lookup[nr][nc]):\n                            continue\n                        new_left.add((nr, nc))\n                left = new_left\n                if len(left) > len(right): \n                    left, right = right, left\n            return False            \n        \n\n        left, right = 0, 10**6\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(heights, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n\n\nimport collections\n\n\n# bfs solutionclass Solution4(object):\n    def minimumEffortPath(self, heights):\n        \"\"\"\n        :type heights: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def check(heights, x):\n            lookup = [[False]*len(heights[0]) for _ in xrange(len(heights))]\n            q = collections.deque([(0, 0)])\n            while q:\n                r, c = q.popleft()\n                if (r, c) == (len(heights)-1, len(heights[0])-1):\n                    return True\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(heights) and\n                                0 <= nc < len(heights[0]) and\n                                abs(heights[nr][nc]-heights[r][c]) <= x and\n                                not lookup[nr][nc]):\n                            continue\n                    lookup[nr][nc] = True\n                    q.append((nr, nc))\n            return False            \n        \n        left, right = 0, 10**6\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(heights, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n\n\n# dfs solutionclass Solution5(object):\n    def minimumEffortPath(self, heights):\n        \"\"\"\n        :type heights: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def check(heights, x):\n            lookup = [[False]*len(heights[0]) for _ in xrange(len(heights))]\n            stk = [(0, 0)]\n            while stk:\n                r, c = stk.pop()\n                if (r, c) == (len(heights)-1, len(heights[0])-1):\n                    return True\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(heights) and\n                                0 <= nc < len(heights[0]) and\n                                abs(heights[nr][nc]-heights[r][c]) <= x and\n                                not lookup[nr][nc]):\n                            continue\n                    lookup[nr][nc] = True\n                    stk.append((nr, nc))\n            return False            \n        \n        left, right = 0, 10**6\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(heights, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left",
      "explanation": "N/A",
      "time_complexity": "O(m * n * logh)",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "Swim in Rising Water",
      "difficulty": "Hard",
      "category": "Shortest Path",
      "link": "https://leetcode.com/problems/swim-in-rising-water",
      "slug": "swim-in-rising-water",
      "description": "You are given an \nn x n\n integer matrix \ngrid\n where each value \ngrid[i][j]\n represents the elevation at that point \n(i, j)\n.\n\n\nIt starts raining, and water gradually rises over time. At time \nt\n, the water level is \nt\n, meaning \nany\n cell with elevation less than equal to \nt\n is submerged or reachable.\n\n\nYou can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most \nt\n. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n\n\nReturn \nthe minimum time until you can reach the bottom right square \n(n - 1, n - 1)\n if you start at the top left square \n(0, 0)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,2],[1,3]]\n\nOutput:\n 3\nExplanation:\nAt time 0, you are in grid location (0, 0).\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\n\nOutput:\n 16\n\nExplanation:\n The final route is shown.\nWe need to wait until time 16 so that (0, 0) and (4, 4) are connected.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\nn == grid[i].length\n\n\n1 <= n <= 50\n\n\n0 <= grid[i][j] < n\n2\n\n\nEach value \ngrid[i][j]\n is \nunique\n.",
      "solution": "class UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        return True\n\nclass Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        positions = [None] * (n**2)\n        for i in xrange(n):\n            for j in xrange(n):\n                positions[grid[i][j]] = (i, j)\n        directions = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n        union_find = UnionFind(n**2)\n        for elevation in xrange(n**2):\n            i, j = positions[elevation]\n            for direction in directions:\n                x, y = i+direction[0], j+direction[1]\n                if 0 <= x < n and 0 <= y < n and grid[x][y] <= elevation:\n                    union_find.union_set(i*n+j, x*n+y)\n                    if union_find.find_set(0) == union_find.find_set(n**2-1):\n                        return elevation\n        return n**2-1",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n^2)"
    }
  ],
  "Eulerian Circuit": [
    {
      "title": "Reconstruct Itinerary",
      "difficulty": "Hard",
      "category": "Eulerian Circuit",
      "link": "https://leetcode.com/problems/reconstruct-itinerary",
      "slug": "reconstruct-itinerary",
      "description": "You are given a list of airline \ntickets\n where \ntickets[i] = [from\ni\n, to\ni\n]\n represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\n\n\nAll of the tickets belong to a man who departs from \n\"JFK\"\n, thus, the itinerary must begin with \n\"JFK\"\n. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\n\n\n\n\nFor example, the itinerary \n[\"JFK\", \"LGA\"]\n has a smaller lexical order than \n[\"JFK\", \"LGB\"]\n.\n\n\n\n\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\n\nOutput:\n [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\n\nOutput:\n [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\n\nExplanation:\n Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it is larger in lexical order.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= tickets.length <= 300\n\n\ntickets[i].length == 2\n\n\nfrom\ni\n.length == 3\n\n\nto\ni\n.length == 3\n\n\nfrom\ni\n and \nto\ni\n consist of uppercase English letters.\n\n\nfrom\ni\n != to\ni",
      "solution": "\n# Hierholzer Algorithm\nimport collections\n\nclass Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        for ticket in tickets:\n            adj[ticket[0]].append(ticket[1])\n        for x in adj.itervalues():\n            x.sort(reverse=True)\n        origin = \"JFK\"\n        result = []\n        stk = [origin]\n        while stk:\n            while adj[stk[-1]]: \n                stk.append(adj[stk[-1]].pop())\n            result.append(stk.pop())\n        result.reverse()\n        return result\n\n\n#                                       ni is the number of the ticket which from is city i,\n#                                       k is the total number of cities.\nimport collections\n\nclass Solution2(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        def route_helper(origin, ticket_cnt, graph, ans):\n            if ticket_cnt == 0:\n                return True\n\n            for i, (dest, valid)  in enumerate(graph[origin]):\n                if valid:\n                    graph[origin][i][1] = False\n                    ans.append(dest)\n                    if route_helper(dest, ticket_cnt - 1, graph, ans):\n                        return ans\n                    ans.pop()\n                    graph[origin][i][1] = True\n            return False\n\n        graph = collections.defaultdict(list)\n        for ticket in tickets:\n            graph[ticket[0]].append([ticket[1], True])\n        for k in graph.keys():\n            graph[k].sort()\n\n        origin = \"JFK\"\n        ans = [origin]\n        route_helper(origin, len(tickets), graph, ans)\n        return ans",
      "explanation": "N/A",
      "time_complexity": "O(t! / (n1! * n2! * ... nk!)), t is the total number of tickets,",
      "space_complexity": "O(t)"
    },
    {
      "title": "Cracking the Safe",
      "difficulty": "Hard",
      "category": "Eulerian Circuit",
      "link": "https://leetcode.com/problems/cracking-the-safe",
      "slug": "cracking-the-safe",
      "description": "There is a safe protected by a password. The password is a sequence of \nn\n digits where each digit can be in the range \n[0, k - 1]\n.\n\n\nThe safe has a peculiar way of checking the password. When you enter in a sequence, it checks the \nmost recent \nn\n digits\n that were entered each time you type a digit.\n\n\n\n\nFor example, the correct password is \n\"345\"\n and you enter in \n\"012345\"\n:\n\n\t\n\n\nAfter typing \n0\n, the most recent \n3\n digits is \n\"0\"\n, which is incorrect.\n\n\nAfter typing \n1\n, the most recent \n3\n digits is \n\"01\"\n, which is incorrect.\n\n\nAfter typing \n2\n, the most recent \n3\n digits is \n\"012\"\n, which is incorrect.\n\n\nAfter typing \n3\n, the most recent \n3\n digits is \n\"123\"\n, which is incorrect.\n\n\nAfter typing \n4\n, the most recent \n3\n digits is \n\"234\"\n, which is incorrect.\n\n\nAfter typing \n5\n, the most recent \n3\n digits is \n\"345\"\n, which is correct and the safe unlocks.\n\n\n\n\n\n\n\n\nReturn \nany string of \nminimum length\n that will unlock the safe \nat some point\n of entering it\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 1, k = 2\n\nOutput:\n \"10\"\n\nExplanation:\n The password is a single digit, so enter each digit. \"01\" would also unlock the safe.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2, k = 2\n\nOutput:\n \"01100\"\n\nExplanation:\n For each possible password:\n- \"00\" is typed in starting from the 4\nth\n digit.\n- \"01\" is typed in starting from the 1\nst\n digit.\n- \"10\" is typed in starting from the 3\nrd\n digit.\n- \"11\" is typed in starting from the 2\nnd\n digit.\nThus \"01100\" will unlock the safe. \"10011\", and \"11001\" would also unlock the safe.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 4\n\n\n1 <= k <= 10\n\n\n1 <= k\nn\n <= 4096",
      "solution": "class Solution(object):\n    def crackSafe(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        M = k**(n-1)\n        P = [q*k+i for i in xrange(k) for q in xrange(M)]  # rotate: i*k^(n-1) + q => q*k + i\n        result = [str(k-1)]*(n-1)\n        for i in xrange(k**n):\n            j = i\n            # concatenation in lexicographic order of Lyndon words\n            while P[j] >= 0:\n                result.append(str(j//M))\n                P[j], j = -1, P[j]\n        return \"\".join(result)\n\nclass Solution2(object):\n    def crackSafe(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        total = k**n\n        M = total//k\n        unique_rolling_hash = 0\n        result = [str(0)]*(n-1)\n        lookup = set()\n        while len(lookup) < total:\n            for i in reversed(xrange(k)):  # preorder like traversal relative to initial result to avoid getting stuck, i.e. don't use 0 until there is no other choice\n                new_unique_rolling_hash = unique_rolling_hash*k + i\n                if new_unique_rolling_hash not in lookup:\n                    lookup.add(new_unique_rolling_hash)\n                    result.append(str(i))\n                    unique_rolling_hash = new_unique_rolling_hash%M\n                    break\n        return \"\".join(result)\n\nclass Solution3(object):\n    def crackSafe(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        M = k**(n-1)\n        def dfs(k, unique_rolling_hash, lookup, result):\n            for i in reversed(xrange(k)):  # preorder like traversal relative to initial result to avoid getting stuck, i.e. don't use 0 until there is no other choice\n                new_unique_rolling_hash = unique_rolling_hash*k + i\n                if new_unique_rolling_hash not in lookup:\n                    lookup.add(new_unique_rolling_hash)\n                    result.append(str(i))\n                    dfs(k, new_unique_rolling_hash%M, lookup, result)\n                    break\n\n        unique_rolling_hash = 0\n        result = [str(0)]*(n-1)\n        lookup = set()\n        dfs(k, unique_rolling_hash, lookup, result)\n        return \"\".join(result)\n\nclass Solution4(object):\n    def crackSafe(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        result = [str(k-1)]*(n-1)\n        lookup = set()\n        total = k**n\n        while len(lookup) < total:\n            node = result[len(result)-n+1:]\n            for i in xrange(k):  # preorder like traversal relative to initial result to avoid getting stuck, i.e. don't use k-1 until there is no other choice\n                neighbor = \"\".join(node) + str(i)\n                if neighbor not in lookup:\n                    lookup.add(neighbor)\n                    result.append(str(i))\n                    break\n        return \"\".join(result)\n\nclass Solution5(object):\n    def crackSafe(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        def dfs(k, node, lookup, result):\n            for i in xrange(k):  # preorder like traversal relative to initial result to avoid getting stuck, i.e. don't use k-1 until there is no other choice\n                neighbor = node + str(i)\n                if neighbor not in lookup:\n                    lookup.add(neighbor)\n                    result.append(str(i))\n                    dfs(k, neighbor[1:], lookup, result)\n                    break\n\n        result = [str(k-1)]*(n-1)\n        lookup = set()\n        dfs(k, \"\".join(result), lookup, result)\n        return \"\".join(result)",
      "explanation": "N/A",
      "time_complexity": "O(n * k^n)",
      "space_complexity": "O(n * k^n)"
    }
  ],
  "1-D DP": [
    {
      "title": "Climbing Stairs",
      "difficulty": "Easy",
      "category": "1-D DP",
      "link": "https://leetcode.com/problems/climbing-stairs",
      "slug": "climbing-stairs",
      "description": "You are climbing a staircase. It takes \nn\n steps to reach the top.\n\n\nEach time you can either climb \n1\n or \n2\n steps. In how many distinct ways can you climb to the top?\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 2\n\nExplanation:\n There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 3\n\nExplanation:\n There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 45",
      "solution": "\nimport itertools\n\nclass Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def matrix_expo(A, K):\n            result = [[int(i==j) for j in xrange(len(A))] \\\n                      for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b for a, b in itertools.izip(row, col)) \\\n                     for col in ZB] for row in A]\n\n        T = [[1, 1],\n             [1, 0]]\n        return matrix_mult([[1,  0]], matrix_expo(T, n))[0][0]  # [a0, a(-1)] * T^n\n\nclass Solution2(object):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    def climbStairs(self, n):\n        prev, current = 0, 1\n        for i in xrange(n):\n            prev, current = current, prev + current,\n        return current",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Min Cost Climbing Stairs",
      "difficulty": "Easy",
      "category": "1-D DP",
      "link": "https://leetcode.com/problems/min-cost-climbing-stairs",
      "slug": "min-cost-climbing-stairs",
      "description": "You are given an integer array \ncost\n where \ncost[i]\n is the cost of \ni\nth\n step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\n\nYou can either start from the step with index \n0\n, or the step with index \n1\n.\n\n\nReturn \nthe minimum cost to reach the top of the floor\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n cost = [10,\n15\n,20]\n\nOutput:\n 15\n\nExplanation:\n You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n\n\nExample 2:\n\n\n\n\nInput:\n cost = [\n1\n,100,\n1\n,1,\n1\n,100,\n1\n,\n1\n,100,\n1\n]\n\nOutput:\n 6\n\nExplanation:\n You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= cost.length <= 1000\n\n\n0 <= cost[i] <= 999",
      "solution": "class Solution(object):\n    def minCostClimbingStairs(self, cost):\n        \"\"\"\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [0] * 3\n        for i in reversed(xrange(len(cost))):\n            dp[i%3] = cost[i] + min(dp[(i+1)%3], dp[(i+2)%3])\n        return min(dp[0], dp[1])",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "House Robber",
      "difficulty": "Medium",
      "category": "1-D DP",
      "link": "https://leetcode.com/problems/house-robber",
      "slug": "house-robber",
      "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and \nit will automatically contact the police if two adjacent houses were broken into on the same night\n.\n\n\nGiven an integer array \nnums\n representing the amount of money of each house, return \nthe maximum amount of money you can rob tonight \nwithout alerting the police\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,1]\n\nOutput:\n 4\n\nExplanation:\n Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,7,9,3,1]\n\nOutput:\n 12\n\nExplanation:\n Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 400",
      "solution": "class Solution(object):\n    # @param num, a list of integer\n    # @return an integer\n    def rob(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        last, now = 0, 0\n        for i in nums:\n            last, now = now, max(last + i, now)\n        return now",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "House Robber II",
      "difficulty": "Medium",
      "category": "1-D DP",
      "link": "https://leetcode.com/problems/house-robber-ii",
      "slug": "house-robber-ii",
      "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are \narranged in a circle.\n That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and \nit will automatically contact the police if two adjacent houses were broken into on the same night\n.\n\n\nGiven an integer array \nnums\n representing the amount of money of each house, return \nthe maximum amount of money you can rob tonight \nwithout alerting the police\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,3,2]\n\nOutput:\n 3\n\nExplanation:\n You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,3,1]\n\nOutput:\n 4\n\nExplanation:\n Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 1000",
      "solution": "class Solution(object):\n    # @param {integer[]} nums\n    # @return {integer}\n    def rob(self, nums):\n        if len(nums) == 0:\n            return 0\n\n        if len(nums) == 1:\n            return nums[0]\n\n        return max(self.robRange(nums, 0, len(nums) - 1),\\\n                   self.robRange(nums, 1, len(nums)))\n\n    def robRange(self, nums, start, end):\n        num_i, num_i_1 = nums[start], 0\n        for i in xrange(start + 1, end):\n            num_i_1, num_i_2 = num_i, num_i_1\n            num_i = max(nums[i] + num_i_2, num_i_1)\n\n        return num_i",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    }
  ],
  "Knapsack DP": [
    {
      "title": "Partition Equal Subset Sum",
      "difficulty": "Medium",
      "category": "Knapsack DP",
      "link": "https://leetcode.com/problems/partition-equal-subset-sum",
      "slug": "partition-equal-subset-sum",
      "description": "Given an integer array \nnums\n, return \ntrue\n \nif you can partition the array into two subsets such that the sum of the elements in both subsets is equal or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,5,11,5]\n\nOutput:\n true\n\nExplanation:\n The array can be partitioned as [1, 5, 5] and [11].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,3,5]\n\nOutput:\n false\n\nExplanation:\n The array cannot be partitioned into equal sum subsets.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 200\n\n\n1 <= nums[i] <= 100",
      "solution": "class Solution(object):\n    def canPartition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        s = sum(nums)\n        if s % 2:\n            return False\n\n        dp = [False] * (s/2 + 1)\n        dp[0] = True\n        for num in nums:\n            for i in reversed(xrange(1, len(dp))):\n                if num <= i:\n                    dp[i] = dp[i] or dp[i - num]\n        return dp[-1]",
      "explanation": "N/A",
      "time_complexity": "O(n * s), s is the sum of nums",
      "space_complexity": "O(s)"
    },
    {
      "title": "Target Sum",
      "difficulty": "Medium",
      "category": "Knapsack DP",
      "link": "https://leetcode.com/problems/target-sum",
      "slug": "target-sum",
      "description": "You are given an integer array \nnums\n and an integer \ntarget\n.\n\n\nYou want to build an \nexpression\n out of nums by adding one of the symbols \n'+'\n and \n'-'\n before each integer in nums and then concatenate all the integers.\n\n\n\n\nFor example, if \nnums = [2, 1]\n, you can add a \n'+'\n before \n2\n and a \n'-'\n before \n1\n and concatenate them to build the expression \n\"+2-1\"\n.\n\n\n\n\nReturn the number of different \nexpressions\n that you can build, which evaluates to \ntarget\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,1,1,1], target = 3\n\nOutput:\n 5\n\nExplanation:\n There are 5 ways to assign symbols to make the sum of nums be target 3.\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1], target = 1\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 20\n\n\n0 <= nums[i] <= 1000\n\n\n0 <= sum(nums[i]) <= 1000\n\n\n-1000 <= target <= 1000",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def findTargetSumWays(self, nums, S):\n        \"\"\"\n        :type nums: List[int]\n        :type S: int\n        :rtype: int\n        \"\"\"\n        def subsetSum(nums, S):\n            dp = collections.defaultdict(int)\n            dp[0] = 1\n            for n in nums:\n                for i in reversed(xrange(n, S+1)):\n                    if i-n in dp:\n                        dp[i] += dp[i-n]\n            return dp[S]\n\n        total = sum(nums)\n        if total < S or (S + total) % 2: return 0\n        P = (S + total) // 2\n        return subsetSum(nums, P)",
      "explanation": "N/A",
      "time_complexity": "O(n * S)",
      "space_complexity": "O(S)"
    },
    {
      "title": "Last Stone Weight II",
      "difficulty": "Medium",
      "category": "Knapsack DP",
      "link": "https://leetcode.com/problems/last-stone-weight-ii",
      "slug": "last-stone-weight-ii",
      "description": "You are given an array of integers \nstones\n where \nstones[i]\n is the weight of the \ni\nth\n stone.\n\n\nWe are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights \nx\n and \ny\n with \nx <= y\n. The result of this smash is:\n\n\n\n\nIf \nx == y\n, both stones are destroyed, and\n\n\nIf \nx != y\n, the stone of weight \nx\n is destroyed, and the stone of weight \ny\n has new weight \ny - x\n.\n\n\n\n\nAt the end of the game, there is \nat most one\n stone left.\n\n\nReturn \nthe smallest possible weight of the left stone\n. If there are no stones left, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n stones = [2,7,4,1,8,1]\n\nOutput:\n 1\n\nExplanation:\n\nWe can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,\nwe can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,\nwe can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,\nwe can combine 1 and 1 to get 0, so the array converts to [1], then that's the optimal value.\n\n\n\nExample 2:\n\n\n\n\nInput:\n stones = [31,26,33,21,40]\n\nOutput:\n 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= stones.length <= 30\n\n\n1 <= stones[i] <= 100",
      "solution": "class Solution(object):\n    def lastStoneWeightII(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: int\n        \"\"\"\n        dp = {0}\n        for stone in stones:\n            dp |= {stone+i for i in dp}\n        S = sum(stones)\n        return min(abs(i-(S-i)) for i in dp)",
      "explanation": "N/A",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(2^n)"
    }
  ],
  "Unbounded Knapsack DP": [
    {
      "title": "Coin Change",
      "difficulty": "Medium",
      "category": "Unbounded Knapsack DP",
      "link": "https://leetcode.com/problems/coin-change",
      "slug": "coin-change",
      "description": "You are given an integer array \ncoins\n representing coins of different denominations and an integer \namount\n representing a total amount of money.\n\n\nReturn \nthe fewest number of coins that you need to make up that amount\n. If that amount of money cannot be made up by any combination of the coins, return \n-1\n.\n\n\nYou may assume that you have an infinite number of each kind of coin.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n coins = [1,2,5], amount = 11\n\nOutput:\n 3\n\nExplanation:\n 11 = 5 + 5 + 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n coins = [2], amount = 3\n\nOutput:\n -1\n\n\n\nExample 3:\n\n\n\n\nInput:\n coins = [1], amount = 0\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= coins.length <= 12\n\n\n1 <= coins[i] <= 2\n31\n - 1\n\n\n0 <= amount <= 10\n4",
      "solution": "class Solution(object):\n    def coinChange(self, coins, amount):\n        \"\"\"\n        :type coins: List[int]\n        :type amount: int\n        :rtype: int\n        \"\"\"\n        INF = 0x7fffffff  # Using float(\"inf\") would be slower.\n        dp = [INF] * (amount + 1)\n        dp[0] = 0\n        for i in xrange(amount + 1):\n            if dp[i] != INF:\n                for coin in coins:\n                    if i + coin <= amount:\n                        dp[i + coin] = min(dp[i + coin], dp[i] + 1)\n        return dp[amount] if dp[amount] != INF else -1",
      "explanation": "N/A",
      "time_complexity": "O(n * k), n is the number of coins, k is the amount of money",
      "space_complexity": "O(k)"
    },
    {
      "title": "Coin Change II",
      "difficulty": "Medium",
      "category": "Unbounded Knapsack DP",
      "link": "https://leetcode.com/problems/coin-change-ii",
      "slug": "coin-change-ii",
      "description": "You are given an integer array \ncoins\n representing coins of different denominations and an integer \namount\n representing a total amount of money.\n\n\nReturn \nthe number of combinations that make up that amount\n. If that amount of money cannot be made up by any combination of the coins, return \n0\n.\n\n\nYou may assume that you have an infinite number of each kind of coin.\n\n\nThe answer is \nguaranteed\n to fit into a signed \n32-bit\n integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n amount = 5, coins = [1,2,5]\n\nOutput:\n 4\n\nExplanation:\n there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n\n\n\nExample 2:\n\n\n\n\nInput:\n amount = 3, coins = [2]\n\nOutput:\n 0\n\nExplanation:\n the amount of 3 cannot be made up just with coins of 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n amount = 10, coins = [10]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= coins.length <= 300\n\n\n1 <= coins[i] <= 5000\n\n\nAll the values of \ncoins\n are \nunique\n.\n\n\n0 <= amount <= 5000",
      "solution": "# Solution not found in kamyu104 repository",
      "explanation": "N/A",
      "time_complexity": "N/A",
      "space_complexity": "N/A"
    },
    {
      "title": "Perfect Squares",
      "difficulty": "Medium",
      "category": "Unbounded Knapsack DP",
      "link": "https://leetcode.com/problems/perfect-squares",
      "slug": "perfect-squares",
      "description": "Given an integer \nn\n, return \nthe least number of perfect square numbers that sum to\n \nn\n.\n\n\nA \nperfect square\n is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, \n1\n, \n4\n, \n9\n, and \n16\n are perfect squares while \n3\n and \n11\n are not.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 12\n\nOutput:\n 3\n\nExplanation:\n 12 = 4 + 4 + 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 13\n\nOutput:\n 2\n\nExplanation:\n 13 = 4 + 9.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n4",
      "solution": "class Solution(object):\n    _num = [0]\n    def numSquares(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        num = self._num\n        while len(num) <= n:\n            num += min(num[-i*i] for i in xrange(1, int(len(num)**0.5+1))) + 1,\n        return num[n]",
      "explanation": "N/A",
      "time_complexity": "O(n * sqrt(n))",
      "space_complexity": "O(n)"
    }
  ],
  "Longest Increasing Subsequence DP": [
    {
      "title": "Longest Increasing Subsequence",
      "difficulty": "Medium",
      "category": "Longest Increasing Subsequence DP",
      "link": "https://leetcode.com/problems/longest-increasing-subsequence",
      "slug": "longest-increasing-subsequence",
      "description": "Given an integer array \nnums\n, return \nthe length of the longest \nstrictly increasing \nsubsequence\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [10,9,2,5,3,7,101,18]\n\nOutput:\n 4\n\nExplanation:\n The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,1,0,3,2,3]\n\nOutput:\n 4\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [7,7,7,7,7,7,7]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2500\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n Can you come up with an algorithm that runs in \nO(n log(n))\n time complexity?",
      "solution": "\nimport bisect\n\nclass Solution(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        LIS = []\n        def insert(target):\n            left = bisect.bisect_left(LIS, target)\n            # If not found, append the target.\n            if left == len(LIS):\n                LIS.append(target)\n            else:\n                LIS[left] = target\n    \n        for num in nums:\n            insert(num)\n        return len(LIS)\n\nclass Solution2(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        LIS = []\n        def insert(target):\n            left, right = 0, len(LIS) - 1\n            # Find the first index \"left\" which satisfies LIS[left] >= target\n            while left <= right:\n                mid = left + (right - left) // 2\n                if LIS[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            # If not found, append the target.\n            if left == len(LIS):\n                LIS.append(target)\n            else:\n                LIS[left] = target\n\n        for num in nums:\n            insert(num)\n\n        return len(LIS)\n\n\n# bit, fenwick treeclass Solution3(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        class BIT(object):  # 0-indexed.\n            def __init__(self, n, default=0, fn=lambda x, y: x+y):\n                self.__bit = [default]*(n+1)  # Extra one for dummy node.\n                self.__default = default\n                self.__fn = fn\n\n            def update(self, i, val):\n                i += 1  # Extra one for dummy node.\n                while i < len(self.__bit):\n                    self.__bit[i] = self.__fn(self.__bit[i], val)\n                    i += (i & -i)\n\n            def query(self, i):\n                i += 1  # Extra one for dummy node.\n                ret = self.__default\n                while i > 0:\n                    ret = self.__fn(ret, self.__bit[i])\n                    i -= (i & -i)\n                return ret\n    \n        lookup = {x:i for i, x in enumerate(sorted(set(nums)))}\n        bit = BIT(len(lookup), fn=max)\n        for x in nums:\n            bit.update(lookup[x], bit.query(lookup[x]-1)+1)\n        return bit.query(len(lookup)-1)\n\n\n# Range Maximum Queryclass SegmentTree(object):  # 0-based index\n    def __init__(self, N,\n                 build_fn=lambda x, y: [y]*(2*x),\n                 query_fn=lambda x, y: y if x is None else max(x, y),  # (lambda x, y: y if x is None else min(x, y))\n                 update_fn=lambda x, y: y,\n                 default_val=0):\n        self.N = N\n        self.H = (N-1).bit_length()\n        self.query_fn = query_fn\n        self.update_fn = update_fn\n        self.default_val = default_val\n        self.tree = build_fn(N, default_val)\n        self.lazy = [None]*N\n\n    def __apply(self, x, val):\n        self.tree[x] = self.update_fn(self.tree[x], val)\n        if x < self.N:\n            self.lazy[x] = self.update_fn(self.lazy[x], val)\n\n    def update(self, L, R, h):  # Time: O(logN), Space: O(N)\n        def pull(x):\n            while x > 1:\n                x //= 2\n                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n                if self.lazy[x] is not None:\n                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])\n\n        L += self.N\n        R += self.N\n        L0, R0 = L, R\n        while L <= R:\n            if L & 1:  # is right child\n                self.__apply(L, h) \n                L += 1\n            if R & 1 == 0:  # is left child\n                self.__apply(R, h)\n                R -= 1\n            L //= 2\n            R //= 2\n        pull(L0)\n        pull(R0)\n\n    def query(self, L, R):  # Time: O(logN), Space: O(N)\n        def push(x):\n            n = 2**self.H\n            while n != 1:\n                y = x // n\n                if self.lazy[y] is not None:\n                    self.__apply(y*2, self.lazy[y])\n                    self.__apply(y*2 + 1, self.lazy[y])\n                    self.lazy[y] = None\n                n //= 2\n\n        result = None\n        if L > R:\n            return result\n\n        L += self.N\n        R += self.N\n        push(L)\n        push(R)\n        while L <= R:\n            if L & 1:  # is right child\n                result = self.query_fn(result, self.tree[L])\n                L += 1\n            if R & 1 == 0:  # is left child\n                result = self.query_fn(result, self.tree[R])\n                R -= 1\n            L //= 2\n            R //= 2\n        return result\n    \n    def __str__(self):\n        showList = []\n        for i in xrange(self.N):\n            showList.append(self.query(i, i))\n        return \",\".join(map(str, showList))\n\n\n# optimized from Solution5class Solution4(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        val_to_idx = {num:i for i, num in enumerate(sorted(set(nums)))}\n        st = SegmentTree(len(val_to_idx))\n        for x in nums:\n            st.update(val_to_idx[x], val_to_idx[x], st.query(0, val_to_idx[x]-1)+1 if val_to_idx[x] >= 1 else 1)\n        return st.query(0, len(val_to_idx)-1) if len(val_to_idx) >= 1 else 0\n\n\n# Traditional DP solution.class Solution5(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        dp = []  # dp[i]: the length of LIS ends with nums[i]\n        for i in xrange(len(nums)):\n            dp.append(1)\n            for j in xrange(i):\n                if nums[j] < nums[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp) if dp else 0",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Number of Longest Increasing Subsequence",
      "difficulty": "Medium",
      "category": "Longest Increasing Subsequence DP",
      "link": "https://leetcode.com/problems/number-of-longest-increasing-subsequence",
      "slug": "number-of-longest-increasing-subsequence",
      "description": "Given an integer array \nnums\n, return \nthe number of longest increasing subsequences.\n\n\nNotice\n that the sequence has to be \nstrictly\n increasing.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,5,4,7]\n\nOutput:\n 2\n\nExplanation:\n The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,2,2,2,2]\n\nOutput:\n 5\n\nExplanation:\n The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2000\n\n\n-10\n6\n <= nums[i] <= 10\n6\n\n\nThe answer is guaranteed to fit inside a 32-bit integer.",
      "solution": "class Solution(object):\n    def findNumberOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, max_len = 0, 0\n        dp = [[1, 1] for _ in xrange(len(nums))]  # {length, number} pair\n        for i in xrange(len(nums)):\n            for j in xrange(i):\n                if nums[i] > nums[j]:\n                    if dp[i][0] == dp[j][0]+1:\n                        dp[i][1] += dp[j][1]\n                    elif dp[i][0] < dp[j][0]+1:\n                        dp[i] = [dp[j][0]+1, dp[j][1]]\n            if max_len == dp[i][0]:\n                result += dp[i][1]\n            elif max_len < dp[i][0]:\n                max_len = dp[i][0]\n                result = dp[i][1]\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Russian Doll Envelopes",
      "difficulty": "Hard",
      "category": "Longest Increasing Subsequence DP",
      "link": "https://leetcode.com/problems/russian-doll-envelopes",
      "slug": "russian-doll-envelopes",
      "description": "You are given a 2D array of integers \nenvelopes\n where \nenvelopes[i] = [w\ni\n, h\ni\n]\n represents the width and the height of an envelope.\n\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\n\nReturn \nthe maximum number of envelopes you can Russian doll (i.e., put one inside the other)\n.\n\n\nNote:\n You cannot rotate an envelope.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n envelopes = [[5,4],[6,4],[6,7],[2,3]]\n\nOutput:\n 3\n\nExplanation:\n The maximum number of envelopes you can Russian doll is \n3\n ([2,3] => [5,4] => [6,7]).\n\n\n\nExample 2:\n\n\n\n\nInput:\n envelopes = [[1,1],[1,1],[1,1]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= envelopes.length <= 10\n5\n\n\nenvelopes[i].length == 2\n\n\n1 <= w\ni\n, h\ni\n <= 10\n5",
      "solution": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def insert(target):\n            left, right = 0, len(result) - 1\n            while left <= right:\n                mid = left + (right - left) / 2\n                if result[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            if left == len(result):\n                result.append(target)\n            else:\n                result[left] = target\n\n        result = []\n\n        envelopes.sort(lambda x, y: y[1] - x[1] if x[0] == y[0] else \\\n                                    x[0] - y[0])\n        for envelope in envelopes:\n            insert(envelope[1])\n\n        return len(result)",
      "explanation": "N/A",
      "time_complexity": "O(nlogn + nlogk) = O(nlogn), k is the length of the result.",
      "space_complexity": "O(1)"
    }
  ],
  "2D (Grid) DP": [
    {
      "title": "Unique Paths II",
      "difficulty": "Medium",
      "category": "2D (Grid) DP",
      "link": "https://leetcode.com/problems/unique-paths-ii",
      "slug": "unique-paths-ii",
      "description": "You are given an \nm x n\n integer array \ngrid\n. There is a robot initially located at the \ntop-left corner\n (i.e., \ngrid[0][0]\n). The robot tries to move to the \nbottom-right corner\n (i.e., \ngrid[m - 1][n - 1]\n). The robot can only move either down or right at any point in time.\n\n\nAn obstacle and space are marked as \n1\n or \n0\n respectively in \ngrid\n. A path that the robot takes cannot include \nany\n square that is an obstacle.\n\n\nReturn \nthe number of possible unique paths that the robot can take to reach the bottom-right corner\n.\n\n\nThe testcases are generated so that the answer will be less than or equal to \n2 * 10\n9\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n\nOutput:\n 2\n\nExplanation:\n There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n obstacleGrid = [[0,1],[0,0]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == obstacleGrid.length\n\n\nn == obstacleGrid[i].length\n\n\n1 <= m, n <= 100\n\n\nobstacleGrid[i][j]\n is \n0\n or \n1\n.",
      "solution": "class Solution(object):\n    # @param obstacleGrid, a list of lists of integers\n    # @return an integer\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n\n        ways = [0]*n\n        ways[0] = 1\n        for i in xrange(m):\n            if obstacleGrid[i][0] == 1:\n                ways[0] = 0\n            for j in xrange(n):\n                if obstacleGrid[i][j] == 1:\n                    ways[j] = 0\n                elif j>0:\n                    ways[j] += ways[j-1]\n        return ways[-1]",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m + n)"
    },
    {
      "title": "Minimum Path Sum",
      "difficulty": "Medium",
      "category": "2D (Grid) DP",
      "link": "https://leetcode.com/problems/minimum-path-sum",
      "slug": "minimum-path-sum",
      "description": "Given a \nm x n\n \ngrid\n filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\n\nNote:\n You can only move either down or right at any point in time.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[1,3,1],[1,5,1],[4,2,1]]\n\nOutput:\n 7\n\nExplanation:\n Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[1,2,3],[4,5,6]]\n\nOutput:\n 12\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 200\n\n\n0 <= grid[i][j] <= 200",
      "solution": "class Solution(object):\n    # @param grid, a list of lists of integers\n    # @return an integer\n    def minPathSum(self, grid):\n        sum = list(grid[0])\n        for j in xrange(1, len(grid[0])):\n            sum[j] = sum[j - 1] + grid[0][j]\n\n        for i in xrange(1, len(grid)):\n            sum[0] += grid[i][0]\n            for j in xrange(1, len(grid[0])):\n                sum[j] = min(sum[j - 1], sum[j]) + grid[i][j]\n\n        return sum[-1]",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m + n)"
    },
    {
      "title": "Triangle",
      "difficulty": "Medium",
      "category": "2D (Grid) DP",
      "link": "https://leetcode.com/problems/triangle",
      "slug": "triangle",
      "description": "Given a \ntriangle\n array, return \nthe minimum path sum from top to bottom\n.\n\n\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index \ni\n on the current row, you may move to either index \ni\n or index \ni + 1\n on the next row.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n\nOutput:\n 11\n\nExplanation:\n The triangle looks like:\n   \n2\n\n  \n3\n 4\n 6 \n5\n 7\n4 \n1\n 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n\n\n\nExample 2:\n\n\n\n\nInput:\n triangle = [[-10]]\n\nOutput:\n -10\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= triangle.length <= 200\n\n\ntriangle[0].length == 1\n\n\ntriangle[i].length == triangle[i - 1].length + 1\n\n\n-10\n4\n <= triangle[i][j] <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n Could you do this using only \nO(n)\n extra space, where \nn\n is the total number of rows in the triangle?",
      "solution": "from functools import reduce\nclass Solution(object):\n    # @param triangle, a list of lists of integers\n    # @return an integer\n    def minimumTotal(self, triangle):\n        if not triangle:\n            return 0\n\n        cur = triangle[0] + [float(\"inf\")]\n        for i in xrange(1, len(triangle)):\n            next = []\n            next.append(triangle[i][0] + cur[0])\n            for j in xrange(1, i + 1):\n                next.append(triangle[i][j] + min(cur[j - 1], cur[j]))\n            cur = next + [float(\"inf\")]\n\n        return reduce(min, cur)",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Count Square Submatrices with All Ones",
      "difficulty": "Medium",
      "category": "2D (Grid) DP",
      "link": "https://leetcode.com/problems/count-square-submatrices-with-all-ones",
      "slug": "count-square-submatrices-with-all-ones",
      "description": "Given a \nm * n\n matrix of ones and zeros, return how many \nsquare\n submatrices have all ones.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n matrix =\n[\n  [0,1,1,1],\n  [1,1,1,1],\n  [0,1,1,1]\n]\n\nOutput:\n 15\n\nExplanation:\n \nThere are \n10\n squares of side 1.\nThere are \n4\n squares of side 2.\nThere is  \n1\n square of side 3.\nTotal number of squares = 10 + 4 + 1 = \n15\n.\n\n\n\nExample 2:\n\n\n\n\nInput:\n matrix = \n[\n  [1,0,1],\n  [1,1,0],\n  [1,1,0]\n]\n\nOutput:\n 7\n\nExplanation:\n \nThere are \n6\n squares of side 1.  \nThere is \n1\n square of side 2. \nTotal number of squares = 6 + 1 = \n7\n.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr.length <= 300\n\n\n1 <= arr[0].length <= 300\n\n\n0 <= arr[i][j] <= 1",
      "solution": "class Solution(object):\n    def countSquares(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        for i in xrange(1, len(matrix)):\n            for j in xrange(1, len(matrix[0])):\n                if not matrix[i][j]:\n                    continue\n                l = min(matrix[i-1][j], matrix[i][j-1])\n                matrix[i][j] = l+1 if matrix[i-l][j-l] else l\n        return sum(x for row in matrix for x in row)",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Maximum Number of Points with Cost",
      "difficulty": "Medium",
      "category": "2D (Grid) DP",
      "link": "https://leetcode.com/problems/maximum-number-of-points-with-cost",
      "slug": "maximum-number-of-points-with-cost",
      "description": "You are given an \nm x n\n integer matrix \npoints\n (\n0-indexed\n). Starting with \n0\n points, you want to \nmaximize\n the number of points you can get from the matrix.\n\n\nTo gain points, you must pick one cell in \neach row\n. Picking the cell at coordinates \n(r, c)\n will \nadd\n \npoints[r][c]\n to your score.\n\n\nHowever, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows \nr\n and \nr + 1\n (where \n0 <= r < m - 1\n), picking cells at coordinates \n(r, c\n1\n)\n and \n(r + 1, c\n2\n)\n will \nsubtract\n \nabs(c\n1\n - c\n2\n)\n from your score.\n\n\nReturn \nthe \nmaximum\n number of points you can achieve\n.\n\n\nabs(x)\n is defined as:\n\n\n\n\nx\n for \nx >= 0\n.\n\n\n-x\n for \nx < 0\n.\n\n\n\n\n \n\n\nExample 1:\n \n\n\n\n\n\n\nInput:\n points = [[1,2,3],[1,5,1],[3,1,1]]\n\nOutput:\n 9\n\nExplanation:\n\nThe blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0).\nYou add 3 + 5 + 3 = 11 to your score.\nHowever, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.\nYour final score is 11 - 2 = 9.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n points = [[1,5],[2,3],[4,2]]\n\nOutput:\n 11\n\nExplanation:\n\nThe blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0).\nYou add 5 + 3 + 4 = 12 to your score.\nHowever, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.\nYour final score is 12 - 1 = 11.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == points.length\n\n\nn == points[r].length\n\n\n1 <= m, n <= 10\n5\n\n\n1 <= m * n <= 10\n5\n\n\n0 <= points[r][c] <= 10\n5",
      "solution": "class Solution(object):\n    def maxPoints(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        dp = points[0]\n        for i in xrange(1, len(points)):\n            prefix = [0]*len(points[i])\n            prefix[0] = dp[0]\n            for j in xrange(1, len(points[i])):\n                prefix[j] = max(prefix[j-1], dp[j]+j)\n            suffix = [0]*len(points[i])\n            suffix[-1] = dp[-1]-(len(points[i])-1)\n            for j in reversed(xrange(len(points[i])-1)):\n                suffix[j] = max(suffix[j+1], dp[j]-j)\n            new_dp = [0]*len(points[i])\n            for j in xrange(len(points[i])):\n                new_dp[j] = max(prefix[j]-j, suffix[j]+j)+points[i][j]\n            dp = new_dp\n        return max(dp)",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Burst Balloons",
      "difficulty": "Hard",
      "category": "2D (Grid) DP",
      "link": "https://leetcode.com/problems/burst-balloons",
      "slug": "burst-balloons",
      "description": "You are given \nn\n balloons, indexed from \n0\n to \nn - 1\n. Each balloon is painted with a number on it represented by an array \nnums\n. You are asked to burst all the balloons.\n\n\nIf you burst the \ni\nth\n balloon, you will get \nnums[i - 1] * nums[i] * nums[i + 1]\n coins. If \ni - 1\n or \ni + 1\n goes out of bounds of the array, then treat it as if there is a balloon with a \n1\n painted on it.\n\n\nReturn \nthe maximum coins you can collect by bursting the balloons wisely\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,1,5,8]\n\nOutput:\n 167\n\nExplanation:\n\nnums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,5]\n\nOutput:\n 10\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 300\n\n\n0 <= nums[i] <= 100",
      "solution": "\nclass Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        coins = [1] + [i for i in nums if i > 0] + [1]\n        n = len(coins)\n        max_coins = [[0 for _ in xrange(n)] for _ in xrange(n)]\n\n        for k in xrange(2, n):\n            for left in xrange(n - k):\n                right = left + k\n                for i in xrange(left + 1, right):\n                    max_coins[left][right] = \\\n                        max(max_coins[left][right],\n                            coins[left] * coins[i] * coins[right] +\n                            max_coins[left][i] +\n                            max_coins[i][right])\n\n        return max_coins[0][-1]",
      "explanation": "N/A",
      "time_complexity": "O(n^3)",
      "space_complexity": "O(n^2)"
    },
    {
      "title": "Maximum Profit in Job Scheduling",
      "difficulty": "Hard",
      "category": "2D (Grid) DP",
      "link": "https://leetcode.com/problems/maximum-profit-in-job-scheduling",
      "slug": "maximum-profit-in-job-scheduling",
      "description": "We have \nn\n jobs, where every job is scheduled to be done from \nstartTime[i]\n to \nendTime[i]\n, obtaining a profit of \nprofit[i]\n.\n\n\nYou're given the \nstartTime\n, \nendTime\n and \nprofit\n arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\n\n\nIf you choose a job that ends at time \nX\n you will be able to start another job that starts at time \nX\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\n\nOutput:\n 120\n\nExplanation:\n The subset chosen is the first and fourth job. \nTime range [1-3]+[3-6] , we get profit of 120 = 50 + 70.\n\n\n\nExample 2:\n\n\n \n\n\n\n\nInput:\n startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\n\nOutput:\n 150\n\nExplanation:\n The subset chosen is the first, fourth and fifth job. \nProfit obtained 150 = 20 + 70 + 60.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]\n\nOutput:\n 6\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= startTime.length == endTime.length == profit.length <= 5 * 10\n4\n\n\n1 <= startTime[i] < endTime[i] <= 10\n9\n\n\n1 <= profit[i] <= 10\n4",
      "solution": "\nimport itertools\nimport bisect\n\nclass Solution(object):\n    def jobScheduling(self, startTime, endTime, profit):\n        \"\"\"\n        :type startTime: List[int]\n        :type endTime: List[int]\n        :type profit: List[int]\n        :rtype: int\n        \"\"\"\n        jobs = sorted(itertools.izip(endTime, startTime, profit))\n        dp = [(0, 0)]\n        for e, s, p in jobs:\n            i = bisect.bisect_right(dp, (s+1, 0))-1\n            if dp[i][1]+p > dp[-1][1]:\n                dp.append((e, dp[i][1]+p))\n        return dp[-1][1]\n\n\nimport heapqclass Solution(object):\n    def jobScheduling(self, startTime, endTime, profit):\n        \"\"\"\n        :type startTime: List[int]\n        :type endTime: List[int]\n        :type profit: List[int]\n        :rtype: int\n        \"\"\"\n        min_heap = zip(startTime, endTime, profit)\n        heapq.heapify(min_heap)\n        result = 0\n        while min_heap:\n            s, e, p = heapq.heappop(min_heap)\n            if s < e:\n                heapq.heappush(min_heap, (e, s, result+p))\n            else:\n                result = max(result, p)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Cherry Pickup",
      "difficulty": "Hard",
      "category": "2D (Grid) DP",
      "link": "https://leetcode.com/problems/cherry-pickup",
      "slug": "cherry-pickup",
      "description": "You are given an \nn x n\n \ngrid\n representing a field of cherries, each cell is one of three possible integers.\n\n\n\n\n0\n means the cell is empty, so you can pass through,\n\n\n1\n means the cell contains a cherry that you can pick up and pass through, or\n\n\n-1\n means the cell contains a thorn that blocks your way.\n\n\n\n\nReturn \nthe maximum number of cherries you can collect by following the rules below\n:\n\n\n\n\nStarting at the position \n(0, 0)\n and reaching \n(n - 1, n - 1)\n by moving right or down through valid path cells (cells with value \n0\n or \n1\n).\n\n\nAfter reaching \n(n - 1, n - 1)\n, returning to \n(0, 0)\n by moving left or up through valid path cells.\n\n\nWhen passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell \n0\n.\n\n\nIf there is no valid path between \n(0, 0)\n and \n(n - 1, n - 1)\n, then no cherries can be collected.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,1,-1],[1,0,-1],[1,1,1]]\n\nOutput:\n 5\n\nExplanation:\n The player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[1,1,-1],[1,-1,1],[-1,1,1]]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\nn == grid[i].length\n\n\n1 <= n <= 50\n\n\ngrid[i][j]\n is \n-1\n, \n0\n, or \n1\n.\n\n\ngrid[0][0] != -1\n\n\ngrid[n - 1][n - 1] != -1",
      "solution": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # dp holds the max # of cherries two k-length paths can pickup.\n        # The two k-length paths arrive at (i, k - i) and (j, k - j),\n        # respectively.\n        n = len(grid)\n        dp = [[-1 for _ in xrange(n)] for _ in xrange(n)]\n        dp[0][0] = grid[0][0]\n        max_len = 2 * (n-1)\n        directions = [(0, 0), (-1, 0), (0, -1), (-1, -1)]\n        for k in xrange(1, max_len+1):\n            for i in reversed(xrange(max(0, k-n+1), min(k+1, n))):  # 0 <= i < n, 0 <= k-i < n\n                for j in reversed(xrange(i, min(k+1, n))):          # i <= j < n, 0 <= k-j < n\n                    if grid[i][k-i] == -1 or grid[j][k-j] == -1:\n                        dp[i][j] = -1\n                        continue\n                    cnt = grid[i][k-i]\n                    if i != j:\n                        cnt += grid[j][k-j]\n                    max_cnt = -1\n                    for direction in directions:\n                        ii, jj = i+direction[0], j+direction[1]\n                        if ii >= 0 and jj >= 0 and dp[ii][jj] >= 0:\n                            max_cnt = max(max_cnt, dp[ii][jj]+cnt)\n                    dp[i][j] = max_cnt\n        return max(dp[n-1][n-1], 0)",
      "explanation": "N/A",
      "time_complexity": "O(n^3)",
      "space_complexity": "O(n^2)"
    },
    {
      "title": "Longest Increasing Path in a Matrix",
      "difficulty": "Hard",
      "category": "2D (Grid) DP",
      "link": "https://leetcode.com/problems/longest-increasing-path-in-a-matrix",
      "slug": "longest-increasing-path-in-a-matrix",
      "description": "Given an \nm x n\n integers \nmatrix\n, return \nthe length of the longest increasing path in \nmatrix\n.\n\n\nFrom each cell, you can either move in four directions: left, right, up, or down. You \nmay not\n move \ndiagonally\n or move \noutside the boundary\n (i.e., wrap-around is not allowed).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[9,9,4],[6,6,8],[2,1,1]]\n\nOutput:\n 4\n\nExplanation:\n The longest increasing path is \n[1, 2, 6, 9]\n.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[3,4,5],[3,2,6],[2,2,1]]\n\nOutput:\n 4\n\nExplanation: \nThe longest increasing path is \n[3, 4, 5, 6]\n. Moving diagonally is not allowed.\n\n\n\nExample 3:\n\n\n\n\nInput:\n matrix = [[1]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 200\n\n\n0 <= matrix[i][j] <= 2\n31\n - 1",
      "solution": "\n# topological sort solutionclass Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n        if not matrix:\n            return 0\n        \n        in_degree = [[0]*len(matrix[0]) for _ in xrange(len(matrix))]\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[0])):\n                for di, dj in directions:\n                    ni, nj = i+di, j+dj\n                    if not (0 <= ni < len(matrix) and\n                            0 <= nj < len(matrix[0]) and\n                            matrix[ni][nj] > matrix[i][j]):\n                        continue\n                    in_degree[i][j] += 1\n        q = []\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[0])):\n                if not in_degree[i][j]:\n                    q.append((i, j))\n        result = 0\n        while q:\n            new_q = []\n            for i, j in q:\n                for di, dj in directions:\n                    ni, nj = i+di, j+dj\n                    if not (0 <= ni < len(matrix) and\n                            0 <= nj < len(matrix[0]) and\n                            matrix[i][j] > matrix[ni][nj]):\n                        continue\n                    in_degree[ni][nj] -= 1\n                    if not in_degree[ni][nj]:\n                        new_q.append((ni, nj))\n            q = new_q\n            result += 1         \n        return result\n\n\n# dfs + memoization solutionclass Solution2(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n        def longestpath(matrix, i, j, max_lengths):\n            if max_lengths[i][j]:\n                return max_lengths[i][j]\n            max_depth = 0\n            for di, dj in directions:\n                x, y = i+di, j+dj\n                if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and \\\n                   matrix[x][y] < matrix[i][j]:\n                    max_depth = max(max_depth, longestpath(matrix, x, y, max_lengths))\n            max_lengths[i][j] = max_depth + 1\n            return max_lengths[i][j]\n\n        if not matrix:\n            return 0\n        result = 0\n        max_lengths = [[0 for _ in xrange(len(matrix[0]))] for _ in xrange(len(matrix))]\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[0])):\n                result = max(result, longestpath(matrix, i, j, max_lengths))\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n)"
    }
  ],
  "String DP": [
    {
      "title": "Longest Common Subsequence",
      "difficulty": "Medium",
      "category": "String DP",
      "link": "https://leetcode.com/problems/longest-common-subsequence",
      "slug": "longest-common-subsequence",
      "description": "Given two strings \ntext1\n and \ntext2\n, return \nthe length of their longest \ncommon subsequence\n. \nIf there is no \ncommon subsequence\n, return \n0\n.\n\n\nA \nsubsequence\n of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n\n\n\nFor example, \n\"ace\"\n is a subsequence of \n\"abcde\"\n.\n\n\n\n\nA \ncommon subsequence\n of two strings is a subsequence that is common to both strings.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n text1 = \"abcde\", text2 = \"ace\" \n\nOutput:\n 3  \n\nExplanation:\n The longest common subsequence is \"ace\" and its length is 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n text1 = \"abc\", text2 = \"abc\"\n\nOutput:\n 3\n\nExplanation:\n The longest common subsequence is \"abc\" and its length is 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n text1 = \"abc\", text2 = \"def\"\n\nOutput:\n 0\n\nExplanation:\n There is no such common subsequence, so the result is 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= text1.length, text2.length <= 1000\n\n\ntext1\n and \ntext2\n consist of only lowercase English characters.",
      "solution": "class Solution(object):\n    def longestCommonSubsequence(self, text1, text2):\n        \"\"\"\n        :type text1: str\n        :type text2: str\n        :rtype: int\n        \"\"\"\n        if len(text1) < len(text2):\n            return self.longestCommonSubsequence(text2, text1)\n\n        dp = [[0 for _ in xrange(len(text2)+1)] for _ in xrange(2)]\n        for i in xrange(1, len(text1)+1):\n            for j in xrange(1, len(text2)+1):\n                dp[i%2][j] = dp[(i-1)%2][j-1]+1 if text1[i-1] == text2[j-1] \\\n                             else max(dp[(i-1)%2][j], dp[i%2][j-1])\n        return dp[len(text1)%2][len(text2)]",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(min(m, n))"
    },
    {
      "title": "Edit Distance",
      "difficulty": "Medium",
      "category": "String DP",
      "link": "https://leetcode.com/problems/edit-distance",
      "slug": "edit-distance",
      "description": "Given two strings \nword1\n and \nword2\n, return \nthe minimum number of operations required to convert \nword1\n to \nword2\n.\n\n\nYou have the following three operations permitted on a word:\n\n\n\n\nInsert a character\n\n\nDelete a character\n\n\nReplace a character\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n word1 = \"horse\", word2 = \"ros\"\n\nOutput:\n 3\n\nExplanation:\n \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n\n\n\nExample 2:\n\n\n\n\nInput:\n word1 = \"intention\", word2 = \"execution\"\n\nOutput:\n 5\n\nExplanation:\n \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= word1.length, word2.length <= 500\n\n\nword1\n and \nword2\n consist of lowercase English letters.",
      "solution": "class Solution(object):\n    # @return an integer\n    def minDistance(self, word1, word2):\n        if len(word1) < len(word2):\n            return self.minDistance(word2, word1)\n\n        distance = [i for i in xrange(len(word2) + 1)]\n\n        for i in xrange(1, len(word1) + 1):\n            pre_distance_i_j = distance[0]\n            distance[0] = i\n            for j in xrange(1, len(word2) + 1):\n                insert = distance[j - 1] + 1\n                delete = distance[j] + 1\n                replace = pre_distance_i_j\n                if word1[i - 1] != word2[j - 1]:\n                    replace += 1\n                pre_distance_i_j = distance[j]\n                distance[j] = min(insert, delete, replace)\n\n        return distance[-1]\nclass Solution2(object):\n    # @return an integer\n    def minDistance(self, word1, word2):\n        distance = [[i] for i in xrange(len(word1) + 1)]\n        distance[0] = [j for j in xrange(len(word2) + 1)]\n\n        for i in xrange(1, len(word1) + 1):\n            for j in xrange(1, len(word2) + 1):\n                insert = distance[i][j - 1] + 1\n                delete = distance[i - 1][j] + 1\n                replace = distance[i - 1][j - 1]\n                if word1[i - 1] != word2[j - 1]:\n                    replace += 1\n                distance[i].append(min(insert, delete, replace))\n\n        return distance[-1][-1]",
      "explanation": "N/A",
      "time_complexity": "O(n * m)",
      "space_complexity": "O(n * m)"
    },
    {
      "title": "Longest Palindromic Subsequence",
      "difficulty": "Medium",
      "category": "String DP",
      "link": "https://leetcode.com/problems/longest-palindromic-subsequence",
      "slug": "longest-palindromic-subsequence",
      "description": "Given a string \ns\n, find \nthe longest palindromic \nsubsequence\n's length in\n \ns\n.\n\n\nA \nsubsequence\n is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"bbbab\"\n\nOutput:\n 4\n\nExplanation:\n One possible longest palindromic subsequence is \"bbbb\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"cbbd\"\n\nOutput:\n 2\n\nExplanation:\n One possible longest palindromic subsequence is \"bb\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consists only of lowercase English letters.",
      "solution": "class Solution(object):\n    def longestPalindromeSubseq(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if s == s[::-1]:  # optional, to optimize special case\n            return len(s)\n\n        dp = [[1] * len(s) for _ in xrange(2)]\n        for i in reversed(xrange(len(s))):\n            for j in xrange(i+1, len(s)):\n                if s[i] == s[j]:\n                    dp[i%2][j] = 2 + dp[(i+1)%2][j-1] if i+1 <= j-1 else 2\n                else:\n                    dp[i%2][j] = max(dp[(i+1)%2][j], dp[i%2][j-1])\n        return dp[0][-1]",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Decode Ways",
      "difficulty": "Medium",
      "category": "String DP",
      "link": "https://leetcode.com/problems/decode-ways",
      "slug": "decode-ways",
      "description": "You have intercepted a secret message encoded as a string of numbers. The message is \ndecoded\n via the following mapping:\n\n\n\"1\" -> 'A'\n\n\"2\" -> 'B'\n\n...\n\n\"25\" -> 'Y'\n\n\"26\" -> 'Z'\n\n\nHowever, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (\n\"2\"\n and \n\"5\"\n vs \n\"25\"\n).\n\n\nFor example, \n\"11106\"\n can be decoded into:\n\n\n\n\n\"AAJF\"\n with the grouping \n(1, 1, 10, 6)\n\n\n\"KJF\"\n with the grouping \n(11, 10, 6)\n\n\nThe grouping \n(1, 11, 06)\n is invalid because \n\"06\"\n is not a valid code (only \n\"6\"\n is valid).\n\n\n\n\nNote: there may be strings that are impossible to decode.\n\n\n\nGiven a string s containing only digits, return the \nnumber of ways\n to \ndecode\n it. If the entire string cannot be decoded in any valid way, return \n0\n.\n\n\nThe test cases are generated so that the answer fits in a \n32-bit\n integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"12\"\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\n\"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"226\"\n\n\nOutput:\n \n3\n\n\nExplanation:\n\n\n\"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"06\"\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\"). In this case, the string is not a valid encoding, so return 0.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 100\n\n\ns\n contains only digits and may contain leading zero(s).",
      "solution": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 0 or s[0] == '0':\n            return 0\n        prev, prev_prev = 1, 0\n        for i in xrange(len(s)):\n            cur = 0\n            if s[i] != '0':\n                cur = prev\n            if i > 0 and (s[i - 1] == '1' or (s[i - 1] == '2' and s[i] <= '6')):\n                cur += prev_prev\n            prev, prev_prev = cur, prev\n        return prev",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Word Break",
      "difficulty": "Medium",
      "category": "String DP",
      "link": "https://leetcode.com/problems/word-break",
      "slug": "word-break",
      "description": "Given a string \ns\n and a dictionary of strings \nwordDict\n, return \ntrue\n if \ns\n can be segmented into a space-separated sequence of one or more dictionary words.\n\n\nNote\n that the same word in the dictionary may be reused multiple times in the segmentation.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"leetcode\", wordDict = [\"leet\",\"code\"]\n\nOutput:\n true\n\nExplanation:\n Return true because \"leetcode\" can be segmented as \"leet code\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\n\nOutput:\n true\n\nExplanation:\n Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\nNote that you are allowed to reuse a dictionary word.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 300\n\n\n1 <= wordDict.length <= 1000\n\n\n1 <= wordDict[i].length <= 20\n\n\ns\n and \nwordDict[i]\n consist of only lowercase English letters.\n\n\nAll the strings of \nwordDict\n are \nunique\n.",
      "solution": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: Set[str]\n        :rtype: bool\n        \"\"\"\n        n = len(s)\n\n        max_len = 0\n        for string in wordDict:\n            max_len = max(max_len, len(string))\n\n        can_break = [False for _ in xrange(n + 1)]\n        can_break[0] = True\n        for i in xrange(1, n + 1):\n            for l in xrange(1, min(i, max_len) + 1):\n                if can_break[i-l] and s[i-l:i] in wordDict:\n                    can_break[i] = True\n                    break\n\n        return can_break[-1]",
      "explanation": "N/A",
      "time_complexity": "O(n * l^2)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Interleaving String",
      "difficulty": "Medium",
      "category": "String DP",
      "link": "https://leetcode.com/problems/interleaving-string",
      "slug": "interleaving-string",
      "description": "Given strings \ns1\n, \ns2\n, and \ns3\n, find whether \ns3\n is formed by an \ninterleaving\n of \ns1\n and \ns2\n.\n\n\nAn \ninterleaving\n of two strings \ns\n and \nt\n is a configuration where \ns\n and \nt\n are divided into \nn\n and \nm\n \nsubstrings\n respectively, such that:\n\n\n\n\ns = s\n1\n + s\n2\n + ... + s\nn\n\n\nt = t\n1\n + t\n2\n + ... + t\nm\n\n\n|n - m| <= 1\n\n\nThe \ninterleaving\n is \ns\n1\n + t\n1\n + s\n2\n + t\n2\n + s\n3\n + t\n3\n + ...\n or \nt\n1\n + s\n1\n + t\n2\n + s\n2\n + t\n3\n + s\n3\n + ...\n\n\n\n\nNote:\n \na + b\n is the concatenation of strings \na\n and \nb\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\n\nOutput:\n true\n\nExplanation:\n One way to obtain s3 is:\nSplit s1 into s1 = \"aa\" + \"bc\" + \"c\", and s2 into s2 = \"dbbc\" + \"a\".\nInterleaving the two splits, we get \"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\".\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\n\nOutput:\n false\n\nExplanation:\n Notice how it is impossible to interleave s2 with any other string to obtain s3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s1 = \"\", s2 = \"\", s3 = \"\"\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s1.length, s2.length <= 100\n\n\n0 <= s3.length <= 200\n\n\ns1\n, \ns2\n, and \ns3\n consist of lowercase English letters.\n\n\n\n\n \n\n\nFollow up:\n Could you solve it using only \nO(s2.length)\n additional memory space?",
      "solution": "class Solution(object):\n    # @return a boolean\n    def isInterleave(self, s1, s2, s3):\n        if len(s1) + len(s2) != len(s3):\n            return False\n        if len(s1) > len(s2):\n            return self.isInterleave(s2, s1, s3)\n        match = [False for i in xrange(len(s1) + 1)]\n        match[0] = True\n        for i in xrange(1, len(s1) + 1):\n            match[i] = match[i -1] and s1[i - 1] == s3[i - 1]\n        for j in xrange(1, len(s2) + 1):\n            match[0] = match[0] and s2[j - 1] == s3[j - 1]\n            for i in xrange(1, len(s1) + 1):\n                match[i] = (match[i - 1] and s1[i - 1] == s3[i + j - 1]) \\\n                                       or (match[i] and s2[j - 1] == s3[i + j - 1])\n        return match[-1]\n\n# Dynamic Programmingclass Solution2(object):\n    # @return a boolean\n    def isInterleave(self, s1, s2, s3):\n        if len(s1) + len(s2) != len(s3):\n            return False\n        match = [[False for i in xrange(len(s2) + 1)] for j in xrange(len(s1) + 1)]\n        match[0][0] = True\n        for i in xrange(1, len(s1) + 1):\n            match[i][0] = match[i - 1][0] and s1[i - 1] == s3[i - 1]\n        for j in xrange(1, len(s2) + 1):\n            match[0][j] = match[0][j - 1] and s2[j - 1] == s3[j - 1]\n        for i in xrange(1, len(s1) + 1):\n            for j in xrange(1, len(s2) + 1):\n                match[i][j] = (match[i - 1][j] and s1[i - 1] == s3[i + j - 1]) \\\n                                       or (match[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        return match[-1][-1]\n\n# Recursive + Hashclass Solution3(object):\n    # @return a boolean\n    def isInterleave(self, s1, s2, s3):\n        self.match = {}\n        if len(s1) + len(s2) != len(s3):\n            return False\n        return self.isInterleaveRecu(s1, s2, s3, 0, 0, 0)\n\n    def isInterleaveRecu(self, s1, s2, s3, a, b, c):\n        if repr([a, b]) in self.match.keys():\n            return self.match[repr([a, b])]\n\n        if c == len(s3):\n            return True\n\n        result = False\n        if a < len(s1) and s1[a] == s3[c]:\n            result = result or self.isInterleaveRecu(s1, s2, s3, a + 1, b, c + 1)\n        if b < len(s2) and s2[b] == s3[c]:\n            result = result or self.isInterleaveRecu(s1, s2, s3, a, b + 1, c + 1)\n\n        self.match[repr([a, b])] = result\n\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "Wildcard Matching",
      "difficulty": "Hard",
      "category": "String DP",
      "link": "https://leetcode.com/problems/wildcard-matching",
      "slug": "wildcard-matching",
      "description": "Given an input string (\ns\n) and a pattern (\np\n), implement wildcard pattern matching with support for \n'?'\n and \n'*'\n where:\n\n\n\n\n'?'\n Matches any single character.\n\n\n'*'\n Matches any sequence of characters (including the empty sequence).\n\n\n\n\nThe matching should cover the \nentire\n input string (not partial).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"aa\", p = \"a\"\n\nOutput:\n false\n\nExplanation:\n \"a\" does not match the entire string \"aa\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"aa\", p = \"*\"\n\nOutput:\n true\n\nExplanation:\n '*' matches any sequence.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"cb\", p = \"?a\"\n\nOutput:\n false\n\nExplanation:\n '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length, p.length <= 2000\n\n\ns\n contains only lowercase English letters.\n\n\np\n contains only lowercase English letters, \n'?'\n or \n'*'\n.",
      "solution": "\n# iterative solution with greedyclass Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        count = 0  # used for complexity check\n        p_ptr, s_ptr, last_s_ptr, last_p_ptr = 0, 0, -1, -1\n        while s_ptr < len(s):\n            if p_ptr < len(p) and (s[s_ptr] == p[p_ptr] or p[p_ptr] == '?'):\n                s_ptr += 1\n                p_ptr += 1\n            elif p_ptr < len(p) and p[p_ptr] == '*':\n                p_ptr += 1\n                last_s_ptr = s_ptr\n                last_p_ptr = p_ptr\n            elif last_p_ptr != -1:\n                last_s_ptr += 1\n                s_ptr = last_s_ptr\n                p_ptr = last_p_ptr\n            else:\n                assert(count <= (len(p)+1) * (len(s)+1))\n                return False\n            count += 1  # used for complexity check\n \n        while p_ptr < len(p) and p[p_ptr] == '*':\n            p_ptr += 1\n            count += 1  # used for complexity check\n\n        assert(count <= (len(p)+1) * (len(s)+1))\n        return p_ptr == len(p)\n\n\n# dp with rolling windowclass Solution2(object):\n    # @return a boolean\n    def isMatch(self, s, p):\n        k = 2\n        result = [[False for j in xrange(len(p) + 1)] for i in xrange(k)]\n\n        result[0][0] = True\n        for i in xrange(1, len(p) + 1):\n            if p[i-1] == '*':\n                result[0][i] = result[0][i-1]\n        for i in xrange(1,len(s) + 1):\n            result[i % k][0] = False\n            for j in xrange(1, len(p) + 1):\n                if p[j-1] != '*':\n                    result[i % k][j] = result[(i-1) % k][j-1] and (s[i-1] == p[j-1] or p[j-1] == '?')\n                else:\n                    result[i % k][j] = result[i % k][j-1] or result[(i-1) % k][j]\n\n        return result[len(s) % k][len(p)]\n\n\n# dpclass Solution3(object):\n    # @return a boolean\n    def isMatch(self, s, p):\n        result = [[False for j in xrange(len(p) + 1)] for i in xrange(len(s) + 1)]\n\n        result[0][0] = True\n        for i in xrange(1, len(p) + 1):\n            if p[i-1] == '*':\n                result[0][i] = result[0][i-1]\n        for i in xrange(1,len(s) + 1):\n            result[i][0] = False\n            for j in xrange(1, len(p) + 1):\n                if p[j-1] != '*':\n                    result[i][j] = result[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == '?')\n                else:\n                    result[i][j] = result[i][j-1] or result[i-1][j]\n\n        return result[len(s)][len(p)]\n\n\n# recursive, slowest, TLEclass Solution4(object):\n    # @return a boolean\n    def isMatch(self, s, p):\n        if not p or not s:\n            return not s and not p\n\n        if p[0] != '*':\n            if p[0] == s[0] or p[0] == '?':\n                return self.isMatch(s[1:], p[1:])\n            else:\n                return False\n        else:\n            while len(s) > 0:\n                if self.isMatch(s, p[1:]):\n                    return True\n                s = s[1:]\n            return self.isMatch(s, p[1:])",
      "explanation": "N/A",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n)"
    },
    {
      "title": "Distinct Subsequences",
      "difficulty": "Hard",
      "category": "String DP",
      "link": "https://leetcode.com/problems/distinct-subsequences",
      "slug": "distinct-subsequences",
      "description": "Given two strings s and t, return \nthe number of distinct\n \nsubsequences\n of \ns\n which equals \nt.\n\n\nThe test cases are generated so that the answer fits on a 32-bit signed integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"rabbbit\", t = \"rabbit\"\n\nOutput:\n 3\n\nExplanation:\n\nAs shown below, there are 3 ways you can generate \"rabbit\" from s.\n\nrabb\nb\nit\n\n\nra\nb\nbbit\n\n\nrab\nb\nbit\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"babgbag\", t = \"bag\"\n\nOutput:\n 5\n\nExplanation:\n\nAs shown below, there are 5 ways you can generate \"bag\" from s.\n\nba\nb\ng\nbag\n\n\nba\nbgba\ng\n\n\nb\nabgb\nag\n\n\nba\nb\ngb\nag\n\n\nbabg\nbag\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length, t.length <= 1000\n\n\ns\n and \nt\n consist of English letters.",
      "solution": "class Solution(object):\n    # @return an integer\n    def numDistinct(self, S, T):\n        ways = [0 for _ in xrange(len(T) + 1)]\n        ways[0] = 1\n        for S_char in S:\n            for j, T_char in reversed(list(enumerate(T))):\n                if S_char == T_char:\n                    ways[j + 1] += ways[j]\n        return ways[len(T)]",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Palindrome Partitioning II",
      "difficulty": "Hard",
      "category": "String DP",
      "link": "https://leetcode.com/problems/palindrome-partitioning-ii",
      "slug": "palindrome-partitioning-ii",
      "description": "Given a string \ns\n, partition \ns\n such that every \nsubstring\n of the partition is a \npalindrome\n.\n\n\nReturn \nthe \nminimum\n cuts needed for a palindrome partitioning of\n \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"aab\"\n\nOutput:\n 1\n\nExplanation:\n The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"a\"\n\nOutput:\n 0\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"ab\"\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 2000\n\n\ns\n consists of lowercase English letters only.",
      "solution": "class Solution(object):\n    # @param s, a string\n    # @return an integer\n    def minCut(self, s):\n        lookup = [[False for j in xrange(len(s))] for i in xrange(len(s))]\n        mincut = [len(s) - 1 - i for i in xrange(len(s) + 1)]\n\n        for i in reversed(xrange(len(s))):\n            for j in xrange(i, len(s)):\n                if s[i] == s[j]  and (j - i < 2 or lookup[i + 1][j - 1]):\n                    lookup[i][j] = True\n                    mincut[i] = min(mincut[i], mincut[j + 1] + 1)\n\n        return mincut[0]",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n^2)"
    }
  ],
  "Tree / Graph DP": [
    {
      "title": "House Robber III",
      "difficulty": "Medium",
      "category": "Tree / Graph DP",
      "link": "https://leetcode.com/problems/house-robber-iii",
      "slug": "house-robber-iii",
      "description": "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called \nroot\n.\n\n\nBesides the \nroot\n, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if \ntwo directly-linked houses were broken into on the same night\n.\n\n\nGiven the \nroot\n of the binary tree, return \nthe maximum amount of money the thief can rob \nwithout alerting the police\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,2,3,null,3,null,1]\n\nOutput:\n 7\n\nExplanation:\n Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,4,5,1,3,null,1]\n\nOutput:\n 9\n\nExplanation:\n Maximum amount of money the thief can rob = 4 + 5 = 9.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n0 <= Node.val <= 10\n4",
      "solution": "class Solution(object):\n    def rob(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def robHelper(root):\n            if not root:\n                return (0, 0)\n            left, right = robHelper(root.left), robHelper(root.right)\n            return (root.val + left[1] + right[1], max(left) + max(right))\n\n        return max(robHelper(root))",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Unique Binary Search Trees II",
      "difficulty": "Medium",
      "category": "Tree / Graph DP",
      "link": "https://leetcode.com/problems/unique-binary-search-trees-ii",
      "slug": "unique-binary-search-trees-ii",
      "description": "Given an integer \nn\n, return \nall the structurally unique \nBST'\ns (binary search trees), which has exactly \nn\n nodes of unique values from\n \n1\n \nto\n \nn\n. Return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 3\n\nOutput:\n [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n [[1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 8",
      "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        if self:\n            serial = []\n            queue = [self]\n\n            while queue:\n                cur = queue[0]\n\n                if cur:\n                    serial.append(cur.val)\n                    queue.append(cur.left)\n                    queue.append(cur.right)\n                else:\n                    serial.append(\"#\")\n\n                queue = queue[1:]\n\n            while serial[-1] == \"#\":\n                serial.pop()\n\n            return repr(serial)\n\n        else:\n            return None\nclass Solution(object):\n    # @return a list of tree node\n    def generateTrees(self, n):\n        return self.generateTreesRecu(1, n)\n\n    def generateTreesRecu(self, low, high):\n        result = []\n        if low > high:\n            result.append(None)\n        for i in xrange(low, high + 1):\n            left = self.generateTreesRecu(low, i - 1)\n            right = self.generateTreesRecu(i + 1, high)\n            for j in left:\n                for k in right:\n                    cur = TreeNode(i)\n                    cur.left = j\n                    cur.right = k\n                    result.append(cur)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(4^n / n^(3/2)) ~= Catalan numbers",
      "space_complexity": "O(4^n / n^(3/2)) ~= Catalan numbers"
    },
    {
      "title": "Number of Ways to Arrive at Destination",
      "difficulty": "Medium",
      "category": "Tree / Graph DP",
      "link": "https://leetcode.com/problems/number-of-ways-to-arrive-at-destination",
      "slug": "number-of-ways-to-arrive-at-destination",
      "description": "You are in a city that consists of \nn\n intersections numbered from \n0\n to \nn - 1\n with \nbi-directional\n roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.\n\n\nYou are given an integer \nn\n and a 2D integer array \nroads\n where \nroads[i] = [u\ni\n, v\ni\n, time\ni\n]\n means that there is a road between intersections \nu\ni\n and \nv\ni\n that takes \ntime\ni\n minutes to travel. You want to know in how many ways you can travel from intersection \n0\n to intersection \nn - 1\n in the \nshortest amount of time\n.\n\n\nReturn \nthe \nnumber of ways\n you can arrive at your destination in the \nshortest amount of time\n. Since the answer may be large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]\n\nOutput:\n 4\n\nExplanation:\n The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.\nThe four ways to get there in 7 minutes are:\n- 0 ➝ 6\n- 0 ➝ 4 ➝ 6\n- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6\n- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2, roads = [[1,0,10]]\n\nOutput:\n 1\n\nExplanation:\n There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 200\n\n\nn - 1 <= roads.length <= n * (n - 1) / 2\n\n\nroads[i].length == 3\n\n\n0 <= u\ni\n, v\ni\n <= n - 1\n\n\n1 <= time\ni\n <= 10\n9\n\n\nu\ni \n!= v\ni\n\n\nThere is at most one road connecting any two intersections.\n\n\nYou can reach any intersection from any other intersection.",
      "solution": "#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)\n\nimport heapq\n\nclass Solution(object):\n    def countPaths(self, n, roads):\n        \"\"\"\n        :type n: int\n        :type roads: List[List[int]]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n\n        def dijkstra(adj, start, target):\n            best = collections.defaultdict(lambda:float(\"inf\"))\n            best[start] = 0\n            min_heap = [(0, start)]\n            dp = [0]*(len(adj))  # modified, add dp to keep number of ways\n            dp[0] = 1\n            while min_heap:\n                curr, u = heapq.heappop(min_heap)\n                if best[u] < curr:\n                    continue\n                if u == target:  # modified, early return\n                    break\n                for v, w in adj[u]:                \n                    if v in best and best[v] <= curr+w:\n                        if best[v] == curr+w:  # modified, update number of ways in this minimal time\n                            dp[v] = (dp[v]+dp[u])%MOD\n                        continue\n                    dp[v] = dp[u]  # modified, init number of ways in this minimal time\n                    best[v] = curr+w\n                    heapq.heappush(min_heap, (curr+w, v))\n            return dp[target]\n\n        adj = [[] for i in xrange(n)]\n        for u, v, w in roads:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n        return dijkstra(adj, 0, n-1)",
      "explanation": "N/A",
      "time_complexity": "O((|E| + |V|) * log|V|) = O(|E| * log|V|),",
      "space_complexity": "O(|E| + |V|) = O(|E|)"
    },
    {
      "title": "Binary Tree Cameras",
      "difficulty": "Hard",
      "category": "Tree / Graph DP",
      "link": "https://leetcode.com/problems/binary-tree-cameras",
      "slug": "binary-tree-cameras",
      "description": "You are given the \nroot\n of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children.\n\n\nReturn \nthe minimum number of cameras needed to monitor all nodes of the tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [0,0,null,0,0]\n\nOutput:\n 1\n\nExplanation:\n One camera is enough to monitor all nodes if placed as shown.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [0,0,null,0,null,0,null,null,0]\n\nOutput:\n 2\n\nExplanation:\n At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\nNode.val == 0",
      "solution": "\n# Definition for a binary tree node.class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def minCameraCover(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        UNCOVERED, COVERED, CAMERA = range(3)\n        def dfs(root, result):\n            left = dfs(root.left, result) if root.left else COVERED\n            right = dfs(root.right, result) if root.right else COVERED\n            if left == UNCOVERED or right == UNCOVERED:\n                result[0] += 1\n                return CAMERA\n            if left == CAMERA or right == CAMERA:\n                return COVERED\n            return UNCOVERED\n        \n        result = [0]\n        if dfs(root, result) == UNCOVERED:\n            result[0] += 1\n        return result[0]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)"
    },
    {
      "title": "Sum of Distances in Tree",
      "difficulty": "Hard",
      "category": "Tree / Graph DP",
      "link": "https://leetcode.com/problems/sum-of-distances-in-tree",
      "slug": "sum-of-distances-in-tree",
      "description": "There is an undirected connected tree with \nn\n nodes labeled from \n0\n to \nn - 1\n and \nn - 1\n edges.\n\n\nYou are given the integer \nn\n and the array \nedges\n where \nedges[i] = [a\ni\n, b\ni\n]\n indicates that there is an edge between nodes \na\ni\n and \nb\ni\n in the tree.\n\n\nReturn an array \nanswer\n of length \nn\n where \nanswer[i]\n is the sum of the distances between the \ni\nth\n node in the tree and all other nodes.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]\n\nOutput:\n [8,12,6,10,10,10]\n\nExplanation:\n The tree is shown above.\nWe can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\nequals 1 + 1 + 2 + 2 + 2 = 8.\nHence, answer[0] = 8, and so on.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 1, edges = []\n\nOutput:\n [0]\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n n = 2, edges = [[1,0]]\n\nOutput:\n [1,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 3 * 10\n4\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < n\n\n\na\ni\n != b\ni\n\n\nThe given input represents a valid tree.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def sumOfDistancesInTree(self, N, edges):\n        \"\"\"\n        :type N: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def dfs(graph, node, parent, count, result):\n            for nei in graph[node]:\n                if nei != parent:\n                    dfs(graph, nei, node, count, result)\n                    count[node] += count[nei]\n                    result[node] += result[nei]+count[nei]\n\n        def dfs2(graph, node, parent, count, result):\n            for nei in graph[node]:\n                if nei != parent:\n                    result[nei] = result[node]-count[nei] + \\\n                                  len(count)-count[nei]\n                    dfs2(graph, nei, node, count, result)\n\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        count = [1] * N\n        result = [0] * N\n\n        dfs(graph, 0, None, count, result)\n        dfs2(graph, 0, None, count, result)\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    }
  ],
  "Bitmask DP": [
    {
      "title": "Minimum Number of Work Sessions to Finish the Tasks",
      "difficulty": "Medium",
      "category": "Bitmask DP",
      "link": "https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks",
      "slug": "minimum-number-of-work-sessions-to-finish-the-tasks",
      "description": "There are \nn\n tasks assigned to you. The task times are represented as an integer array \ntasks\n of length \nn\n, where the \ni\nth\n task takes \ntasks[i]\n hours to finish. A \nwork session\n is when you work for \nat most\n \nsessionTime\n consecutive hours and then take a break.\n\n\nYou should finish the given tasks in a way that satisfies the following conditions:\n\n\n\n\nIf you start a task in a work session, you must complete it in the \nsame\n work session.\n\n\nYou can start a new task \nimmediately\n after finishing the previous one.\n\n\nYou may complete the tasks in \nany order\n.\n\n\n\n\nGiven \ntasks\n and \nsessionTime\n, return \nthe \nminimum\n number of \nwork sessions\n needed to finish all the tasks following the conditions above.\n\n\nThe tests are generated such that \nsessionTime\n is \ngreater\n than or \nequal\n to the \nmaximum\n element in \ntasks[i]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n tasks = [1,2,3], sessionTime = 3\n\nOutput:\n 2\n\nExplanation:\n You can finish the tasks in two work sessions.\n- First work session: finish the first and the second tasks in 1 + 2 = 3 hours.\n- Second work session: finish the third task in 3 hours.\n\n\n\nExample 2:\n\n\n\n\nInput:\n tasks = [3,1,3,1,1], sessionTime = 8\n\nOutput:\n 2\n\nExplanation:\n You can finish the tasks in two work sessions.\n- First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.\n- Second work session: finish the last task in 1 hour.\n\n\n\nExample 3:\n\n\n\n\nInput:\n tasks = [1,2,3,4,5], sessionTime = 15\n\nOutput:\n 1\n\nExplanation:\n You can finish all the tasks in one work session.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == tasks.length\n\n\n1 <= n <= 14\n\n\n1 <= tasks[i] <= 10\n\n\nmax(tasks[i]) <= sessionTime <= 15",
      "solution": "class Solution(object):\n    def minSessions(self, tasks, sessionTime):\n        \"\"\"\n        :type tasks: List[int]\n        :type sessionTime: int\n        :rtype: int\n        \"\"\"\n        # dp[mask]: min used time by choosing tasks in mask bitset\n        dp = [float(\"inf\") for _ in xrange(1<<len(tasks))]\n        dp[0] = 0\n        for mask in xrange(len(dp)-1):\n            basis = 1\n            for task in tasks:\n                new_mask = mask|basis\n                basis <<= 1\n                if new_mask == mask:\n                    continue\n                if dp[mask]%sessionTime + task > sessionTime:\n                    task += sessionTime-dp[mask]%sessionTime  # take a break\n                dp[new_mask] = min(dp[new_mask], dp[mask]+task)\n        return (dp[-1]+sessionTime-1)//sessionTime\n\nclass Solution2(object):\n    def minSessions(self, tasks, sessionTime):\n        \"\"\"\n        :type tasks: List[int]\n        :type sessionTime: int\n        :rtype: int\n        \"\"\"\n        # dp[mask][0]: min number of sessions by choosing tasks in mask bitset\n        # dp[mask][1]: min used time of last session by choosing tasks in mask bitset\n        dp = [[float(\"inf\")]*2 for _ in xrange(1<<len(tasks))]\n        dp[0] = [0, sessionTime]\n        for mask in xrange(len(dp)-1):\n            basis = 1\n            for task in tasks:\n                new_mask = mask|basis\n                basis <<= 1\n                if new_mask == mask:\n                    continue\n                if dp[mask][1]+task <= sessionTime:\n                    dp[new_mask] = min(dp[new_mask], [dp[mask][0], dp[mask][1]+task])\n                else:\n                    dp[new_mask] = min(dp[new_mask], [dp[mask][0]+1, task])\n        return dp[-1][0]",
      "explanation": "N/A",
      "time_complexity": "O(n * 2^n)",
      "space_complexity": "O(2^n)"
    },
    {
      "title": "Fair Distribution of Cookies",
      "difficulty": "Medium",
      "category": "Bitmask DP",
      "link": "https://leetcode.com/problems/fair-distribution-of-cookies",
      "slug": "fair-distribution-of-cookies",
      "description": "You are given an integer array \ncookies\n, where \ncookies[i]\n denotes the number of cookies in the \ni\nth\n bag. You are also given an integer \nk\n that denotes the number of children to distribute \nall\n the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up.\n\n\nThe \nunfairness\n of a distribution is defined as the \nmaximum\n \ntotal\n cookies obtained by a single child in the distribution.\n\n\nReturn \nthe \nminimum\n unfairness of all distributions\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n cookies = [8,15,10,20,8], k = 2\n\nOutput:\n 31\n\nExplanation:\n One optimal distribution is [8,15,8] and [10,20]\n- The 1\nst\n child receives [8,15,8] which has a total of 8 + 15 + 8 = 31 cookies.\n- The 2\nnd\n child receives [10,20] which has a total of 10 + 20 = 30 cookies.\nThe unfairness of the distribution is max(31,30) = 31.\nIt can be shown that there is no distribution with an unfairness less than 31.\n\n\n\nExample 2:\n\n\n\n\nInput:\n cookies = [6,1,3,2,2,4,1,2], k = 3\n\nOutput:\n 7\n\nExplanation:\n One optimal distribution is [6,1], [3,2,2], and [4,1,2]\n- The 1\nst\n child receives [6,1] which has a total of 6 + 1 = 7 cookies.\n- The 2\nnd\n child receives [3,2,2] which has a total of 3 + 2 + 2 = 7 cookies.\n- The 3\nrd\n child receives [4,1,2] which has a total of 4 + 1 + 2 = 7 cookies.\nThe unfairness of the distribution is max(7,7,7) = 7.\nIt can be shown that there is no distribution with an unfairness less than 7.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= cookies.length <= 8\n\n\n1 <= cookies[i] <= 10\n5\n\n\n2 <= k <= cookies.length",
      "solution": "\n# dp, submask enumerationclass Solution(object):\n    def distributeCookies(self, cookies, k):\n        \"\"\"\n        :type cookies: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        total = [0]*(1<<len(cookies))\n        for mask in xrange(1<<len(cookies)):\n            total[mask] = sum(cookies[i] for i in xrange(len(cookies)) if mask&(1<<i))\n        dp = [[float(\"inf\")]*(1<<len(cookies)) for _ in xrange(2)]\n        dp[0][0] = 0\n        for i in xrange(k):\n            for mask in xrange(1<<len(cookies)):\n                submask = mask\n                while submask:\n                    dp[(i+1)%2][mask] = min(dp[(i+1)%2][mask], max(total[submask], dp[i%2][mask^submask]))\n                    submask = (submask-1)&mask\n        return dp[k%2][-1]",
      "explanation": "N/A",
      "time_complexity": "O(k * 3^n)",
      "space_complexity": "O(2^n)"
    },
    {
      "title": "Shortest Path Visiting All Nodes",
      "difficulty": "Hard",
      "category": "Bitmask DP",
      "link": "https://leetcode.com/problems/shortest-path-visiting-all-nodes",
      "slug": "shortest-path-visiting-all-nodes",
      "description": "You have an undirected, connected graph of \nn\n nodes labeled from \n0\n to \nn - 1\n. You are given an array \ngraph\n where \ngraph[i]\n is a list of all the nodes connected with node \ni\n by an edge.\n\n\nReturn \nthe length of the shortest path that visits every node\n. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n graph = [[1,2,3],[0],[0],[0]]\n\nOutput:\n 4\n\nExplanation:\n One possible path is [1,0,2,0,3]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]\n\nOutput:\n 4\n\nExplanation:\n One possible path is [0,1,4,2,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == graph.length\n\n\n1 <= n <= 12\n\n\n0 <= graph[i].length < n\n\n\ngraph[i]\n does not contain \ni\n.\n\n\nIf \ngraph[a]\n contains \nb\n, then \ngraph[b]\n contains \na\n.\n\n\nThe input graph is always connected.",
      "solution": "\nimport collections\n\nclass Solution(object):\n    def shortestPathLength(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: int\n        \"\"\"\n        dp = [[float(\"inf\")]*(len(graph))\n              for _ in xrange(1 << len(graph))]\n        q = collections.deque()\n        for i in xrange(len(graph)):\n            dp[1 << i][i] = 0\n            q.append((1 << i, i))\n        while q:\n            state, node = q.popleft()\n            steps = dp[state][node]\n            for nei in graph[node]:\n                new_state = state | (1 << nei)\n                if dp[new_state][nei] == float(\"inf\"):\n                    dp[new_state][nei] = steps+1\n                    q.append((new_state, nei))\n        return min(dp[-1])",
      "explanation": "N/A",
      "time_complexity": "O(n * 2^n)",
      "space_complexity": "O(n * 2^n)"
    }
  ],
  "Digit DP": [
    {
      "title": "Count Numbers with Unique Digits",
      "difficulty": "Medium",
      "category": "Digit DP",
      "link": "https://leetcode.com/problems/count-numbers-with-unique-digits",
      "slug": "count-numbers-with-unique-digits",
      "description": "Given an integer \nn\n, return the count of all numbers with unique digits, \nx\n, where \n0 <= x < 10\nn\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 91\n\nExplanation:\n The answer should be the total numbers in the range of 0 ≤ x < 100, excluding 11,22,33,44,55,66,77,88,99\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 0\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 8",
      "solution": "class Solution(object):\n    def countNumbersWithUniqueDigits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 1\n        result = cnt = 1\n        for i in xrange(n-1):\n            cnt *= 9-i\n            result += cnt\n        return 1+9*result\n\nclass Solution2(object):\n    def countNumbersWithUniqueDigits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        fact = [1]*2\n        def nPr(n, k):\n            while len(fact) <= n:  # lazy initialization\n                fact.append(fact[-1]*len(fact))\n            return fact[n]//fact[n-k]\n\n        return 1+9*sum(nPr(9, i) for i in xrange(n))",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "title": "Number of Digit One",
      "difficulty": "Hard",
      "category": "Digit DP",
      "link": "https://leetcode.com/problems/number-of-digit-one",
      "slug": "number-of-digit-one",
      "description": "Given an integer \nn\n, count \nthe total number of digit \n1\n appearing in all non-negative integers less than or equal to\n \nn\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 13\n\nOutput:\n 6\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 0\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 10\n9",
      "solution": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        DIGIT = 1\n        is_zero = int(DIGIT == 0)\n        result = is_zero\n        base = 1\n        while n >= base:\n            result += (n//(10*base)-is_zero)*base + \\\n                      min(base, max(n%(10*base) - DIGIT*base + 1, 0))\n            base *= 10\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Numbers At Most N Given Digit Set",
      "difficulty": "Hard",
      "category": "Digit DP",
      "link": "https://leetcode.com/problems/numbers-at-most-n-given-digit-set",
      "slug": "numbers-at-most-n-given-digit-set",
      "description": "Given an array of \ndigits\n which is sorted in \nnon-decreasing\n order. You can write numbers using each \ndigits[i]\n as many times as we want. For example, if \ndigits = ['1','3','5']\n, we may write numbers such as \n'13'\n, \n'551'\n, and \n'1351315'\n.\n\n\nReturn \nthe number of positive integers that can be generated \nthat are less than or equal to a given integer \nn\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n digits = [\"1\",\"3\",\"5\",\"7\"], n = 100\n\nOutput:\n 20\n\nExplanation: \n\nThe 20 numbers that can be written are:\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\n\n\n\nExample 2:\n\n\n\n\nInput:\n digits = [\"1\",\"4\",\"9\"], n = 1000000000\n\nOutput:\n 29523\n\nExplanation: \n\nWe can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,\n81 four digit numbers, 243 five digit numbers, 729 six digit numbers,\n2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.\nIn total, this is 29523 integers that can be written using the digits array.\n\n\n\nExample 3:\n\n\n\n\nInput:\n digits = [\"7\"], n = 8\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= digits.length <= 9\n\n\ndigits[i].length == 1\n\n\ndigits[i]\n is a digit from \n'1'\n to \n'9'\n.\n\n\nAll the values in \ndigits\n are \nunique\n.\n\n\ndigits\n is sorted in \nnon-decreasing\n order.\n\n\n1 <= n <= 10\n9",
      "solution": "class Solution(object):\n    def atMostNGivenDigitSet(self, D, N):\n        \"\"\"\n        :type D: List[str]\n        :type N: int\n        :rtype: int\n        \"\"\"\n        str_N = str(N)\n        set_D = set(D)\n        result = sum(len(D)**i for i in xrange(1, len(str_N)))\n        i = 0\n        while i < len(str_N):\n            result += sum(c < str_N[i] for c in D) * (len(D)**(len(str_N)-i-1))\n            if str_N[i] not in set_D:\n                break\n            i += 1\n        return result + int(i == len(str_N))",
      "explanation": "N/A",
      "time_complexity": "O(logn)",
      "space_complexity": "O(logn)"
    }
  ],
  "Probability DP": [
    {
      "title": "Knight Probability in Chessboard",
      "difficulty": "Medium",
      "category": "Probability DP",
      "link": "https://leetcode.com/problems/knight-probability-in-chessboard",
      "slug": "knight-probability-in-chessboard",
      "description": "On an \nn x n\n chessboard, a knight starts at the cell \n(row, column)\n and attempts to make exactly \nk\n moves. The rows and columns are \n0-indexed\n, so the top-left cell is \n(0, 0)\n, and the bottom-right cell is \n(n - 1, n - 1)\n.\n\n\nA chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.\n\n\n\n\nEach time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\n\n\nThe knight continues moving until it has made exactly \nk\n moves or has moved off the chessboard.\n\n\nReturn \nthe probability that the knight remains on the board after it has stopped moving\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 3, k = 2, row = 0, column = 0\n\nOutput:\n 0.06250\n\nExplanation:\n There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\nFrom each of those positions, there are also two moves that will keep the knight on the board.\nThe total probability the knight stays on the board is 0.0625.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1, k = 0, row = 0, column = 0\n\nOutput:\n 1.00000\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 25\n\n\n0 <= k <= 100\n\n\n0 <= row, column <= n - 1",
      "solution": "class Solution(object):\n    def knightProbability(self, N, K, r, c):\n        \"\"\"\n        :type N: int\n        :type K: int\n        :type r: int\n        :type c: int\n        :rtype: float\n        \"\"\"\n        directions = \\\n            [[ 1, 2], [ 1, -2], [ 2, 1], [ 2, -1], \\\n             [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n        dp = [[[1 for _ in xrange(N)] for _ in xrange(N)] for _ in xrange(2)]\n        for step in xrange(1, K+1):\n            for i in xrange(N):\n                for j in xrange(N):\n                    dp[step%2][i][j] = 0\n                    for direction in directions:\n                        rr, cc = i+direction[0], j+direction[1]\n                        if 0 <= cc < N and 0 <= rr < N:\n                            dp[step%2][i][j] += 0.125 * dp[(step-1)%2][rr][cc]\n\n        return dp[K%2][r][c]",
      "explanation": "N/A",
      "time_complexity": "O(k * n^2)",
      "space_complexity": "O(n^2)"
    },
    {
      "title": "Soup Servings",
      "difficulty": "Medium",
      "category": "Probability DP",
      "link": "https://leetcode.com/problems/soup-servings",
      "slug": "soup-servings",
      "description": "There are two types of soup: \ntype A\n and \ntype B\n. Initially, we have \nn\n ml of each type of soup. There are four kinds of operations:\n\n\n\n\nServe \n100\n ml of \nsoup A\n and \n0\n ml of \nsoup B\n,\n\n\nServe \n75\n ml of \nsoup A\n and \n25\n ml of \nsoup B\n,\n\n\nServe \n50\n ml of \nsoup A\n and \n50\n ml of \nsoup B\n, and\n\n\nServe \n25\n ml of \nsoup A\n and \n75\n ml of \nsoup B\n.\n\n\n\n\nWhen we serve some soup, we give it to someone, and we no longer have it. Each turn, we will choose from the four operations with an equal probability \n0.25\n. If the remaining volume of soup is not enough to complete the operation, we will serve as much as possible. We stop once we no longer have some quantity of both types of soup.\n\n\nNote\n that we do not have an operation where all \n100\n ml's of \nsoup B\n are used first.\n\n\nReturn \nthe probability that \nsoup A\n will be empty first, plus half the probability that \nA\n and \nB\n become empty at the same time\n. Answers within \n10\n-5\n of the actual answer will be accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 50\n\nOutput:\n 0.62500\n\nExplanation:\n If we choose the first two operations, A will become empty first.\nFor the third operation, A and B will become empty at the same time.\nFor the fourth operation, B will become empty first.\nSo the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 100\n\nOutput:\n 0.71875\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 10\n9",
      "solution": "class Solution(object):\n    def soupServings(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: float\n        \"\"\"\n        def dp(a, b, lookup):\n            if (a, b) in lookup:\n                return lookup[a, b]\n            if a <= 0 and b <= 0:\n                return 0.5\n            if a <= 0:\n                return 1.0\n            if b <= 0:\n                return 0.0\n            lookup[a, b] = 0.25 * (dp(a-4, b, lookup) +\n                                   dp(a-3, b-1, lookup) +\n                                   dp(a-2, b-2, lookup) +\n                                   dp(a-1, b-3, lookup))\n            return lookup[a, b]\n\n        if N >= 4800:\n            return 1.0\n        lookup = {}\n        N = (N+24)//25\n        return dp(N, N, lookup)",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "title": "New 21 Game",
      "difficulty": "Medium",
      "category": "Probability DP",
      "link": "https://leetcode.com/problems/new-21-game",
      "slug": "new-21-game",
      "description": "Alice plays the following game, loosely based on the card game \n\"21\"\n.\n\n\nAlice starts with \n0\n points and draws numbers while she has less than \nk\n points. During each draw, she gains an integer number of points randomly from the range \n[1, maxPts]\n, where \nmaxPts\n is an integer. Each draw is independent and the outcomes have equal probabilities.\n\n\nAlice stops drawing numbers when she gets \nk\n \nor more points\n.\n\n\nReturn the probability that Alice has \nn\n or fewer points.\n\n\nAnswers within \n10\n-5\n of the actual answer are considered accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 10, k = 1, maxPts = 10\n\nOutput:\n 1.00000\n\nExplanation:\n Alice gets a single card, then stops.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 6, k = 1, maxPts = 10\n\nOutput:\n 0.60000\n\nExplanation:\n Alice gets a single card, then stops.\nIn 6 out of 10 possibilities, she is at or below 6 points.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 21, k = 17, maxPts = 10\n\nOutput:\n 0.73278\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= k <= n <= 10\n4\n\n\n1 <= maxPts <= 10\n4",
      "solution": "# Solution not found in kamyu104 repository",
      "explanation": "N/A",
      "time_complexity": "N/A",
      "space_complexity": "N/A"
    }
  ],
  "State Machine DP": [
    {
      "title": "Best Time to Buy and Sell Stock with Cooldown",
      "difficulty": "Medium",
      "category": "State Machine DP",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown",
      "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
      "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n\n\n\n\nAfter you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n\n\n\n\nNote:\n You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [1,2,3,0,2]\n\nOutput:\n 3\n\nExplanation:\n transactions = [buy, sell, cooldown, buy, sell]\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [1]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 5000\n\n\n0 <= prices[i] <= 1000",
      "solution": "\nclass Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if not prices:\n            return 0\n        buy, sell, coolDown = [0] * 2, [0] * 2, [0] * 2\n        buy[0] = -prices[0]\n        for i in xrange(1, len(prices)):\n            # Bought before or buy today.\n            buy[i % 2] = max(buy[(i - 1) % 2],\n                             coolDown[(i - 1) % 2] - prices[i])\n            # Sell today.\n            sell[i % 2] = buy[(i - 1) % 2] + prices[i]\n            # Sold before yesterday or sold yesterday.\n            coolDown[i % 2] = max(coolDown[(i - 1) % 2], sell[(i - 1) % 2])\n        return max(coolDown[(len(prices) - 1) % 2],\n                   sell[(len(prices) - 1) % 2])",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Best Time to Buy and Sell Stock III",
      "difficulty": "Hard",
      "category": "State Machine DP",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii",
      "slug": "best-time-to-buy-and-sell-stock-iii",
      "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nFind the maximum profit you can achieve. You may complete \nat most two transactions\n.\n\n\nNote:\n You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [3,3,5,0,0,3,1,4]\n\nOutput:\n 6\n\nExplanation:\n Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [1,2,3,4,5]\n\nOutput:\n 4\n\nExplanation:\n Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n\n\n\nExample 3:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transaction is done, i.e. max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n5",
      "solution": "from typing import List\n\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        max_txn = k\n        n = len(prices)\n        # dp[t][d] = max profit with at most t transactions by day d\n        # t ∈ [0..2] (number of transactions)\n        # d ∈ [0..n-1] (days)\n        dp = [[0] * n for _ in range(max_txn + 1)]\n\n        for t in range(1, max_txn+1):\n            max_profit_so_far = -prices[0]\n            for d in range(1, n):\n                # Option 1: don't sell today, carry forward previous max\n                # Option 2: sell today, and find best buy day using max_so_far\n                dp[t][d] = max(dp[t][d-1], prices[d] + max_profit_so_far)\n                # Update max_so_far for future days\n                max_profit_so_far = max(max_profit_so_far, dp[t-1][d] - prices[d])\n        # last day upto max_txn \n        return dp[max_txn][n-1]",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    }
  ],
  "String Matching": [
    {
      "title": "Repeated String Match",
      "difficulty": "Medium",
      "category": "String Matching",
      "link": "https://leetcode.com/problems/repeated-string-match",
      "slug": "repeated-string-match",
      "description": "Given two strings \na\n and \nb\n, return \nthe minimum number of times you should repeat string \na\n so that string\n \nb\n \nis a substring of it\n. If it is impossible for \nb\n​​​​​​ to be a substring of \na\n after repeating it, return \n-1\n.\n\n\nNotice:\n string \n\"abc\"\n repeated 0 times is \n\"\"\n, repeated 1 time is \n\"abc\"\n and repeated 2 times is \n\"abcabc\"\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n a = \"abcd\", b = \"cdabcdab\"\n\nOutput:\n 3\n\nExplanation:\n We return 3 because by repeating a three times \"ab\ncdabcdab\ncd\", b is a substring of it.\n\n\n\nExample 2:\n\n\n\n\nInput:\n a = \"a\", b = \"aa\"\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= a.length, b.length <= 10\n4\n\n\na\n and \nb\n consist of lowercase English letters.",
      "solution": "class Solution(object):\n    def repeatedStringMatch(self, A, B):\n        \"\"\"\n        :type A: str\n        :type B: str\n        :rtype: int\n        \"\"\"\n        def check(index):\n            return all(A[(i+index) % len(A)] == c\n                       for i, c in enumerate(B))\n\n        M, p = 10**9+7, 113\n        p_inv = pow(p, M-2, M)\n        q = (len(B)+len(A)-1) // len(A)\n\n        b_hash, power = 0, 1\n        for c in B:\n            b_hash += power * ord(c)\n            b_hash %= M\n            power = (power*p) % M\n\n        a_hash, power = 0, 1\n        for i in xrange(len(B)):\n            a_hash += power * ord(A[i%len(A)])\n            a_hash %= M\n            power = (power*p) % M\n\n        if a_hash == b_hash and check(0): return q\n\n        power = (power*p_inv) % M\n        for i in xrange(len(B), (q+1)*len(A)):\n            a_hash = (a_hash-ord(A[(i-len(B))%len(A)])) * p_inv\n            a_hash += power * ord(A[i%len(A)])\n            a_hash %= M\n            if a_hash == b_hash and check(i-len(B)+1):\n                return q if i < q*len(A) else q+1\n\n        return -1",
      "explanation": "N/A",
      "time_complexity": "O(n + m)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Shortest Palindrome",
      "difficulty": "Hard",
      "category": "String Matching",
      "link": "https://leetcode.com/problems/shortest-palindrome",
      "slug": "shortest-palindrome",
      "description": "You are given a string \ns\n. You can convert \ns\n to a \npalindrome\n by adding characters in front of it.\n\n\nReturn \nthe shortest palindrome you can find by performing this transformation\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"aacecaaa\"\n\nOutput:\n \"aaacecaaa\"\n\nExample 2:\n\n\nInput:\n s = \"abcd\"\n\nOutput:\n \"dcbabcd\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 5 * 10\n4\n\n\ns\n consists of lowercase English letters only.",
      "solution": "\n# optimized from Solution2class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1] * len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j > -1 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        if not s:\n            return s\n\n        A = s + '#' + s[::-1]\n        return s[getPrefix(A)[-1]+1:][::-1] + s\n\nclass Solution2(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1] * len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j > -1 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        if not s:\n            return s\n\n        A = s + s[::-1]\n        prefix = getPrefix(A)\n        i = prefix[-1]\n        while i >= len(s):\n            i = prefix[i]\n        return s[i+1:][::-1] + s\n\n\n# Manacher's Algorithmclass Solution3(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def preProcess(s):\n            if not s:\n                return ['^', '$']\n            string = ['^']\n            for c in s:\n                string +=  ['#', c]\n            string += ['#', '$']\n            return string\n\n        string = preProcess(s)\n        palindrome = [0] * len(string)\n        center, right = 0, 0\n        for i in xrange(1, len(string) - 1):\n            i_mirror = 2 * center - i\n            if right > i:\n                palindrome[i] = min(right - i, palindrome[i_mirror])\n            else:\n                palindrome[i] = 0\n\n            while string[i + 1 + palindrome[i]] == string[i - 1 - palindrome[i]]:\n                palindrome[i] += 1\n\n            if i + palindrome[i] > right:\n                center, right = i, i + palindrome[i]\n\n        max_len = 0\n        for i in xrange(1, len(string) - 1):\n            if i - palindrome[i] == 1:\n                max_len = palindrome[i]\n        return s[len(s)-1:max_len-1:-1] + s",
      "explanation": "N/A",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    }
  ],
  "Binary Indexed Tree / Segment Tree": [
    {
      "title": "Range Sum Query - Mutable",
      "difficulty": "Medium",
      "category": "Binary Indexed Tree / Segment Tree",
      "link": "https://leetcode.com/problems/range-sum-query-mutable",
      "slug": "range-sum-query-mutable",
      "description": "Given an integer array \nnums\n, handle multiple queries of the following types:\n\n\n\n\nUpdate\n the value of an element in \nnums\n.\n\n\nCalculate the \nsum\n of the elements of \nnums\n between indices \nleft\n and \nright\n \ninclusive\n where \nleft <= right\n.\n\n\n\n\nImplement the \nNumArray\n class:\n\n\n\n\nNumArray(int[] nums)\n Initializes the object with the integer array \nnums\n.\n\n\nvoid update(int index, int val)\n \nUpdates\n the value of \nnums[index]\n to be \nval\n.\n\n\nint sumRange(int left, int right)\n Returns the \nsum\n of the elements of \nnums\n between indices \nleft\n and \nright\n \ninclusive\n (i.e. \nnums[left] + nums[left + 1] + ... + nums[right]\n).\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"]\n[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]\n\nOutput\n\n[null, 9, null, 8]\n\n\nExplanation\n\nNumArray numArray = new NumArray([1, 3, 5]);\nnumArray.sumRange(0, 2); // return 1 + 3 + 5 = 9\nnumArray.update(1, 2);   // nums = [1, 2, 5]\nnumArray.sumRange(0, 2); // return 1 + 2 + 5 = 8\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 3 * 10\n4\n\n\n-100 <= nums[i] <= 100\n\n\n0 <= index < nums.length\n\n\n-100 <= val <= 100\n\n\n0 <= left <= right < nums.length\n\n\nAt most \n3 * 10\n4\n calls will be made to \nupdate\n and \nsumRange\n.",
      "solution": "#        update: O(logn),\n#        query:  O(logn)\nclass NumArray(object):\n    def __init__(self, nums):\n        \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n        if not nums:\n            return\n        self.__nums = nums\n        self.__bit = [0] * (len(self.__nums) + 1)\n        for i in xrange(1, len(self.__bit)):\n            self.__bit[i] = nums[i-1] + self.__bit[i-1]\n\n        for i in reversed(xrange(1, len(self.__bit))):\n            last_i = i - (i & -i)\n            self.__bit[i] -= self.__bit[last_i]\n\n    def update(self, i, val):\n        \"\"\"\n        :type i: int\n        :type val: int\n        :rtype: int\n        \"\"\"\n        if val - self.__nums[i]:\n            self.__add(i, val - self.__nums[i])\n            self.__nums[i] = val\n\n    def sumRange(self, i, j):\n        \"\"\"\n        sum of elements nums[i..j], inclusive.\n        :type i: int\n        :type j: int\n        :rtype: int\n        \"\"\"\n        return self.__sum(j) - self.__sum(i-1)\n\n    def __sum(self, i):\n        i += 1\n        ret = 0\n        while i > 0:\n            ret += self.__bit[i]\n            i -= (i & -i)\n        return ret\n\n    def __add(self, i, val):\n        i += 1\n        while i <= len(self.__nums):\n            self.__bit[i] += val\n            i += (i & -i)\n\n\n#        update: O(logn),\n#        query:  O(logn)\n# Segment Tree solution.class NumArray2(object):\n    def __init__(self, nums,\n                 query_fn=lambda x, y: x+y,\n                 update_fn=lambda x, y: y,\n                 default_val=0):\n        \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n        N = len(nums)\n        self.__original_length = N\n        self.__tree_length = 2**(N.bit_length() + (N&(N-1) != 0))-1\n        self.__query_fn = query_fn\n        self.__update_fn = update_fn\n        self.__default_val = default_val\n        self.__tree = [default_val for _ in range(self.__tree_length)]\n        self.__lazy = [None for _ in range(self.__tree_length)]\n        self.__constructTree(nums, 0, self.__original_length-1, 0)\n\n    def update(self, i, val):\n        self.__updateTree(val, i, i, 0, self.__original_length-1, 0)\n\n    def sumRange(self, i, j):\n        return self.__queryRange(i, j, 0, self.__original_length-1, 0)\n\n    def __constructTree(self, nums, left, right, idx):\n        if left > right:\n             return\n        if left == right:\n            self.__tree[idx] = self.__update_fn(self.__tree[idx], nums[left])\n            return \n        mid = left + (right-left)//2\n        self.__constructTree(nums, left, mid, idx*2 + 1)\n        self.__constructTree(nums, mid+1, right, idx*2 + 2)\n        self.__tree[idx] = self.__query_fn(self.__tree[idx*2 + 1], self.__tree[idx*2 + 2])\n\n    def __apply(self, left, right, idx, val):\n        self.__tree[idx] = self.__update_fn(self.__tree[idx], val)\n        if left != right:\n            self.__lazy[idx*2 + 1] = self.__update_fn(self.__lazy[idx*2 + 1], val)\n            self.__lazy[idx*2 + 2] = self.__update_fn(self.__lazy[idx*2 + 2], val)\n\n    def __updateTree(self, val, range_left, range_right, left, right, idx):\n        if left > right:\n            return\n        if self.__lazy[idx] is not None:\n            self.__apply(left, right, idx, self.__lazy[idx])\n            self.__lazy[idx] = None\n        if range_left > right or range_right < left:\n            return\n        if range_left <= left and right <= range_right:\n            self.__apply(left, right, idx, val)\n            return\n        mid = left + (right-left)//2\n        self.__updateTree(val, range_left, range_right, left, mid, idx*2 + 1)\n        self.__updateTree(val, range_left, range_right, mid+1, right, idx*2 + 2)\n        self.__tree[idx] = self.__query_fn(self.__tree[idx*2 + 1],\n                                           self.__tree[idx*2 + 2])\n\n    def __queryRange(self, range_left, range_right, left, right, idx):\n        if left > right:\n            return self.__default_val\n        if self.__lazy[idx] is not None:\n            self.__apply(left, right, idx, self.__lazy[idx])\n            self.__lazy[idx] = None\n        if right < range_left or left > range_right:\n            return self.__default_val\n        if range_left <= left and right <= range_right:\n            return self.__tree[idx]\n        mid = left + (right-left)//2\n        return self.__query_fn(self.__queryRange(range_left, range_right, left, mid, idx*2 + 1), \n                               self.__queryRange(range_left, range_right, mid + 1, right, idx*2 + 2))",
      "explanation": "N/A",
      "time_complexity": "ctor:   O(n),",
      "space_complexity": "O(n)"
    },
    {
      "title": "Count of Smaller Numbers After Self",
      "difficulty": "Hard",
      "category": "Binary Indexed Tree / Segment Tree",
      "link": "https://leetcode.com/problems/count-of-smaller-numbers-after-self",
      "slug": "count-of-smaller-numbers-after-self",
      "description": "Given an integer array \nnums\n, return\n an integer array \ncounts\n where \ncounts[i]\n is the number of smaller elements to the right of \nnums[i]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [5,2,6,1]\n\nOutput:\n [2,1,1,0]\n\nExplanation:\n\nTo the right of 5 there are \n2\n smaller elements (2 and 1).\nTo the right of 2 there is only \n1\n smaller element (1).\nTo the right of 6 there is \n1\n smaller element (1).\nTo the right of 1 there is \n0\n smaller element.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-1]\n\nOutput:\n [0]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [-1,-1]\n\nOutput:\n [0,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4",
      "solution": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def countAndMergeSort(num_idxs, start, end, counts):\n            if end - start <= 0:  # The size of range [start, end] less than 2 is always with count 0.\n                return\n\n            mid = start + (end - start) // 2\n            countAndMergeSort(num_idxs, start, mid, counts)\n            countAndMergeSort(num_idxs, mid + 1, end, counts)\n            r = mid + 1\n            tmp = []\n            for i in xrange(start, mid + 1):\n                # Merge the two sorted arrays into tmp.\n                while r <= end and num_idxs[r][0] < num_idxs[i][0]:\n                    tmp.append(num_idxs[r])\n                    r += 1\n                tmp.append(num_idxs[i])\n                counts[num_idxs[i][1]] += r - (mid + 1)\n\n            # Copy tmp back to num_idxs\n            num_idxs[start:start+len(tmp)] = tmp\n\n        num_idxs = []\n        counts = [0] * len(nums)\n        for i, num in enumerate(nums):\n            num_idxs.append((num, i))\n        countAndMergeSort(num_idxs, 0, len(num_idxs) - 1, counts)\n        return counts\n\n\n# BIT solution.class Solution2(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        class BIT(object):  # 0-indexed.\n            def __init__(self, n):\n                self.__bit = [0]*(n+1)  # Extra one for dummy node.\n\n            def add(self, i, val):\n                i += 1  # Extra one for dummy node.\n                while i < len(self.__bit):\n                    self.__bit[i] += val\n                    i += (i & -i)\n\n            def query(self, i):\n                i += 1  # Extra one for dummy node.\n                ret = 0\n                while i > 0:\n                    ret += self.__bit[i]\n                    i -= (i & -i)\n                return ret\n\n        # Get the place (position in the ascending order) of each number.\n        sorted_nums = sorted(zip(nums, range(len(nums))))\n        lookup = {i:new_i for new_i, (_, i) in enumerate(sorted_nums)}\n\n        # Count the smaller elements after the number.\n        result, bit = [0]*len(nums), BIT(len(nums))\n        for i in reversed(xrange(len(nums))):\n            result[i] = bit.query(lookup[i]-1)\n            bit.add(lookup[i], 1)\n        return result\n\n\n# BST solution.class Solution3(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = [0] * len(nums)\n        bst = self.BST()\n        # Insert into BST and get left count.\n        for i in reversed(xrange(len(nums))):\n            bst.insertNode(nums[i])\n            res[i] = bst.query(nums[i])\n\n        return res\n\n    class BST(object):\n        class BSTreeNode(object):\n            def __init__(self, val):\n                self.val = val\n                self.count = 0\n                self.left = self.right = None\n\n        def __init__(self):\n            self.root = None\n\n        # Insert node into BST.\n        def insertNode(self, val):\n            node = self.BSTreeNode(val)\n            if not self.root:\n                self.root = node\n                return\n            curr = self.root\n            while curr:\n                # Insert left if smaller.\n                if node.val < curr.val:\n                    curr.count += 1  # Increase the number of left children.\n                    if curr.left:\n                        curr = curr.left\n                    else:\n                        curr.left = node\n                        break\n                else:  # Insert right if larger or equal.\n                    if curr.right:\n                        curr = curr.right\n                    else:\n                        curr.right = node\n                        break\n\n        # Query the smaller count of the value.\n        def query(self, val):\n            count = 0\n            curr = self.root\n            while curr:\n                # Insert left.\n                if val < curr.val:\n                    curr = curr.left\n                elif val > curr.val:\n                    count += 1 + curr.count  # Count the number of the smaller nodes.\n                    curr = curr.right\n                else:  # Equal.\n                    return count + curr.count\n            return 0",
      "explanation": "N/A",
      "time_complexity": "O(nlogn) ~ O(n^2)",
      "space_complexity": "O(n)"
    }
  ],
  "Maths / Geometry": [
    {
      "title": "Palindrome Number",
      "difficulty": "Easy",
      "category": "Maths / Geometry",
      "link": "https://leetcode.com/problems/palindrome-number",
      "slug": "palindrome-number",
      "description": "Given an integer \nx\n, return \ntrue\n if \nx\n is a \npalindrome\n, and \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 121\n\nOutput:\n true\n\nExplanation:\n 121 reads as 121 from left to right and from right to left.\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = -121\n\nOutput:\n false\n\nExplanation:\n From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n\n\nExample 3:\n\n\n\n\nInput:\n x = 10\n\nOutput:\n false\n\nExplanation:\n Reads 01 from right to left. Therefore it is not a palindrome.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= x <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you solve it without converting the integer to a string?",
      "solution": "class Solution(object):\n    # @return a boolean\n    def isPalindrome(self, x):\n        if x < 0:\n            return False\n        copy, reverse = x, 0\n\n        while copy:\n            reverse *= 10\n            reverse += copy % 10\n            copy //= 10\n\n        return x == reverse",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Reverse Integer",
      "difficulty": "Medium",
      "category": "Maths / Geometry",
      "link": "https://leetcode.com/problems/reverse-integer",
      "slug": "reverse-integer",
      "description": "Given a signed 32-bit integer \nx\n, return \nx\n with its digits reversed\n. If reversing \nx\n causes the value to go outside the signed 32-bit integer range \n[-2\n31\n, 2\n31\n - 1]\n, then return \n0\n.\n\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 123\n\nOutput:\n 321\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = -123\n\nOutput:\n -321\n\n\n\nExample 3:\n\n\n\n\nInput:\n x = 120\n\nOutput:\n 21\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= x <= 2\n31\n - 1",
      "solution": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 0:\n            return -self.reverse(-x)\n\n        result = 0\n        while x:\n            result = result * 10 + x % 10\n            x //= 10\n        return result if result <= 0x7fffffff else 0  # Handle overflow.\n\n    def reverse2(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 0:\n            x = int(str(x)[::-1][-1] + str(x)[::-1][:-1])\n        else:\n            x = int(str(x)[::-1])\n        x = 0 if abs(x) > 0x7FFFFFFF else x\n        return x\n\n    def reverse3(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        s = cmp(x, 0)\n        r = int(repr(s * x)[::-1])\n        return s * r * (r < 2 ** 31)",
      "explanation": "N/A",
      "time_complexity": "O(logn) = O(1)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Factorial Trailing Zeroes",
      "difficulty": "Medium",
      "category": "Maths / Geometry",
      "link": "https://leetcode.com/problems/factorial-trailing-zeroes",
      "slug": "factorial-trailing-zeroes",
      "description": "Given an integer \nn\n, return \nthe number of trailing zeroes in \nn!\n.\n\n\nNote that \nn! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 0\n\nExplanation:\n 3! = 6, no trailing zero.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 5\n\nOutput:\n 1\n\nExplanation:\n 5! = 120, one trailing zero.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 0\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n Could you write a solution that works in logarithmic time complexity?",
      "solution": "class Solution(object):\n    # @return an integer\n    def trailingZeroes(self, n):\n        result = 0\n        while n > 0:\n            result += n / 5\n            n /= 5\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(logn) = O(1)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Valid Square",
      "difficulty": "Medium",
      "category": "Maths / Geometry",
      "link": "https://leetcode.com/problems/valid-square",
      "slug": "valid-square",
      "description": "Given the coordinates of four points in 2D space \np1\n, \np2\n, \np3\n and \np4\n, return \ntrue\n \nif the four points construct a square\n.\n\n\nThe coordinate of a point \np\ni\n is represented as \n[x\ni\n, y\ni\n]\n. The input is \nnot\n given in any order.\n\n\nA \nvalid square\n has four equal sides with positive length and four equal angles (90-degree angles).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\nInput:\n p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]\n\nOutput:\n false\n\n\n\nExample 3:\n\n\n\n\nInput:\n p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\np1.length == p2.length == p3.length == p4.length == 2\n\n\n-10\n4\n <= x\ni\n, y\ni\n <= 10\n4",
      "solution": "class Solution(object):\n    def validSquare(self, p1, p2, p3, p4):\n        \"\"\"\n        :type p1: List[int]\n        :type p2: List[int]\n        :type p3: List[int]\n        :type p4: List[int]\n        :rtype: bool\n        \"\"\"\n        def dist(p1, p2):\n            return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\n        lookup = set([dist(p1, p2), dist(p1, p3),\\\n                      dist(p1, p4), dist(p2, p3),\\\n                      dist(p2, p4), dist(p3, p4)])\n        return 0 not in lookup and len(lookup) == 2",
      "explanation": "N/A",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "title": "Minimum Area Rectangle II",
      "difficulty": "Medium",
      "category": "Maths / Geometry",
      "link": "https://leetcode.com/problems/minimum-area-rectangle-ii",
      "slug": "minimum-area-rectangle-ii",
      "description": "You are given an array of points in the \nX-Y\n plane \npoints\n where \npoints[i] = [x\ni\n, y\ni\n]\n.\n\n\nReturn \nthe minimum area of any rectangle formed from these points, with sides \nnot necessarily parallel\n to the X and Y axes\n. If there is not any such rectangle, return \n0\n.\n\n\nAnswers within \n10\n-5\n of the actual answer will be accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[1,2],[2,1],[1,0],[0,1]]\n\nOutput:\n 2.00000\n\nExplanation:\n The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n points = [[0,1],[2,1],[1,1],[1,0],[2,0]]\n\nOutput:\n 1.00000\n\nExplanation:\n The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n points = [[0,3],[1,2],[3,1],[1,3],[2,1]]\n\nOutput:\n 0\n\nExplanation:\n There is no possible rectangle to form from these points.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= points.length <= 50\n\n\npoints[i].length == 2\n\n\n0 <= x\ni\n, y\ni\n <= 4 * 10\n4\n\n\nAll the given points are \nunique\n.",
      "solution": "\nimport collections\nimport itertools\n\nclass Solution(object):\n    def minAreaFreeRect(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: float\n        \"\"\"\n        points.sort()\n        points = [complex(*z) for z in points]\n        lookup = collections.defaultdict(list)\n        for P, Q in itertools.combinations(points, 2):\n            lookup[P-Q].append((P+Q) / 2)\n\n        result = float(\"inf\")\n        for A, candidates in lookup.iteritems():\n            for P, Q in itertools.combinations(candidates, 2):\n                if A.real * (P-Q).real + A.imag * (P-Q).imag == 0.0:\n                    result = min(result, abs(A) * abs(P-Q))\n        return result if result < float(\"inf\") else 0.0",
      "explanation": "N/A",
      "time_complexity": "O(n^2) ~ O(n^3)",
      "space_complexity": "O(n^2)"
    },
    {
      "title": "Max Points on a Line",
      "difficulty": "Hard",
      "category": "Maths / Geometry",
      "link": "https://leetcode.com/problems/max-points-on-a-line",
      "slug": "max-points-on-a-line",
      "description": "Given an array of \npoints\n where \npoints[i] = [x\ni\n, y\ni\n]\n represents a point on the \nX-Y\n plane, return \nthe maximum number of points that lie on the same straight line\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[1,1],[2,2],[3,3]]\n\nOutput:\n 3\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= points.length <= 300\n\n\npoints[i].length == 2\n\n\n-10\n4\n <= x\ni\n, y\ni\n <= 10\n4\n\n\nAll the \npoints\n are \nunique\n.",
      "solution": "\nimport collections\n\n\n# Definition for a pointclass Point(object):\n    def __init__(self, a=0, b=0):\n        self.x = a\n        self.y = b\nclass Solution(object):\n    def maxPoints(self, points):\n        \"\"\"\n        :type points: List[Point]\n        :rtype: int\n        \"\"\"\n        max_points = 0\n        for i, start in enumerate(points):\n            slope_count, same = collections.defaultdict(int), 1\n            for j in xrange(i + 1, len(points)):\n                end = points[j]\n                if start.x == end.x and start.y == end.y:\n                    same += 1\n                else:\n                    slope = float(\"inf\")\n                    if start.x - end.x != 0:\n                        slope = (start.y - end.y) * 1.0 / (start.x - end.x)\n                    slope_count[slope] += 1\n\n            current_max = same\n            for slope in slope_count:\n                current_max = max(current_max, slope_count[slope] + same)\n\n            max_points = max(max_points, current_max)\n\n        return max_points",
      "explanation": "N/A",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n)"
    }
  ],
  "Line Sweep": [
    {
      "title": "Minimum Interval to Include Each Query",
      "difficulty": "Hard",
      "category": "Line Sweep",
      "link": "https://leetcode.com/problems/minimum-interval-to-include-each-query",
      "slug": "minimum-interval-to-include-each-query",
      "description": "You are given a 2D integer array \nintervals\n, where \nintervals[i] = [left\ni\n, right\ni\n]\n describes the \ni\nth\n interval starting at \nleft\ni\n and ending at \nright\ni\n \n(inclusive)\n. The \nsize\n of an interval is defined as the number of integers it contains, or more formally \nright\ni\n - left\ni\n + 1\n.\n\n\nYou are also given an integer array \nqueries\n. The answer to the \nj\nth\n query is the \nsize of the smallest interval\n \ni\n such that \nleft\ni\n <= queries[j] <= right\ni\n. If no such interval exists, the answer is \n-1\n.\n\n\nReturn \nan array containing the answers to the queries\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]\n\nOutput:\n [3,3,1,4]\n\nExplanation:\n The queries are processed as follows:\n- Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.\n- Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.\n- Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.\n- Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]\n\nOutput:\n [2,-1,4,6]\n\nExplanation:\n The queries are processed as follows:\n- Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.\n- Query = 19: None of the intervals contain 19. The answer is -1.\n- Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.\n- Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= intervals.length <= 10\n5\n\n\n1 <= queries.length <= 10\n5\n\n\nintervals[i].length == 2\n\n\n1 <= left\ni\n <= right\ni\n <= 10\n7\n\n\n1 <= queries[j] <= 10\n7",
      "solution": "# space: O(n + k)\n\nimport heapq\n\nclass Solution(object):\n    def minInterval(self, intervals, queries):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        intervals.sort()\n        queries = [(q, i) for i, q in enumerate(queries)]\n        queries.sort()\n        min_heap = []\n        i = 0\n        result =[-1]*len(queries)\n        for q, idx in queries:\n            while i != len(intervals) and intervals[i][0] <= q:\n                heapq.heappush(min_heap, [intervals[i][1]-intervals[i][0]+1, i])\n                i += 1\n            while min_heap and intervals[min_heap[0][1]][1] < q:\n                heapq.heappop(min_heap)\n            result[idx] = min_heap[0][0] if min_heap else -1\n        return result",
      "explanation": "N/A",
      "time_complexity": "O(nlogn + klogk + klogn)",
      "space_complexity": "N/A"
    },
    {
      "title": "The Skyline Problem",
      "difficulty": "Hard",
      "category": "Line Sweep",
      "link": "https://leetcode.com/problems/the-skyline-problem",
      "slug": "the-skyline-problem",
      "description": "A city's \nskyline\n is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return \nthe \nskyline\n formed by these buildings collectively\n.\n\n\nThe geometric information of each building is given in the array \nbuildings\n where \nbuildings[i] = [left\ni\n, right\ni\n, height\ni\n]\n:\n\n\n\n\nleft\ni\n is the x coordinate of the left edge of the \ni\nth\n building.\n\n\nright\ni\n is the x coordinate of the right edge of the \ni\nth\n building.\n\n\nheight\ni\n is the height of the \ni\nth\n building.\n\n\n\n\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height \n0\n.\n\n\nThe \nskyline\n should be represented as a list of \"key points\" \nsorted by their x-coordinate\n in the form \n[[x\n1\n,y\n1\n],[x\n2\n,y\n2\n],...]\n. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate \n0\n and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.\n\n\nNote:\n There must be no consecutive horizontal lines of equal height in the output skyline. For instance, \n[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]\n is not acceptable; the three lines of height 5 should be merged into one in the final output as such: \n[...,[2 3],[4 5],[12 7],...]\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\n\nOutput:\n [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\n\nExplanation:\n\nFigure A shows the buildings of the input.\nFigure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\n\n\n\nExample 2:\n\n\n\n\nInput:\n buildings = [[0,2,3],[2,5,3]]\n\nOutput:\n [[0,3],[5,0]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= buildings.length <= 10\n4\n\n\n0 <= left\ni\n < right\ni\n <= 2\n31\n - 1\n\n\n1 <= height\ni\n <= 2\n31\n - 1\n\n\nbuildings\n is sorted by \nleft\ni\n in non-decreasing order.",
      "solution": "\nstart, end, height = 0, 1, 2class Solution(object):\n    # @param {integer[][]} buildings\n    # @return {integer[][]}\n    def getSkyline(self, buildings):\n        intervals = self.ComputeSkylineInInterval(buildings, 0, len(buildings))\n\n        res = []\n        last_end = -1\n        for interval in intervals:\n            if last_end != -1 and last_end < interval[start]:\n                res.append([last_end, 0])\n            res.append([interval[start], interval[height]])\n            last_end = interval[end]\n        if last_end != -1:\n            res.append([last_end, 0])\n\n        return res\n\n    # Divide and Conquer.\n    def ComputeSkylineInInterval(self, buildings, left_endpoint, right_endpoint):\n        if right_endpoint - left_endpoint <= 1:\n            return buildings[left_endpoint:right_endpoint]\n        mid = left_endpoint + ((right_endpoint - left_endpoint) / 2)\n        left_skyline = self.ComputeSkylineInInterval(buildings, left_endpoint, mid)\n        right_skyline = self.ComputeSkylineInInterval(buildings, mid, right_endpoint)\n        return self.MergeSkylines(left_skyline, right_skyline)\n\n    # Merge Sort.\n    def MergeSkylines(self, left_skyline, right_skyline):\n        i, j = 0, 0\n        merged = []\n\n        while i < len(left_skyline) and j < len(right_skyline):\n            if left_skyline[i][end] < right_skyline[j][start]:\n                merged.append(left_skyline[i])\n                i += 1\n            elif right_skyline[j][end] < left_skyline[i][start]:\n                merged.append(right_skyline[j])\n                j += 1\n            elif left_skyline[i][start] <= right_skyline[j][start]:\n                i, j = self.MergeIntersectSkylines(merged, left_skyline[i], i,\\\n                                                   right_skyline[j], j)\n            else: # left_skyline[i][start] > right_skyline[j][start].\n                j, i = self.MergeIntersectSkylines(merged, right_skyline[j], j, \\\n                                                   left_skyline[i], i)\n\n        # Insert the remaining skylines.\n        merged += left_skyline[i:]\n        merged += right_skyline[j:]\n        return merged\n\n    # a[start] <= b[start]\n    def MergeIntersectSkylines(self, merged, a, a_idx, b, b_idx):\n        if a[end] <= b[end]:\n            if a[height] > b[height]:   # |aaa|\n                if b[end] != a[end]:    # |abb|b\n                    b[start] = a[end]\n                    merged.append(a)\n                    a_idx += 1\n                else:             # aaa\n                    b_idx += 1    # abb\n            elif a[height] == b[height]:  # abb\n                b[start] = a[start]       # abb\n                a_idx += 1\n            else:  # a[height] < b[height].\n                if a[start] != b[start]:                            #    bb\n                    merged.append([a[start], b[start], a[height]])  # |a|bb\n                a_idx += 1\n        else:  # a[end] > b[end].\n            if a[height] >= b[height]:  # aaaa\n                b_idx += 1              # abba\n            else:\n                #    |bb|\n                # |a||bb|a\n                if a[start] != b[start]:\n                    merged.append([a[start], b[start], a[height]])\n                a[start] = b[end]\n                merged.append(b)\n                b_idx += 1\n        return a_idx, b_idx",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    }
  ],
  "Suffix Array": [
    {
      "title": "Longest Duplicate Substring",
      "difficulty": "Hard",
      "category": "Suffix Array",
      "link": "https://leetcode.com/problems/longest-duplicate-substring",
      "slug": "longest-duplicate-substring",
      "description": "Given a string \ns\n, consider all \nduplicated substrings\n: (contiguous) substrings of s that occur 2 or more times. The occurrences may overlap.\n\n\nReturn \nany\n duplicated substring that has the longest possible length. If \ns\n does not have a duplicated substring, the answer is \n\"\"\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"banana\"\n\nOutput:\n \"ana\"\n\nExample 2:\n\n\nInput:\n s = \"abcd\"\n\nOutput:\n \"\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= s.length <= 3 * 10\n4\n\n\ns\n consists of lowercase English letters.",
      "solution": "\n# 1. other solution is to apply kasai's algorithm, refer to the link below:\n# - https://leetcode.com/problems/longest-duplicate-substring/discuss/290852/Suffix-array-clear-solution\n# 2. the best solution is to apply ukkonen's algorithm, refer to the link below:\n# - https://leetcode.com/problems/longest-duplicate-substring/discuss/312999/best-java-on-complexity-and-on-space-solution-suffix-tree-67ms\n\nimport collections\n\nclass Solution(object):\n    def longestDupSubstring(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n        M = 10**9+7\n        D = 26\n\n        def check(S, L):\n            p = pow(D, L, M)\n            curr = reduce(lambda x, y: (D*x+ord(y)-ord('a')) % M, S[:L], 0)\n            lookup = collections.defaultdict(list)\n            lookup[curr].append(L-1)\n            for i in xrange(L, len(S)):\n                curr = ((D*curr) % M + ord(S[i])-ord('a') -\n                        ((ord(S[i-L])-ord('a'))*p) % M) % M\n                if curr in lookup:\n                    for j in lookup[curr]:  # check if string is the same when hash is the same\n                        if S[j-L+1:j+1] == S[i-L+1:i+1]:\n                            return i-L+1\n                lookup[curr].append(i)\n            return 0\n\n        left, right = 1, len(S)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(S, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        result = check(S, right)\n        return S[result:result + right]",
      "explanation": "N/A",
      "time_complexity": "O(nlogn)",
      "space_complexity": "O(n)"
    }
  ]
}