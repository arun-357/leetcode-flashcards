[
  {
    "title": "Two Sum",
    "difficulty": "EASY",
    "category": "Array, Hash Table",
    "link": "https://leetcode.com/problems/two-sum",
    "slug": "two-sum",
    "description": "Given an array of integers \nnums\n and an integer \ntarget\n, return \nindices of the two numbers such that they add up to \ntarget\n.\n\n\nYou may assume that each input would have \nexactly\n one solution\n, and you may not use the \nsame\n element twice.\n\n\nYou can return the answer in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,7,11,15], target = 9\n\nOutput:\n [0,1]\n\nExplanation:\n Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,4], target = 6\n\nOutput:\n [1,2]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,3], target = 6\n\nOutput:\n [0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n-10\n9\n <= target <= 10\n9\n\n\nOnly one valid answer exists.\n\n\n\n\n \n\n\nFollow-up: \nCan you come up with an algorithm that is less than \nO(n\n2\n)\n \ntime complexity?",
    "solution": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        lookup = {}\n        for i, num in enumerate(nums):\n            if target - num in lookup:\n                return [lookup[target - num], i]\n            lookup[num] = i\n\n    def twoSum2(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        for i in nums:\n            j = target - i\n            tmp_nums_start_index = nums.index(i) + 1\n            tmp_nums = nums[tmp_nums_start_index:]\n            if j in tmp_nums:\n                return [nums.index(i), tmp_nums_start_index + tmp_nums.index(j)]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "MEDIUM",
    "category": "Hash Table, String, Sliding Window",
    "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters",
    "slug": "longest-substring-without-repeating-characters",
    "description": "Given a string \ns\n, find the length of the \nlongest\n \nsubstring\n without duplicate characters.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abcabcbb\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"abc\", with the length of 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"bbbbb\"\n\nOutput:\n 1\n\nExplanation:\n The answer is \"b\", with the length of 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"pwwkew\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 5 * 10\n4\n\n\ns\n consists of English letters, digits, symbols and spaces.",
    "solution": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, left = 0, 0\n        lookup = {}\n        for right in xrange(len(s)):\n            if s[right] in lookup:\n                left = max(left, lookup[s[right]]+1)\n            lookup[s[right]] = right\n            result = max(result, right-left+1)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Longest Palindromic Substring",
    "difficulty": "MEDIUM",
    "category": "Two Pointers, String, Dynamic Programming",
    "link": "https://leetcode.com/problems/longest-palindromic-substring",
    "slug": "longest-palindromic-substring",
    "description": "Given a string \ns\n, return \nthe longest\n \npalindromic\n \nsubstring\n in \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"babad\"\n\nOutput:\n \"bab\"\n\nExplanation:\n \"aba\" is also a valid answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"cbbd\"\n\nOutput:\n \"bb\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consist of only digits and English letters.",
    "solution": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def preProcess(s):\n            if not s:\n                return ['^', '$']\n            T = ['^']\n            for c in s:\n                T +=  ['#', c]\n            T += ['#', '$']\n            return T\n\n        T = preProcess(s)\n        P = [0] * len(T)\n        center, right = 0, 0\n        for i in xrange(1, len(T) - 1):\n            i_mirror = 2 * center - i\n            if right > i:\n                P[i] = min(right - i, P[i_mirror])\n            else:\n                P[i] = 0\n\n            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:\n                P[i] += 1\n\n            if i + P[i] > right:\n                center, right = i, i + P[i]\n\n        max_i = 0\n        for i in xrange(1, len(T) - 1):\n            if P[i] > P[max_i]:\n                max_i = i\n        start = (max_i - 1 - P[max_i]) // 2\n        return s[start : start + P[max_i]]\n\nclass Solution2(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return (right-left+1)-2\n        \n        left, right = -1, -2\n        for i in xrange(len(s)):\n            l = max(expand(s, i, i), expand(s, i, i+1))\n            if l > right-left+1:\n                right = i+l//2\n                left = right-l+1\n        return s[left:right+1] if left >= 0 else \"\"",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Median of Two Sorted Arrays",
    "difficulty": "HARD",
    "category": "Array, Binary Search, Divide and Conquer",
    "link": "https://leetcode.com/problems/median-of-two-sorted-arrays",
    "slug": "median-of-two-sorted-arrays",
    "description": "Given two sorted arrays \nnums1\n and \nnums2\n of size \nm\n and \nn\n respectively, return \nthe median\n of the two sorted arrays.\n\n\nThe overall run time complexity should be \nO(log (m+n))\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,3], nums2 = [2]\n\nOutput:\n 2.00000\n\nExplanation:\n merged array = [1,2,3] and median is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1,2], nums2 = [3,4]\n\nOutput:\n 2.50000\n\nExplanation:\n merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m\n\n\nnums2.length == n\n\n\n0 <= m <= 1000\n\n\n0 <= n <= 1000\n\n\n1 <= m + n <= 2000\n\n\n-10\n6\n <= nums1[i], nums2[i] <= 10\n6",
    "solution": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(A, B, k):\n            m, n = len(A), len(B)\n            if m > n:\n                m, n = n, m\n                A, B = B, A\n            i = binary_search(max(k-n, 0), min(m, k)-1, lambda i: A[i] >= B[k-1-i])\n            return max(A[i-1] if i-1 >= 0 else float(\"-inf\"), B[k-1-i] if k-1-i >= 0 else float(\"-inf\"))\n\n        len1, len2 = len(nums1), len(nums2)\n        if (len1+len2) % 2 == 1:\n            return getKth(nums1, nums2, (len1+len2)//2+1)\n        else:\n            return (getKth(nums1, nums2, (len1+len2)//2)+getKth(nums1, nums2, (len1+len2)//2+1))*0.5    \n\n\n# Generic solution.class Solution_Generic(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(arrays, k):\n            def check(num):\n                # count the number of values which are less or equal to num\n                return sum(binary_search(0, len(arr)-1, lambda x: arr[x] > num) for arr in arrays) >= k\n    \n            return binary_search(min(arr[0] for arr in arrays if arr), max(arr[-1] for arr in arrays if arr), check)\n\n        array = [nums1, nums2]\n        total = sum(len(nums) for nums in array)\n        if total % 2 == 1:\n            return getKth(array, total//2+1)\n        else:\n            return (getKth(array, total//2)+getKth(array, total//2+1))*0.5",
    "explanation": "N/A",
    "time_complexity": "O(log(max(m, n)) * log(max_val - min_val))",
    "space_complexity": "O(1)"
  },
  {
    "title": "Search in Rotated Sorted Array",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/search-in-rotated-sorted-array",
    "slug": "search-in-rotated-sorted-array",
    "description": "There is an integer array \nnums\n sorted in ascending order (with \ndistinct\n values).\n\n\nPrior to being passed to your function, \nnums\n is \npossibly rotated\n at an unknown pivot index \nk\n (\n1 <= k < nums.length\n) such that the resulting array is \n[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]\n (\n0-indexed\n). For example, \n[0,1,2,4,5,6,7]\n might be rotated at pivot index \n3\n and become \n[4,5,6,7,0,1,2]\n.\n\n\nGiven the array \nnums\n \nafter\n the possible rotation and an integer \ntarget\n, return \nthe index of \ntarget\n if it is in \nnums\n, or \n-1\n if it is not in \nnums\n.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [4,5,6,7,0,1,2], target = 0\n\nOutput:\n 4\n\nExample 2:\n\n\nInput:\n nums = [4,5,6,7,0,1,2], target = 3\n\nOutput:\n -1\n\nExample 3:\n\n\nInput:\n nums = [1], target = 0\n\nOutput:\n -1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 5000\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nAll values of \nnums\n are \nunique\n.\n\n\nnums\n is an ascending array that is possibly rotated.\n\n\n-10\n4\n <= target <= 10\n4",
    "solution": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) / 2\n\n            if nums[mid] == target:\n                return mid\n            elif (nums[mid] >= nums[left] and nums[left] <= target < nums[mid]) or \\\n                 (nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])):\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return -1",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Container With Most Water",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers, Greedy",
    "link": "https://leetcode.com/problems/container-with-most-water",
    "slug": "container-with-most-water",
    "description": "You are given an integer array \nheight\n of length \nn\n. There are \nn\n vertical lines drawn such that the two endpoints of the \ni\nth\n line are \n(i, 0)\n and \n(i, height[i])\n.\n\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\n\nReturn \nthe maximum amount of water a container can store\n.\n\n\nNotice\n that you may not slant the container.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [1,8,6,2,5,4,8,3,7]\n\nOutput:\n 49\n\nExplanation:\n The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [1,1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= height[i] <= 10\n4",
    "solution": "class Solution(object):\n    # @return an integer\n    def maxArea(self, height):\n        max_area, i, j = 0, 0, len(height) - 1\n        while i < j:\n            max_area = max(max_area, min(height[i], height[j]) * (j - i))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return max_area",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Group Anagrams",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, String, Sorting",
    "link": "https://leetcode.com/problems/group-anagrams",
    "slug": "group-anagrams",
    "description": "Given an array of strings \nstrs\n, group the \nanagrams\n together. You can return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nstrs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n\n\nOutput:\n \n[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\n\nExplanation:\n\n\n\n\nThere is no string in strs that can be rearranged to form \n\"bat\"\n.\n\n\nThe strings \n\"nat\"\n and \n\"tan\"\n are anagrams as they can be rearranged to form each other.\n\n\nThe strings \n\"ate\"\n, \n\"eat\"\n, and \n\"tea\"\n are anagrams as they can be rearranged to form each other.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nstrs = [\"\"]\n\n\nOutput:\n \n[[\"\"]]\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nstrs = [\"a\"]\n\n\nOutput:\n \n[[\"a\"]]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 10\n4\n\n\n0 <= strs[i].length <= 100\n\n\nstrs[i]\n consists of lowercase English letters.",
    "solution": "\nimport collections\n\nclass Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagrams_map, result = collections.defaultdict(list), []\n        for s in strs:\n            sorted_str = (\"\").join(sorted(s))\n            anagrams_map[sorted_str].append(s)\n        for anagram in anagrams_map.values():\n            anagram.sort()\n            result.append(anagram)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n * glogg), g is the max size of groups.",
    "space_complexity": "O(n)"
  },
  {
    "title": "Minimum Edge Reversals So Every Node Is Reachable",
    "difficulty": "HARD",
    "category": "Dynamic Programming, Depth-First Search, Breadth-First Search, Graph",
    "link": "https://leetcode.com/problems/minimum-edge-reversals-so-every-node-is-reachable",
    "slug": "minimum-edge-reversals-so-every-node-is-reachable",
    "description": "There is a \nsimple directed graph\n with \nn\n nodes labeled from \n0\n to \nn - 1\n. The graph would form a \ntree\n if its edges were bi-directional.\n\n\nYou are given an integer \nn\n and a \n2D\n integer array \nedges\n, where \nedges[i] = [u\ni\n, v\ni\n]\n represents a \ndirected edge\n going from node \nu\ni\n to node \nv\ni\n.\n\n\nAn \nedge reversal\n changes the direction of an edge, i.e., a directed edge going from node \nu\ni\n to node \nv\ni\n becomes a directed edge going from node \nv\ni\n to node \nu\ni\n.\n\n\nFor every node \ni\n in the range \n[0, n - 1]\n, your task is to \nindependently\n calculate the \nminimum\n number of \nedge reversals\n required so it is possible to reach any other node starting from node \ni\n through a \nsequence\n of \ndirected edges\n.\n\n\nReturn \nan integer array \nanswer\n, where \nanswer[i]\n is the\n \n \nminimum\n number of \nedge reversals\n required so it is possible to reach any other node starting from node \ni\n through a \nsequence\n of \ndirected edges\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4, edges = [[2,0],[2,1],[1,3]]\n\nOutput:\n [1,1,0,2]\n\nExplanation:\n The image above shows the graph formed by the edges.\nFor node 0: after reversing the edge [2,0], it is possible to reach any other node starting from node 0.\nSo, answer[0] = 1.\nFor node 1: after reversing the edge [2,1], it is possible to reach any other node starting from node 1.\nSo, answer[1] = 1.\nFor node 2: it is already possible to reach any other node starting from node 2.\nSo, answer[2] = 0.\nFor node 3: after reversing the edges [1,3] and [2,1], it is possible to reach any other node starting from node 3.\nSo, answer[3] = 2.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n n = 3, edges = [[1,2],[2,0]]\n\nOutput:\n [2,0,1]\n\nExplanation:\n The image above shows the graph formed by the edges.\nFor node 0: after reversing the edges [2,0] and [1,2], it is possible to reach any other node starting from node 0.\nSo, answer[0] = 2.\nFor node 1: it is already possible to reach any other node starting from node 1.\nSo, answer[1] = 0.\nFor node 2: after reversing the edge [1, 2], it is possible to reach any other node starting from node 2.\nSo, answer[2] = 1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= n <= 10\n5\n\n\nedges.length == n - 1\n\n\nedges[i].length == 2\n\n\n0 <= u\ni\n == edges[i][0] < n\n\n\n0 <= v\ni\n == edges[i][1] < n\n\n\nu\ni\n != v\ni\n\n\nThe input is generated such that if the edges were bi-directional, the graph would be a tree.",
    "solution": "\n# iterative dfs, tree dpclass Solution(object):\n    def minEdgeReversals(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def iter_dfs1():\n            result = 0\n            stk = [(0, -1)]\n            while stk:\n                u, p = stk.pop()\n                for v in adj[u].iterkeys():\n                    if v == p:\n                        continue\n                    result += adj[u][v]\n                    stk.append((v, u))\n            return result\n\n        def iter_dfs2(curr):\n            result = [-1]*n\n            stk = [(0, curr)]\n            while stk:\n                u, curr = stk.pop()\n                result[u] = curr\n                for v in adj[u].iterkeys():\n                    if result[v] == -1:\n                        stk.append((v, curr-adj[u][v]+adj[v][u]))\n            return result\n    \n        adj = collections.defaultdict(dict)\n        for u, v in edges:\n            adj[u][v] = 0\n            adj[v][u] = 1\n        return iter_dfs2(iter_dfs1())\n        \n\n# dfs, tree dpclass Solution2(object):\n    def minEdgeReversals(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def dfs1(u, p):\n            return sum(adj[u][v]+dfs1(v, u) for v in adj[u] if v != p)\n\n        def dfs2(u, curr):\n            result[u] = curr\n            for v in adj[u]:\n                if result[v] == -1:\n                    dfs2(v, curr-adj[u][v]+adj[v][u])\n    \n        adj = collections.defaultdict(dict)\n        for u, v in edges:\n            adj[u][v] = 0\n            adj[v][u] = 1\n        result = [-1]*n\n        dfs2(0, dfs1(0, -1))\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Roman to Integer",
    "difficulty": "EASY",
    "category": "Hash Table, Math, String",
    "link": "https://leetcode.com/problems/roman-to-integer",
    "slug": "roman-to-integer",
    "description": "Roman numerals are represented by seven different symbols: \nI\n, \nV\n, \nX\n, \nL\n, \nC\n, \nD\n and \nM\n.\n\n\n\n\nSymbol\n       \nValue\n\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\n\nFor example, \n2\n is written as \nII\n in Roman numeral, just two ones added together. \n12\n is written as \nXII\n, which is simply \nX + II\n. The number \n27\n is written as \nXXVII\n, which is \nXX + V + II\n.\n\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not \nIIII\n. Instead, the number four is written as \nIV\n. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as \nIX\n. There are six instances where subtraction is used:\n\n\n\n\nI\n can be placed before \nV\n (5) and \nX\n (10) to make 4 and 9. \n\n\nX\n can be placed before \nL\n (50) and \nC\n (100) to make 40 and 90. \n\n\nC\n can be placed before \nD\n (500) and \nM\n (1000) to make 400 and 900.\n\n\n\n\nGiven a roman numeral, convert it to an integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"III\"\n\nOutput:\n 3\n\nExplanation:\n III = 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"LVIII\"\n\nOutput:\n 58\n\nExplanation:\n L = 50, V= 5, III = 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"MCMXCIV\"\n\nOutput:\n 1994\n\nExplanation:\n M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 15\n\n\ns\n contains only the characters \n('I', 'V', 'X', 'L', 'C', 'D', 'M')\n.\n\n\nIt is \nguaranteed\n that \ns\n is a valid roman numeral in the range \n[1, 3999]\n.",
    "solution": "class Solution(object):\n    # @return an integer\n    def romanToInt(self, s):\n        numeral_map = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\":100, \"D\": 500, \"M\": 1000}\n        decimal = 0\n        for i in xrange(len(s)):\n            if i > 0 and numeral_map[s[i]] > numeral_map[s[i - 1]]:\n                decimal += numeral_map[s[i]] - 2 * numeral_map[s[i - 1]]\n            else:\n                decimal += numeral_map[s[i]]\n        return decimal",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Find Peak Element",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/find-peak-element",
    "slug": "find-peak-element",
    "description": "A peak element is an element that is strictly greater than its neighbors.\n\n\nGiven a \n0-indexed\n integer array \nnums\n, find a peak element, and return its index. If the array contains multiple peaks, return the index to \nany of the peaks\n.\n\n\nYou may imagine that \nnums[-1] = nums[n] = -∞\n. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\n\nYou must write an algorithm that runs in \nO(log n)\n time.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,1]\n\nOutput:\n 2\n\nExplanation:\n 3 is a peak element and your function should return the index number 2.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,1,3,5,6,4]\n\nOutput:\n 5\n\nExplanation:\n Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\nnums[i] != nums[i + 1]\n for all valid \ni\n.",
    "solution": "class Solution(object):\n    def findPeakElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            mid = left + (right - left) / 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Climbing Stairs",
    "difficulty": "EASY",
    "category": "Math, Dynamic Programming, Memoization",
    "link": "https://leetcode.com/problems/climbing-stairs",
    "slug": "climbing-stairs",
    "description": "You are climbing a staircase. It takes \nn\n steps to reach the top.\n\n\nEach time you can either climb \n1\n or \n2\n steps. In how many distinct ways can you climb to the top?\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 2\n\nExplanation:\n There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 3\n\nExplanation:\n There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 45",
    "solution": "\nimport itertools\n\nclass Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def matrix_expo(A, K):\n            result = [[int(i==j) for j in xrange(len(A))] \\\n                      for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b for a, b in itertools.izip(row, col)) \\\n                     for col in ZB] for row in A]\n\n        T = [[1, 1],\n             [1, 0]]\n        return matrix_mult([[1,  0]], matrix_expo(T, n))[0][0]  # [a0, a(-1)] * T^n\n\nclass Solution2(object):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    def climbStairs(self, n):\n        prev, current = 0, 1\n        for i in xrange(n):\n            prev, current = current, prev + current,\n        return current",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "EASY",
    "category": "Array, Dynamic Programming",
    "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
    "slug": "best-time-to-buy-and-sell-stock",
    "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nYou want to maximize your profit by choosing a \nsingle day\n to buy one stock and choosing a \ndifferent day in the future\n to sell that stock.\n\n\nReturn \nthe maximum profit you can achieve from this transaction\n. If you cannot achieve any profit, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 5\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transactions are done and the max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n4",
    "solution": "class Solution(object):\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, prices):\n        max_profit, min_price = 0, float(\"inf\")\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Move Zeroes",
    "difficulty": "EASY",
    "category": "Array, Two Pointers",
    "link": "https://leetcode.com/problems/move-zeroes",
    "slug": "move-zeroes",
    "description": "Given an integer array \nnums\n, move all \n0\n's to the end of it while maintaining the relative order of the non-zero elements.\n\n\nNote\n that you must do this in-place without making a copy of the array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [0,1,0,3,12]\n\nOutput:\n [1,3,12,0,0]\n\nExample 2:\n\n\nInput:\n nums = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you minimize the total number of operations done?",
    "solution": "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i]:\n                nums[i], nums[pos] = nums[pos], nums[i]\n                pos += 1\n\n    def moveZeroes2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort(cmp=lambda a, b: 0 if b else -1)\n\nclass Solution2(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i]:\n                nums[pos] = nums[i]\n                pos += 1\n\n        for i in xrange(pos, len(nums)):\n            nums[i] = 0",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Largest Rectangle in Histogram",
    "difficulty": "HARD",
    "category": "Array, Stack, Monotonic Stack",
    "link": "https://leetcode.com/problems/largest-rectangle-in-histogram",
    "slug": "largest-rectangle-in-histogram",
    "description": "Given an array of integers \nheights\n representing the histogram's bar height where the width of each bar is \n1\n, return \nthe area of the largest rectangle in the histogram\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [2,1,5,6,2,3]\n\nOutput:\n 10\n\nExplanation:\n The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n heights = [2,4]\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= heights.length <= 10\n5\n\n\n0 <= heights[i] <= 10\n4",
    "solution": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stk, result = [-1], 0\n        for i in xrange(len(heights)+1):\n            while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):\n                result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))\n            stk.append(i) \n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "K-th Smallest in Lexicographical Order",
    "difficulty": "HARD",
    "category": "Trie",
    "link": "https://leetcode.com/problems/k-th-smallest-in-lexicographical-order",
    "slug": "k-th-smallest-in-lexicographical-order",
    "description": "Given two integers \nn\n and \nk\n, return \nthe\n \nk\nth\n \nlexicographically smallest integer in the range\n \n[1, n]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 13, k = 2\n\nOutput:\n 10\n\nExplanation:\n The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1, k = 1\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= n <= 10\n9",
    "solution": "class Solution(object):\n    def findKthNumber(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n\n        cnts = [0] * 10\n        for i in xrange(1, 10):\n            cnts[i] = cnts[i - 1] * 10 + 1\n\n        nums = []\n        i = n\n        while i:\n            nums.append(i % 10)\n            i /= 10\n\n        total, target = n, 0\n        i = len(nums) - 1\n        while i >= 0 and k > 0:\n            target = target*10 + nums[i]\n            start = int(i == len(nums)-1)\n            for j in xrange(start, 10):\n                candidate = result*10 + j\n                if candidate < target:\n                    num = cnts[i+1]\n                elif candidate > target:\n                    num = cnts[i]\n                else:\n                    num = total - cnts[i + 1]*(j-start) - cnts[i]*(9-j)\n                if k > num:\n                    k -= num\n                else:\n                    result = candidate\n                    k -= 1\n                    total = num-1\n                    break\n            i -= 1\n\n        return result\n\nclass Solution2(object):\n    def findKthNumber(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def count(n, prefix):\n            result, number = 0, 1\n            while prefix <= n:\n                result += number\n                prefix *= 10\n                number *= 10\n            result -= max(number/10 - (n - prefix/10 + 1), 0)\n            return result\n\n        def findKthNumberHelper(n, k, cur, index):\n            if cur:\n                index += 1\n                if index == k:\n                    return (cur, index)\n\n            i = int(cur == 0)\n            while i <= 9:\n                cur = cur * 10 + i\n                cnt = count(n, cur)\n                if k > cnt + index:\n                    index += cnt\n                elif cur <= n:\n                    result = findKthNumberHelper(n, k, cur, index)\n                    if result[0]:\n                        return result\n                i += 1\n                cur /= 10\n            return (0, index)\n\n        return findKthNumberHelper(n, k, 0, 0)[0]",
    "explanation": "N/A",
    "time_complexity": "O(logn * logn)",
    "space_complexity": "O(logn)"
  },
  {
    "title": "Jump Game II",
    "difficulty": "MEDIUM",
    "category": "Array, Dynamic Programming, Greedy",
    "link": "https://leetcode.com/problems/jump-game-ii",
    "slug": "jump-game-ii",
    "description": "You are given a \n0-indexed\n array of integers \nnums\n of length \nn\n. You are initially positioned at \nnums[0]\n.\n\n\nEach element \nnums[i]\n represents the maximum length of a forward jump from index \ni\n. In other words, if you are at \nnums[i]\n, you can jump to any \nnums[i + j]\n where:\n\n\n\n\n0 <= j <= nums[i]\n and\n\n\ni + j < n\n\n\n\n\nReturn \nthe minimum number of jumps to reach \nnums[n - 1]\n. The test cases are generated such that you can reach \nnums[n - 1]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,3,1,1,4]\n\nOutput:\n 2\n\nExplanation:\n The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,3,0,1,4]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n0 <= nums[i] <= 1000\n\n\nIt's guaranteed that you can reach \nnums[n - 1]\n.",
    "solution": "class Solution(object):\n    # @param A, a list of integers\n    # @return an integer\n    def jump(self, A):\n        jump_count = 0\n        reachable = 0\n        curr_reachable = 0\n        for i, length in enumerate(A):\n            if i > reachable:\n                return -1\n            if i > curr_reachable:\n                curr_reachable = reachable\n                jump_count += 1\n            reachable = max(reachable, i + length)\n        return jump_count",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Max Consecutive Ones",
    "difficulty": "EASY",
    "category": "Array",
    "link": "https://leetcode.com/problems/max-consecutive-ones",
    "slug": "max-consecutive-ones",
    "description": "Given a binary array \nnums\n, return \nthe maximum number of consecutive \n1\n's in the array\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,0,1,1,1]\n\nOutput:\n 3\n\nExplanation:\n The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,0,1,1,0,1]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\nnums[i]\n is either \n0\n or \n1\n.",
    "solution": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, local_max = 0, 0\n        for n in nums:\n            local_max = (local_max + 1 if n else 0)\n            result = max(result, local_max)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Minimum Size Subarray Sum",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search, Sliding Window, Prefix Sum",
    "link": "https://leetcode.com/problems/minimum-size-subarray-sum",
    "slug": "minimum-size-subarray-sum",
    "description": "Given an array of positive integers \nnums\n and a positive integer \ntarget\n, return \nthe \nminimal length\n of a \nsubarray\n whose sum is greater than or equal to\n \ntarget\n. If there is no such subarray, return \n0\n instead.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n target = 7, nums = [2,3,1,2,4,3]\n\nOutput:\n 2\n\nExplanation:\n The subarray [4,3] has the minimal length under the problem constraint.\n\n\n\nExample 2:\n\n\n\n\nInput:\n target = 4, nums = [1,4,4]\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\nInput:\n target = 11, nums = [1,1,1,1,1,1,1,1]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= target <= 10\n9\n\n\n1 <= nums.length <= 10\n5\n\n\n1 <= nums[i] <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n If you have figured out the \nO(n)\n solution, try coding another solution of which the time complexity is \nO(n log(n))\n.",
    "solution": "class Solution(object):\n    # @param {integer} s\n    # @param {integer[]} nums\n    # @return {integer}\n    def minSubArrayLen(self, s, nums):\n        start = 0\n        sum = 0\n        min_size = float(\"inf\")\n        for i in xrange(len(nums)):\n            sum += nums[i]\n            while sum >= s:\n                min_size = min(min_size, i - start + 1)\n                sum -= nums[start]\n                start += 1\n\n        return min_size if min_size != float(\"inf\") else 0\n\n# Binary search solution.class Solution2(object):\n    # @param {integer} s\n    # @param {integer[]} nums\n    # @return {integer}\n    def minSubArrayLen(self, s, nums):\n        min_size = float(\"inf\")\n        sum_from_start = [n for n in nums]\n        for i in xrange(len(sum_from_start) - 1):\n            sum_from_start[i + 1] += sum_from_start[i]\n        for i in xrange(len(sum_from_start)):\n            end = self.binarySearch(lambda x, y: x <= y, sum_from_start, \\\n                                    i, len(sum_from_start), \\\n                                    sum_from_start[i] - nums[i] + s)\n            if end < len(sum_from_start):\n                min_size = min(min_size, end - i + 1)\n\n        return min_size if min_size != float(\"inf\") else 0\n\n    def binarySearch(self, compare, A, start, end, target):\n        while start < end:\n            mid = start + (end - start) / 2\n            if compare(target, A[mid]):\n                end = mid\n            else:\n                start = mid + 1\n        return start",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Gas Station",
    "difficulty": "MEDIUM",
    "category": "Array, Greedy",
    "link": "https://leetcode.com/problems/gas-station",
    "slug": "gas-station",
    "description": "There are \nn\n gas stations along a circular route, where the amount of gas at the \ni\nth\n station is \ngas[i]\n.\n\n\nYou have a car with an unlimited gas tank and it costs \ncost[i]\n of gas to travel from the \ni\nth\n station to its next \n(i + 1)\nth\n station. You begin the journey with an empty tank at one of the gas stations.\n\n\nGiven two integer arrays \ngas\n and \ncost\n, return \nthe starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return\n \n-1\n. If there exists a solution, it is \nguaranteed\n to be \nunique\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n\nOutput:\n 3\n\nExplanation:\n\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n\n\n\nExample 2:\n\n\n\n\nInput:\n gas = [2,3,4], cost = [3,4,3]\n\nOutput:\n -1\n\nExplanation:\n\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == gas.length == cost.length\n\n\n1 <= n <= 10\n5\n\n\n0 <= gas[i], cost[i] <= 10\n4\n\n\nThe input is generated such that the answer is unique.",
    "solution": "class Solution(object):\n    # @param gas, a list of integers\n    # @param cost, a list of integers\n    # @return an integer\n    def canCompleteCircuit(self, gas, cost):\n        start, total_sum, current_sum = 0, 0, 0\n        for i in xrange(len(gas)):\n            diff = gas[i] - cost[i]\n            current_sum += diff\n            total_sum += diff\n            if current_sum < 0:\n                start = i + 1\n                current_sum = 0\n        if total_sum >= 0:\n            return start\n\n        return -1",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Split Array Largest Sum",
    "difficulty": "HARD",
    "category": "Array, Binary Search, Dynamic Programming, Greedy, Prefix Sum",
    "link": "https://leetcode.com/problems/split-array-largest-sum",
    "slug": "split-array-largest-sum",
    "description": "Given an integer array \nnums\n and an integer \nk\n, split \nnums\n into \nk\n non-empty subarrays such that the largest sum of any subarray is \nminimized\n.\n\n\nReturn \nthe minimized largest sum of the split\n.\n\n\nA \nsubarray\n is a contiguous part of the array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [7,2,5,10,8], k = 2\n\nOutput:\n 18\n\nExplanation:\n There are four ways to split nums into two subarrays.\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,3,4,5], k = 2\n\nOutput:\n 9\n\nExplanation:\n There are four ways to split nums into two subarrays.\nThe best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n0 <= nums[i] <= 10\n6\n\n\n1 <= k <= min(50, nums.length)",
    "solution": "class Solution(object):\n    def splitArray(self, nums, m):\n        \"\"\"\n        :type nums: List[int]\n        :type m: int\n        :rtype: int\n        \"\"\"\n        def check(nums, m, s):\n            cnt, curr_sum = 1, 0\n            for num in nums:\n                curr_sum += num\n                if curr_sum > s:\n                    curr_sum = num\n                    cnt += 1\n            return cnt <= m\n\n        left, right = max(nums), sum(nums)\n        while left <= right:\n            mid = left + (right - left) // 2\n            if check(nums, m, mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left",
    "explanation": "N/A",
    "time_complexity": "O(nlogs), s is the sum of nums",
    "space_complexity": "O(1)"
  },
  {
    "title": "Subarray Sum Equals K",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Prefix Sum",
    "link": "https://leetcode.com/problems/subarray-sum-equals-k",
    "slug": "subarray-sum-equals-k",
    "description": "Given an array of integers \nnums\n and an integer \nk\n, return \nthe total number of subarrays whose sum equals to\n \nk\n.\n\n\nA subarray is a contiguous \nnon-empty\n sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,1,1], k = 2\n\nOutput:\n 2\n\nExample 2:\n\n\nInput:\n nums = [1,2,3], k = 3\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2 * 10\n4\n\n\n-1000 <= nums[i] <= 1000\n\n\n-10\n7\n <= k <= 10\n7",
    "solution": "\nimport collections\n\nclass Solution(object):\n    def subarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        accumulated_sum = 0\n        lookup = collections.defaultdict(int)\n        lookup[0] += 1\n        for num in nums:\n            accumulated_sum += num\n            result += lookup[accumulated_sum - k]\n            lookup[accumulated_sum] += 1\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Contains Duplicate",
    "difficulty": "EASY",
    "category": "Array, Hash Table, Sorting",
    "link": "https://leetcode.com/problems/contains-duplicate",
    "slug": "contains-duplicate",
    "description": "Given an integer array \nnums\n, return \ntrue\n if any value appears \nat least twice\n in the array, and return \nfalse\n if every element is distinct.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,3,1]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThe element 1 occurs at the indices 0 and 3.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,2,3,4]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nAll elements are distinct.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,1,1,3,3,4,3,2,4,2]\n\n\nOutput:\n \ntrue\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9",
    "solution": "class Solution(object):\n    # @param {integer[]} nums\n    # @return {boolean}\n    def containsDuplicate(self, nums):\n        return len(nums) > len(set(nums))",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Minimum Operations to Reduce an Integer to 0",
    "difficulty": "MEDIUM",
    "category": "Dynamic Programming, Greedy, Bit Manipulation",
    "link": "https://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0",
    "slug": "minimum-operations-to-reduce-an-integer-to-0",
    "description": "You are given a positive integer \nn\n, you can do the following operation \nany\n number of times:\n\n\n\n\nAdd or subtract a \npower\n of \n2\n from \nn\n.\n\n\n\n\nReturn \nthe \nminimum\n number of operations to make \nn\n equal to \n0\n.\n\n\nA number \nx\n is power of \n2\n if \nx == 2\ni\n where \ni >= 0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 39\n\nOutput:\n 3\n\nExplanation:\n We can do the following operations:\n- Add 2\n0\n = 1 to n, so now n = 40.\n- Subtract 2\n3\n = 8 from n, so now n = 32.\n- Subtract 2\n5\n = 32 from n, so now n = 0.\nIt can be shown that 3 is the minimum number of operations we need to make n equal to 0.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 54\n\nOutput:\n 3\n\nExplanation:\n We can do the following operations:\n- Add 2\n1\n = 2 to n, so now n = 56.\n- Add 2\n3\n = 8 to n, so now n = 64.\n- Subtract 2\n6\n = 64 from n, so now n = 0.\nSo the minimum number of operations is 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 10\n5",
    "solution": "\n# greedy, trick\n# reference: https://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3203994/java-c-python-1-line-solution/class Solution(object):\n    def minOperations(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def popcount(x):\n            return bin(x)[2:].count('1')\n\n        return popcount(n^(n*0b11))\n\n\n# greedyclass Solution2(object):\n    def minOperations(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while n:\n            if n&1:\n                n >>= 1\n                n += n&1\n                result += 1\n            n >>= 1\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Frequency of the Most Frequent Element",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search, Greedy, Sliding Window, Sorting, Prefix Sum",
    "link": "https://leetcode.com/problems/frequency-of-the-most-frequent-element",
    "slug": "frequency-of-the-most-frequent-element",
    "description": "The \nfrequency\n of an element is the number of times it occurs in an array.\n\n\nYou are given an integer array \nnums\n and an integer \nk\n. In one operation, you can choose an index of \nnums\n and increment the element at that index by \n1\n.\n\n\nReturn \nthe \nmaximum possible frequency\n of an element after performing \nat most\n \nk\n operations\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,4], k = 5\n\nOutput:\n 3\n\nExplanation:\n Increment the first element three times and the second element two times to make nums = [4,4,4].\n4 has a frequency of 3.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,4,8,13], k = 5\n\nOutput:\n 2\n\nExplanation:\n There are multiple optimal solutions:\n- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.\n- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.\n- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,9,6], k = 2\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n1 <= nums[i] <= 10\n5\n\n\n1 <= k <= 10\n5",
    "solution": "class Solution(object):\n    def maxFrequency(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        left = 0\n        nums.sort()\n        for right in xrange(len(nums)):\n            k += nums[right]\n            if k < nums[right]*(right-left+1):\n                k -= nums[left]\n                left += 1\n        return right-left+1",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Reverse Nodes in k-Group",
    "difficulty": "HARD",
    "category": "Linked List, Recursion",
    "link": "https://leetcode.com/problems/reverse-nodes-in-k-group",
    "slug": "reverse-nodes-in-k-group",
    "description": "Given the \nhead\n of a linked list, reverse the nodes of the list \nk\n at a time, and return \nthe modified list\n.\n\n\nk\n is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of \nk\n then left-out nodes, in the end, should remain as it is.\n\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 2\n\nOutput:\n [2,1,4,3,5]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 3\n\nOutput:\n [3,2,1,4,5]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is \nn\n.\n\n\n1 <= k <= n <= 5000\n\n\n0 <= Node.val <= 1000\n\n\n\n\n \n\n\nFollow-up:\n Can you solve the problem in \nO(1)\n extra memory space?",
    "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\nclass Solution(object):\n    # @param head, a ListNode\n    # @param k, an integer\n    # @return a ListNode\n    def reverseKGroup(self, head, k):\n        dummy = ListNode(-1)\n        dummy.next = head\n\n        cur, cur_dummy = head, dummy\n        length = 0\n\n        while cur:\n            next_cur = cur.next\n            length = (length + 1) % k\n\n            if length == 0:\n                next_dummy = cur_dummy.next\n                self.reverse(cur_dummy, cur.next)\n                cur_dummy = next_dummy\n\n            cur = next_cur\n\n        return dummy.next\n\n    def reverse(self, begin, end):\n            first = begin.next\n            cur = first.next\n\n            while cur != end:\n                first.next = cur.next\n                cur.next = begin.next\n                begin.next = cur\n                cur = first.next",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Intersection of Two Linked Lists",
    "difficulty": "EASY",
    "category": "Hash Table, Linked List, Two Pointers",
    "link": "https://leetcode.com/problems/intersection-of-two-linked-lists",
    "slug": "intersection-of-two-linked-lists",
    "description": "Given the heads of two singly linked-lists \nheadA\n and \nheadB\n, return \nthe node at which the two lists intersect\n. If the two linked lists have no intersection at all, return \nnull\n.\n\n\nFor example, the following two linked lists begin to intersect at node \nc1\n:\n\n\n\n\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\n\n\nNote\n that the linked lists must \nretain their original structure\n after the function returns.\n\n\nCustom Judge:\n\n\nThe inputs to the \njudge\n are given as follows (your program is \nnot\n given these inputs):\n\n\n\n\nintersectVal\n - The value of the node where the intersection occurs. This is \n0\n if there is no intersected node.\n\n\nlistA\n - The first linked list.\n\n\nlistB\n - The second linked list.\n\n\nskipA\n - The number of nodes to skip ahead in \nlistA\n (starting from the head) to get to the intersected node.\n\n\nskipB\n - The number of nodes to skip ahead in \nlistB\n (starting from the head) to get to the intersected node.\n\n\n\n\nThe judge will then create the linked structure based on these inputs and pass the two heads, \nheadA\n and \nheadB\n to your program. If you correctly return the intersected node, then your solution will be \naccepted\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n\nOutput:\n Intersected at '8'\n\nExplanation:\n The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2\nnd\n node in A and 3\nrd\n node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3\nrd\n node in A and 4\nth\n node in B) point to the same location in memory.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n\nOutput:\n Intersected at '2'\n\nExplanation:\n The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n\nOutput:\n No intersection\n\nExplanation:\n From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes of \nlistA\n is in the \nm\n.\n\n\nThe number of nodes of \nlistB\n is in the \nn\n.\n\n\n1 <= m, n <= 3 * 10\n4\n\n\n1 <= Node.val <= 10\n5\n\n\n0 <= skipA <= m\n\n\n0 <= skipB <= n\n\n\nintersectVal\n is \n0\n if \nlistA\n and \nlistB\n do not intersect.\n\n\nintersectVal == listA[skipA] == listB[skipB]\n if \nlistA\n and \nlistB\n intersect.\n\n\n\n\n \n\n\nFollow up:\n Could you write a solution that runs in \nO(m + n)\n time and use only \nO(1)\n memory?",
    "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\nclass Solution(object):\n    # @param two ListNodes\n    # @return the intersected ListNode\n    def getIntersectionNode(self, headA, headB):\n        curA, curB = headA, headB\n        while curA != curB:\n            curA = curA.next if curA else headB\n            curB = curB.next if curB else headA\n        return curA",
    "explanation": "N/A",
    "time_complexity": "O(m + n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Rotate Image",
    "difficulty": "MEDIUM",
    "category": "Array, Math, Matrix",
    "link": "https://leetcode.com/problems/rotate-image",
    "slug": "rotate-image",
    "description": "You are given an \nn x n\n 2D \nmatrix\n representing an image, rotate the image by \n90\n degrees (clockwise).\n\n\nYou have to rotate the image \nin-place\n, which means you have to modify the input 2D matrix directly. \nDO NOT\n allocate another 2D matrix and do the rotation.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [[7,4,1],[8,5,2],[9,6,3]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n\nOutput:\n [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 20\n\n\n-1000 <= matrix[i][j] <= 1000",
    "solution": "class Solution(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        n = len(matrix)\n\n        # anti-diagonal mirror\n        for i in xrange(n):\n            for j in xrange(n - i):\n                matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j]\n\n        # horizontal mirror\n        for i in xrange(n / 2):\n            for j in xrange(n):\n                matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]\n\n        return matrix\nclass Solution2(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        return [list(reversed(x)) for x in zip(*matrix)]",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n^2)"
  },
  {
    "title": "Sliding Window Maximum",
    "difficulty": "HARD",
    "category": "Array, Queue, Sliding Window, Heap (Priority Queue), Monotonic Queue",
    "link": "https://leetcode.com/problems/sliding-window-maximum",
    "slug": "sliding-window-maximum",
    "description": "You are given an array of integers \nnums\n, there is a sliding window of size \nk\n which is moving from the very left of the array to the very right. You can only see the \nk\n numbers in the window. Each time the sliding window moves right by one position.\n\n\nReturn \nthe max sliding window\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,-1,-3,5,3,6,7], k = 3\n\nOutput:\n [3,3,5,5,6,7]\n\nExplanation:\n \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       \n3\n\n 1 [3  -1  -3] 5  3  6  7       \n3\n\n 1  3 [-1  -3  5] 3  6  7      \n 5\n\n 1  3  -1 [-3  5  3] 6  7       \n5\n\n 1  3  -1  -3 [5  3  6] 7       \n6\n\n 1  3  -1  -3  5 [3  6  7]      \n7\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1], k = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n1 <= k <= nums.length",
    "solution": "\nfrom collections import deque\n\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result, dq = [], deque()\n        for i in xrange(len(nums)):\n            if dq and i-dq[0] == k:\n                dq.popleft()\n            while dq and nums[dq[-1]] <= nums[i]:\n                dq.pop()\n            dq.append(i)\n            if i >= k-1:\n                result.append(nums[dq[0]])\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(k)"
  },
  {
    "title": "Find Minimum in Rotated Sorted Array",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array",
    "slug": "find-minimum-in-rotated-sorted-array",
    "description": "Suppose an array of length \nn\n sorted in ascending order is \nrotated\n between \n1\n and \nn\n times. For example, the array \nnums = [0,1,2,4,5,6,7]\n might become:\n\n\n\n\n[4,5,6,7,0,1,2]\n if it was rotated \n4\n times.\n\n\n[0,1,2,4,5,6,7]\n if it was rotated \n7\n times.\n\n\n\n\nNotice that \nrotating\n an array \n[a[0], a[1], a[2], ..., a[n-1]]\n 1 time results in the array \n[a[n-1], a[0], a[1], a[2], ..., a[n-2]]\n.\n\n\nGiven the sorted rotated array \nnums\n of \nunique\n elements, return \nthe minimum element of this array\n.\n\n\nYou must write an algorithm that runs in \nO(log n) time\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,4,5,1,2]\n\nOutput:\n 1\n\nExplanation:\n The original array was [1,2,3,4,5] rotated 3 times.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [4,5,6,7,0,1,2]\n\nOutput:\n 0\n\nExplanation:\n The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [11,13,15,17]\n\nOutput:\n 11\n\nExplanation:\n The original array was [11,13,15,17] and it was rotated 4 times. \n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 5000\n\n\n-5000 <= nums[i] <= 5000\n\n\nAll the integers of \nnums\n are \nunique\n.\n\n\nnums\n is sorted and rotated between \n1\n and \nn\n times.",
    "solution": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums)\n        target = nums[-1]\n\n        while left < right:\n            mid = left + (right - left) / 2\n\n            if nums[mid] <= target:\n                right = mid\n            else:\n                left = mid + 1\n\n        return nums[left]\n\nclass Solution2(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] >= nums[right]:\n            mid = left + (right - left) / 2\n\n            if nums[mid] < nums[left]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return nums[left]",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Recover Binary Search Tree",
    "difficulty": "MEDIUM",
    "category": "Tree, Depth-First Search, Binary Search Tree, Binary Tree",
    "link": "https://leetcode.com/problems/recover-binary-search-tree",
    "slug": "recover-binary-search-tree",
    "description": "You are given the \nroot\n of a binary search tree (BST), where the values of \nexactly\n two nodes of the tree were swapped by mistake. \nRecover the tree without changing its structure\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,3,null,null,2]\n\nOutput:\n [3,1,null,null,2]\n\nExplanation:\n 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,1,4,null,null,2]\n\nOutput:\n [2,1,4,null,null,3]\n\nExplanation:\n 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 1000]\n.\n\n\n-2\n31\n <= Node.val <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n A solution using \nO(n)\n space is pretty straight-forward. Could you devise a constant \nO(1)\n space solution?",
    "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        if self:\n            serial = []\n            queue = [self]\n\n            while queue:\n                cur = queue[0]\n\n                if cur:\n                    serial.append(cur.val)\n                    queue.append(cur.left)\n                    queue.append(cur.right)\n                else:\n                    serial.append(\"#\")\n\n                queue = queue[1:]\n\n            while serial[-1] == \"#\":\n                serial.pop()\n\n            return repr(serial)\n\n        else:\n            return None\nclass Solution(object):\n    # @param root, a tree node\n    # @return a tree node\n    def recoverTree(self, root):\n        return self.MorrisTraversal(root)\n\n    def MorrisTraversal(self, root):\n        if root is None:\n            return\n        broken = [None, None]\n        pre, cur = None, root\n\n        while cur:\n            if cur.left is None:\n                self.detectBroken(broken, pre, cur)\n                pre = cur\n                cur = cur.right\n            else:\n                node = cur.left\n                while node.right and node.right != cur:\n                    node = node.right\n\n                if node.right is None:\n                    node.right =cur\n                    cur = cur.left\n                else:\n                    self.detectBroken(broken, pre, cur)\n                    node.right = None\n                    pre = cur\n                    cur = cur.right\n\n        broken[0].val, broken[1].val = broken[1].val, broken[0].val\n\n        return root\n\n    def detectBroken(self, broken, pre, cur):\n        if pre and pre.val > cur.val:\n            if broken[0] is None:\n                broken[0] = pre\n            broken[1] = cur",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Valid Parentheses",
    "difficulty": "EASY",
    "category": "String, Stack",
    "link": "https://leetcode.com/problems/valid-parentheses",
    "slug": "valid-parentheses",
    "description": "Given a string \ns\n containing just the characters \n'('\n, \n')'\n, \n'{'\n, \n'}'\n, \n'['\n and \n']'\n, determine if the input string is valid.\n\n\nAn input string is valid if:\n\n\n\n\nOpen brackets must be closed by the same type of brackets.\n\n\nOpen brackets must be closed in the correct order.\n\n\nEvery close bracket has a corresponding open bracket of the same type.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"()\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"()[]{}\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"(]\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"([])\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"([)]\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of parentheses only \n'()[]{}'\n.",
    "solution": "class Solution(object):\n    # @return a boolean\n    def isValid(self, s):\n        stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        for parenthese in s:\n            if parenthese in lookup:\n                stack.append(parenthese)\n            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:\n                return False\n        return len(stack) == 0",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Longest Substring with At Most K Distinct Characters",
    "difficulty": "MEDIUM",
    "category": "Hash Table, String, Sliding Window",
    "link": "https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters",
    "slug": "longest-substring-with-at-most-k-distinct-characters",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "class Solution(object):\n    def lengthOfLongestSubstringKDistinct(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in xrange(256)]\n        for i, char in enumerate(s):\n            if visited[ord(char)] == 0:\n                distinct_count += 1\n            visited[ord(char)] += 1\n            while distinct_count > k:\n                visited[ord(s[start])] -= 1\n                if visited[ord(s[start])] == 0:\n                    distinct_count -= 1\n                start += 1\n            longest = max(longest, i - start + 1)\n        return longest\n\n\nfrom collections import Counter\n\nclass Solution2(object):\n    def lengthOfLongestSubstringKDistinct(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        counter = Counter()\n        left, max_length = 0, 0\n        for right, char in enumerate(s):\n            counter[char] += 1\n            while len(counter) > k:\n                counter[s[left]] -= 1\n                if counter[s[left]] == 0:\n                    del counter[s[left]]\n                left += 1\n            max_length = max(max_length, right-left+1)\n        return max_length",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Longest Consecutive Sequence",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Union Find",
    "link": "https://leetcode.com/problems/longest-consecutive-sequence",
    "slug": "longest-consecutive-sequence",
    "description": "Given an unsorted array of integers \nnums\n, return \nthe length of the longest consecutive elements sequence.\n\n\nYou must write an algorithm that runs in \nO(n)\n time.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [100,4,200,1,3,2]\n\nOutput:\n 4\n\nExplanation:\n The longest consecutive elements sequence is \n[1, 2, 3, 4]\n. Therefore its length is 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,3,7,2,5,8,4,6,0,1]\n\nOutput:\n 9\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,0,1,2]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9",
    "solution": "class Solution(object):\n    # @param num, a list of integer\n    # @return an integer\n    def longestConsecutive(self, num):\n        result, lengths = 1, {key: 0 for key in num}\n        for i in num:\n            if lengths[i] == 0:\n                lengths[i] = 1\n                left, right = lengths.get(i - 1, 0), lengths.get(i + 1, 0)\n                length = 1 + left + right\n                result, lengths[i - left], lengths[i + right] = max(result, length), length, length\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Zero Array Transformation III",
    "difficulty": "MEDIUM",
    "category": "Array, Greedy, Sorting, Heap (Priority Queue), Prefix Sum",
    "link": "https://leetcode.com/problems/zero-array-transformation-iii",
    "slug": "zero-array-transformation-iii",
    "description": "You are given an integer array \nnums\n of length \nn\n and a 2D array \nqueries\n where \nqueries[i] = [l\ni\n, r\ni\n]\n.\n\n\nEach \nqueries[i]\n represents the following action on \nnums\n:\n\n\n\n\nDecrement the value at each index in the range \n[l\ni\n, r\ni\n]\n in \nnums\n by \nat most\n \n1.\n\n\nThe amount by which the value is decremented can be chosen \nindependently\n for each index.\n\n\n\n\nA \nZero Array\n is an array with all its elements equal to 0.\n\n\nReturn the \nmaximum \nnumber of elements that can be removed from \nqueries\n, such that \nnums\n can still be converted to a \nzero array\n using the \nremaining\n queries. If it is not possible to convert \nnums\n to a \nzero array\n, return -1.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,0,2], queries = [[0,2],[0,2],[1,1]]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nAfter removing \nqueries[2]\n, \nnums\n can still be converted to a zero array.\n\n\n\n\nUsing \nqueries[0]\n, decrement \nnums[0]\n and \nnums[2]\n by 1 and \nnums[1]\n by 0.\n\n\nUsing \nqueries[1]\n, decrement \nnums[0]\n and \nnums[2]\n by 1 and \nnums[1]\n by 0.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,1,1,1], queries = [[1,3],[0,2],[1,3],[1,2]]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nWe can remove \nqueries[2]\n and \nqueries[3]\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,2,3,4], queries = [[0,3]]\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\nnums\n cannot be converted to a zero array even after using all the queries.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n0 <= nums[i] <= 10\n5\n\n\n1 <= queries.length <= 10\n5\n\n\nqueries[i].length == 2\n\n\n0 <= l\ni\n <= r\ni\n < nums.length",
    "solution": "\nimport heapq\n\n\n# sort, heap, greedyclass Solution(object):\n    def maxRemoval(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        queries.sort(reverse=True)\n        max_heap, min_heap = [], []\n        for i in xrange(len(nums)):\n            while queries and queries[-1][0] <= i:\n                heapq.heappush(max_heap, -queries.pop()[1])\n            while min_heap and min_heap[0] < i:\n                heapq.heappop(min_heap)\n            while len(min_heap) < nums[i]:\n                if not max_heap or -max_heap[0] < i:\n                    return -1\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        return len(max_heap)",
    "explanation": "N/A",
    "time_complexity": "O(n + qlogq)",
    "space_complexity": "O(q)"
  },
  {
    "title": "Combination Sum II",
    "difficulty": "MEDIUM",
    "category": "Array, Backtracking",
    "link": "https://leetcode.com/problems/combination-sum-ii",
    "slug": "combination-sum-ii",
    "description": "Given a collection of candidate numbers (\ncandidates\n) and a target number (\ntarget\n), find all unique combinations in \ncandidates\n where the candidate numbers sum to \ntarget\n.\n\n\nEach number in \ncandidates\n may only be used \nonce\n in the combination.\n\n\nNote:\n The solution set must not contain duplicate combinations.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n candidates = [10,1,2,7,6,1,5], target = 8\n\nOutput:\n \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\n\n\nExample 2:\n\n\n\n\nInput:\n candidates = [2,5,2,1,2], target = 5\n\nOutput:\n \n[\n[1,2,2],\n[5]\n]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= candidates.length <= 100\n\n\n1 <= candidates[i] <= 50\n\n\n1 <= target <= 30",
    "solution": "class Solution(object):\n    # @param candidates, a list of integers\n    # @param target, integer\n    # @return a list of lists of integers\n    def combinationSum2(self, candidates, target):\n        result = []\n        self.combinationSumRecu(sorted(candidates), result, 0, [], target)\n        return result\n\n    def combinationSumRecu(self, candidates, result, start, intermediate, target):\n        if target == 0:\n            result.append(list(intermediate))\n        prev = 0\n        while start < len(candidates) and candidates[start] <= target:\n            if prev != candidates[start]:\n                intermediate.append(candidates[start])\n                self.combinationSumRecu(candidates, result, start + 1, intermediate, target - candidates[start])\n                intermediate.pop()\n                prev = candidates[start]\n            start += 1",
    "explanation": "N/A",
    "time_complexity": "O(k * C(n, k))",
    "space_complexity": "O(k)"
  },
  {
    "title": "Maximum Difference Between Even and Odd Frequency II",
    "difficulty": "HARD",
    "category": "String, Sliding Window, Enumeration, Prefix Sum",
    "link": "https://leetcode.com/problems/maximum-difference-between-even-and-odd-frequency-ii",
    "slug": "maximum-difference-between-even-and-odd-frequency-ii",
    "description": "You are given a string \ns\n and an integer \nk\n. Your task is to find the \nmaximum\n difference between the frequency of \ntwo\n characters, \nfreq[a] - freq[b]\n, in a \nsubstring\n \nsubs\n of \ns\n, such that:\n\n\n\n\nsubs\n has a size of \nat least\n \nk\n.\n\n\nCharacter \na\n has an \nodd frequency\n in \nsubs\n.\n\n\nCharacter \nb\n has a \nnon-zero\n \neven frequency\n in \nsubs\n.\n\n\n\n\nReturn the \nmaximum\n difference.\n\n\nNote\n that \nsubs\n can contain more than 2 \ndistinct\n characters.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"12233\", k = 4\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\nFor the substring \n\"12233\"\n, the frequency of \n'1'\n is 1 and the frequency of \n'3'\n is 2. The difference is \n1 - 2 = -1\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"1122211\", k = 3\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nFor the substring \n\"11222\"\n, the frequency of \n'2'\n is 3 and the frequency of \n'1'\n is 2. The difference is \n3 - 2 = 1\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"110\", k = 3\n\n\nOutput:\n \n-1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= s.length <= 3 * 10\n4\n\n\ns\n consists only of digits \n'0'\n to \n'4'\n.\n\n\nThe input is generated that at least one substring has a character with an even frequency and a character with an odd frequency.\n\n\n1 <= k <= s.length",
    "solution": "\n# prefix sum, two pointers, sliding windowclass Solution(object):\n    def maxDifference(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def diff(x, y):\n            prefix1, prefix2, prefix = [0]*(len(s)+1), [0]*(len(s)+1), [0]*(len(s)+1)\n            for i in xrange(len(s)):\n                prefix1[i+1] = prefix1[i]+int(s[i] == x)\n                prefix2[i+1] = prefix2[i]+int(s[i] == y)\n                prefix[i+1] = prefix[i]+(int(s[i] == x)-int(s[i] == y))\n            result = float(\"-inf\")\n            mn = [[float(\"inf\")]*2 for _ in xrange(2)]\n            left = 0\n            for right in xrange(k-1, len(s)):\n                while k <= right-left+1 and prefix1[right+1]-prefix1[left] and prefix2[right+1]-prefix2[left]:\n                    i, j = prefix1[left]%2, prefix2[left]%2\n                    mn[i][j] = min(mn[i][j], prefix[left])\n                    left += 1\n                i, j = prefix1[right+1]%2, prefix2[right+1]%2\n                result = max(result, prefix[right+1]-mn[i^1][j])\n            return result\n        \n        lookup = set(s)\n        return max(diff(x, y) for x in lookup for y in lookup if x != y)",
    "explanation": "N/A",
    "time_complexity": "O(d^2 * n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Next Greater Element I",
    "difficulty": "EASY",
    "category": "Array, Hash Table, Stack, Monotonic Stack",
    "link": "https://leetcode.com/problems/next-greater-element-i",
    "slug": "next-greater-element-i",
    "description": "The \nnext greater element\n of some element \nx\n in an array is the \nfirst greater\n element that is \nto the right\n of \nx\n in the same array.\n\n\nYou are given two \ndistinct 0-indexed\n integer arrays \nnums1\n and \nnums2\n, where \nnums1\n is a subset of \nnums2\n.\n\n\nFor each \n0 <= i < nums1.length\n, find the index \nj\n such that \nnums1[i] == nums2[j]\n and determine the \nnext greater element\n of \nnums2[j]\n in \nnums2\n. If there is no next greater element, then the answer for this query is \n-1\n.\n\n\nReturn \nan array \nans\n of length \nnums1.length\n such that \nans[i]\n is the \nnext greater element\n as described above.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [4,1,2], nums2 = [1,3,4,2]\n\nOutput:\n [-1,3,-1]\n\nExplanation:\n The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,\n4\n,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [\n1\n,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,\n2\n]. There is no next greater element, so the answer is -1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [2,4], nums2 = [1,2,3,4]\n\nOutput:\n [3,-1]\n\nExplanation:\n The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,\n2\n,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,\n4\n]. There is no next greater element, so the answer is -1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums1.length <= nums2.length <= 1000\n\n\n0 <= nums1[i], nums2[i] <= 10\n4\n\n\nAll integers in \nnums1\n and \nnums2\n are \nunique\n.\n\n\nAll the integers of \nnums1\n also appear in \nnums2\n.\n\n\n\n\n \n\n\nFollow up:\n Could you find an \nO(nums1.length + nums2.length)\n solution?",
    "solution": "class Solution(object):\n    def nextGreaterElement(self, findNums, nums):\n        \"\"\"\n        :type findNums: List[int]\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        stk, lookup = [], {}\n        for num in nums:\n            while stk and num > stk[-1]:\n                lookup[stk.pop()] = num\n            stk.append(num)\n        while stk:\n            lookup[stk.pop()] = -1\n        return map(lambda x : lookup[x], findNums)",
    "explanation": "N/A",
    "time_complexity": "O(m + n)",
    "space_complexity": "O(m + n)"
  },
  {
    "title": "Add Strings",
    "difficulty": "EASY",
    "category": "Math, String, Simulation",
    "link": "https://leetcode.com/problems/add-strings",
    "slug": "add-strings",
    "description": "Given two non-negative integers, \nnum1\n and \nnum2\n represented as string, return \nthe sum of\n \nnum1\n \nand\n \nnum2\n \nas a string\n.\n\n\nYou must solve the problem without using any built-in library for handling large integers (such as \nBigInteger\n). You must also not convert the inputs to integers directly.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num1 = \"11\", num2 = \"123\"\n\nOutput:\n \"134\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n num1 = \"456\", num2 = \"77\"\n\nOutput:\n \"533\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n num1 = \"0\", num2 = \"0\"\n\nOutput:\n \"0\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num1.length, num2.length <= 10\n4\n\n\nnum1\n and \nnum2\n consist of only digits.\n\n\nnum1\n and \nnum2\n don't have any leading zeros except for the zero itself.",
    "solution": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        result = []\n        i, j, carry = len(num1) - 1, len(num2) - 1, 0\n\n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += ord(num1[i]) - ord('0')\n                i -= 1\n            if j >= 0:\n                carry += ord(num2[j]) - ord('0')\n                j -= 1\n            result.append(str(carry % 10))\n            carry /= 10\n        result.reverse()\n\n        return \"\".join(result)\n\n    def addStrings2(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        length = max(len(num1), len(num2))\n        num1 = num1.zfill(length)[::-1]\n        num2 = num2.zfill(length)[::-1]\n        res, plus = '', 0\n        for index, num in enumerate(num1):\n            tmp = str(int(num) + int(num2[index]) + plus)\n            res += tmp[-1]\n            if int(tmp) > 9:\n                plus = 1\n            else:\n                plus = 0\n        if plus:\n            res += '1'\n        return res[::-1]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Maximal Rectangle",
    "difficulty": "HARD",
    "category": "Array, Dynamic Programming, Stack, Matrix, Monotonic Stack",
    "link": "https://leetcode.com/problems/maximal-rectangle",
    "slug": "maximal-rectangle",
    "description": "Given a \nrows x cols\n binary \nmatrix\n filled with \n0\n's and \n1\n's, find the largest rectangle containing only \n1\n's and return \nits area\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\n\nOutput:\n 6\n\nExplanation:\n The maximal rectangle is shown in the above picture.\n\n\n\nExample 2:\n\n\n\n\nInput:\n matrix = [[\"0\"]]\n\nOutput:\n 0\n\n\n\nExample 3:\n\n\n\n\nInput:\n matrix = [[\"1\"]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nrows == matrix.length\n\n\ncols == matrix[i].length\n\n\n1 <= row, cols <= 200\n\n\nmatrix[i][j]\n is \n'0'\n or \n'1'\n.",
    "solution": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        def largestRectangleArea(heights):\n            stk, result, i = [-1], 0, 0\n            for i in xrange(len(heights)+1):\n                while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):\n                    result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))\n                stk.append(i) \n            return result\n\n        if not matrix:\n            return 0\n        result = 0\n        heights = [0]*len(matrix[0])\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[0])):\n                heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0\n            result = max(result, largestRectangleArea(heights))\n        return result\n\n\n# DP solution.class Solution2(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        if not matrix:\n            return 0\n\n        result = 0\n        m = len(matrix)\n        n = len(matrix[0])\n        L = [0 for _ in xrange(n)]\n        H = [0 for _ in xrange(n)]\n        R = [n for _ in xrange(n)]\n\n        for i in xrange(m):\n            left = 0\n            for j in xrange(n):\n                if matrix[i][j] == '1':\n                    L[j] = max(L[j], left)\n                    H[j] += 1\n                else:\n                    L[j] = 0\n                    H[j] = 0\n                    R[j] = n\n                    left = j + 1\n\n            right = n\n            for j in reversed(xrange(n)):\n                if matrix[i][j] == '1':\n                    R[j] = min(R[j], right)\n                    result = max(result, H[j] * (R[j] - L[j]))\n                else:\n                    right = j\n\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)"
  },
  {
    "title": "3Sum",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers, Sorting",
    "link": "https://leetcode.com/problems/3sum",
    "slug": "3sum",
    "description": "Given an integer array nums, return all the triplets \n[nums[i], nums[j], nums[k]]\n such that \ni != j\n, \ni != k\n, and \nj != k\n, and \nnums[i] + nums[j] + nums[k] == 0\n.\n\n\nNotice that the solution set must not contain duplicate triplets.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-1,0,1,2,-1,-4]\n\nOutput:\n [[-1,-1,2],[-1,0,1]]\n\nExplanation:\n \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,1,1]\n\nOutput:\n []\n\nExplanation:\n The only possible triplet does not sum up to 0.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [0,0,0]\n\nOutput:\n [[0,0,0]]\n\nExplanation:\n The only possible triplet sums up to 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= nums.length <= 3000\n\n\n-10\n5\n <= nums[i] <= 10\n5",
    "solution": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        nums.sort()\n        for i in reversed(xrange(2, len(nums))):\n            if i+1 < len(nums) and nums[i] == nums[i+1]:\n                continue\n            target = -nums[i]\n            left, right = 0, i-1\n            while left < right:\n                if nums[left]+nums[right] < target:\n                    left += 1\n                elif nums[left]+nums[right] > target:\n                    right -= 1\n                else:\n                    result.append([nums[left], nums[right], nums[i]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left-1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right+1]:\n                        right -= 1\n        return result\n\nclass Solution2(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, i = sorted(nums), [], 0\n        while i < len(nums) - 2:\n            if i == 0 or nums[i] != nums[i - 1]:\n                j, k = i + 1, len(nums) - 1\n                while j < k:\n                    if nums[i] + nums[j] + nums[k] < 0:\n                        j += 1\n                    elif nums[i] + nums[j] + nums[k] > 0:\n                        k -= 1\n                    else:\n                        result.append([nums[i], nums[j], nums[k]])\n                        j, k = j + 1, k - 1\n                        while j < k and nums[j] == nums[j - 1]:\n                            j += 1\n                        while j < k and nums[k] == nums[k + 1]:\n                            k -= 1\n            i += 1\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Maximum Difference Between Even and Odd Frequency I",
    "difficulty": "EASY",
    "category": "Hash Table, String, Counting",
    "link": "https://leetcode.com/problems/maximum-difference-between-even-and-odd-frequency-i",
    "slug": "maximum-difference-between-even-and-odd-frequency-i",
    "description": "You are given a string \ns\n consisting of lowercase English letters.\n\n\nYour task is to find the \nmaximum\n difference \ndiff = freq(a\n1\n) - freq(a\n2\n)\n between the frequency of characters \na\n1\n and \na\n2\n in the string such that:\n\n\n\n\na\n1\n has an \nodd frequency\n in the string.\n\n\na\n2\n has an \neven frequency\n in the string.\n\n\n\n\nReturn this \nmaximum\n difference.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"aaaaabbc\"\n\n\nOutput:\n 3\n\n\nExplanation:\n\n\n\n\nThe character \n'a'\n has an \nodd frequency\n of \n5\n,\n and \n'b'\n has an \neven frequency\n of \n2\n.\n\n\nThe maximum difference is \n5 - 2 = 3\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"abcabcab\"\n\n\nOutput:\n 1\n\n\nExplanation:\n\n\n\n\nThe character \n'a'\n has an \nodd frequency\n of \n3\n,\n and \n'c'\n has an \neven frequency\n of \n2\n.\n\n\nThe maximum difference is \n3 - 2 = 1\n.\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= s.length <= 100\n\n\ns\n consists only of lowercase English letters.\n\n\ns\n contains at least one character with an odd frequency and one with an even frequency.",
    "solution": "\n# freq tableclass Solution(object):\n    def maxDifference(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        cnt = [0]*26\n        for x in s:\n            cnt[ord(x)-ord('a')] += 1\n        mn, mx = float(\"inf\"), 0\n        for x in cnt:\n            if not x:\n                continue\n            if x%2 == 0:\n                mn = min(mn, x)\n            else:\n                mx = max(mx, x)\n        return mx-mn",
    "explanation": "N/A",
    "time_complexity": "O(n + 26)",
    "space_complexity": "O(26)"
  },
  {
    "title": "Search Insert Position",
    "difficulty": "EASY",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/search-insert-position",
    "slug": "search-insert-position",
    "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 5\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 2\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 7\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nnums\n contains \ndistinct\n values sorted in \nascending\n order.\n\n\n-10\n4\n <= target <= 10\n4",
    "solution": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if nums[mid] >= target:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return left",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Trapping Rain Water",
    "difficulty": "HARD",
    "category": "Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack",
    "link": "https://leetcode.com/problems/trapping-rain-water",
    "slug": "trapping-rain-water",
    "description": "Given \nn\n non-negative integers representing an elevation map where the width of each bar is \n1\n, compute how much water it can trap after raining.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [0,1,0,2,1,0,1,3,2,1,2,1]\n\nOutput:\n 6\n\nExplanation:\n The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [4,2,0,3,2,5]\n\nOutput:\n 9\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n1 <= n <= 2 * 10\n4\n\n\n0 <= height[i] <= 10\n5",
    "solution": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result, left, right, level = 0, 0, len(height)-1, 0\n        while left < right:\n            if height[left] < height[right]:\n                lower = height[left]\n                left += 1\n            else:\n                lower = height[right]\n                right -= 1\n            level = max(level, lower)\n            result += level-lower\n        return result\n\nclass Solution2(object):\n    # @param A, a list of integers\n    # @return an integer\n    def trap(self, A):\n        result = 0\n        top = 0\n        for i in xrange(len(A)):\n            if A[top] < A[i]:\n                top = i\n\n        second_top = 0\n        for i in xrange(top):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        second_top = len(A) - 1\n        for i in reversed(xrange(top, len(A))):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        return result\n\nclass Solution3(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        right = [0]*len(height)\n        mx = 0\n        for i in reversed(xrange(len(height))):\n            right[i] = mx\n            mx = max(mx, height[i])\n        result = left = 0\n        for i in xrange(len(height)):\n            left = max(left, height[i])\n            result += max(min(left, right[i])-height[i], 0)\n        return result\n\nclass Solution4(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        stk = []\n        for i in xrange(len(height)):\n            prev = 0\n            while stk and height[stk[-1]] <= height[i]:\n                j = stk.pop()\n                result += (height[j] - prev) * (i - j - 1)\n                prev = height[j]\n            if stk:\n                result += (height[i] - prev) * (i - stk[-1] - 1)\n            stk.append(i)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Binary Tree Level Order Traversal",
    "difficulty": "MEDIUM",
    "category": "Tree, Breadth-First Search, Binary Tree",
    "link": "https://leetcode.com/problems/binary-tree-level-order-traversal",
    "slug": "binary-tree-level-order-traversal",
    "description": "Given the \nroot\n of a binary tree, return \nthe level order traversal of its nodes' values\n. (i.e., from left to right, level by level).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n [[3],[9,20],[15,7]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1]\n\nOutput:\n [[1]]\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 2000]\n.\n\n\n-1000 <= Node.val <= 1000",
    "solution": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return a list of lists of integers\n    def levelOrder(self, root):\n        if root is None:\n            return []\n        result, current = [], [root]\n        while current:\n            next_level, vals = [], []\n            for node in current:\n                vals.append(node.val)\n                if node.left:\n                    next_level.append(node.left)\n                if node.right:\n                    next_level.append(node.right)\n            current = next_level\n            result.append(vals)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Transform Array to All Equal Elements",
    "difficulty": "MEDIUM",
    "category": "Array, Greedy",
    "link": "https://leetcode.com/problems/transform-array-to-all-equal-elements",
    "slug": "transform-array-to-all-equal-elements",
    "description": "You are given an integer array \nnums\n of size \nn\n containing only \n1\n and \n-1\n, and an integer \nk\n.\n\n\nYou can perform the following operation at most \nk\n times:\n\n\n\n\n\n\nChoose an index \ni\n (\n0 <= i < n - 1\n), and \nmultiply\n both \nnums[i]\n and \nnums[i + 1]\n by \n-1\n.\n\n\n\n\n\n\nNote\n that you can choose the same index \ni\n more than once in \ndifferent\n operations.\n\n\nReturn \ntrue\n if it is possible to make all elements of the array \nequal\n after at most \nk\n operations, and \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,-1,1,-1,1], k = 3\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nWe can make all elements in the array equal in 2 operations as follows:\n\n\n\n\nChoose index \ni = 1\n, and multiply both \nnums[1]\n and \nnums[2]\n by -1. Now \nnums = [1,1,-1,-1,1]\n.\n\n\nChoose index \ni = 2\n, and multiply both \nnums[2]\n and \nnums[3]\n by -1. Now \nnums = [1,1,1,1,1]\n.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [-1,-1,-1,1,1,1], k = 5\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nIt is not possible to make all array elements equal in at most 5 operations.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n == nums.length <= 10\n5\n\n\nnums[i]\n is either -1 or 1.\n\n\n1 <= k <= n",
    "solution": "\n# greedyclass Solution(object):\n    def canMakeEqual(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        def check(target):\n            cnt = 0\n            sign = 1\n            for i in xrange(len(nums)):\n                if nums[i]*sign == target:\n                    sign = 1\n                    continue\n                cnt += 1\n                if i+1 == len(nums) or cnt > k:\n                    return False\n                sign = -1\n            return True\n\n        return check(1) or check(-1)\n\n\n# greedyclass Solution2(object):\n    def canMakeEqual(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        def check(target):\n            parity = cnt = 0\n            for i in xrange(len(nums)):\n                if nums[i] == target:\n                    continue\n                cnt += i if parity else -i\n                if cnt > k:\n                    return False\n                parity ^= 1\n            return parity == 0\n\n        return check(1) or check(-1)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "LRU Cache",
    "difficulty": "MEDIUM",
    "category": "Hash Table, Linked List, Design, Doubly-Linked List",
    "link": "https://leetcode.com/problems/lru-cache",
    "slug": "lru-cache",
    "description": "Design a data structure that follows the constraints of a \nLeast Recently Used (LRU) cache\n.\n\n\nImplement the \nLRUCache\n class:\n\n\n\n\nLRUCache(int capacity)\n Initialize the LRU cache with \npositive\n size \ncapacity\n.\n\n\nint get(int key)\n Return the value of the \nkey\n if the key exists, otherwise return \n-1\n.\n\n\nvoid put(int key, int value)\n Update the value of the \nkey\n if the \nkey\n exists. Otherwise, add the \nkey-value\n pair to the cache. If the number of keys exceeds the \ncapacity\n from this operation, \nevict\n the least recently used key.\n\n\n\n\nThe functions \nget\n and \nput\n must each run in \nO(1)\n average time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n\nOutput\n\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n\nExplanation\n\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= capacity <= 3000\n\n\n0 <= key <= 10\n4\n\n\n0 <= value <= 10\n5\n\n\nAt most \n2 * 10\n5\n calls will be made to \nget\n and \nput\n.",
    "solution": "\nimport collections\n\n\n# using OrderedDictclass LRUCache(object):\n    def __init__(self, capacity):\n        self.cache = collections.OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        val = self.cache[key]\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.cache and len(self.cache) == self.capacity:\n            self.cache.popitem(last=False)\n        self.__update(key, val)\n    \n    def __update(self, key, val):\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = val\n\n\n\nclass ListNode(object):\n    def __init__(self, key, val):\n        self.val = val\n        self.key = key\n        self.next = None\n        self.prev = None\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\nclass LRUCache2(object):\n\n    def __init__(self, capacity):\n        self.list = LinkedList()\n        self.dict = {}\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.dict:\n            return -1\n        val = self.dict[key].val\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.dict and len(self.dict) == self.capacity:\n            del self.dict[self.list.head.key]\n            self.list.delete(self.list.head)\n        self.__update(key, val)\n\n    def __update(self, key, val):\n        if key in self.dict:\n            self.list.delete(self.dict[key])\n        node = ListNode(key, val)\n        self.list.insert(node)\n        self.dict[key] = node",
    "explanation": "N/A",
    "time_complexity": "O(1), per operation.",
    "space_complexity": "O(k), k is the capacity of cache."
  },
  {
    "title": "Next Permutation",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers",
    "link": "https://leetcode.com/problems/next-permutation",
    "slug": "next-permutation",
    "description": "A \npermutation\n of an array of integers is an arrangement of its members into a sequence or linear order.\n\n\n\n\nFor example, for \narr = [1,2,3]\n, the following are all the permutations of \narr\n: \n[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]\n.\n\n\n\n\nThe \nnext permutation\n of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the \nnext permutation\n of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n\n\n\nFor example, the next permutation of \narr = [1,2,3]\n is \n[1,3,2]\n.\n\n\nSimilarly, the next permutation of \narr = [2,3,1]\n is \n[3,1,2]\n.\n\n\nWhile the next permutation of \narr = [3,2,1]\n is \n[1,2,3]\n because \n[3,2,1]\n does not have a lexicographical larger rearrangement.\n\n\n\n\nGiven an array of integers \nnums\n, \nfind the next permutation of\n \nnums\n.\n\n\nThe replacement must be \nin place\n and use only constant extra memory.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n [1,3,2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,1]\n\nOutput:\n [1,2,3]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,1,5]\n\nOutput:\n [1,5,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 100",
    "solution": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in reversed(xrange(len(nums)-1)):\n            if nums[i] < nums[i+1]:\n                k = i\n                break\n        else:\n            nums.reverse()\n            return\n\n        for i in reversed(xrange(k+1, len(nums))):\n            if nums[i] > nums[k]:\n                l = i\n                break\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]\n        \nclass Solution2(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in xrange(len(nums)-1):\n            if nums[i] < nums[i+1]:\n                k = i\n\n        if k == -1:\n            nums.reverse()\n            return\n\n        for i in xrange(k+1, len(nums)):\n            if nums[i] > nums[k]:\n                l = i\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  }
]