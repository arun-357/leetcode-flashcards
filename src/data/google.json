[
  {
    "title": "Two Sum",
    "difficulty": "EASY",
    "category": "Array, Hash Table",
    "link": "https://leetcode.com/problems/two-sum",
    "slug": "two-sum",
    "description": "Given an array of integers \nnums\n and an integer \ntarget\n, return \nindices of the two numbers such that they add up to \ntarget\n.\n\n\nYou may assume that each input would have \nexactly\n one solution\n, and you may not use the \nsame\n element twice.\n\n\nYou can return the answer in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,7,11,15], target = 9\n\nOutput:\n [0,1]\n\nExplanation:\n Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,4], target = 6\n\nOutput:\n [1,2]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,3], target = 6\n\nOutput:\n [0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n-10\n9\n <= target <= 10\n9\n\n\nOnly one valid answer exists.\n\n\n\n\n \n\n\nFollow-up: \nCan you come up with an algorithm that is less than \nO(n\n2\n)\n \ntime complexity?",
    "solution": "\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        lookup = {}\n        for i, num in enumerate(nums):\n            if target - num in lookup:\n                return [lookup[target - num], i]\n            lookup[num] = i\n\n    def twoSum2(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        for i in nums:\n            j = target - i\n            tmp_nums_start_index = nums.index(i) + 1\n            tmp_nums = nums[tmp_nums_start_index:]\n            if j in tmp_nums:\n                return [nums.index(i), tmp_nums_start_index + tmp_nums.index(j)]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Palindrome Number",
    "difficulty": "EASY",
    "category": "Math",
    "link": "https://leetcode.com/problems/palindrome-number",
    "slug": "palindrome-number",
    "description": "Given an integer \nx\n, return \ntrue\n if \nx\n is a \npalindrome\n, and \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 121\n\nOutput:\n true\n\nExplanation:\n 121 reads as 121 from left to right and from right to left.\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = -121\n\nOutput:\n false\n\nExplanation:\n From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n\n\nExample 3:\n\n\n\n\nInput:\n x = 10\n\nOutput:\n false\n\nExplanation:\n Reads 01 from right to left. Therefore it is not a palindrome.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= x <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you solve it without converting the integer to a string?",
    "solution": "\nclass Solution(object):\n    # @return a boolean\n    def isPalindrome(self, x):\n        if x < 0:\n            return False\n        copy, reverse = x, 0\n\n        while copy:\n            reverse *= 10\n            reverse += copy % 10\n            copy //= 10\n\n        return x == reverse",
    "explanation": "N/A",
    "time_complexity": "O(1)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Add Two Numbers",
    "difficulty": "MEDIUM",
    "category": "Linked List, Math, Recursion",
    "link": "https://leetcode.com/problems/add-two-numbers",
    "slug": "add-two-numbers",
    "description": "You are given two \nnon-empty\n linked lists representing two non-negative integers. The digits are stored in \nreverse order\n, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n l1 = [2,4,3], l2 = [5,6,4]\n\nOutput:\n [7,0,8]\n\nExplanation:\n 342 + 465 = 807.\n\n\n\nExample 2:\n\n\n\n\nInput:\n l1 = [0], l2 = [0]\n\nOutput:\n [0]\n\n\n\nExample 3:\n\n\n\n\nInput:\n l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n\nOutput:\n [8,9,9,9,0,0,0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in each linked list is in the range \n[1, 100]\n.\n\n\n0 <= Node.val <= 9\n\n\nIt is guaranteed that the list represents a number that does not have leading zeros.",
    "solution": "\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        current, carry = dummy, 0\n\n        while l1 or l2:\n            val = carry\n            if l1:\n                val += l1.val\n                l1 = l1.next\n            if l2:\n                val += l2.val\n                l2 = l2.next\n            carry, val = divmod(val, 10)\n            current.next = ListNode(val)\n            current = current.next\n\n        if carry == 1:\n            current.next = ListNode(1)\n\n        return dummy.next",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "EASY",
    "category": "Array, Dynamic Programming",
    "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
    "slug": "best-time-to-buy-and-sell-stock",
    "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nYou want to maximize your profit by choosing a \nsingle day\n to buy one stock and choosing a \ndifferent day in the future\n to sell that stock.\n\n\nReturn \nthe maximum profit you can achieve from this transaction\n. If you cannot achieve any profit, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 5\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transactions are done and the max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n4",
    "solution": "\nclass Solution(object):\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, prices):\n        max_profit, min_price = 0, float(\"inf\")\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Longest Common Prefix",
    "difficulty": "EASY",
    "category": "String, Trie",
    "link": "https://leetcode.com/problems/longest-common-prefix",
    "slug": "longest-common-prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings.\n\n\nIf there is no common prefix, return an empty string \n\"\"\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n strs = [\"flower\",\"flow\",\"flight\"]\n\nOutput:\n \"fl\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n strs = [\"dog\",\"racecar\",\"car\"]\n\nOutput:\n \"\"\n\nExplanation:\n There is no common prefix among the input strings.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 200\n\n\n0 <= strs[i].length <= 200\n\n\nstrs[i]\n consists of only lowercase English letters if it is non-empty.",
    "solution": "\nclass Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n\n        for i in xrange(len(strs[0])):\n            for string in strs[1:]:\n                if i >= len(string) or string[i] != strs[0][i]:\n                    return strs[0][:i]\n        return strs[0]\n\n\nclass Solution2(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        prefix = \"\"\n        \n        for chars in zip(*strs):\n            if all(c == chars[0] for c in chars):\n                prefix += chars[0]\n            else:\n                return prefix\n            \n        return prefix",
    "explanation": "N/A",
    "time_complexity": "O(n * k), k is the length of the common prefix",
    "space_complexity": "O(k)"
  },
  {
    "title": "Longest Consecutive Sequence",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Union Find",
    "link": "https://leetcode.com/problems/longest-consecutive-sequence",
    "slug": "longest-consecutive-sequence",
    "description": "Given an unsorted array of integers \nnums\n, return \nthe length of the longest consecutive elements sequence.\n\n\nYou must write an algorithm that runs in \nO(n)\n time.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [100,4,200,1,3,2]\n\nOutput:\n 4\n\nExplanation:\n The longest consecutive elements sequence is \n[1, 2, 3, 4]\n. Therefore its length is 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,3,7,2,5,8,4,6,0,1]\n\nOutput:\n 9\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,0,1,2]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9",
    "solution": "\nclass Solution(object):\n    # @param num, a list of integer\n    # @return an integer\n    def longestConsecutive(self, num):\n        result, lengths = 1, {key: 0 for key in num}\n        for i in num:\n            if lengths[i] == 0:\n                lengths[i] = 1\n                left, right = lengths.get(i - 1, 0), lengths.get(i + 1, 0)\n                length = 1 + left + right\n                result, lengths[i - left], lengths[i + right] = max(result, length), length, length\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Trapping Rain Water",
    "difficulty": "HARD",
    "category": "Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack",
    "link": "https://leetcode.com/problems/trapping-rain-water",
    "slug": "trapping-rain-water",
    "description": "Given \nn\n non-negative integers representing an elevation map where the width of each bar is \n1\n, compute how much water it can trap after raining.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [0,1,0,2,1,0,1,3,2,1,2,1]\n\nOutput:\n 6\n\nExplanation:\n The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [4,2,0,3,2,5]\n\nOutput:\n 9\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n1 <= n <= 2 * 10\n4\n\n\n0 <= height[i] <= 10\n5",
    "solution": "\nclass Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result, left, right, level = 0, 0, len(height)-1, 0\n        while left < right:\n            if height[left] < height[right]:\n                lower = height[left]\n                left += 1\n            else:\n                lower = height[right]\n                right -= 1\n            level = max(level, lower)\n            result += level-lower\n        return result\n\n\nclass Solution2(object):\n    # @param A, a list of integers\n    # @return an integer\n    def trap(self, A):\n        result = 0\n        top = 0\n        for i in xrange(len(A)):\n            if A[top] < A[i]:\n                top = i\n\n        second_top = 0\n        for i in xrange(top):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        second_top = len(A) - 1\n        for i in reversed(xrange(top, len(A))):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        return result\n\n\nclass Solution3(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        right = [0]*len(height)\n        mx = 0\n        for i in reversed(xrange(len(height))):\n            right[i] = mx\n            mx = max(mx, height[i])\n        result = left = 0\n        for i in xrange(len(height)):\n            left = max(left, height[i])\n            result += max(min(left, right[i])-height[i], 0)\n        return result\n\n\nclass Solution4(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        stk = []\n        for i in xrange(len(height)):\n            prev = 0\n            while stk and height[stk[-1]] <= height[i]:\n                j = stk.pop()\n                result += (height[j] - prev) * (i - j - 1)\n                prev = height[j]\n            if stk:\n                result += (height[i] - prev) * (i - stk[-1] - 1)\n            stk.append(i)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "MEDIUM",
    "category": "Hash Table, String, Sliding Window",
    "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters",
    "slug": "longest-substring-without-repeating-characters",
    "description": "Given a string \ns\n, find the length of the \nlongest\n \nsubstring\n without duplicate characters.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abcabcbb\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"abc\", with the length of 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"bbbbb\"\n\nOutput:\n 1\n\nExplanation:\n The answer is \"b\", with the length of 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"pwwkew\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 5 * 10\n4\n\n\ns\n consists of English letters, digits, symbols and spaces.",
    "solution": "\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, left = 0, 0\n        lookup = {}\n        for right in xrange(len(s)):\n            if s[right] in lookup:\n                left = max(left, lookup[s[right]]+1)\n            lookup[s[right]] = right\n            result = max(result, right-left+1)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Roman to Integer",
    "difficulty": "EASY",
    "category": "Hash Table, Math, String",
    "link": "https://leetcode.com/problems/roman-to-integer",
    "slug": "roman-to-integer",
    "description": "Roman numerals are represented by seven different symbols: \nI\n, \nV\n, \nX\n, \nL\n, \nC\n, \nD\n and \nM\n.\n\n\n\n\nSymbol\n       \nValue\n\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\n\nFor example, \n2\n is written as \nII\n in Roman numeral, just two ones added together. \n12\n is written as \nXII\n, which is simply \nX + II\n. The number \n27\n is written as \nXXVII\n, which is \nXX + V + II\n.\n\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not \nIIII\n. Instead, the number four is written as \nIV\n. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as \nIX\n. There are six instances where subtraction is used:\n\n\n\n\nI\n can be placed before \nV\n (5) and \nX\n (10) to make 4 and 9. \n\n\nX\n can be placed before \nL\n (50) and \nC\n (100) to make 40 and 90. \n\n\nC\n can be placed before \nD\n (500) and \nM\n (1000) to make 400 and 900.\n\n\n\n\nGiven a roman numeral, convert it to an integer.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"III\"\n\nOutput:\n 3\n\nExplanation:\n III = 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"LVIII\"\n\nOutput:\n 58\n\nExplanation:\n L = 50, V= 5, III = 3.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"MCMXCIV\"\n\nOutput:\n 1994\n\nExplanation:\n M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 15\n\n\ns\n contains only the characters \n('I', 'V', 'X', 'L', 'C', 'D', 'M')\n.\n\n\nIt is \nguaranteed\n that \ns\n is a valid roman numeral in the range \n[1, 3999]\n.",
    "solution": "\nclass Solution(object):\n    # @return an integer\n    def romanToInt(self, s):\n        numeral_map = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\":100, \"D\": 500, \"M\": 1000}\n        decimal = 0\n        for i in xrange(len(s)):\n            if i > 0 and numeral_map[s[i]] > numeral_map[s[i - 1]]:\n                decimal += numeral_map[s[i]] - 2 * numeral_map[s[i - 1]]\n            else:\n                decimal += numeral_map[s[i]]\n        return decimal",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Median of Two Sorted Arrays",
    "difficulty": "HARD",
    "category": "Array, Binary Search, Divide and Conquer",
    "link": "https://leetcode.com/problems/median-of-two-sorted-arrays",
    "slug": "median-of-two-sorted-arrays",
    "description": "Given two sorted arrays \nnums1\n and \nnums2\n of size \nm\n and \nn\n respectively, return \nthe median\n of the two sorted arrays.\n\n\nThe overall run time complexity should be \nO(log (m+n))\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,3], nums2 = [2]\n\nOutput:\n 2.00000\n\nExplanation:\n merged array = [1,2,3] and median is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1,2], nums2 = [3,4]\n\nOutput:\n 2.50000\n\nExplanation:\n merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m\n\n\nnums2.length == n\n\n\n0 <= m <= 1000\n\n\n0 <= n <= 1000\n\n\n1 <= m + n <= 2000\n\n\n-10\n6\n <= nums1[i], nums2[i] <= 10\n6",
    "solution": "\nclass Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(A, B, k):\n            m, n = len(A), len(B)\n            if m > n:\n                m, n = n, m\n                A, B = B, A\n            i = binary_search(max(k-n, 0), min(m, k)-1, lambda i: A[i] >= B[k-1-i])\n            return max(A[i-1] if i-1 >= 0 else float(\"-inf\"), B[k-1-i] if k-1-i >= 0 else float(\"-inf\"))\n\n        len1, len2 = len(nums1), len(nums2)\n        if (len1+len2) % 2 == 1:\n            return getKth(nums1, nums2, (len1+len2)//2+1)\n        else:\n            return (getKth(nums1, nums2, (len1+len2)//2)+getKth(nums1, nums2, (len1+len2)//2+1))*0.5    \n\n\n# Generic solution.\nclass Solution_Generic(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(arrays, k):\n            def check(num):\n                # count the number of values which are less or equal to num\n                return sum(binary_search(0, len(arr)-1, lambda x: arr[x] > num) for arr in arrays) >= k\n    \n            return binary_search(min(arr[0] for arr in arrays if arr), max(arr[-1] for arr in arrays if arr), check)\n\n        array = [nums1, nums2]\n        total = sum(len(nums) for nums in array)\n        if total % 2 == 1:\n            return getKth(array, total//2+1)\n        else:\n            return (getKth(array, total//2)+getKth(array, total//2+1))*0.5",
    "explanation": "N/A",
    "time_complexity": "O(log(max(m, n)) * log(max_val - min_val))",
    "space_complexity": "O(1)"
  },
  {
    "title": "Merge Intervals",
    "difficulty": "MEDIUM",
    "category": "Array, Sorting",
    "link": "https://leetcode.com/problems/merge-intervals",
    "slug": "merge-intervals",
    "description": "Given an array of \nintervals\n where \nintervals[i] = [start\ni\n, end\ni\n]\n, merge all overlapping intervals, and return \nan array of the non-overlapping intervals that cover all the intervals in the input\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n intervals = [[1,3],[2,6],[8,10],[15,18]]\n\nOutput:\n [[1,6],[8,10],[15,18]]\n\nExplanation:\n Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\n\n\nExample 2:\n\n\n\n\nInput:\n intervals = [[1,4],[4,5]]\n\nOutput:\n [[1,5]]\n\nExplanation:\n Intervals [1,4] and [4,5] are considered overlapping.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= intervals.length <= 10\n4\n\n\nintervals[i].length == 2\n\n\n0 <= start\ni\n <= end\ni\n <= 10\n4",
    "solution": "\nclass Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        intervals.sort()\n        result = []\n        for interval in intervals:\n            if not result or interval[0] > result[-1][1]:\n                result.append(interval)\n            else:\n                result[-1][1] = max(result[-1][1], interval[1])\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "3Sum",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers, Sorting",
    "link": "https://leetcode.com/problems/3sum",
    "slug": "3sum",
    "description": "Given an integer array nums, return all the triplets \n[nums[i], nums[j], nums[k]]\n such that \ni != j\n, \ni != k\n, and \nj != k\n, and \nnums[i] + nums[j] + nums[k] == 0\n.\n\n\nNotice that the solution set must not contain duplicate triplets.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-1,0,1,2,-1,-4]\n\nOutput:\n [[-1,-1,2],[-1,0,1]]\n\nExplanation:\n \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,1,1]\n\nOutput:\n []\n\nExplanation:\n The only possible triplet does not sum up to 0.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [0,0,0]\n\nOutput:\n [[0,0,0]]\n\nExplanation:\n The only possible triplet sums up to 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= nums.length <= 3000\n\n\n-10\n5\n <= nums[i] <= 10\n5",
    "solution": "\nclass Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        nums.sort()\n        for i in reversed(xrange(2, len(nums))):\n            if i+1 < len(nums) and nums[i] == nums[i+1]:\n                continue\n            target = -nums[i]\n            left, right = 0, i-1\n            while left < right:\n                if nums[left]+nums[right] < target:\n                    left += 1\n                elif nums[left]+nums[right] > target:\n                    right -= 1\n                else:\n                    result.append([nums[left], nums[right], nums[i]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left-1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right+1]:\n                        right -= 1\n        return result\n\n\nclass Solution2(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, i = sorted(nums), [], 0\n        while i < len(nums) - 2:\n            if i == 0 or nums[i] != nums[i - 1]:\n                j, k = i + 1, len(nums) - 1\n                while j < k:\n                    if nums[i] + nums[j] + nums[k] < 0:\n                        j += 1\n                    elif nums[i] + nums[j] + nums[k] > 0:\n                        k -= 1\n                    else:\n                        result.append([nums[i], nums[j], nums[k]])\n                        j, k = j + 1, k - 1\n                        while j < k and nums[j] == nums[j - 1]:\n                            j += 1\n                        while j < k and nums[k] == nums[k + 1]:\n                            k -= 1\n            i += 1\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)"
  },
  {
    "title": "4Sum",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers, Sorting",
    "link": "https://leetcode.com/problems/4sum",
    "slug": "4sum",
    "description": "Given an array \nnums\n of \nn\n integers, return \nan array of all the \nunique\n quadruplets\n \n[nums[a], nums[b], nums[c], nums[d]]\n such that:\n\n\n\n\n0 <= a, b, c, d < n\n\n\na\n, \nb\n, \nc\n, and \nd\n are \ndistinct\n.\n\n\nnums[a] + nums[b] + nums[c] + nums[d] == target\n\n\n\n\nYou may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,0,-1,0,-2,2], target = 0\n\nOutput:\n [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,2,2,2,2], target = 8\n\nOutput:\n [[2,2,2,2]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 200\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n-10\n9\n <= target <= 10\n9",
    "solution": "\nimport collections\n\n\n# Two pointer solution. (1356ms)\nclass Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        result = []\n        for i in xrange(len(nums) - 3):\n            if i and nums[i] == nums[i - 1]:\n                continue\n            for j in xrange(i + 1, len(nums) - 2):\n                if j != i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                total = target - nums[i] - nums[j]\n                left, right = j + 1, len(nums) - 1\n                while left < right:\n                    if nums[left] + nums[right] == total:\n                        result.append([nums[i], nums[j], nums[left], nums[right]])\n                        right -= 1\n                        left += 1\n                        while left < right and nums[left] == nums[left - 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right + 1]:\n                            right -= 1\n                    elif nums[left] + nums[right] > total:\n                        right -= 1\n                    else:\n                        left += 1\n        return result\n\n\n# Hash solution. (224ms)\nclass Solution2(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, lookup = sorted(nums), [], collections.defaultdict(list)\n        for i in xrange(0, len(nums) - 1):\n            for j in xrange(i + 1, len(nums)):\n                is_duplicated = False\n                for [x, y] in lookup[nums[i] + nums[j]]:\n                    if nums[x] == nums[i]:\n                        is_duplicated = True\n                        break\n                if not is_duplicated:\n                    lookup[nums[i] + nums[j]].append([i, j])\n        ans = {}\n        for c in xrange(2, len(nums)):\n            for d in xrange(c+1, len(nums)):\n                if target - nums[c] - nums[d] in lookup:\n                    for [a, b] in lookup[target - nums[c] - nums[d]]:\n                        if b < c:\n                            quad = [nums[a], nums[b], nums[c], nums[d]]\n                            quad_hash = \" \".join(str(quad))\n                            if quad_hash not in ans:\n                                ans[quad_hash] = True\n                                result.append(quad)\n        return result\n\n\nclass Solution3(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, lookup = sorted(nums), [], collections.defaultdict(list)\n        for i in xrange(0, len(nums) - 1):\n            for j in xrange(i + 1, len(nums)):\n                lookup[nums[i] + nums[j]].append([i, j])\n\n        for i in lookup.keys():\n            if target - i in lookup:\n                for x in lookup[i]:\n                    for y in lookup[target - i]:\n                        [a, b], [c, d] = x, y\n                        if a is not c and a is not d and \\\n                           b is not c and b is not d:\n                            quad = sorted([nums[a], nums[b], nums[c], nums[d]])\n                            if quad not in result:\n                                result.append(quad)\n        return sorted(result)",
    "explanation": "N/A",
    "time_complexity": "O(n^2 * p) ~ O(n^4)",
    "space_complexity": "O(n^2)"
  },
  {
    "title": "Zigzag Conversion",
    "difficulty": "MEDIUM",
    "category": "String",
    "link": "https://leetcode.com/problems/zigzag-conversion",
    "slug": "zigzag-conversion",
    "description": "The string \n\"PAYPALISHIRING\"\n is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\n\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\n\n\nAnd then read line by line: \n\"PAHNAPLSIIGYIR\"\n\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\n\n\nstring convert(string s, int numRows);\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"PAYPALISHIRING\", numRows = 3\n\nOutput:\n \"PAHNAPLSIIGYIR\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"PAYPALISHIRING\", numRows = 4\n\nOutput:\n \"PINALSIGYAHRPI\"\n\nExplanation:\n\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"A\", numRows = 1\n\nOutput:\n \"A\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consists of English letters (lower-case and upper-case), \n','\n and \n'.'\n.\n\n\n1 <= numRows <= 1000",
    "solution": "\nclass Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        if numRows == 1:\n            return s\n        step, zigzag = 2 * numRows - 2, \"\"\n        for i in xrange(numRows):\n            for j in xrange(i, len(s), step):\n                zigzag += s[j]\n                if 0 < i < numRows - 1 and j + step - 2 * i < len(s):\n                    zigzag += s[j + step - 2 * i]\n        return zigzag",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Valid Parentheses",
    "difficulty": "EASY",
    "category": "String, Stack",
    "link": "https://leetcode.com/problems/valid-parentheses",
    "slug": "valid-parentheses",
    "description": "Given a string \ns\n containing just the characters \n'('\n, \n')'\n, \n'{'\n, \n'}'\n, \n'['\n and \n']'\n, determine if the input string is valid.\n\n\nAn input string is valid if:\n\n\n\n\nOpen brackets must be closed by the same type of brackets.\n\n\nOpen brackets must be closed in the correct order.\n\n\nEvery close bracket has a corresponding open bracket of the same type.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"()\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"()[]{}\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"(]\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"([])\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"([)]\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of parentheses only \n'()[]{}'\n.",
    "solution": "\nclass Solution(object):\n    # @return a boolean\n    def isValid(self, s):\n        stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        for parenthese in s:\n            if parenthese in lookup:\n                stack.append(parenthese)\n            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:\n                return False\n        return len(stack) == 0",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Top K Frequent Words",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, String, Trie, Sorting, Heap (Priority Queue), Bucket Sort, Counting",
    "link": "https://leetcode.com/problems/top-k-frequent-words",
    "slug": "top-k-frequent-words",
    "description": "Given an array of strings \nwords\n and an integer \nk\n, return \nthe \nk\n most frequent strings\n.\n\n\nReturn the answer \nsorted\n by \nthe frequency\n from highest to lowest. Sort the words with the same frequency by their \nlexicographical order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2\n\nOutput:\n [\"i\",\"love\"]\n\nExplanation:\n \"i\" and \"love\" are the two most frequent words.\nNote that \"i\" comes before \"love\" due to a lower alphabetical order.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4\n\nOutput:\n [\"the\",\"is\",\"sunny\",\"day\"]\n\nExplanation:\n \"the\", \"is\", \"sunny\" and \"day\" are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 500\n\n\n1 <= words[i].length <= 10\n\n\nwords[i]\n consists of lowercase English letters.\n\n\nk\n is in the range \n[1, The number of \nunique\n words[i]]\n\n\n\n\n \n\n\nFollow-up:\n Could you solve it in \nO(n log(k))\n time and \nO(n)\n extra space?",
    "solution": "\nimport collections\nimport heapq\nfrom random import randint\n\n\nclass Solution(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counts = collections.Counter(words)\n        p = []\n        for key, val in counts.iteritems():\n            p.append((-val, key))\n        self.kthElement(p, k-1)\n\n        result = []\n        sorted_p = sorted(p[:k])\n        for i in xrange(k):\n            result.append(sorted_p[i][1])\n        return result\n\n    def kthElement(self, nums, k):  # O(n) on average\n        def PartitionAroundPivot(left, right, pivot_idx, nums):\n            pivot_value = nums[pivot_idx]\n            new_pivot_idx = left\n            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n            for i in xrange(left, right):\n                if nums[i] < pivot_value:\n                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                    new_pivot_idx += 1\n\n            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n            return new_pivot_idx\n\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k:\n                return\n            elif new_pivot_idx > k:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k.\n                left = new_pivot_idx + 1\n\n\n# Heap Solution\nclass Solution2(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        class MinHeapObj(object):\n            def __init__(self,val):\n                self.val = val\n            def __lt__(self,other):\n                return self.val[1] > other.val[1] if self.val[0] == other.val[0] else \\\n                       self.val < other.val\n            def __eq__(self,other):\n                return self.val == other.val\n            def __str__(self):\n                return str(self.val)\n\n        counts = collections.Counter(words)\n        min_heap = []\n        for word, count in counts.iteritems():\n            heapq.heappush(min_heap, MinHeapObj((count, word)))\n            if len(min_heap) == k+1:\n                heapq.heappop(min_heap)\n        result = []\n        while min_heap:\n            result.append(heapq.heappop(min_heap).val[1])\n        return result[::-1]\n\n\n# Bucket Sort Solution\nclass Solution3(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counts = collections.Counter(words)\n        buckets = [[] for _ in xrange(len(words)+1)]\n        for word, count in counts.iteritems():\n            buckets[count].append(word)\n        pairs = []\n        for i in reversed(xrange(len(words))):\n            for word in buckets[i]:\n                pairs.append((-i, word))\n            if len(pairs) >= k:\n                break\n        pairs.sort()\n        return [pair[1] for pair in pairs[:k]]\n\n\n# time: O(nlogn)\n# space: O(n)\n\nfrom collections import Counter\n\n\nclass Solution4(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counter = Counter(words)\n        candidates = counter.keys()\n        candidates.sort(key=lambda w: (-counter[w], w))\n        return candidates[:k]",
    "explanation": "N/A",
    "time_complexity": "O(n + klogk) ~ O(n + nlogn)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Single Number",
    "difficulty": "EASY",
    "category": "Array, Bit Manipulation",
    "link": "https://leetcode.com/problems/single-number",
    "slug": "single-number",
    "description": "Given a \nnon-empty\n array of integers \nnums\n, every element appears \ntwice\n except for one. Find that single one.\n\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,2,1]\n\n\nOutput:\n \n1\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [4,1,2,1,2]\n\n\nOutput:\n \n4\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1]\n\n\nOutput:\n \n1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 3 * 10\n4\n\n\n-3 * 10\n4\n <= nums[i] <= 3 * 10\n4\n\n\nEach element in the array appears twice except for one element which appears only once.",
    "solution": "\nimport operator\nfrom functools import reduce\n\n\nclass Solution(object):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    def singleNumber(self, A):\n        return reduce(operator.xor, A)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Container With Most Water",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers, Greedy",
    "link": "https://leetcode.com/problems/container-with-most-water",
    "slug": "container-with-most-water",
    "description": "You are given an integer array \nheight\n of length \nn\n. There are \nn\n vertical lines drawn such that the two endpoints of the \ni\nth\n line are \n(i, 0)\n and \n(i, height[i])\n.\n\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\n\nReturn \nthe maximum amount of water a container can store\n.\n\n\nNotice\n that you may not slant the container.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [1,8,6,2,5,4,8,3,7]\n\nOutput:\n 49\n\nExplanation:\n The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [1,1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= height[i] <= 10\n4",
    "solution": "\nclass Solution(object):\n    # @return an integer\n    def maxArea(self, height):\n        max_area, i, j = 0, 0, len(height) - 1\n        while i < j:\n            max_area = max(max_area, min(height[i], height[j]) * (j - i))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return max_area",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Remove Duplicates from Sorted Array",
    "difficulty": "EASY",
    "category": "Array, Two Pointers",
    "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array",
    "slug": "remove-duplicates-from-sorted-array",
    "description": "Given an integer array \nnums\n sorted in \nnon-decreasing order\n, remove the duplicates \nin-place\n such that each unique element appears only \nonce\n. The \nrelative order\n of the elements should be kept the \nsame\n. Then return \nthe number of unique elements in \nnums\n.\n\n\nConsider the number of unique elements of \nnums\n to be \nk\n, to get accepted, you need to do the following things:\n\n\n\n\nChange the array \nnums\n such that the first \nk\n elements of \nnums\n contain the unique elements in the order they were present in \nnums\n initially. The remaining elements of \nnums\n are not important as well as the size of \nnums\n.\n\n\nReturn \nk\n.\n\n\n\n\nCustom Judge:\n\n\nThe judge will test your solution with the following code:\n\n\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\n\n\nIf all assertions pass, then your solution will be \naccepted\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,2]\n\nOutput:\n 2, nums = [1,2,_]\n\nExplanation:\n Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,0,1,1,1,2,2,3,3,4]\n\nOutput:\n 5, nums = [0,1,2,3,4,_,_,_,_,_]\n\nExplanation:\n Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 3 * 10\n4\n\n\n-100 <= nums[i] <= 100\n\n\nnums\n is sorted in \nnon-decreasing\n order.",
    "solution": "\nclass Solution(object):\n    # @param a list of integers\n    # @return an integer\n    def removeDuplicates(self, A):\n        if not A:\n            return 0\n\n        last = 0\n        for i in xrange(len(A)):\n            if A[last] != A[i]:\n                last += 1\n                A[last] = A[i]\n        return last + 1",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Next Permutation",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers",
    "link": "https://leetcode.com/problems/next-permutation",
    "slug": "next-permutation",
    "description": "A \npermutation\n of an array of integers is an arrangement of its members into a sequence or linear order.\n\n\n\n\nFor example, for \narr = [1,2,3]\n, the following are all the permutations of \narr\n: \n[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]\n.\n\n\n\n\nThe \nnext permutation\n of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the \nnext permutation\n of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n\n\n\nFor example, the next permutation of \narr = [1,2,3]\n is \n[1,3,2]\n.\n\n\nSimilarly, the next permutation of \narr = [2,3,1]\n is \n[3,1,2]\n.\n\n\nWhile the next permutation of \narr = [3,2,1]\n is \n[1,2,3]\n because \n[3,2,1]\n does not have a lexicographical larger rearrangement.\n\n\n\n\nGiven an array of integers \nnums\n, \nfind the next permutation of\n \nnums\n.\n\n\nThe replacement must be \nin place\n and use only constant extra memory.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n [1,3,2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,1]\n\nOutput:\n [1,2,3]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,1,5]\n\nOutput:\n [1,5,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 100",
    "solution": "\nclass Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in reversed(xrange(len(nums)-1)):\n            if nums[i] < nums[i+1]:\n                k = i\n                break\n        else:\n            nums.reverse()\n            return\n\n        for i in reversed(xrange(k+1, len(nums))):\n            if nums[i] > nums[k]:\n                l = i\n                break\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]\n        \n\nclass Solution2(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in xrange(len(nums)-1):\n            if nums[i] < nums[i+1]:\n                k = i\n\n        if k == -1:\n            nums.reverse()\n            return\n\n        for i in xrange(k+1, len(nums)):\n            if nums[i] > nums[k]:\n                l = i\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Sliding Window Maximum",
    "difficulty": "HARD",
    "category": "Array, Queue, Sliding Window, Heap (Priority Queue), Monotonic Queue",
    "link": "https://leetcode.com/problems/sliding-window-maximum",
    "slug": "sliding-window-maximum",
    "description": "You are given an array of integers \nnums\n, there is a sliding window of size \nk\n which is moving from the very left of the array to the very right. You can only see the \nk\n numbers in the window. Each time the sliding window moves right by one position.\n\n\nReturn \nthe max sliding window\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,-1,-3,5,3,6,7], k = 3\n\nOutput:\n [3,3,5,5,6,7]\n\nExplanation:\n \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       \n3\n\n 1 [3  -1  -3] 5  3  6  7       \n3\n\n 1  3 [-1  -3  5] 3  6  7      \n 5\n\n 1  3  -1 [-3  5  3] 6  7       \n5\n\n 1  3  -1  -3 [5  3  6] 7       \n6\n\n 1  3  -1  -3  5 [3  6  7]      \n7\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1], k = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n1 <= k <= nums.length",
    "solution": "\nfrom collections import deque\n\n\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result, dq = [], deque()\n        for i in xrange(len(nums)):\n            if dq and i-dq[0] == k:\n                dq.popleft()\n            while dq and nums[dq[-1]] <= nums[i]:\n                dq.pop()\n            dq.append(i)\n            if i >= k-1:\n                result.append(nums[dq[0]])\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(k)"
  },
  {
    "title": "Pascal's Triangle",
    "difficulty": "EASY",
    "category": "Array, Dynamic Programming",
    "link": "https://leetcode.com/problems/pascals-triangle",
    "slug": "pascals-triangle",
    "description": "Given an integer \nnumRows\n, return the first numRows of \nPascal's triangle\n.\n\n\nIn \nPascal's triangle\n, each number is the sum of the two numbers directly above it as shown:\n\n\n\n\n \n\n\nExample 1:\n\n\nInput:\n numRows = 5\n\nOutput:\n [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n\nExample 2:\n\n\nInput:\n numRows = 1\n\nOutput:\n [[1]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numRows <= 30",
    "solution": "\nclass Solution(object):\n    # @return a list of lists of integers\n    def generate(self, numRows):\n        result = []\n        for i in xrange(numRows):\n            result.append([])\n            for j in xrange(i + 1):\n                if j in (0, i):\n                    result[i].append(1)\n                else:\n                    result[i].append(result[i - 1][j - 1] + result[i - 1][j])\n        return result\n\n    def generate2(self, numRows):\n        if not numRows: return []\n        res = [[1]]\n        for i in range(1, numRows):\n            res += [map(lambda x, y: x + y, res[-1] + [0], [0] + res[-1])]\n        return res[:numRows]\n\n    def generate3(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if numRows == 0: return []\n        if numRows == 1: return [[1]]\n        res = [[1], [1, 1]]\n\n        def add(nums):\n            res = nums[:1]\n            for i, j in enumerate(nums):\n                if i < len(nums) - 1:\n                    res += [nums[i] + nums[i + 1]]\n            res += nums[:1]\n            return res\n\n        while len(res) < numRows:\n            res.extend([add(res[-1])])\n        return res",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Diameter of Binary Tree",
    "difficulty": "EASY",
    "category": "Tree, Depth-First Search, Binary Tree",
    "link": "https://leetcode.com/problems/diameter-of-binary-tree",
    "slug": "diameter-of-binary-tree",
    "description": "Given the \nroot\n of a binary tree, return \nthe length of the \ndiameter\n of the tree\n.\n\n\nThe \ndiameter\n of a binary tree is the \nlength\n of the longest path between any two nodes in a tree. This path may or may not pass through the \nroot\n.\n\n\nThe \nlength\n of a path between two nodes is represented by the number of edges between them.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5]\n\nOutput:\n 3\n\nExplanation:\n 3 is the length of the path [4,2,1,3] or [5,2,1,3].\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1,2]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-100 <= Node.val <= 100",
    "solution": "\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution(object):\n    def diameterOfBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def iter_dfs(node):\n            result = 0\n            stk = [(1, [node, [0]])]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, ret = params\n                    if not node:\n                        continue\n                    ret1, ret2 = [0], [0]\n                    stk.append((2, [node, ret1, ret2, ret]))\n                    stk.append((1, [node.right, ret2]))\n                    stk.append((1, [node.left, ret1]))\n                elif step == 2:\n                    node, ret1, ret2, ret = params\n                    result = max(result, ret1[0]+ret2[0])\n                    ret[0] = 1+max(ret1[0], ret2[0])\n            return result\n        \n        return iter_dfs(root)\n\n\nclass Solution2(object):\n    def diameterOfBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(root):\n            if not root: \n                return 0, 0\n            left_d, left_h = dfs(root.left)\n            right_d, right_h = dfs(root.right)\n            return max(left_d, right_d, left_h+right_h), 1+max(left_h, right_h)\n \n        return dfs(root)[0]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(h)"
  },
  {
    "title": "Number of Visible People in a Queue",
    "difficulty": "HARD",
    "category": "Array, Stack, Monotonic Stack",
    "link": "https://leetcode.com/problems/number-of-visible-people-in-a-queue",
    "slug": "number-of-visible-people-in-a-queue",
    "description": "There are \nn\n people standing in a queue, and they numbered from \n0\n to \nn - 1\n in \nleft to right\n order. You are given an array \nheights\n of \ndistinct\n integers where \nheights[i]\n represents the height of the \ni\nth\n person.\n\n\nA person can \nsee\n another person to their right in the queue if everybody in between is \nshorter\n than both of them. More formally, the \ni\nth\n person can see the \nj\nth\n person if \ni < j\n and \nmin(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1])\n.\n\n\nReturn \nan array \nanswer\n of length \nn\n where \nanswer[i]\n is the \nnumber of people\n the \ni\nth\n person can \nsee\n to their right in the queue\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [10,6,8,5,11,9]\n\nOutput:\n [3,1,2,1,1,0]\n\nExplanation:\n\nPerson 0 can see person 1, 2, and 4.\nPerson 1 can see person 2.\nPerson 2 can see person 3 and 4.\nPerson 3 can see person 4.\nPerson 4 can see person 5.\nPerson 5 can see no one since nobody is to the right of them.\n\n\n\nExample 2:\n\n\n\n\nInput:\n heights = [5,1,2,3,10]\n\nOutput:\n [4,1,1,1,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == heights.length\n\n\n1 <= n <= 10\n5\n\n\n1 <= heights[i] <= 10\n5\n\n\nAll the values of \nheights\n are \nunique\n.",
    "solution": "\nclass Solution(object):\n    def canSeePersonsCount(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(heights)\n        stk = []\n        for i, h in enumerate(heights):\n            while stk and heights[stk[-1]] < h:\n                result[stk.pop()] += 1\n            if stk:\n                result[stk[-1]] += 1\n            if stk and heights[stk[-1]] == h:\n                stk.pop()\n            stk.append(i)\n        return result\n\n\nclass Solution2(object):\n    def canSeePersonsCount(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(heights)\n        stk = []\n        for i in reversed(xrange(len(heights))):\n            cnt = 0\n            while stk and heights[stk[-1]] < heights[i]:\n                stk.pop()\n                cnt += 1\n            result[i] = cnt+1 if stk else cnt\n            if stk and heights[stk[-1]] == heights[i]:\n                stk.pop()\n            stk.append(i)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Find Peak Element",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/find-peak-element",
    "slug": "find-peak-element",
    "description": "A peak element is an element that is strictly greater than its neighbors.\n\n\nGiven a \n0-indexed\n integer array \nnums\n, find a peak element, and return its index. If the array contains multiple peaks, return the index to \nany of the peaks\n.\n\n\nYou may imagine that \nnums[-1] = nums[n] = -∞\n. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\n\nYou must write an algorithm that runs in \nO(log n)\n time.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,1]\n\nOutput:\n 2\n\nExplanation:\n 3 is a peak element and your function should return the index number 2.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,1,3,5,6,4]\n\nOutput:\n 5\n\nExplanation:\n Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\nnums[i] != nums[i + 1]\n for all valid \ni\n.",
    "solution": "\nclass Solution(object):\n    def findPeakElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            mid = left + (right - left) / 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Longest Palindromic Substring",
    "difficulty": "MEDIUM",
    "category": "Two Pointers, String, Dynamic Programming",
    "link": "https://leetcode.com/problems/longest-palindromic-substring",
    "slug": "longest-palindromic-substring",
    "description": "Given a string \ns\n, return \nthe longest\n \npalindromic\n \nsubstring\n in \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"babad\"\n\nOutput:\n \"bab\"\n\nExplanation:\n \"aba\" is also a valid answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"cbbd\"\n\nOutput:\n \"bb\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consist of only digits and English letters.",
    "solution": "\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def preProcess(s):\n            if not s:\n                return ['^', '$']\n            T = ['^']\n            for c in s:\n                T +=  ['#', c]\n            T += ['#', '$']\n            return T\n\n        T = preProcess(s)\n        P = [0] * len(T)\n        center, right = 0, 0\n        for i in xrange(1, len(T) - 1):\n            i_mirror = 2 * center - i\n            if right > i:\n                P[i] = min(right - i, P[i_mirror])\n            else:\n                P[i] = 0\n\n            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:\n                P[i] += 1\n\n            if i + P[i] > right:\n                center, right = i, i + P[i]\n\n        max_i = 0\n        for i in xrange(1, len(T) - 1):\n            if P[i] > P[max_i]:\n                max_i = i\n        start = (max_i - 1 - P[max_i]) // 2\n        return s[start : start + P[max_i]]\n\n\nclass Solution2(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return (right-left+1)-2\n        \n        left, right = -1, -2\n        for i in xrange(len(s)):\n            l = max(expand(s, i, i), expand(s, i, i+1))\n            if l > right-left+1:\n                right = i+l//2\n                left = right-l+1\n        return s[left:right+1] if left >= 0 else \"\"",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Russian Doll Envelopes",
    "difficulty": "HARD",
    "category": "Array, Binary Search, Dynamic Programming, Sorting",
    "link": "https://leetcode.com/problems/russian-doll-envelopes",
    "slug": "russian-doll-envelopes",
    "description": "You are given a 2D array of integers \nenvelopes\n where \nenvelopes[i] = [w\ni\n, h\ni\n]\n represents the width and the height of an envelope.\n\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\n\nReturn \nthe maximum number of envelopes you can Russian doll (i.e., put one inside the other)\n.\n\n\nNote:\n You cannot rotate an envelope.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n envelopes = [[5,4],[6,4],[6,7],[2,3]]\n\nOutput:\n 3\n\nExplanation:\n The maximum number of envelopes you can Russian doll is \n3\n ([2,3] => [5,4] => [6,7]).\n\n\n\nExample 2:\n\n\n\n\nInput:\n envelopes = [[1,1],[1,1],[1,1]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= envelopes.length <= 10\n5\n\n\nenvelopes[i].length == 2\n\n\n1 <= w\ni\n, h\ni\n <= 10\n5",
    "solution": "\nclass Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def insert(target):\n            left, right = 0, len(result) - 1\n            while left <= right:\n                mid = left + (right - left) / 2\n                if result[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            if left == len(result):\n                result.append(target)\n            else:\n                result[left] = target\n\n        result = []\n\n        envelopes.sort(lambda x, y: y[1] - x[1] if x[0] == y[0] else \\\n                                    x[0] - y[0])\n        for envelope in envelopes:\n            insert(envelope[1])\n\n        return len(result)",
    "explanation": "N/A",
    "time_complexity": "O(nlogn + nlogk) = O(nlogn), k is the length of the result.",
    "space_complexity": "O(1)"
  },
  {
    "title": "Set Matrix Zeroes",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Matrix",
    "link": "https://leetcode.com/problems/set-matrix-zeroes",
    "slug": "set-matrix-zeroes",
    "description": "Given an \nm x n\n integer matrix \nmatrix\n, if an element is \n0\n, set its entire row and column to \n0\n's.\n\n\nYou must do it \nin place\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,1,1],[1,0,1],[1,1,1]]\n\nOutput:\n [[1,0,1],[0,0,0],[1,0,1]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n\nOutput:\n [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[0].length\n\n\n1 <= m, n <= 200\n\n\n-2\n31\n <= matrix[i][j] <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nA straightforward solution using \nO(mn)\n space is probably a bad idea.\n\n\nA simple improvement uses \nO(m + n)\n space, but still not the best solution.\n\n\nCould you devise a constant space solution?",
    "solution": "from functools import reduce\n\nclass Solution(object):\n    # @param matrix, a list of lists of integers\n    # RETURN NOTHING, MODIFY matrix IN PLACE.\n    def setZeroes(self, matrix):\n        first_col = reduce(lambda acc, i: acc or matrix[i][0] == 0, xrange(len(matrix)), False)\n        first_row = reduce(lambda acc, j: acc or matrix[0][j] == 0, xrange(len(matrix[0])), False)\n\n        for i in xrange(1, len(matrix)):\n            for j in xrange(1, len(matrix[0])):\n                if matrix[i][j] == 0:\n                    matrix[i][0], matrix[0][j] = 0, 0\n\n        for i in xrange(1, len(matrix)):\n            for j in xrange(1, len(matrix[0])):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n\n        if first_col:\n            for i in xrange(len(matrix)):\n                matrix[i][0] = 0\n\n        if first_row:\n            for j in xrange(len(matrix[0])):\n                matrix[0][j] = 0",
    "explanation": "N/A",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Move Zeroes",
    "difficulty": "EASY",
    "category": "Array, Two Pointers",
    "link": "https://leetcode.com/problems/move-zeroes",
    "slug": "move-zeroes",
    "description": "Given an integer array \nnums\n, move all \n0\n's to the end of it while maintaining the relative order of the non-zero elements.\n\n\nNote\n that you must do this in-place without making a copy of the array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [0,1,0,3,12]\n\nOutput:\n [1,3,12,0,0]\n\nExample 2:\n\n\nInput:\n nums = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you minimize the total number of operations done?",
    "solution": "\nclass Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i]:\n                nums[i], nums[pos] = nums[pos], nums[i]\n                pos += 1\n\n    def moveZeroes2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort(cmp=lambda a, b: 0 if b else -1)\n\n\nclass Solution2(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i]:\n                nums[pos] = nums[i]\n                pos += 1\n\n        for i in xrange(pos, len(nums)):\n            nums[i] = 0",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Word Break",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, String, Dynamic Programming, Trie, Memoization",
    "link": "https://leetcode.com/problems/word-break",
    "slug": "word-break",
    "description": "Given a string \ns\n and a dictionary of strings \nwordDict\n, return \ntrue\n if \ns\n can be segmented into a space-separated sequence of one or more dictionary words.\n\n\nNote\n that the same word in the dictionary may be reused multiple times in the segmentation.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"leetcode\", wordDict = [\"leet\",\"code\"]\n\nOutput:\n true\n\nExplanation:\n Return true because \"leetcode\" can be segmented as \"leet code\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\n\nOutput:\n true\n\nExplanation:\n Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\nNote that you are allowed to reuse a dictionary word.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 300\n\n\n1 <= wordDict.length <= 1000\n\n\n1 <= wordDict[i].length <= 20\n\n\ns\n and \nwordDict[i]\n consist of only lowercase English letters.\n\n\nAll the strings of \nwordDict\n are \nunique\n.",
    "solution": "\nclass Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: Set[str]\n        :rtype: bool\n        \"\"\"\n        n = len(s)\n\n        max_len = 0\n        for string in wordDict:\n            max_len = max(max_len, len(string))\n\n        can_break = [False for _ in xrange(n + 1)]\n        can_break[0] = True\n        for i in xrange(1, n + 1):\n            for l in xrange(1, min(i, max_len) + 1):\n                if can_break[i-l] and s[i-l:i] in wordDict:\n                    can_break[i] = True\n                    break\n\n        return can_break[-1]",
    "explanation": "N/A",
    "time_complexity": "O(n * l^2)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Number of Islands",
    "difficulty": "MEDIUM",
    "category": "Array, Depth-First Search, Breadth-First Search, Union Find, Matrix",
    "link": "https://leetcode.com/problems/number-of-islands",
    "slug": "number-of-islands",
    "description": "Given an \nm x n\n 2D binary grid \ngrid\n which represents a map of \n'1'\ns (land) and \n'0'\ns (water), return \nthe number of islands\n.\n\n\nAn \nisland\n is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 300\n\n\ngrid[i][j]\n is \n'0'\n or \n'1'\n.",
    "solution": "\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n       if self.set[x] != x:\n           self.set[x] = self.find_set(self.set[x])  # path compression.\n       return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root != y_root:\n            self.set[min(x_root, y_root)] = max(x_root, y_root)\n            self.count -= 1\n\n\nclass Solution(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        def index(n, i, j):\n            return i*n + j\n    \n        if not grid:\n            return 0\n\n        zero_count = 0\n        union_find = UnionFind(len(grid)*len(grid[0]))\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j] == '1':\n                    if i and grid[i-1][j] == '1':\n                        union_find.union_set(index(len(grid[0]), i-1, j),\n                                             index(len(grid[0]),i, j))\n                    if j and grid[i][j-1] == '1':\n                        union_find.union_set(index(len(grid[0]), i, j-1),\n                                             index(len(grid[0]), i, j))\n                else:\n                    zero_count += 1        \n        return union_find.count-zero_count\n\n\n# dfs solution\nclass Solution2(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def dfs(grid, i, j):\n            if grid[i][j] == '0':\n                return False\n            grid[i][j] = '0'\n            stk = [(i, j)]\n            while stk:\n                r, c = stk.pop()\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(grid) and\n                            0 <= nc < len(grid[0]) and\n                            grid[nr][nc] == '1'):\n                        continue\n                    grid[nr][nc] = '0'\n                    stk.append((nr, nc))\n            return True\n\n        count = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if dfs(grid, i, j):\n                    count += 1\n        return count\n\n \nimport collections\n\n\n# bfs solution\nclass Solution3(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def bfs(grid, i, j):\n            if grid[i][j] == '0':\n                return False\n            grid[i][j] ='0'\n            q = collections.deque([(i, j)])\n            while q:\n                r, c = q.popleft()\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(grid) and\n                            0 <= nc < len(grid[0]) and\n                            grid[nr][nc] == '1'):\n                        continue\n                    grid[nr][nc] = '0'\n                    q.append((nr, nc))\n            return True\n\n        count = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if bfs(grid, i, j):\n                    count += 1\n        return count",
    "explanation": "N/A",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m * n)"
  },
  {
    "title": "First Missing Positive",
    "difficulty": "HARD",
    "category": "Array, Hash Table",
    "link": "https://leetcode.com/problems/first-missing-positive",
    "slug": "first-missing-positive",
    "description": "Given an unsorted integer array \nnums\n. Return the \nsmallest positive integer\n that is \nnot present\n in \nnums\n.\n\n\nYou must implement an algorithm that runs in \nO(n)\n time and uses \nO(1)\n auxiliary space.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,0]\n\nOutput:\n 3\n\nExplanation:\n The numbers in the range [1,2] are all in the array.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,4,-1,1]\n\nOutput:\n 2\n\nExplanation:\n 1 is in the array but 2 is missing.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [7,8,9,11,12]\n\nOutput:\n 1\n\nExplanation:\n The smallest positive integer 1 is missing.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1",
    "solution": "\nclass Solution(object):\n    # @param A, a list of integers\n    # @return an integer\n    def firstMissingPositive(self, A):\n        i = 0\n        while i < len(A):\n            if A[i] > 0 and A[i] - 1 < len(A) and A[i] != A[A[i]-1]:\n                A[A[i]-1], A[i] = A[i], A[A[i]-1]\n            else:\n                i += 1\n\n        for i, integer in enumerate(A):\n            if integer != i + 1:\n                return i + 1\n        return len(A) + 1",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Best Time to Buy and Sell Stock II",
    "difficulty": "MEDIUM",
    "category": "Array, Dynamic Programming, Greedy",
    "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii",
    "slug": "best-time-to-buy-and-sell-stock-ii",
    "description": "You are given an integer array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold \nat most one\n share of the stock at any time. However, you can buy it then immediately sell it on the \nsame day\n.\n\n\nFind and return \nthe \nmaximum\n profit you can achieve\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 7\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [1,2,3,4,5]\n\nOutput:\n 4\n\nExplanation:\n Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n\n\n\nExample 3:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 3 * 10\n4\n\n\n0 <= prices[i] <= 10\n4",
    "solution": "\n\nclass Solution(object):\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, prices):\n        profit = 0\n        for i in xrange(len(prices) - 1):\n            profit += max(0, prices[i + 1] - prices[i])\n        return profit\n\n    def maxProfit2(self, prices):\n        return sum(map(lambda x: max(prices[x + 1] - prices[x], 0),\n                       xrange(len(prices[:-1]))))",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "String to Integer (atoi)",
    "difficulty": "MEDIUM",
    "category": "String",
    "link": "https://leetcode.com/problems/string-to-integer-atoi",
    "slug": "string-to-integer-atoi",
    "description": "Implement the \nmyAtoi(string s)\n function, which converts a string to a 32-bit signed integer.\n\n\nThe algorithm for \nmyAtoi(string s)\n is as follows:\n\n\n\n\nWhitespace\n: Ignore any leading whitespace (\n\" \"\n).\n\n\nSignedness\n: Determine the sign by checking if the next character is \n'-'\n or \n'+'\n, assuming positivity if neither present.\n\n\nConversion\n: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.\n\n\nRounding\n: If the integer is out of the 32-bit signed integer range \n[-2\n31\n, 2\n31\n - 1]\n, then round the integer to remain in the range. Specifically, integers less than \n-2\n31\n should be rounded to \n-2\n31\n, and integers greater than \n2\n31\n - 1\n should be rounded to \n2\n31\n - 1\n.\n\n\n\n\nReturn the integer as the final result.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"42\"\n\n\nOutput:\n \n42\n\n\nExplanation:\n\n\n\nThe underlined characters are what is read in and the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n42\n\" (\"42\" is read in)\n           ^\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \" -042\"\n\n\nOutput:\n \n-42\n\n\nExplanation:\n\n\n\nStep 1: \"\n   \n-042\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   \n-\n042\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -\n042\n\" (\"042\" is read in, leading zeros ignored in the result)\n               ^\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"1337c0d3\"\n\n\nOutput:\n \n1337\n\n\nExplanation:\n\n\n\nStep 1: \"1337c0d3\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"1337c0d3\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n1337\nc0d3\" (\"1337\" is read in; reading stops because the next character is a non-digit)\n             ^\n\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"0-1\"\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\nStep 1: \"0-1\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"0-1\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n0\n-1\" (\"0\" is read in; reading stops because the next character is a non-digit)\n          ^\n\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"words and 987\"\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nReading stops at the first non-digit character 'w'.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 200\n\n\ns\n consists of English letters (lower-case and upper-case), digits (\n0-9\n), \n' '\n, \n'+'\n, \n'-'\n, and \n'.'\n.",
    "solution": "\nclass Solution(object):\n    def myAtoi(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: int\n        \"\"\"\n        INT_MAX =  2147483647\n        INT_MIN = -2147483648\n        result = 0\n\n        if not str:\n            return result\n\n        i = 0\n        while i < len(str) and str[i].isspace():\n            i += 1\n\n        if len(str) == i:\n            return result\n\n        sign = 1\n        if str[i] == \"+\":\n            i += 1\n        elif str[i] == \"-\":\n            sign = -1\n            i += 1\n\n        while i < len(str) and '0' <= str[i] <= '9':\n            if result > (INT_MAX - int(str[i])) / 10:\n                return INT_MAX if sign > 0 else INT_MIN\n            result = result * 10 + int(str[i])\n            i += 1\n\n        return sign * result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Minimum Window Substring",
    "difficulty": "HARD",
    "category": "Hash Table, String, Sliding Window",
    "link": "https://leetcode.com/problems/minimum-window-substring",
    "slug": "minimum-window-substring",
    "description": "Given two strings \ns\n and \nt\n of lengths \nm\n and \nn\n respectively, return \nthe \nminimum window\n \nsubstring\n of \ns\n such that every character in \nt\n (\nincluding duplicates\n) is included in the window\n. If there is no such substring, return \nthe empty string \n\"\"\n.\n\n\nThe testcases will be generated such that the answer is \nunique\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"ADOBECODEBANC\", t = \"ABC\"\n\nOutput:\n \"BANC\"\n\nExplanation:\n The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"a\", t = \"a\"\n\nOutput:\n \"a\"\n\nExplanation:\n The entire string s is the minimum window.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"a\", t = \"aa\"\n\nOutput:\n \"\"\n\nExplanation:\n Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == s.length\n\n\nn == t.length\n\n\n1 <= m, n <= 10\n5\n\n\ns\n and \nt\n consist of uppercase and lowercase English letters.\n\n\n\n\n \n\n\nFollow up:\n Could you find an algorithm that runs in \nO(m + n)\n time?",
    "solution": "\nimport collections\n\n\nclass Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        count, remain = collections.Counter(t), len(t)\n        i, left, right = 0, -1, -1\n        for j, c in enumerate(s):\n            remain -= count[c] > 0\n            count[c] -= 1\n            if remain:\n                continue\n            while count[s[i]] < 0:  # greedily discard uneeds\n                count[s[i]] += 1\n                i += 1\n            if right == -1 or j-i+1 < right-left+1:\n                left, right = i, j\n        return s[left:right+1]\n\n\nclass Solution2(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        current_count = [0 for i in xrange(52)]\n        expected_count = [0 for i in xrange(52)]\n\n        for char in t:\n            expected_count[ord(char) - ord('a')] += 1\n\n        i, count, start, min_width, min_start = 0, 0, 0, float(\"inf\"), 0\n        while i < len(s):\n            current_count[ord(s[i]) - ord('a')] += 1\n            if current_count[ord(s[i]) - ord('a')] <= expected_count[ord(s[i]) - ord('a')]:\n                count += 1\n\n            if count == len(t):\n                while expected_count[ord(s[start]) - ord('a')] == 0 or \\\n                      current_count[ord(s[start]) - ord('a')] > expected_count[ord(s[start]) - ord('a')]:\n                    current_count[ord(s[start]) - ord('a')] -= 1\n                    start += 1\n\n                if min_width > i - start + 1:\n                    min_width = i - start + 1\n                    min_start = start\n            i += 1\n\n        if min_width == float(\"inf\"):\n            return \"\"\n\n        return s[min_start:min_start + min_width]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(k), k is the number of different characters"
  },
  {
    "title": "Group Anagrams",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, String, Sorting",
    "link": "https://leetcode.com/problems/group-anagrams",
    "slug": "group-anagrams",
    "description": "Given an array of strings \nstrs\n, group the \nanagrams\n together. You can return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nstrs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n\n\nOutput:\n \n[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\n\nExplanation:\n\n\n\n\nThere is no string in strs that can be rearranged to form \n\"bat\"\n.\n\n\nThe strings \n\"nat\"\n and \n\"tan\"\n are anagrams as they can be rearranged to form each other.\n\n\nThe strings \n\"ate\"\n, \n\"eat\"\n, and \n\"tea\"\n are anagrams as they can be rearranged to form each other.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nstrs = [\"\"]\n\n\nOutput:\n \n[[\"\"]]\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nstrs = [\"a\"]\n\n\nOutput:\n \n[[\"a\"]]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 10\n4\n\n\n0 <= strs[i].length <= 100\n\n\nstrs[i]\n consists of lowercase English letters.",
    "solution": "\nimport collections\n\n\nclass Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagrams_map, result = collections.defaultdict(list), []\n        for s in strs:\n            sorted_str = (\"\").join(sorted(s))\n            anagrams_map[sorted_str].append(s)\n        for anagram in anagrams_map.values():\n            anagram.sort()\n            result.append(anagram)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n * glogg), g is the max size of groups.",
    "space_complexity": "O(n)"
  },
  {
    "title": "Range Module",
    "difficulty": "HARD",
    "category": "Design, Segment Tree, Ordered Set",
    "link": "https://leetcode.com/problems/range-module",
    "slug": "range-module",
    "description": "A Range Module is a module that tracks ranges of numbers. Design a data structure to track the ranges represented as \nhalf-open intervals\n and query about them.\n\n\nA \nhalf-open interval\n \n[left, right)\n denotes all the real numbers \nx\n where \nleft <= x < right\n.\n\n\nImplement the \nRangeModule\n class:\n\n\n\n\nRangeModule()\n Initializes the object of the data structure.\n\n\nvoid addRange(int left, int right)\n Adds the \nhalf-open interval\n \n[left, right)\n, tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval \n[left, right)\n that are not already tracked.\n\n\nboolean queryRange(int left, int right)\n Returns \ntrue\n if every real number in the interval \n[left, right)\n is currently being tracked, and \nfalse\n otherwise.\n\n\nvoid removeRange(int left, int right)\n Stops tracking every real number currently being tracked in the \nhalf-open interval\n \n[left, right)\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"RangeModule\", \"addRange\", \"removeRange\", \"queryRange\", \"queryRange\", \"queryRange\"]\n[[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]\n\nOutput\n\n[null, null, null, true, false, true]\n\n\nExplanation\n\nRangeModule rangeModule = new RangeModule();\nrangeModule.addRange(10, 20);\nrangeModule.removeRange(14, 16);\nrangeModule.queryRange(10, 14); // return True,(Every number in [10, 14) is being tracked)\nrangeModule.queryRange(13, 15); // return False,(Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)\nrangeModule.queryRange(16, 17); // return True, (The number 16 in [16, 17) is still being tracked, despite the remove operation)\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= left < right <= 10\n9\n\n\nAt most \n10\n4\n calls will be made to \naddRange\n, \nqueryRange\n, and \nremoveRange\n.",
    "solution": "#        removeRange: O(n)\n#        queryRange:  O(logn)\n\nimport bisect\n\n\nclass RangeModule(object):\n\n    def __init__(self):\n        self.__intervals = []\n\n    def addRange(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: void\n        \"\"\"\n        tmp = []\n        i = 0\n        for interval in self.__intervals:\n            if right < interval[0]:\n                tmp.append((left, right))\n                break\n            elif interval[1] < left:\n                tmp.append(interval)\n            else:\n                left = min(left, interval[0])\n                right = max(right, interval[1])\n            i += 1\n        if i == len(self.__intervals):\n            tmp.append((left, right))\n        while i < len(self.__intervals):\n            tmp.append(self.__intervals[i])\n            i += 1\n        self.__intervals = tmp\n\n    def queryRange(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: bool\n        \"\"\"\n        i = bisect.bisect_left(self.__intervals, (left, float(\"inf\")))\n        if i: i -= 1\n        return bool(self.__intervals) and \\\n               self.__intervals[i][0] <= left and \\\n               right <= self.__intervals[i][1]\n\n    def removeRange(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: void\n        \"\"\"\n        tmp = []\n        for interval in self.__intervals:\n            if interval[1] <= left or interval[0] >= right:\n                tmp.append(interval)\n            else:\n                if interval[0] < left:\n                    tmp.append((interval[0], left))\n                if right < interval[1]:\n                    tmp.append((right, interval[1]))\n        self.__intervals = tmp",
    "explanation": "N/A",
    "time_complexity": "addRange:    O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Longest Increasing Subsequence",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search, Dynamic Programming",
    "link": "https://leetcode.com/problems/longest-increasing-subsequence",
    "slug": "longest-increasing-subsequence",
    "description": "Given an integer array \nnums\n, return \nthe length of the longest \nstrictly increasing \nsubsequence\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [10,9,2,5,3,7,101,18]\n\nOutput:\n 4\n\nExplanation:\n The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,1,0,3,2,3]\n\nOutput:\n 4\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [7,7,7,7,7,7,7]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2500\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n Can you come up with an algorithm that runs in \nO(n log(n))\n time complexity?",
    "solution": "\nimport bisect\n\n\nclass Solution(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        LIS = []\n        def insert(target):\n            left = bisect.bisect_left(LIS, target)\n            # If not found, append the target.\n            if left == len(LIS):\n                LIS.append(target)\n            else:\n                LIS[left] = target\n    \n        for num in nums:\n            insert(num)\n        return len(LIS)\n\n\nclass Solution2(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        LIS = []\n        def insert(target):\n            left, right = 0, len(LIS) - 1\n            # Find the first index \"left\" which satisfies LIS[left] >= target\n            while left <= right:\n                mid = left + (right - left) // 2\n                if LIS[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            # If not found, append the target.\n            if left == len(LIS):\n                LIS.append(target)\n            else:\n                LIS[left] = target\n\n        for num in nums:\n            insert(num)\n\n        return len(LIS)\n\n\n# bit, fenwick tree\nclass Solution3(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        class BIT(object):  # 0-indexed.\n            def __init__(self, n, default=0, fn=lambda x, y: x+y):\n                self.__bit = [default]*(n+1)  # Extra one for dummy node.\n                self.__default = default\n                self.__fn = fn\n\n            def update(self, i, val):\n                i += 1  # Extra one for dummy node.\n                while i < len(self.__bit):\n                    self.__bit[i] = self.__fn(self.__bit[i], val)\n                    i += (i & -i)\n\n            def query(self, i):\n                i += 1  # Extra one for dummy node.\n                ret = self.__default\n                while i > 0:\n                    ret = self.__fn(ret, self.__bit[i])\n                    i -= (i & -i)\n                return ret\n    \n        lookup = {x:i for i, x in enumerate(sorted(set(nums)))}\n        bit = BIT(len(lookup), fn=max)\n        for x in nums:\n            bit.update(lookup[x], bit.query(lookup[x]-1)+1)\n        return bit.query(len(lookup)-1)\n\n\n# Range Maximum Query\nclass SegmentTree(object):  # 0-based index\n    def __init__(self, N,\n                 build_fn=lambda x, y: [y]*(2*x),\n                 query_fn=lambda x, y: y if x is None else max(x, y),  # (lambda x, y: y if x is None else min(x, y))\n                 update_fn=lambda x, y: y,\n                 default_val=0):\n        self.N = N\n        self.H = (N-1).bit_length()\n        self.query_fn = query_fn\n        self.update_fn = update_fn\n        self.default_val = default_val\n        self.tree = build_fn(N, default_val)\n        self.lazy = [None]*N\n\n    def __apply(self, x, val):\n        self.tree[x] = self.update_fn(self.tree[x], val)\n        if x < self.N:\n            self.lazy[x] = self.update_fn(self.lazy[x], val)\n\n    def update(self, L, R, h):  # Time: O(logN), Space: O(N)\n        def pull(x):\n            while x > 1:\n                x //= 2\n                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n                if self.lazy[x] is not None:\n                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])\n\n        L += self.N\n        R += self.N\n        L0, R0 = L, R\n        while L <= R:\n            if L & 1:  # is right child\n                self.__apply(L, h) \n                L += 1\n            if R & 1 == 0:  # is left child\n                self.__apply(R, h)\n                R -= 1\n            L //= 2\n            R //= 2\n        pull(L0)\n        pull(R0)\n\n    def query(self, L, R):  # Time: O(logN), Space: O(N)\n        def push(x):\n            n = 2**self.H\n            while n != 1:\n                y = x // n\n                if self.lazy[y] is not None:\n                    self.__apply(y*2, self.lazy[y])\n                    self.__apply(y*2 + 1, self.lazy[y])\n                    self.lazy[y] = None\n                n //= 2\n\n        result = None\n        if L > R:\n            return result\n\n        L += self.N\n        R += self.N\n        push(L)\n        push(R)\n        while L <= R:\n            if L & 1:  # is right child\n                result = self.query_fn(result, self.tree[L])\n                L += 1\n            if R & 1 == 0:  # is left child\n                result = self.query_fn(result, self.tree[R])\n                R -= 1\n            L //= 2\n            R //= 2\n        return result\n    \n    def __str__(self):\n        showList = []\n        for i in xrange(self.N):\n            showList.append(self.query(i, i))\n        return \",\".join(map(str, showList))\n\n\n# optimized from Solution5\nclass Solution4(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        val_to_idx = {num:i for i, num in enumerate(sorted(set(nums)))}\n        st = SegmentTree(len(val_to_idx))\n        for x in nums:\n            st.update(val_to_idx[x], val_to_idx[x], st.query(0, val_to_idx[x]-1)+1 if val_to_idx[x] >= 1 else 1)\n        return st.query(0, len(val_to_idx)-1) if len(val_to_idx) >= 1 else 0\n\n\n# Traditional DP solution.\nclass Solution5(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        dp = []  # dp[i]: the length of LIS ends with nums[i]\n        for i in xrange(len(nums)):\n            dp.append(1)\n            for j in xrange(i):\n                if nums[j] < nums[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp) if dp else 0",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)"
  },
  {
    "title": "N-Queens",
    "difficulty": "HARD",
    "category": "Array, Backtracking",
    "link": "https://leetcode.com/problems/n-queens",
    "slug": "n-queens",
    "description": "The \nn-queens\n puzzle is the problem of placing \nn\n queens on an \nn x n\n chessboard such that no two queens attack each other.\n\n\nGiven an integer \nn\n, return \nall distinct solutions to the \nn-queens puzzle\n. You may return the answer in \nany order\n.\n\n\nEach solution contains a distinct board configuration of the n-queens' placement, where \n'Q'\n and \n'.'\n both indicate a queen and an empty space, respectively.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 4\n\nOutput:\n [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n\nExplanation:\n There exist two distinct solutions to the 4-queens puzzle as shown above\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n [[\"Q\"]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 9",
    "solution": "\nclass Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        def dfs(row):\n            if row == n:\n                result.append(map(lambda x: '.'*x + \"Q\" + '.'*(n-x-1), curr))\n                return\n            for i in xrange(n):\n                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:\n                    continue\n                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True\n                curr.append(i)\n                dfs(row+1)\n                curr.pop()\n                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False\n\n        result, curr = [], []\n        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)\n        dfs(0)\n        return result\n\n\n# For any point (x,y), if we want the new point (p,q) don't share the same row, column, or diagonal.\n# then there must have ```p+q != x+y``` and ```p-q!= x-y```\n# the former focus on eliminate 'left bottom right top' diagonal\n# the latter focus on eliminate 'left top right bottom' diagonal\n\n# - col_per_row: the list of column index per row\n# - cur_row：current row we are seraching for valid column\n# - xy_diff：the list of x-y\n# - xy_sum：the list of x+y\nclass Solution2(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        def dfs(col_per_row, xy_diff, xy_sum):\n            cur_row = len(col_per_row)\n            if cur_row == n:\n                ress.append(col_per_row)\n            for col in range(n):\n                if col not in col_per_row and cur_row-col not in xy_diff and cur_row+col not in xy_sum:\n                    dfs(col_per_row+[col], xy_diff+[cur_row-col], xy_sum+[cur_row+col])\n        ress = []\n        dfs([], [], [])\n        return [['.'*i + 'Q' + '.'*(n-i-1) for i in res] for res in ress]",
    "explanation": "N/A",
    "time_complexity": "O(n^2 * n!)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Add Two Integers",
    "difficulty": "EASY",
    "category": "Math",
    "link": "https://leetcode.com/problems/add-two-integers",
    "slug": "add-two-integers",
    "description": "Given two integers \nnum1\n and \nnum2\n, return \nthe \nsum\n of the two integers\n.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num1 = 12, num2 = 5\n\nOutput:\n 17\n\nExplanation:\n num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is returned.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num1 = -10, num2 = 4\n\nOutput:\n -6\n\nExplanation:\n num1 + num2 = -6, so -6 is returned.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-100 <= num1, num2 <= 100",
    "solution": "\n# math\nclass Solution(object):\n    def sum(self, num1, num2):\n        \"\"\"\n        :type num1: int\n        :type num2: int\n        :rtype: int\n        \"\"\"\n        return num1+num2",
    "explanation": "N/A",
    "time_complexity": "O(1)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Basic Calculator",
    "difficulty": "HARD",
    "category": "Math, String, Stack, Recursion",
    "link": "https://leetcode.com/problems/basic-calculator",
    "slug": "basic-calculator",
    "description": "Given a string \ns\n representing a valid expression, implement a basic calculator to evaluate it, and return \nthe result of the evaluation\n.\n\n\nNote:\n You are \nnot\n allowed to use any built-in function which evaluates strings as mathematical expressions, such as \neval()\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"1 + 1\"\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \" 2-1 + 2 \"\n\nOutput:\n 3\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"(1+(4+5+2)-3)+(6+8)\"\n\nOutput:\n 23\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 3 * 10\n5\n\n\ns\n consists of digits, \n'+'\n, \n'-'\n, \n'('\n, \n')'\n, and \n' '\n.\n\n\ns\n represents a valid expression.\n\n\n'+'\n is \nnot\n used as a unary operation (i.e., \n\"+1\"\n and \n\"+(2 + 3)\"\n is invalid).\n\n\n'-'\n could be used as a unary operation (i.e., \n\"-1\"\n and \n\"-(2 + 3)\"\n is valid).\n\n\nThere will be no two consecutive operators in the input.\n\n\nEvery number and running calculation will fit in a signed 32-bit integer.",
    "solution": "\nimport operator\n\n\nclass Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def compute(operands, operators):\n            right, left = operands.pop(), operands.pop()\n            operands.append(ops[operators.pop()](left, right))\n\n        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}\n        precedence = {'+':0, '-':0, '*':1, '/':1}\n        operands, operators, operand = [], [], 0\n        for i in xrange(len(s)):\n            if s[i].isdigit():\n                operand = operand*10 + int(s[i])\n                if i == len(s)-1 or not s[i+1].isdigit():\n                    operands.append(operand)\n                    operand = 0\n            elif s[i] == '(':\n                operators.append(s[i])\n            elif s[i] == ')':\n                while operators[-1] != '(':\n                    compute(operands, operators)\n                operators.pop()\n            elif s[i] in precedence:\n                while operators and operators[-1] in precedence and \\\n                      precedence[operators[-1]] >= precedence[s[i]]:\n                    compute(operands, operators)\n                operators.append(s[i])\n        while operators:\n            compute(operands, operators)\n        return operands[-1]\n\n\nclass Solution2(object):\n    # @param {string} s\n    # @return {integer}\n    def calculate(self, s):\n        operands, operators = [], []\n        operand = \"\"\n        for i in reversed(xrange(len(s))):\n            if s[i].isdigit():\n                operand += s[i]\n                if i == 0 or not s[i-1].isdigit():\n                    operands.append(int(operand[::-1]))\n                    operand = \"\"\n            elif s[i] == ')' or s[i] == '+' or s[i] == '-':\n                operators.append(s[i])\n            elif s[i] == '(':\n                while operators[-1] != ')':\n                    self.compute(operands, operators)\n                operators.pop()\n\n        while operators:\n            self.compute(operands, operators)\n\n        return operands[-1]\n\n    def compute(self, operands, operators):\n        left, right = operands.pop(), operands.pop()\n        op = operators.pop()\n        if op == '+':\n            operands.append(left + right)\n        elif op == '-':\n            operands.append(left - right)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "LRU Cache",
    "difficulty": "MEDIUM",
    "category": "Hash Table, Linked List, Design, Doubly-Linked List",
    "link": "https://leetcode.com/problems/lru-cache",
    "slug": "lru-cache",
    "description": "Design a data structure that follows the constraints of a \nLeast Recently Used (LRU) cache\n.\n\n\nImplement the \nLRUCache\n class:\n\n\n\n\nLRUCache(int capacity)\n Initialize the LRU cache with \npositive\n size \ncapacity\n.\n\n\nint get(int key)\n Return the value of the \nkey\n if the key exists, otherwise return \n-1\n.\n\n\nvoid put(int key, int value)\n Update the value of the \nkey\n if the \nkey\n exists. Otherwise, add the \nkey-value\n pair to the cache. If the number of keys exceeds the \ncapacity\n from this operation, \nevict\n the least recently used key.\n\n\n\n\nThe functions \nget\n and \nput\n must each run in \nO(1)\n average time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n\nOutput\n\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n\nExplanation\n\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= capacity <= 3000\n\n\n0 <= key <= 10\n4\n\n\n0 <= value <= 10\n5\n\n\nAt most \n2 * 10\n5\n calls will be made to \nget\n and \nput\n.",
    "solution": "\nimport collections\n\n\n# using OrderedDict\nclass LRUCache(object):\n    def __init__(self, capacity):\n        self.cache = collections.OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        val = self.cache[key]\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.cache and len(self.cache) == self.capacity:\n            self.cache.popitem(last=False)\n        self.__update(key, val)\n    \n    def __update(self, key, val):\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = val\n\n\n\n\nclass ListNode(object):\n    def __init__(self, key, val):\n        self.val = val\n        self.key = key\n        self.next = None\n        self.prev = None\n\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\n\nclass LRUCache2(object):\n\n    def __init__(self, capacity):\n        self.list = LinkedList()\n        self.dict = {}\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.dict:\n            return -1\n        val = self.dict[key].val\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.dict and len(self.dict) == self.capacity:\n            del self.dict[self.list.head.key]\n            self.list.delete(self.list.head)\n        self.__update(key, val)\n\n    def __update(self, key, val):\n        if key in self.dict:\n            self.list.delete(self.dict[key])\n        node = ListNode(key, val)\n        self.list.insert(node)\n        self.dict[key] = node",
    "explanation": "N/A",
    "time_complexity": "O(1), per operation.",
    "space_complexity": "O(k), k is the capacity of cache."
  },
  {
    "title": "Merge Strings Alternately",
    "difficulty": "EASY",
    "category": "Two Pointers, String",
    "link": "https://leetcode.com/problems/merge-strings-alternately",
    "slug": "merge-strings-alternately",
    "description": "You are given two strings \nword1\n and \nword2\n. Merge the strings by adding letters in alternating order, starting with \nword1\n. If a string is longer than the other, append the additional letters onto the end of the merged string.\n\n\nReturn \nthe merged string.\n\n\n \n\n\nExample 1:\n\n\n\r\n\nInput:\n word1 = \"abc\", word2 = \"pqr\"\r\n\nOutput:\n \"apbqcr\"\r\n\nExplanation:\n The merged string will be merged as so:\r\nword1:  a   b   c\r\nword2:    p   q   r\r\nmerged: a p b q c r\r\n\n\n\nExample 2:\n\n\n\r\n\nInput:\n word1 = \"ab\", word2 = \"pqrs\"\r\n\nOutput:\n \"apbqrs\"\r\n\nExplanation:\n Notice that as word2 is longer, \"rs\" is appended to the end.\r\nword1:  a   b \r\nword2:    p   q   r   s\r\nmerged: a p b q   r   s\r\n\n\n\nExample 3:\n\n\n\r\n\nInput:\n word1 = \"abcd\", word2 = \"pq\"\r\n\nOutput:\n \"apbqcd\"\r\n\nExplanation:\n Notice that as word1 is longer, \"cd\" is appended to the end.\r\nword1:  a   b   c   d\r\nword2:    p   q \r\nmerged: a p b q c   d\r\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= word1.length, word2.length <= 100\n\n\nword1\n and \nword2\n consist of lowercase English letters.",
    "solution": "\nclass Solution(object):\n    def mergeAlternately(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: str\n        \"\"\"\n        result = []\n        i = 0\n        while i < len(word1) or i < len(word2):\n            if i < len(word1):\n                result.append(word1[i])\n            if i < len(word2):\n                result.append(word2[i])\n            i += 1\n        return \"\".join(result)",
    "explanation": "N/A",
    "time_complexity": "O(m + n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Text Justification",
    "difficulty": "HARD",
    "category": "Array, String, Simulation",
    "link": "https://leetcode.com/problems/text-justification",
    "slug": "text-justification",
    "description": "Given an array of strings \nwords\n and a width \nmaxWidth\n, format the text such that each line has exactly \nmaxWidth\n characters and is fully (left and right) justified.\n\n\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces \n' '\n when necessary so that each line has exactly \nmaxWidth\n characters.\n\n\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n\n\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\n\n\nNote:\n\n\n\n\nA word is defined as a character sequence consisting of non-space characters only.\n\n\nEach word's length is guaranteed to be greater than \n0\n and not exceed \nmaxWidth\n.\n\n\nThe input array \nwords\n contains at least one word.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n\nOutput:\n\n[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n\nOutput:\n\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\n\nExplanation:\n Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n\nOutput:\n\n[\n  \"Science  is  what we\",\n  \"understand      well\",\n  \"enough to explain to\",\n  \"a  computer.  Art is\",\n  \"everything  else  we\",\n  \"do                  \"\n]\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 300\n\n\n1 <= words[i].length <= 20\n\n\nwords[i]\n consists of only English letters and symbols.\n\n\n1 <= maxWidth <= 100\n\n\nwords[i].length <= maxWidth",
    "solution": "\nclass Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        def addSpaces(i, spaceCnt, maxWidth, is_last):\n            if i < spaceCnt:\n                # For the last line of text, it should be left justified,\n                # and no extra space is inserted between words.\n                return 1 if is_last else (maxWidth // spaceCnt) + int(i < maxWidth % spaceCnt)\n            return 0\n\n        def connect(words, maxWidth, begin, end, length, is_last):\n            s = []  # The extra space O(k) is spent here.\n            n = end - begin\n            for i in xrange(n):\n                s += words[begin + i],\n                s += ' ' * addSpaces(i, n - 1, maxWidth - length, is_last),\n            # For only one word in a line.\n            line = \"\".join(s)\n            if len(line) < maxWidth:\n                line += ' ' * (maxWidth - len(line))\n            return line\n\n        res = []\n        begin, length = 0, 0\n        for i in xrange(len(words)):\n            if length + len(words[i]) + (i - begin) > maxWidth:\n                res += connect(words, maxWidth, begin, i, length, False),\n                begin, length = i, 0\n            length += len(words[i])\n\n        # Last line.\n        res += connect(words, maxWidth, begin, len(words), length, True),\n        return res",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(k), k is maxWidth."
  },
  {
    "title": "Maximal Rectangle",
    "difficulty": "HARD",
    "category": "Array, Dynamic Programming, Stack, Matrix, Monotonic Stack",
    "link": "https://leetcode.com/problems/maximal-rectangle",
    "slug": "maximal-rectangle",
    "description": "Given a \nrows x cols\n binary \nmatrix\n filled with \n0\n's and \n1\n's, find the largest rectangle containing only \n1\n's and return \nits area\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\n\nOutput:\n 6\n\nExplanation:\n The maximal rectangle is shown in the above picture.\n\n\n\nExample 2:\n\n\n\n\nInput:\n matrix = [[\"0\"]]\n\nOutput:\n 0\n\n\n\nExample 3:\n\n\n\n\nInput:\n matrix = [[\"1\"]]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nrows == matrix.length\n\n\ncols == matrix[i].length\n\n\n1 <= row, cols <= 200\n\n\nmatrix[i][j]\n is \n'0'\n or \n'1'\n.",
    "solution": "\nclass Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        def largestRectangleArea(heights):\n            stk, result, i = [-1], 0, 0\n            for i in xrange(len(heights)+1):\n                while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):\n                    result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))\n                stk.append(i) \n            return result\n\n        if not matrix:\n            return 0\n        result = 0\n        heights = [0]*len(matrix[0])\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[0])):\n                heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0\n            result = max(result, largestRectangleArea(heights))\n        return result\n\n\n# DP solution.\nclass Solution2(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        if not matrix:\n            return 0\n\n        result = 0\n        m = len(matrix)\n        n = len(matrix[0])\n        L = [0 for _ in xrange(n)]\n        H = [0 for _ in xrange(n)]\n        R = [n for _ in xrange(n)]\n\n        for i in xrange(m):\n            left = 0\n            for j in xrange(n):\n                if matrix[i][j] == '1':\n                    L[j] = max(L[j], left)\n                    H[j] += 1\n                else:\n                    L[j] = 0\n                    H[j] = 0\n                    R[j] = n\n                    left = j + 1\n\n            right = n\n            for j in reversed(xrange(n)):\n                if matrix[i][j] == '1':\n                    R[j] = min(R[j], right)\n                    result = max(result, H[j] * (R[j] - L[j]))\n                else:\n                    right = j\n\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Majority Element",
    "difficulty": "EASY",
    "category": "Array, Hash Table, Divide and Conquer, Sorting, Counting",
    "link": "https://leetcode.com/problems/majority-element",
    "slug": "majority-element",
    "description": "Given an array \nnums\n of size \nn\n, return \nthe majority element\n.\n\n\nThe majority element is the element that appears more than \n⌊n / 2⌋\n times. You may assume that the majority element always exists in the array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [3,2,3]\n\nOutput:\n 3\n\nExample 2:\n\n\nInput:\n nums = [2,2,1,1,1,2,2]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 5 * 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n\n\n \n\n\nFollow-up:\n Could you solve the problem in linear time and in \nO(1)\n space?",
    "solution": "\nimport collections\n\n\nclass Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def boyer_moore_majority_vote():\n            result, cnt = None, 0\n            for x in nums:\n                if not cnt:\n                    result = x\n                if x == result:\n                    cnt += 1\n                else:\n                    cnt -= 1\n            return result\n\n        return boyer_moore_majority_vote()\n\n\nimport collections\n\n\nclass Solution2(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return collections.Counter(nums).most_common(1)[0][0]\n\n\nimport collections\n\n\nclass Solution3(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sorted(collections.Counter(nums).items(), key=lambda a: a[1], reverse=True)[0][0]",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Subarray Sum Equals K",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Prefix Sum",
    "link": "https://leetcode.com/problems/subarray-sum-equals-k",
    "slug": "subarray-sum-equals-k",
    "description": "Given an array of integers \nnums\n and an integer \nk\n, return \nthe total number of subarrays whose sum equals to\n \nk\n.\n\n\nA subarray is a contiguous \nnon-empty\n sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,1,1], k = 2\n\nOutput:\n 2\n\nExample 2:\n\n\nInput:\n nums = [1,2,3], k = 3\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2 * 10\n4\n\n\n-1000 <= nums[i] <= 1000\n\n\n-10\n7\n <= k <= 10\n7",
    "solution": "\nimport collections\n\n\nclass Solution(object):\n    def subarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        accumulated_sum = 0\n        lookup = collections.defaultdict(int)\n        lookup[0] += 1\n        for num in nums:\n            accumulated_sum += num\n            result += lookup[accumulated_sum - k]\n            lookup[accumulated_sum] += 1\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Lowest Common Ancestor of a Binary Tree",
    "difficulty": "MEDIUM",
    "category": "Tree, Depth-First Search, Binary Tree",
    "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree",
    "slug": "lowest-common-ancestor-of-a-binary-tree",
    "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\n\nAccording to the \ndefinition of LCA on Wikipedia\n: “The lowest common ancestor is defined between two nodes \np\n and \nq\n as the lowest node in \nT\n that has both \np\n and \nq\n as descendants (where we allow \na node to be a descendant of itself\n).”\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n\nOutput:\n 3\n\nExplanation:\n The LCA of nodes 5 and 1 is 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n\nOutput:\n 5\n\nExplanation:\n The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [1,2], p = 1, q = 2\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 10\n5\n]\n.\n\n\n-10\n9\n <= Node.val <= 10\n9\n\n\nAll \nNode.val\n are \nunique\n.\n\n\np != q\n\n\np\n and \nq\n will exist in the tree.",
    "solution": "\nclass Solution(object):\n    # @param {TreeNode} root\n    # @param {TreeNode} p\n    # @param {TreeNode} q\n    # @return {TreeNode}\n    def lowestCommonAncestor(self, root, p, q):\n        if root in (None, p, q):\n            return root\n\n        left, right = [self.lowestCommonAncestor(child, p, q) \\\n                         for child in (root.left, root.right)]\n        # 1. If the current subtree contains both p and q,\n        #    return their LCA.\n        # 2. If only one of them is in that subtree,\n        #    return that one of them.\n        # 3. If neither of them is in that subtree,\n        #    return the node of that subtree.\n        return root if left and right else left or right",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(h)"
  },
  {
    "title": "Peak Index in a Mountain Array",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/peak-index-in-a-mountain-array",
    "slug": "peak-index-in-a-mountain-array",
    "description": "You are given an integer \nmountain\n array \narr\n of length \nn\n where the values increase to a \npeak element\n and then decrease.\n\n\nReturn the index of the peak element.\n\n\nYour task is to solve it in \nO(log(n))\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \narr = [0,1,0]\n\n\nOutput:\n \n1\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \narr = [0,2,1,0]\n\n\nOutput:\n \n1\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \narr = [0,10,5,2]\n\n\nOutput:\n \n1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= arr.length <= 10\n5\n\n\n0 <= arr[i] <= 10\n6\n\n\narr\n is \nguaranteed\n to be a mountain array.",
    "solution": "\nclass Solution(object):\n    def peakIndexInMountainArray(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(arr)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if arr[mid] > arr[mid+1]:\n                right = mid-1\n            else:\n                left = mid+1\n        return left",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Search in Rotated Sorted Array",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/search-in-rotated-sorted-array",
    "slug": "search-in-rotated-sorted-array",
    "description": "There is an integer array \nnums\n sorted in ascending order (with \ndistinct\n values).\n\n\nPrior to being passed to your function, \nnums\n is \npossibly rotated\n at an unknown pivot index \nk\n (\n1 <= k < nums.length\n) such that the resulting array is \n[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]\n (\n0-indexed\n). For example, \n[0,1,2,4,5,6,7]\n might be rotated at pivot index \n3\n and become \n[4,5,6,7,0,1,2]\n.\n\n\nGiven the array \nnums\n \nafter\n the possible rotation and an integer \ntarget\n, return \nthe index of \ntarget\n if it is in \nnums\n, or \n-1\n if it is not in \nnums\n.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [4,5,6,7,0,1,2], target = 0\n\nOutput:\n 4\n\nExample 2:\n\n\nInput:\n nums = [4,5,6,7,0,1,2], target = 3\n\nOutput:\n -1\n\nExample 3:\n\n\nInput:\n nums = [1], target = 0\n\nOutput:\n -1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 5000\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nAll values of \nnums\n are \nunique\n.\n\n\nnums\n is an ascending array that is possibly rotated.\n\n\n-10\n4\n <= target <= 10\n4",
    "solution": "\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) / 2\n\n            if nums[mid] == target:\n                return mid\n            elif (nums[mid] >= nums[left] and nums[left] <= target < nums[mid]) or \\\n                 (nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])):\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return -1",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Pow(x, n)",
    "difficulty": "MEDIUM",
    "category": "Math, Recursion",
    "link": "https://leetcode.com/problems/powx-n",
    "slug": "powx-n",
    "description": "Implement \npow(x, n)\n, which calculates \nx\n raised to the power \nn\n (i.e., \nx\nn\n).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 2.00000, n = 10\n\nOutput:\n 1024.00000\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = 2.10000, n = 3\n\nOutput:\n 9.26100\n\n\n\nExample 3:\n\n\n\n\nInput:\n x = 2.00000, n = -2\n\nOutput:\n 0.25000\n\nExplanation:\n 2\n-2\n = 1/2\n2\n = 1/4 = 0.25\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-100.0 < x < 100.0\n\n\n-2\n31\n <= n <= 2\n31\n-1\n\n\nn\n is an integer.\n\n\nEither \nx\n is not zero or \nn > 0\n.\n\n\n-10\n4\n <= x\nn\n <= 10\n4",
    "solution": "\nclass Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        result = 1\n        abs_n = abs(n)\n        while abs_n:\n            if abs_n & 1:\n                result *= x\n            abs_n >>= 1\n            x *= x\n\n        return 1 / result if n < 0 else result\n\n\n# Recursive solution.\nclass Solution2(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        if n < 0 and n != -n:\n            return 1.0 / self.myPow(x, -n)\n        if n == 0:\n            return 1\n        v = self.myPow(x, n / 2)\n        if n % 2 == 0:\n            return v * v\n        else:\n            return v * v * x",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(logn)"
  },
  {
    "title": "Binary Tree Maximum Path Sum",
    "difficulty": "HARD",
    "category": "Dynamic Programming, Tree, Depth-First Search, Binary Tree",
    "link": "https://leetcode.com/problems/binary-tree-maximum-path-sum",
    "slug": "binary-tree-maximum-path-sum",
    "description": "A \npath\n in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence \nat most once\n. Note that the path does not need to pass through the root.\n\n\nThe \npath sum\n of a path is the sum of the node's values in the path.\n\n\nGiven the \nroot\n of a binary tree, return \nthe maximum \npath sum\n of any \nnon-empty\n path\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3]\n\nOutput:\n 6\n\nExplanation:\n The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [-10,9,20,null,null,15,7]\n\nOutput:\n 42\n\nExplanation:\n The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 3 * 10\n4\n]\n.\n\n\n-1000 <= Node.val <= 1000",
    "solution": "\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return an integer\n    def maxPathSum(self, root):\n        def iter_dfs(node):\n            result = float(\"-inf\")\n            max_sum = [0]\n            stk = [(1, [node, max_sum])]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, ret = params\n                    if not node:\n                        continue\n                    ret1, ret2 = [0], [0]\n                    stk.append((2, [node, ret1, ret2, ret]))\n                    stk.append((1, [node.right, ret2]))\n                    stk.append((1, [node.left, ret1]))\n                elif step == 2:\n                    node, ret1, ret2, ret = params\n                    result = max(result, node.val+max(ret1[0], 0)+max(ret2[0], 0))\n                    ret[0] = node.val+max(ret1[0], ret2[0], 0)\n            return result\n        \n        return iter_dfs(root)\n\n\nclass Solution2(object):\n    # @param root, a tree node\n    # @return an integer\n    def maxPathSum(self, root):\n        def dfs(node):\n            if not node:\n                return (float(\"-inf\"), 0)\n            max_left, curr_left = dfs(node.left)\n            max_right, curr_right = dfs(node.right)\n            return (max(max_left, max_right, node.val+max(curr_left, 0)+max(curr_right, 0)),\n                    node.val+max(curr_left, curr_right, 0))\n        \n        return dfs(root)[0]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(h), h is height of binary tree"
  },
  {
    "title": "Apply Substitutions",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, String, Depth-First Search, Breadth-First Search, Graph, Topological Sort",
    "link": "https://leetcode.com/problems/apply-substitutions",
    "slug": "apply-substitutions",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nimport collections\n\n\n# topological sort\nclass Solution(object):\n    def applySubstitutions(self, replacements, text):\n        \"\"\"\n        :type replacements: List[List[str]]\n        :type text: str\n        :rtype: str\n        \"\"\"\n        def find_adj(s):\n            result = set()\n            i = 0\n            while i < len(s):\n                if s[i] != '%':\n                    i += 1\n                    continue\n                j = next(j for j in xrange(i+1, len(s)) if s[j] == '%')\n                result.add(s[i+1:j])\n                i = j+1\n            return result\n        \n        def replace(s):\n            result = []\n            i = 0\n            while i < len(s):\n                if s[i] != '%':\n                    result.append(s[i])\n                    i += 1\n                    continue\n                j = next(j for j in xrange(i+1, len(s)) if s[j] == '%')\n                result.append(lookup[s[i+1:j]])\n                i = j+1\n            return \"\".join(result)\n        \n        def topological_sort():\n            adj = collections.defaultdict(set)\n            in_degree = collections.defaultdict(int)\n            for u, s in replacements:\n                for v in find_adj(s):\n                    adj[v].add(u)\n                    in_degree[u] += 1\n            result = []\n            q = [u for u, _ in replacements if not in_degree[u]]\n            while q:\n                new_q = []\n                for u in q:\n                    lookup[u] = replace(lookup[u])\n                    for v in adj[u]:\n                        in_degree[v] -= 1\n                        if in_degree[v]:\n                            continue\n                        new_q.append(v)\n                q = new_q\n            return result\n\n        lookup = {k:v for k, v in replacements}\n        topological_sort()\n        return replace(text)\n\n\n# memoization\nclass Solution2(object):\n    def applySubstitutions(self, replacements, text):\n        \"\"\"\n        :type replacements: List[List[str]]\n        :type text: str\n        :rtype: str\n        \"\"\"\n        lookup = {k:v for k, v in replacements}\n        memo = {}\n        def replace(s):\n            if s not in memo:\n                result = []\n                i = 0\n                while i < len(s):\n                    if s[i] != '%':\n                        result.append(s[i])\n                        i += 1\n                        continue\n                    j = next(j for j in xrange(i+1, len(s)) if s[j] == '%')\n                    result.append(replace(lookup[s[i+1:j]]))\n                    i = j+1\n                memo[s] = \"\".join(result)\n            return memo[s]\n\n        return replace(text)",
    "explanation": "N/A",
    "time_complexity": "O(r * 2^r)",
    "space_complexity": "O(r * 2^r)"
  },
  {
    "title": "Letter Combinations of a Phone Number",
    "difficulty": "MEDIUM",
    "category": "Hash Table, String, Backtracking",
    "link": "https://leetcode.com/problems/letter-combinations-of-a-phone-number",
    "slug": "letter-combinations-of-a-phone-number",
    "description": "Given a string containing digits from \n2-9\n inclusive, return all possible letter combinations that the number could represent. Return the answer in \nany order\n.\n\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n digits = \"23\"\n\nOutput:\n [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n\n\n\nExample 2:\n\n\n\n\nInput:\n digits = \"\"\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n digits = \"2\"\n\nOutput:\n [\"a\",\"b\",\"c\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= digits.length <= 4\n\n\ndigits[i]\n is a digit in the range \n['2', '9']\n.",
    "solution": "\n# iterative solution\nclass Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        if not digits:\n            return []\n\n        lookup = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n        total = 1\n        for digit in digits:\n            total *= len(lookup[int(digit)])\n        result = []\n        for i in xrange(total):\n            base, curr = total, []\n            for digit in digits:\n                choices = lookup[int(digit)]\n                base //= len(choices)\n                curr.append(choices[(i//base)%len(choices)])\n            result.append(\"\".join(curr))\n        return result\n\n\n# iterative solution\nclass Solution2(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        if not digits:\n            return []\n\n        result = [\"\"]\n        lookup = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n        for digit in reversed(digits):\n            choices = lookup[int(digit)]\n            m, n = len(choices), len(result)\n            result.extend([result[i % n] for i in xrange(n, m*n)])\n            for i in xrange(m*n):\n                result[i] = choices[i//n] + result[i]\n        return result\n\n\n# recursive solution\nclass Solution3(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        lookup = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n\n        def letterCombinationsRecu(result, digits, curr, n):\n            if n == len(digits):\n                result.append(\"\".join(curr))\n                return\n            for choice in lookup[int(digits[n])]:\n                curr.append(choice)\n                letterCombinationsRecu(result, digits, curr, n+1)\n                curr.pop()\n\n        if not digits:\n            return []\n        result = []\n        letterCombinationsRecu(result, digits, [], 0)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n * 4^n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Largest Rectangle in Histogram",
    "difficulty": "HARD",
    "category": "Array, Stack, Monotonic Stack",
    "link": "https://leetcode.com/problems/largest-rectangle-in-histogram",
    "slug": "largest-rectangle-in-histogram",
    "description": "Given an array of integers \nheights\n representing the histogram's bar height where the width of each bar is \n1\n, return \nthe area of the largest rectangle in the histogram\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n heights = [2,1,5,6,2,3]\n\nOutput:\n 10\n\nExplanation:\n The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n heights = [2,4]\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= heights.length <= 10\n5\n\n\n0 <= heights[i] <= 10\n4",
    "solution": "\nclass Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stk, result = [-1], 0\n        for i in xrange(len(heights)+1):\n            while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):\n                result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))\n            stk.append(i) \n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Merge Two Sorted Lists",
    "difficulty": "EASY",
    "category": "Linked List, Recursion",
    "link": "https://leetcode.com/problems/merge-two-sorted-lists",
    "slug": "merge-two-sorted-lists",
    "description": "You are given the heads of two sorted linked lists \nlist1\n and \nlist2\n.\n\n\nMerge the two lists into one \nsorted\n list. The list should be made by splicing together the nodes of the first two lists.\n\n\nReturn \nthe head of the merged linked list\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n list1 = [1,2,4], list2 = [1,3,4]\n\nOutput:\n [1,1,2,3,4,4]\n\n\n\nExample 2:\n\n\n\n\nInput:\n list1 = [], list2 = []\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n list1 = [], list2 = [0]\n\nOutput:\n [0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in both lists is in the range \n[0, 50]\n.\n\n\n-100 <= Node.val <= 100\n\n\nBoth \nlist1\n and \nlist2\n are sorted in \nnon-decreasing\n order.",
    "solution": "\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, self.next)\n\n\nclass Solution(object):\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        curr = dummy = ListNode(0)\n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        curr.next = l1 or l2\n        return dummy.next",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Happy Number",
    "difficulty": "EASY",
    "category": "Hash Table, Math, Two Pointers",
    "link": "https://leetcode.com/problems/happy-number",
    "slug": "happy-number",
    "description": "Write an algorithm to determine if a number \nn\n is happy.\n\n\nA \nhappy number\n is a number defined by the following process:\n\n\n\n\nStarting with any positive integer, replace the number by the sum of the squares of its digits.\n\n\nRepeat the process until the number equals 1 (where it will stay), or it \nloops endlessly in a cycle\n which does not include 1.\n\n\nThose numbers for which this process \nends in 1\n are happy.\n\n\n\n\nReturn \ntrue\n \nif\n \nn\n \nis a happy number, and\n \nfalse\n \nif not\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 19\n\nOutput:\n true\n\nExplanation:\n\n1\n2\n + 9\n2\n = 82\n8\n2\n + 2\n2\n = 68\n6\n2\n + 8\n2\n = 100\n1\n2\n + 0\n2\n + 0\n2\n = 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 2\n31\n - 1",
    "solution": "\nclass Solution(object):\n    # @param {integer} n\n    # @return {boolean}\n    def isHappy(self, n):\n        lookup = {}\n        while n != 1 and n not in lookup:\n            lookup[n] = True\n            n = self.nextNumber(n)\n        return n == 1\n\n    def nextNumber(self, n):\n        new = 0\n        for char in str(n):\n            new += int(char)**2\n        return new",
    "explanation": "N/A",
    "time_complexity": "O(k), where k is the steps to be happy number",
    "space_complexity": "O(k)"
  },
  {
    "title": "Find Minimum in Rotated Sorted Array",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array",
    "slug": "find-minimum-in-rotated-sorted-array",
    "description": "Suppose an array of length \nn\n sorted in ascending order is \nrotated\n between \n1\n and \nn\n times. For example, the array \nnums = [0,1,2,4,5,6,7]\n might become:\n\n\n\n\n[4,5,6,7,0,1,2]\n if it was rotated \n4\n times.\n\n\n[0,1,2,4,5,6,7]\n if it was rotated \n7\n times.\n\n\n\n\nNotice that \nrotating\n an array \n[a[0], a[1], a[2], ..., a[n-1]]\n 1 time results in the array \n[a[n-1], a[0], a[1], a[2], ..., a[n-2]]\n.\n\n\nGiven the sorted rotated array \nnums\n of \nunique\n elements, return \nthe minimum element of this array\n.\n\n\nYou must write an algorithm that runs in \nO(log n) time\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,4,5,1,2]\n\nOutput:\n 1\n\nExplanation:\n The original array was [1,2,3,4,5] rotated 3 times.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [4,5,6,7,0,1,2]\n\nOutput:\n 0\n\nExplanation:\n The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [11,13,15,17]\n\nOutput:\n 11\n\nExplanation:\n The original array was [11,13,15,17] and it was rotated 4 times. \n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 5000\n\n\n-5000 <= nums[i] <= 5000\n\n\nAll the integers of \nnums\n are \nunique\n.\n\n\nnums\n is sorted and rotated between \n1\n and \nn\n times.",
    "solution": "\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums)\n        target = nums[-1]\n\n        while left < right:\n            mid = left + (right - left) / 2\n\n            if nums[mid] <= target:\n                right = mid\n            else:\n                left = mid + 1\n\n        return nums[left]\n\n\nclass Solution2(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] >= nums[right]:\n            mid = left + (right - left) / 2\n\n            if nums[mid] < nums[left]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return nums[left]",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Merge Sorted Array",
    "difficulty": "EASY",
    "category": "Array, Two Pointers, Sorting",
    "link": "https://leetcode.com/problems/merge-sorted-array",
    "slug": "merge-sorted-array",
    "description": "You are given two integer arrays \nnums1\n and \nnums2\n, sorted in \nnon-decreasing order\n, and two integers \nm\n and \nn\n, representing the number of elements in \nnums1\n and \nnums2\n respectively.\n\n\nMerge\n \nnums1\n and \nnums2\n into a single array sorted in \nnon-decreasing order\n.\n\n\nThe final sorted array should not be returned by the function, but instead be \nstored inside the array \nnums1\n. To accommodate this, \nnums1\n has a length of \nm + n\n, where the first \nm\n elements denote the elements that should be merged, and the last \nn\n elements are set to \n0\n and should be ignored. \nnums2\n has a length of \nn\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n\nOutput:\n [1,2,2,3,5,6]\n\nExplanation:\n The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [\n1\n,\n2\n,2,\n3\n,5,6] with the underlined elements coming from nums1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1], m = 1, nums2 = [], n = 0\n\nOutput:\n [1]\n\nExplanation:\n The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums1 = [0], m = 0, nums2 = [1], n = 1\n\nOutput:\n [1]\n\nExplanation:\n The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m + n\n\n\nnums2.length == n\n\n\n0 <= m, n <= 200\n\n\n1 <= m + n <= 200\n\n\n-10\n9\n <= nums1[i], nums2[j] <= 10\n9\n\n\n\n\n \n\n\nFollow up: \nCan you come up with an algorithm that runs in \nO(m + n)\n time?",
    "solution": "\nclass Solution(object):\n    # @param A  a list of integers\n    # @param m  an integer, length of A\n    # @param B  a list of integers\n    # @param n  an integer, length of B\n    # @return nothing\n    def merge(self, A, m, B, n):\n        last, i, j = m + n - 1, m - 1, n - 1\n\n        while i >= 0 and j >= 0:\n            if A[i] > B[j]:\n                A[last] = A[i]\n                last, i = last - 1, i - 1\n            else:\n                A[last] = B[j]\n                last, j = last - 1, j - 1\n\n        while j >= 0:\n                A[last] = B[j]\n                last, j = last - 1, j - 1",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Sort Colors",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers, Sorting",
    "link": "https://leetcode.com/problems/sort-colors",
    "slug": "sort-colors",
    "description": "Given an array \nnums\n with \nn\n objects colored red, white, or blue, sort them \nin-place\n \nso that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\n\nWe will use the integers \n0\n, \n1\n, and \n2\n to represent the color red, white, and blue, respectively.\n\n\nYou must solve this problem without using the library's sort function.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,0,2,1,1,0]\n\nOutput:\n [0,0,1,1,2,2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,0,1]\n\nOutput:\n [0,1,2]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 300\n\n\nnums[i]\n is either \n0\n, \n1\n, or \n2\n.\n\n\n\n\n \n\n\nFollow up:\n Could you come up with a one-pass algorithm using only constant extra space?",
    "solution": "\nclass Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        def triPartition(nums, target):\n            i, left, right = 0, 0, len(nums)-1\n            while i <= right:\n                if nums[i] > target:\n                    nums[i], nums[right] = nums[right], nums[i]\n                    right -= 1\n                else:\n                    if nums[i] < target:\n                        nums[left], nums[i] = nums[i], nums[left]\n                        left += 1\n                    i += 1\n\n        triPartition(nums, 1)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Fibonacci Number",
    "difficulty": "EASY",
    "category": "Math, Dynamic Programming, Recursion, Memoization",
    "link": "https://leetcode.com/problems/fibonacci-number",
    "slug": "fibonacci-number",
    "description": "The \nFibonacci numbers\n, commonly denoted \nF(n)\n form a sequence, called the \nFibonacci sequence\n, such that each number is the sum of the two preceding ones, starting from \n0\n and \n1\n. That is,\n\n\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\n\n\nGiven \nn\n, calculate \nF(n)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 1\n\nExplanation:\n F(2) = F(1) + F(0) = 1 + 0 = 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 2\n\nExplanation:\n F(3) = F(2) + F(1) = 1 + 1 = 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 4\n\nOutput:\n 3\n\nExplanation:\n F(4) = F(3) + F(2) = 2 + 1 = 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 30",
    "solution": "\nimport itertools\n\n\nclass Solution(object):\n    def fib(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        def matrix_expo(A, K):\n            result = [[int(i==j) for j in xrange(len(A))] \\\n                      for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b for a, b in itertools.izip(row, col)) \\\n                     for col in ZB] for row in A]\n\n        T = [[1, 1],\n             [1, 0]]\n        return matrix_mult([[1, 0]], matrix_expo(T, N))[0][1]  # [a1, a0] * T^N\n\n\nclass Solution2(object):\n    def fib(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        prev, current = 0, 1\n        for i in xrange(N):\n            prev, current = current, prev + current,\n        return prev",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Valid Sudoku",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Matrix",
    "link": "https://leetcode.com/problems/valid-sudoku",
    "slug": "valid-sudoku",
    "description": "Determine if a \n9 x 9\n Sudoku board is valid. Only the filled cells need to be validated \naccording to the following rules\n:\n\n\n\n\nEach row must contain the digits \n1-9\n without repetition.\n\n\nEach column must contain the digits \n1-9\n without repetition.\n\n\nEach of the nine \n3 x 3\n sub-boxes of the grid must contain the digits \n1-9\n without repetition.\n\n\n\n\nNote:\n\n\n\n\nA Sudoku board (partially filled) could be valid but is not necessarily solvable.\n\n\nOnly the filled cells need to be validated according to the mentioned rules.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\nInput:\n board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput:\n false\n\nExplanation:\n Same as Example 1, except with the \n5\n in the top left corner being modified to \n8\n. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nboard.length == 9\n\n\nboard[i].length == 9\n\n\nboard[i][j]\n is a digit \n1-9\n or \n'.'\n.",
    "solution": "\nclass Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        for i in xrange(9):\n            if not self.isValidList([board[i][j] for j in xrange(9)]) or \\\n               not self.isValidList([board[j][i] for j in xrange(9)]):\n                return False\n        for i in xrange(3):\n            for j in xrange(3):\n                if not self.isValidList([board[m][n] for n in xrange(3 * j, 3 * j + 3) \\\n                                                     for m in xrange(3 * i, 3 * i + 3)]):\n                    return False\n        return True\n\n    def isValidList(self, xs):\n        xs = filter(lambda x: x != '.', xs)\n        return len(set(xs)) == len(xs)",
    "explanation": "N/A",
    "time_complexity": "O(9^2)",
    "space_complexity": "O(9)"
  },
  {
    "title": "Decode String",
    "difficulty": "MEDIUM",
    "category": "String, Stack, Recursion",
    "link": "https://leetcode.com/problems/decode-string",
    "slug": "decode-string",
    "description": "Given an encoded string, return its decoded string.\n\n\nThe encoding rule is: \nk[encoded_string]\n, where the \nencoded_string\n inside the square brackets is being repeated exactly \nk\n times. Note that \nk\n is guaranteed to be a positive integer.\n\n\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, \nk\n. For example, there will not be input like \n3a\n or \n2[4]\n.\n\n\nThe test cases are generated so that the length of the output will never exceed \n10\n5\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"3[a]2[bc]\"\n\nOutput:\n \"aaabcbc\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"3[a2[c]]\"\n\nOutput:\n \"accaccacc\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"2[abc]3[cd]ef\"\n\nOutput:\n \"abcabccdcdcdef\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 30\n\n\ns\n consists of lowercase English letters, digits, and square brackets \n'[]'\n.\n\n\ns\n is guaranteed to be \na valid\n input.\n\n\nAll the integers in \ns\n are in the range \n[1, 300]\n.",
    "solution": "\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n, curr, nums, strs = 0, [], [], []\n        for c in s:\n            if c.isdigit():\n                n = n*10 + ord(c)-ord('0')\n            elif c.isalpha():\n                curr.append(c)\n            elif c == '[':\n                nums.append(n)\n                strs.append(curr)\n                n, curr = 0, []\n            elif c == ']':\n                strs[-1].extend(curr*nums.pop())\n                curr = strs.pop()\n        return \"\".join(curr)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Reverse Linked List",
    "difficulty": "EASY",
    "category": "Linked List, Recursion",
    "link": "https://leetcode.com/problems/reverse-linked-list",
    "slug": "reverse-linked-list",
    "description": "Given the \nhead\n of a singly linked list, reverse the list, and return \nthe reversed list\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5]\n\nOutput:\n [5,4,3,2,1]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2]\n\nOutput:\n [2,1]\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is the range \n[0, 5000]\n.\n\n\n-5000 <= Node.val <= 5000\n\n\n\n\n \n\n\nFollow up:\n A linked list can be reversed either iteratively or recursively. Could you implement both?",
    "solution": "\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\n# Iterative solution.\nclass Solution(object):\n    # @param {ListNode} head\n    # @return {ListNode}\n    def reverseList(self, head):\n        dummy = ListNode(float(\"-inf\"))\n        while head:\n            dummy.next, head.next, head = head, dummy.next, head.next\n        return dummy.next\n\n# Recursive solution.\nclass Solution2(object):\n    # @param {ListNode} head\n    # @return {ListNode}\n    def reverseList(self, head):\n        [begin, end] = self.reverseListRecu(head)\n        return begin\n\n    def reverseListRecu(self, head):\n        if not head:\n            return [None, None]\n\n        [begin, end] = self.reverseListRecu(head.next)\n\n        if end:\n            end.next = head\n            head.next = None\n            return [begin, head]\n        else:\n            return [head, head]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Find Words Containing Character",
    "difficulty": "EASY",
    "category": "Array, String",
    "link": "https://leetcode.com/problems/find-words-containing-character",
    "slug": "find-words-containing-character",
    "description": "You are given a \n0-indexed\n array of strings \nwords\n and a character \nx\n.\n\n\nReturn \nan \narray of indices\n representing the words that contain the character \nx\n.\n\n\nNote\n that the returned array may be in \nany\n order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"leet\",\"code\"], x = \"e\"\n\nOutput:\n [0,1]\n\nExplanation:\n \"e\" occurs in both words: \"l\nee\nt\", and \"cod\ne\n\". Hence, we return indices 0 and 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"abc\",\"bcd\",\"aaaa\",\"cbc\"], x = \"a\"\n\nOutput:\n [0,2]\n\nExplanation:\n \"a\" occurs in \"\na\nbc\", and \"\naaaa\n\". Hence, we return indices 0 and 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"abc\",\"bcd\",\"aaaa\",\"cbc\"], x = \"z\"\n\nOutput:\n []\n\nExplanation:\n \"z\" does not occur in any of the words. Hence, we return an empty array.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 50\n\n\n1 <= words[i].length <= 50\n\n\nx\n is a lowercase English letter.\n\n\nwords[i]\n consists only of lowercase English letters.",
    "solution": "\n# string\nclass Solution(object):\n    def findWordsContaining(self, words, x):\n        \"\"\"\n        :type words: List[str]\n        :type x: str\n        :rtype: List[int]\n        \"\"\"\n        return [i for i, w in enumerate(words) if x in w]",
    "explanation": "N/A",
    "time_complexity": "O(n * l)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Create Hello World Function",
    "difficulty": "EASY",
    "category": "String",
    "link": "https://leetcode.com/problems/create-hello-world-function",
    "slug": "create-hello-world-function",
    "description": "Write a function \ncreateHelloWorld\n. It should return a new function that always returns \n\"Hello World\"\n.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n args = []\n\nOutput:\n \"Hello World\"\n\nExplanation:\n\nconst f = createHelloWorld();\nf(); // \"Hello World\"\n\nThe function returned by createHelloWorld should always return \"Hello World\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n args = [{},null,42]\n\nOutput:\n \"Hello World\"\n\nExplanation:\n\nconst f = createHelloWorld();\nf({}, null, 42); // \"Hello World\"\n\nAny arguments could be passed to the function but it should still always return \"Hello World\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= args.length <= 10",
    "solution": "# Solution not found in kamyu104 repository",
    "explanation": "N/A",
    "time_complexity": "N/A",
    "space_complexity": "N/A"
  },
  {
    "title": "Rotate Image",
    "difficulty": "MEDIUM",
    "category": "Array, Math, Matrix",
    "link": "https://leetcode.com/problems/rotate-image",
    "slug": "rotate-image",
    "description": "You are given an \nn x n\n 2D \nmatrix\n representing an image, rotate the image by \n90\n degrees (clockwise).\n\n\nYou have to rotate the image \nin-place\n, which means you have to modify the input 2D matrix directly. \nDO NOT\n allocate another 2D matrix and do the rotation.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [[7,4,1],[8,5,2],[9,6,3]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n\nOutput:\n [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 20\n\n\n-1000 <= matrix[i][j] <= 1000",
    "solution": "\nclass Solution(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        n = len(matrix)\n\n        # anti-diagonal mirror\n        for i in xrange(n):\n            for j in xrange(n - i):\n                matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j]\n\n        # horizontal mirror\n        for i in xrange(n / 2):\n            for j in xrange(n):\n                matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]\n\n        return matrix\n\nclass Solution2(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        return [list(reversed(x)) for x in zip(*matrix)]",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n^2)"
  },
  {
    "title": "Max Consecutive Ones",
    "difficulty": "EASY",
    "category": "Array",
    "link": "https://leetcode.com/problems/max-consecutive-ones",
    "slug": "max-consecutive-ones",
    "description": "Given a binary array \nnums\n, return \nthe maximum number of consecutive \n1\n's in the array\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,0,1,1,1]\n\nOutput:\n 3\n\nExplanation:\n The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,0,1,1,0,1]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\nnums[i]\n is either \n0\n or \n1\n.",
    "solution": "\nclass Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, local_max = 0, 0\n        for n in nums:\n            local_max = (local_max + 1 if n else 0)\n            result = max(result, local_max)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "LFU Cache",
    "difficulty": "HARD",
    "category": "Hash Table, Linked List, Design, Doubly-Linked List",
    "link": "https://leetcode.com/problems/lfu-cache",
    "slug": "lfu-cache",
    "description": "Design and implement a data structure for a \nLeast Frequently Used (LFU)\n cache.\n\n\nImplement the \nLFUCache\n class:\n\n\n\n\nLFUCache(int capacity)\n Initializes the object with the \ncapacity\n of the data structure.\n\n\nint get(int key)\n Gets the value of the \nkey\n if the \nkey\n exists in the cache. Otherwise, returns \n-1\n.\n\n\nvoid put(int key, int value)\n Update the value of the \nkey\n if present, or inserts the \nkey\n if not already present. When the cache reaches its \ncapacity\n, it should invalidate and remove the \nleast frequently used\n key before inserting a new item. For this problem, when there is a \ntie\n (i.e., two or more keys with the same frequency), the \nleast recently used\n \nkey\n would be invalidated.\n\n\n\n\nTo determine the least frequently used key, a \nuse counter\n is maintained for each key in the cache. The key with the smallest \nuse counter\n is the least frequently used key.\n\n\nWhen a key is first inserted into the cache, its \nuse counter\n is set to \n1\n (due to the \nput\n operation). The \nuse counter\n for a key in the cache is incremented either a \nget\n or \nput\n operation is called on it.\n\n\nThe functions \nget\n and \nput\n must each run in \nO(1)\n average time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\n\nOutput\n\n[null, null, null, 1, null, -1, 3, null, -1, 3, 4]\n\n\nExplanation\n\n// cnt(x) = the use counter for key x\n// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)\nLFUCache lfu = new LFUCache(2);\nlfu.put(1, 1);   // cache=[1,_], cnt(1)=1\nlfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1\nlfu.get(1);      // return 1\n                 // cache=[1,2], cnt(2)=1, cnt(1)=2\nlfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.\n                 // cache=[3,1], cnt(3)=1, cnt(1)=2\nlfu.get(2);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=[3,1], cnt(3)=2, cnt(1)=2\nlfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.\n                 // cache=[4,3], cnt(4)=1, cnt(3)=2\nlfu.get(1);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=[3,4], cnt(4)=1, cnt(3)=3\nlfu.get(4);      // return 4\n                 // cache=[4,3], cnt(4)=2, cnt(3)=3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= capacity <= 10\n4\n\n\n0 <= key <= 10\n5\n\n\n0 <= value <= 10\n9\n\n\nAt most \n2 * 10\n5\n calls will be made to \nget\n and \nput\n.",
    "solution": "\nimport collections\n\n\n# using OrderedDict\nclass LFUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.__capa = capacity\n        self.__size = 0\n        self.__min_freq = float(\"inf\")\n        self.__freq_to_nodes = collections.defaultdict(collections.OrderedDict)\n        self.__key_to_freq = {}\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.__key_to_freq:\n            return -1\n        value = self.__freq_to_nodes[self.__key_to_freq[key]][key]\n        self.__update(key, value)\n        return value\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: void\n        \"\"\"\n        if self.__capa <= 0:\n            return\n\n        if key not in self.__key_to_freq and self.__size == self.__capa:\n            del self.__key_to_freq[self.__freq_to_nodes[self.__min_freq].popitem(last=False)[0]]\n            if not self.__freq_to_nodes[self.__min_freq]:\n                del self.__freq_to_nodes[self.__min_freq]\n            self.__size -= 1\n        self.__update(key, value)\n        \n    def __update(self, key, value):\n        freq = 0\n        if key in self.__key_to_freq:\n            freq = self.__key_to_freq[key]\n            del self.__freq_to_nodes[freq][key]\n            if not self.__freq_to_nodes[freq]:\n                del self.__freq_to_nodes[freq]\n                if self.__min_freq == freq:\n                    self.__min_freq += 1\n            self.__size -= 1\n\n        freq += 1\n        self.__min_freq = min(self.__min_freq, freq)\n        self.__key_to_freq[key] = freq\n        self.__freq_to_nodes[freq][key] = value\n        self.__size += 1\n\n\nimport collections\n\n\nclass ListNode(object):\n    def __init__(self, key, value, freq):\n        self.key = key\n        self.val = value\n        self.freq = freq\n        self.next = None\n        self.prev = None\n\n\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def append(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\n\n\nclass LFUCache2(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.__capa = capacity\n        self.__size = 0\n        self.__min_freq = float(\"inf\")\n        self.__freq_to_nodes = collections.defaultdict(LinkedList)\n        self.__key_to_node = {}\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.__key_to_node:\n            return -1\n        value = self.__key_to_node[key].val\n        self.__update(key, value)\n        return value\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: void\n        \"\"\"\n        if self.__capa <= 0:\n            return\n\n        if key not in self.__key_to_node and self.__size == self.__capa:\n            del self.__key_to_node[self.__freq_to_nodes[self.__min_freq].head.key]\n            self.__freq_to_nodes[self.__min_freq].delete(self.__freq_to_nodes[self.__min_freq].head)\n            if not self.__freq_to_nodes[self.__min_freq].head:\n                del self.__freq_to_nodes[self.__min_freq]\n            self.__size -= 1\n        self.__update(key, value)\n        \n    def __update(self, key, value):\n        freq = 0\n        if key in self.__key_to_node:\n            old_node = self.__key_to_node[key]\n            freq = old_node.freq\n            self.__freq_to_nodes[freq].delete(old_node)\n            if not self.__freq_to_nodes[freq].head:\n                del self.__freq_to_nodes[freq]\n                if self.__min_freq == freq:\n                    self.__min_freq += 1\n            self.__size -= 1\n\n        freq += 1\n        self.__min_freq = min(self.__min_freq, freq)\n        self.__key_to_node[key] = ListNode(key, value, freq)\n        self.__freq_to_nodes[freq].append(self.__key_to_node[key])\n        self.__size += 1",
    "explanation": "N/A",
    "time_complexity": "O(1), per operation",
    "space_complexity": "O(k), k is the capacity of cache"
  },
  {
    "title": "Power of Two",
    "difficulty": "EASY",
    "category": "Math, Bit Manipulation, Recursion",
    "link": "https://leetcode.com/problems/power-of-two",
    "slug": "power-of-two",
    "description": "Given an integer \nn\n, return \ntrue\n if it is a power of two. Otherwise, return \nfalse\n.\n\n\nAn integer \nn\n is a power of two, if there exists an integer \nx\n such that \nn == 2\nx\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 1\n\nOutput:\n true\n\nExplanation: \n2\n0\n = 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 16\n\nOutput:\n true\n\nExplanation: \n2\n4\n = 16\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= n <= 2\n31\n - 1\n\n\n\n\n \n\n\nFollow up:\n Could you solve it without loops/recursion?",
    "solution": "\nclass Solution(object):\n    # @param {integer} n\n    # @return {boolean}\n    def isPowerOfTwo(self, n):\n        return n > 0 and (n & (n - 1)) == 0\n\n\nclass Solution2(object):\n    # @param {integer} n\n    # @return {boolean}\n    def isPowerOfTwo(self, n):\n        return n > 0 and (n & ~-n) == 0",
    "explanation": "N/A",
    "time_complexity": "O(1)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Max Consecutive Ones III",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search, Sliding Window, Prefix Sum",
    "link": "https://leetcode.com/problems/max-consecutive-ones-iii",
    "slug": "max-consecutive-ones-iii",
    "description": "Given a binary array \nnums\n and an integer \nk\n, return \nthe maximum number of consecutive \n1\n's in the array if you can flip at most\n \nk\n \n0\n's.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\n\nOutput:\n 6\n\nExplanation:\n [1,1,1,0,0,\n1\n,1,1,1,1,\n1\n]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\n\nOutput:\n 10\n\nExplanation:\n [0,0,\n1,1,\n1\n,\n1\n,1,1,1,\n1\n,1,1\n,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\nnums[i]\n is either \n0\n or \n1\n.\n\n\n0 <= k <= nums.length",
    "solution": "\nclass Solution(object):\n    def longestOnes(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        result, i = 0, 0\n        for j in xrange(len(A)):\n            K -= int(A[j] == 0)\n            while K < 0:\n                K += int(A[i] == 0)\n                i += 1\n            result = max(result, j-i+1)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Escape the Spreading Fire",
    "difficulty": "HARD",
    "category": "Array, Binary Search, Breadth-First Search, Matrix",
    "link": "https://leetcode.com/problems/escape-the-spreading-fire",
    "slug": "escape-the-spreading-fire",
    "description": "You are given a \n0-indexed\n 2D integer array \ngrid\n of size \nm x n\n which represents a field. Each cell has one of three values:\n\n\n\n\n0\n represents grass,\n\n\n1\n represents fire,\n\n\n2\n represents a wall that you and fire cannot pass through.\n\n\n\n\nYou are situated in the top-left cell, \n(0, 0)\n, and you want to travel to the safehouse at the bottom-right cell, \n(m - 1, n - 1)\n. Every minute, you may move to an \nadjacent\n grass cell. \nAfter\n your move, every fire cell will spread to all \nadjacent\n cells that are not walls.\n\n\nReturn \nthe \nmaximum\n number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse\n. If this is impossible, return \n-1\n. If you can \nalways\n reach the safehouse regardless of the minutes stayed, return \n10\n9\n.\n\n\nNote that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\n\n\nA cell is \nadjacent\n to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]\n\nOutput:\n 3\n\nExplanation:\n The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]\n\nOutput:\n -1\n\nExplanation:\n The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n grid = [[0,0,0],[2,2,0],[1,2,0]]\n\nOutput:\n 1000000000\n\nExplanation:\n The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 10\n9\n is returned.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n2 <= m, n <= 300\n\n\n4 <= m * n <= 2 * 10\n4\n\n\ngrid[i][j]\n is either \n0\n, \n1\n, or \n2\n.\n\n\ngrid[0][0] == grid[m - 1][n - 1] == 0",
    "solution": "\nimport collections\n\n\n# bfs\nclass Solution(object):\n    def maximumMinutes(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        GRASS, FIRE, WALL, PERSON = range(4)\n        INF = 10**9\n        def bfs(grid):\n            time = collections.defaultdict(int)\n            d = 0\n            q = [(r, c, FIRE) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c] == FIRE]\n            q.append((0, 0, PERSON))\n            while q:\n                new_q = []\n                for r, c, t in q:\n                    for dr, dc in DIRECTIONS:\n                        nr, nc = r+dr, c+dc\n                        if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and\n                                grid[nr][nc] != WALL and\n                                ((t == FIRE and grid[nr][nc] != FIRE) or\n                                 (t == PERSON and (grid[nr][nc] == GRASS or (grid[nr][nc] == FIRE and (nr, nc) == (len(grid)-1, len(grid[0])-1) and d+1 == time[FIRE, nr, nc]))))):\n                            continue\n                        if grid[nr][nc] != FIRE:\n                            grid[nr][nc] = t\n                        if (nr, nc) in ((len(grid)-1, len(grid[0])-1), (len(grid)-1, len(grid[0])-2), (len(grid)-2, len(grid[0])-1)):\n                            time[t, nr, nc] = d+1\n                        new_q.append((nr, nc, t))\n                q = new_q\n                d += 1\n            return time\n\n        time = bfs(grid)\n        if not time[PERSON, len(grid)-1, len(grid[0])-1]:\n            return -1\n        if not time[FIRE, len(grid)-1, len(grid[0])-1]:\n            return INF\n        diff = time[FIRE, len(grid)-1, len(grid[0])-1]-time[PERSON, len(grid)-1, len(grid[0])-1]\n        return diff if diff+2 in (time[FIRE, len(grid)-1, len(grid[0])-2]-time[PERSON, len(grid)-1, len(grid[0])-2],\n                                  time[FIRE, len(grid)-2, len(grid[0])-1]-time[PERSON, len(grid)-2, len(grid[0])-1]) else diff-1\n\n\n# bfs\nclass Solution2(object):\n    def maximumMinutes(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        FIRE, WALL, PERSON = range(1, 4)\n        INF = 10**9\n        def bfs(grid):\n            time = {FIRE:[[INF]*len(grid[0]) for _ in xrange(len(grid))],\n                    PERSON:[[INF]*len(grid[0]) for _ in xrange(len(grid))]}\n            d = 0\n            q = [(r, c, FIRE) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c] == FIRE]\n            q.append((0, 0, PERSON))\n            for r, c, t in q:\n                time[t][r][c] = d\n            while q:\n                new_q = []\n                for r, c, t in q:\n                    for dr, dc in DIRECTIONS:\n                        nr, nc = r+dr, c+dc\n                        if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and\n                                grid[nr][nc] != WALL and time[t][nr][nc] == INF and\n                                (t == FIRE or\n                                 d+1 < time[FIRE][nr][nc] or (d+1 == time[FIRE][nr][nc] and (nr, nc) == (len(grid)-1, len(grid[0])-1)))):\n                            continue\n                        time[t][nr][nc] = d+1\n                        new_q.append((nr, nc, t))\n                q = new_q\n                d += 1\n            return time\n\n        time = bfs(grid)\n        if time[PERSON][-1][-1] == INF:\n            return -1\n        if time[FIRE][-1][-1] == INF:\n            return INF\n        diff = time[FIRE][-1][-1]-time[PERSON][-1][-1]\n        return diff if diff+2 in (time[FIRE][-1][-2]-time[PERSON][-1][-2], time[FIRE][-2][-1]-time[PERSON][-2][-1]) else diff-1",
    "explanation": "N/A",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m * n)"
  },
  {
    "title": "Squares of a Sorted Array",
    "difficulty": "EASY",
    "category": "Array, Two Pointers, Sorting",
    "link": "https://leetcode.com/problems/squares-of-a-sorted-array",
    "slug": "squares-of-a-sorted-array",
    "description": "Given an integer array \nnums\n sorted in \nnon-decreasing\n order, return \nan array of \nthe squares of each number\n sorted in non-decreasing order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-4,-1,0,3,10]\n\nOutput:\n [0,1,9,16,100]\n\nExplanation:\n After squaring, the array becomes [16,1,0,9,100].\nAfter sorting, it becomes [0,1,9,16,100].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-7,-3,2,3,11]\n\nOutput:\n [4,9,9,49,121]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= \n10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nnums\n is sorted in \nnon-decreasing\n order.\n\n\n\n\n \n\n\nFollow up:\n Squaring each element and sorting the new array is very trivial, could you find an \nO(n)\n solution using a different approach?",
    "solution": "\nimport bisect\n\n\nclass Solution(object):\n    def sortedSquares(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        right = bisect.bisect_left(A, 0)\n        left = right-1\n        result = []\n        while 0 <= left or right < len(A):\n            if right == len(A) or \\\n               (0 <= left and A[left]**2 < A[right]**2):\n                result.append(A[left]**2)\n                left -= 1\n            else:\n                result.append(A[right]**2)\n                right += 1\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Burst Balloons",
    "difficulty": "HARD",
    "category": "Array, Dynamic Programming",
    "link": "https://leetcode.com/problems/burst-balloons",
    "slug": "burst-balloons",
    "description": "You are given \nn\n balloons, indexed from \n0\n to \nn - 1\n. Each balloon is painted with a number on it represented by an array \nnums\n. You are asked to burst all the balloons.\n\n\nIf you burst the \ni\nth\n balloon, you will get \nnums[i - 1] * nums[i] * nums[i + 1]\n coins. If \ni - 1\n or \ni + 1\n goes out of bounds of the array, then treat it as if there is a balloon with a \n1\n painted on it.\n\n\nReturn \nthe maximum coins you can collect by bursting the balloons wisely\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [3,1,5,8]\n\nOutput:\n 167\n\nExplanation:\n\nnums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,5]\n\nOutput:\n 10\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 300\n\n\n0 <= nums[i] <= 100",
    "solution": "\n\nclass Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        coins = [1] + [i for i in nums if i > 0] + [1]\n        n = len(coins)\n        max_coins = [[0 for _ in xrange(n)] for _ in xrange(n)]\n\n        for k in xrange(2, n):\n            for left in xrange(n - k):\n                right = left + k\n                for i in xrange(left + 1, right):\n                    max_coins[left][right] = \\\n                        max(max_coins[left][right],\n                            coins[left] * coins[i] * coins[right] +\n                            max_coins[left][i] +\n                            max_coins[i][right])\n\n        return max_coins[0][-1]",
    "explanation": "N/A",
    "time_complexity": "O(n^3)",
    "space_complexity": "O(n^2)"
  },
  {
    "title": "Climbing Stairs",
    "difficulty": "EASY",
    "category": "Math, Dynamic Programming, Memoization",
    "link": "https://leetcode.com/problems/climbing-stairs",
    "slug": "climbing-stairs",
    "description": "You are climbing a staircase. It takes \nn\n steps to reach the top.\n\n\nEach time you can either climb \n1\n or \n2\n steps. In how many distinct ways can you climb to the top?\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 2\n\nExplanation:\n There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 3\n\nExplanation:\n There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 45",
    "solution": "\nimport itertools\n\n\nclass Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def matrix_expo(A, K):\n            result = [[int(i==j) for j in xrange(len(A))] \\\n                      for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b for a, b in itertools.izip(row, col)) \\\n                     for col in ZB] for row in A]\n\n        T = [[1, 1],\n             [1, 0]]\n        return matrix_mult([[1,  0]], matrix_expo(T, n))[0][0]  # [a0, a(-1)] * T^n\n\n\nclass Solution2(object):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    def climbStairs(self, n):\n        prev, current = 0, 1\n        for i in xrange(n):\n            prev, current = current, prev + current,\n        return current",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Longest Palindrome by Concatenating Two Letter Words",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, String, Greedy, Counting",
    "link": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words",
    "slug": "longest-palindrome-by-concatenating-two-letter-words",
    "description": "You are given an array of strings \nwords\n. Each element of \nwords\n consists of \ntwo\n lowercase English letters.\n\n\nCreate the \nlongest possible palindrome\n by selecting some elements from \nwords\n and concatenating them in \nany order\n. Each element can be selected \nat most once\n.\n\n\nReturn \nthe \nlength\n of the longest palindrome that you can create\n. If it is impossible to create any palindrome, return \n0\n.\n\n\nA \npalindrome\n is a string that reads the same forward and backward.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"lc\",\"cl\",\"gg\"]\n\nOutput:\n 6\n\nExplanation:\n One longest palindrome is \"lc\" + \"gg\" + \"cl\" = \"lcggcl\", of length 6.\nNote that \"clgglc\" is another longest palindrome that can be created.\n\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ab\"]\n\nOutput:\n 8\n\nExplanation:\n One longest palindrome is \"ty\" + \"lc\" + \"cl\" + \"yt\" = \"tylcclyt\", of length 8.\nNote that \"lcyttycl\" is another longest palindrome that can be created.\n\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"cc\",\"ll\",\"xx\"]\n\nOutput:\n 2\n\nExplanation:\n One longest palindrome is \"cc\", of length 2.\nNote that \"ll\" is another longest palindrome that can be created, and so is \"xx\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 10\n5\n\n\nwords[i].length == 2\n\n\nwords[i]\n consists of lowercase English letters.",
    "solution": "\nimport collections\n\n\nclass Solution(object):\n    def longestPalindrome(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter(words)\n        result = remain = 0\n        for x, c in cnt.iteritems():\n            if x == x[::-1]:\n                result += c//2\n                remain |= c%2\n            elif x < x[::-1] and x[::-1] in cnt:\n                result += min(c, cnt[x[::-1]])\n        return result*4+remain*2",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Maximum Subarray",
    "difficulty": "MEDIUM",
    "category": "Array, Divide and Conquer, Dynamic Programming",
    "link": "https://leetcode.com/problems/maximum-subarray",
    "slug": "maximum-subarray",
    "description": "Given an integer array \nnums\n, find the \nsubarray\n with the largest sum, and return \nits sum\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-2,1,-3,4,-1,2,1,-5,4]\n\nOutput:\n 6\n\nExplanation:\n The subarray [4,-1,2,1] has the largest sum 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1]\n\nOutput:\n 1\n\nExplanation:\n The subarray [1] has the largest sum 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [5,4,-1,7,8]\n\nOutput:\n 23\n\nExplanation:\n The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n If you have figured out the \nO(n)\n solution, try coding another solution using the \ndivide and conquer\n approach, which is more subtle.",
    "solution": "\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, curr = float(\"-inf\"), float(\"-inf\")\n        for x in nums:\n            curr = max(curr+x, x)\n            result = max(result, curr)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Triangle Judgement",
    "difficulty": "EASY",
    "category": "Database",
    "link": "https://leetcode.com/problems/triangle-judgement",
    "slug": "triangle-judgement",
    "description": "Table: \nTriangle\n\n\n\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| x           | int  |\n| y           | int  |\n| z           | int  |\n+-------------+------+\nIn SQL, (x, y, z) is the primary key column for this table.\nEach row of this table contains the lengths of three line segments.\n\n\n\n \n\n\nReport for every three line segments whether they can form a triangle.\n\n\nReturn the result table in \nany order\n.\n\n\nThe result format is in the following example.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nTriangle table:\n+----+----+----+\n| x  | y  | z  |\n+----+----+----+\n| 13 | 15 | 30 |\n| 10 | 20 | 15 |\n+----+----+----+\n\nOutput:\n \n+----+----+----+----------+\n| x  | y  | z  | triangle |\n+----+----+----+----------+\n| 13 | 15 | 30 | No       |\n| 10 | 20 | 15 | Yes      |\n+----+----+----+----------+",
    "solution": "# Solution not found in kamyu104 repository",
    "explanation": "N/A",
    "time_complexity": "N/A",
    "space_complexity": "N/A"
  },
  {
    "title": "Min Stack",
    "difficulty": "MEDIUM",
    "category": "Stack, Design",
    "link": "https://leetcode.com/problems/min-stack",
    "slug": "min-stack",
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\n\nImplement the \nMinStack\n class:\n\n\n\n\nMinStack()\n initializes the stack object.\n\n\nvoid push(int val)\n pushes the element \nval\n onto the stack.\n\n\nvoid pop()\n removes the element on the top of the stack.\n\n\nint top()\n gets the top element of the stack.\n\n\nint getMin()\n retrieves the minimum element in the stack.\n\n\n\n\nYou must implement a solution with \nO(1)\n time complexity for each function.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n\nOutput\n\n[null,null,null,null,-3,null,0,-2]\n\n\nExplanation\n\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= val <= 2\n31\n - 1\n\n\nMethods \npop\n, \ntop\n and \ngetMin\n operations will always be called on \nnon-empty\n stacks.\n\n\nAt most \n3 * 10\n4\n calls will be made to \npush\n, \npop\n, \ntop\n, and \ngetMin\n.",
    "solution": "\nclass MinStack(object):\n    def __init__(self):\n        self.min = None\n        self.stack = []\n\n    # @param x, an integer\n    # @return an integer\n    def push(self, x):\n        if not self.stack:\n            self.stack.append(0)\n            self.min = x\n        else:\n            self.stack.append(x - self.min)\n            if x < self.min:\n                self.min = x\n\n    # @return nothing\n    def pop(self):\n        x = self.stack.pop()\n        if x < 0:\n            self.min = self.min - x\n\n    # @return an integer\n    def top(self):\n        x = self.stack[-1]\n        if x > 0:\n            return x + self.min\n        else:\n            return self.min\n\n    # @return an integer\n    def getMin(self):\n        return self.min\n\nclass MinStack2(object):\n    def __init__(self):\n        self.stack, self.minStack = [], []\n    # @param x, an integer\n    # @return an integer\n    def push(self, x):\n        self.stack.append(x)\n        if len(self.minStack):\n            if x < self.minStack[-1][0]:\n                self.minStack.append([x, 1])\n            elif x == self.minStack[-1][0]:\n                self.minStack[-1][1] += 1\n        else:\n            self.minStack.append([x, 1])\n\n    # @return nothing\n    def pop(self):\n        x = self.stack.pop()\n        if x == self.minStack[-1][0]:\n            self.minStack[-1][1] -= 1\n            if self.minStack[-1][1] == 0:\n                self.minStack.pop()\n\n    # @return an integer\n    def top(self):\n        return self.stack[-1]\n\n    # @return an integer\n    def getMin(self):\n        return self.minStack[-1][0]\n\n# time: O(1)\n# space: O(n)\n\nclass MinStack3(object):\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x):\n        if self.stack:\n            current_min = min(x, self.stack[-1][0])\n            self.stack.append((current_min, x))\n        else:\n            self.stack.append((x, x))\n\n    def pop(self):\n        return self.stack.pop()[1]\n\n    def top(self):\n        return self.stack[-1][1]\n\n    def getMin(self):\n        return self.stack[-1][0]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Logger Rate Limiter",
    "difficulty": "EASY",
    "category": "Hash Table, Design, Data Stream",
    "link": "https://leetcode.com/problems/logger-rate-limiter",
    "slug": "logger-rate-limiter",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nimport collections\n\n\nclass Logger(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__dq = collections.deque()\n        self.__printed = set()\n\n    def shouldPrintMessage(self, timestamp, message):\n        \"\"\"\n        Returns true if the message should be printed in the given timestamp, otherwise returns false. The timestamp is in seconds granularity.\n        :type timestamp: int\n        :type message: str\n        :rtype: bool\n        \"\"\"\n        while self.__dq and self.__dq[0][0] <= timestamp - 10:\n            self.__printed.remove(self.__dq.popleft()[1])\n        if message in self.__printed:\n            return False\n        self.__dq.append((timestamp, message))\n        self.__printed.add(message)\n        return True",
    "explanation": "N/A",
    "time_complexity": "O(1), amortized",
    "space_complexity": "O(k), k is the max number of printed messages in last 10 seconds"
  },
  {
    "title": "Reorder List",
    "difficulty": "MEDIUM",
    "category": "Linked List, Two Pointers, Stack, Recursion",
    "link": "https://leetcode.com/problems/reorder-list",
    "slug": "reorder-list",
    "description": "You are given the head of a singly linked-list. The list can be represented as:\n\n\n\nL\n0\n → L\n1\n → … → L\nn - 1\n → L\nn\n\n\n\n\nReorder the list to be on the following form:\n\n\n\nL\n0\n → L\nn\n → L\n1\n → L\nn - 1\n → L\n2\n → L\nn - 2\n → …\n\n\n\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4]\n\nOutput:\n [1,4,2,3]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5]\n\nOutput:\n [1,5,2,4,3]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is in the range \n[1, 5 * 10\n4\n]\n.\n\n\n1 <= Node.val <= 1000",
    "solution": "\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution(object):\n    # @param head, a ListNode\n    # @return nothing\n    def reorderList(self, head):\n        if head == None or head.next == None:\n            return head\n\n        fast, slow, prev = head, head, None\n        while fast != None and fast.next != None:\n            fast, slow, prev = fast.next.next, slow.next, slow\n        current, prev.next, prev = slow, None, None\n\n        while current != None:\n            current.next, prev, current = prev, current, current.next\n\n        l1, l2 = head, prev\n        dummy = ListNode(0)\n        current = dummy\n\n        while l1 != None and l2 != None:\n            current.next, current, l1 = l1, l1, l1.next\n            current.next, current, l2 = l2, l2, l2.next\n\n        return dummy.next",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Zero Array Transformation I",
    "difficulty": "MEDIUM",
    "category": "Array, Prefix Sum",
    "link": "https://leetcode.com/problems/zero-array-transformation-i",
    "slug": "zero-array-transformation-i",
    "description": "You are given an integer array \nnums\n of length \nn\n and a 2D array \nqueries\n, where \nqueries[i] = [l\ni\n, r\ni\n]\n.\n\n\nFor each \nqueries[i]\n:\n\n\n\n\nSelect a \nsubset\n of indices within the range \n[l\ni\n, r\ni\n]\n in \nnums\n.\n\n\nDecrement the values at the selected indices by 1.\n\n\n\n\nA \nZero Array\n is an array where all elements are equal to 0.\n\n\nReturn \ntrue\n if it is \npossible\n to transform \nnums\n into a \nZero Array \nafter processing all the queries sequentially, otherwise return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,0,1], queries = [[0,2]]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\n\n\nFor i = 0:\n\n\n\n\nSelect the subset of indices as \n[0, 2]\n and decrement the values at these indices by 1.\n\n\nThe array will become \n[0, 0, 0]\n, which is a Zero Array.\n\n\n\n\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [4,3,2,1], queries = [[1,3],[0,2]]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\n\n\nFor i = 0:\n\n\n\n\nSelect the subset of indices as \n[1, 2, 3]\n and decrement the values at these indices by 1.\n\n\nThe array will become \n[4, 2, 1, 0]\n.\n\n\n\n\n\n\nFor i = 1:\n\n\n\n\nSelect the subset of indices as \n[0, 1, 2]\n and decrement the values at these indices by 1.\n\n\nThe array will become \n[3, 1, 0, 0]\n, which is not a Zero Array.\n\n\n\n\n\n\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n0 <= nums[i] <= 10\n5\n\n\n1 <= queries.length <= 10\n5\n\n\nqueries[i].length == 2\n\n\n0 <= l\ni\n <= r\ni\n < nums.length",
    "solution": "\n# line sweep\nclass Solution(object):\n    def isZeroArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        events = [0]*(len(nums)+1)\n        for l, r in queries:\n            events[l] += 1\n            events[r+1] -= 1\n        curr = 0\n        for i in xrange(len(nums)):\n            curr += events[i]\n            if nums[i] > curr:\n                return False\n        return True",
    "explanation": "N/A",
    "time_complexity": "O(n + q)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Search Insert Position",
    "difficulty": "EASY",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/search-insert-position",
    "slug": "search-insert-position",
    "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 5\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 2\n\nOutput:\n 1\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,3,5,6], target = 7\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nnums\n contains \ndistinct\n values sorted in \nascending\n order.\n\n\n-10\n4\n <= target <= 10\n4",
    "solution": "\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if nums[mid] >= target:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return left",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Koko Eating Bananas",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/koko-eating-bananas",
    "slug": "koko-eating-bananas",
    "description": "Koko loves to eat bananas. There are \nn\n piles of bananas, the \ni\nth\n pile has \npiles[i]\n bananas. The guards have gone and will come back in \nh\n hours.\n\n\nKoko can decide her bananas-per-hour eating speed of \nk\n. Each hour, she chooses some pile of bananas and eats \nk\n bananas from that pile. If the pile has less than \nk\n bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\n\nReturn \nthe minimum integer\n \nk\n \nsuch that she can eat all the bananas within\n \nh\n \nhours\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n piles = [3,6,7,11], h = 8\n\nOutput:\n 4\n\n\n\nExample 2:\n\n\n\n\nInput:\n piles = [30,11,23,4,20], h = 5\n\nOutput:\n 30\n\n\n\nExample 3:\n\n\n\n\nInput:\n piles = [30,11,23,4,20], h = 6\n\nOutput:\n 23\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= piles.length <= 10\n4\n\n\npiles.length <= h <= 10\n9\n\n\n1 <= piles[i] <= 10\n9",
    "solution": "\nclass Solution(object):\n    def minEatingSpeed(self, piles, H):\n        \"\"\"\n        :type piles: List[int]\n        :type H: int\n        :rtype: int\n        \"\"\"\n        def possible(piles, H, K):\n            return sum((pile-1)//K+1 for pile in piles) <= H\n\n        left, right = 1, max(piles)\n        while left <= right:\n            mid = left + (right-left)//2\n            if possible(piles, H, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left",
    "explanation": "N/A",
    "time_complexity": "O(nlogr)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Rotate Array",
    "difficulty": "MEDIUM",
    "category": "Array, Math, Two Pointers",
    "link": "https://leetcode.com/problems/rotate-array",
    "slug": "rotate-array",
    "description": "Given an integer array \nnums\n, rotate the array to the right by \nk\n steps, where \nk\n is non-negative.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,4,5,6,7], k = 3\n\nOutput:\n [5,6,7,1,2,3,4]\n\nExplanation:\n\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-1,-100,3,99], k = 2\n\nOutput:\n [3,99,-1,-100]\n\nExplanation:\n \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\n0 <= k <= 10\n5\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nTry to come up with as many solutions as you can. There are at least \nthree\n different ways to solve this problem.\n\n\nCould you do it in-place with \nO(1)\n extra space?",
    "solution": "\nclass Solution(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    def rotate(self, nums, k):\n        def reverse(nums, start, end):\n            while start < end:\n                nums[start], nums[end - 1] = nums[end - 1], nums[start]\n                start += 1\n                end -= 1\n\n        k %= len(nums)\n        reverse(nums, 0, len(nums))\n        reverse(nums, 0, k)\n        reverse(nums, k, len(nums))\n\n\nfrom fractions import gcd\n\n\nclass Solution2(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n\n    def rotate(self, nums, k):\n        def apply_cycle_permutation(k, offset, cycle_len, nums):\n            tmp = nums[offset]\n            for i in xrange(1, cycle_len):\n                nums[(offset + i * k) % len(nums)], tmp = tmp, nums[(offset + i * k) % len(nums)]\n            nums[offset] = tmp\n\n        k %= len(nums)\n        num_cycles = gcd(len(nums), k)\n        cycle_len = len(nums) / num_cycles\n        for i in xrange(num_cycles):\n            apply_cycle_permutation(k, i, cycle_len, nums)\n\n\nclass Solution3(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n\n    def rotate(self, nums, k):\n        count = 0\n        start = 0\n        while count < len(nums):\n            curr = start\n            prev = nums[curr]\n            while True:\n                idx = (curr + k) % len(nums)\n                nums[idx], prev = prev, nums[idx]\n                curr = idx\n                count += 1\n                if start == curr:\n                    break\n            start += 1\n\n\nclass Solution4(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    def rotate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums[:] = nums[len(nums) - k:] + nums[:len(nums) - k]\n        \n\nclass Solution5(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    def rotate(self, nums, k):\n        while k > 0:\n            nums.insert(0, nums.pop())\n            k -= 1",
    "explanation": "N/A",
    "time_complexity": "O(k * n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Find All Duplicates in an Array",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table",
    "link": "https://leetcode.com/problems/find-all-duplicates-in-an-array",
    "slug": "find-all-duplicates-in-an-array",
    "description": "Given an integer array \nnums\n of length \nn\n where all the integers of \nnums\n are in the range \n[1, n]\n and each integer appears \nat most\n \ntwice\n, return \nan array of all the integers that appears \ntwice\n.\n\n\nYou must write an algorithm that runs in \nO(n)\n time and uses only \nconstant\n auxiliary space, excluding the space needed to store the output\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [4,3,2,7,8,2,3,1]\n\nOutput:\n [2,3]\n\nExample 2:\n\n\nInput:\n nums = [1,1,2]\n\nOutput:\n [1]\n\nExample 3:\n\n\nInput:\n nums = [1]\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 10\n5\n\n\n1 <= nums[i] <= n\n\n\nEach element in \nnums\n appears \nonce\n or \ntwice\n.",
    "solution": "\nclass Solution(object):\n    def findDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i in nums:\n            if nums[abs(i)-1] < 0:\n                result.append(abs(i))\n            else:\n                nums[abs(i)-1] *= -1\n        return result\n\n\nclass Solution2(object):\n    def findDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        i = 0\n        while i < len(nums):\n            if nums[i] != nums[nums[i]-1]:\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\n            else:\n                i += 1\n\n        for i in xrange(len(nums)):\n            if i != nums[i]-1:\n                result.append(nums[i])\n        return result\n\n\nfrom collections import Counter\nclass Solution3(object):\n    def findDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return [elem for elem, count in Counter(nums).items() if count == 2]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n), this doesn't satisfy the question"
  },
  {
    "title": "Meeting Rooms II",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers, Greedy, Sorting, Heap (Priority Queue), Prefix Sum",
    "link": "https://leetcode.com/problems/meeting-rooms-ii",
    "slug": "meeting-rooms-ii",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nclass Solution(object):\n    # @param {Interval[]} intervals\n    # @return {integer}\n    def minMeetingRooms(self, intervals):\n        result, curr = 0, 0\n        line = [x for i, j in intervals for x in [[i, 1], [j, -1]]]\n        line.sort()\n        for _, num in line:\n            curr += num\n            result = max(result, curr)\n        return result\n\n\nclass Solution2(object):\n    # @param {Interval[]} intervals\n    # @return {integer}\n    def minMeetingRooms(self, intervals):\n        starts, ends = [], []\n        for start, end in intervals:\n            starts.append(start)\n            ends.append(end)\n\n        starts.sort()\n        ends.sort()\n\n        s, e = 0, 0\n        min_rooms, cnt_rooms = 0, 0\n        while s < len(starts):\n            if starts[s] < ends[e]:\n                cnt_rooms += 1  # Acquire a room.\n                # Update the min number of rooms.\n                min_rooms = max(min_rooms, cnt_rooms)\n                s += 1\n            else:\n                cnt_rooms -= 1  # Release a room.\n                e += 1\n\n        return min_rooms\n\n\nfrom heapq import heappush, heappop\n\n\nclass Solution3(object):\n    def minMeetingRooms(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return 0\n        \n        intervals.sort(key=lambda x: x[0])\n        free_rooms = []\n        \n        heappush(free_rooms, intervals[0][1])\n        for interval in intervals[1:]:\n            if free_rooms[0] <= interval[0]:\n                heappop(free_rooms)\n            \n            heappush(free_rooms, interval[1])\n        \n        return len(free_rooms)",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Meeting Rooms III",
    "difficulty": "HARD",
    "category": "Array, Hash Table, Sorting, Heap (Priority Queue), Simulation",
    "link": "https://leetcode.com/problems/meeting-rooms-iii",
    "slug": "meeting-rooms-iii",
    "description": "You are given an integer \nn\n. There are \nn\n rooms numbered from \n0\n to \nn - 1\n.\n\n\nYou are given a 2D integer array \nmeetings\n where \nmeetings[i] = [start\ni\n, end\ni\n]\n means that a meeting will be held during the \nhalf-closed\n time interval \n[start\ni\n, end\ni\n)\n. All the values of \nstart\ni\n are \nunique\n.\n\n\nMeetings are allocated to rooms in the following manner:\n\n\n\n\nEach meeting will take place in the unused room with the \nlowest\n number.\n\n\nIf there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the \nsame\n duration as the original meeting.\n\n\nWhen a room becomes unused, meetings that have an earlier original \nstart\n time should be given the room.\n\n\n\n\nReturn\n the \nnumber\n of the room that held the most meetings. \nIf there are multiple rooms, return\n the room with the \nlowest\n number.\n\n\nA \nhalf-closed interval\n \n[a, b)\n is the interval between \na\n and \nb\n \nincluding\n \na\n and \nnot including\n \nb\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]\n\nOutput:\n 0\n\nExplanation:\n\n- At time 0, both rooms are not being used. The first meeting starts in room 0.\n- At time 1, only room 1 is not being used. The second meeting starts in room 1.\n- At time 2, both rooms are being used. The third meeting is delayed.\n- At time 3, both rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period [5,10).\n- At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period [10,11).\nBoth rooms 0 and 1 held 2 meetings, so we return 0. \n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\n\nOutput:\n 1\n\nExplanation:\n\n- At time 1, all three rooms are not being used. The first meeting starts in room 0.\n- At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1.\n- At time 3, only room 2 is not being used. The third meeting starts in room 2.\n- At time 4, all three rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period [5,10).\n- At time 6, all three rooms are being used. The fifth meeting is delayed.\n- At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period [10,12).\nRoom 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1. \n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100\n\n\n1 <= meetings.length <= 10\n5\n\n\nmeetings[i].length == 2\n\n\n0 <= start\ni\n < end\ni\n <= 5 * 10\n5\n\n\nAll the values of \nstart\ni\n are \nunique\n.",
    "solution": "\nimport heapq\n\n\n# one heap solution\nclass Solution(object):\n    def mostBooked(self, n, meetings):\n        \"\"\"\n        :type n: int\n        :type meetings: List[List[int]]\n        :rtype: int\n        \"\"\"\n        meetings.sort()\n        min_heap = [(meetings[0][0], i) for i in xrange(n)]\n        result = [0]*n\n        for s, e in meetings:\n            while min_heap and min_heap[0][0] < s:\n                _, i = heapq.heappop(min_heap)\n                heapq.heappush(min_heap, (s, i))\n            e2, i = heapq.heappop(min_heap)\n            heapq.heappush(min_heap, (e2+(e-s), i))\n            result[i] += 1\n        return max(xrange(n), key=lambda x:result[x])\n\n\nimport heapq\n\n\n# two heaps solution\nclass Solution2(object):\n    def mostBooked(self, n, meetings):\n        \"\"\"\n        :type n: int\n        :type meetings: List[List[int]]\n        :rtype: \n        \"\"\"\n        meetings.sort()\n        unused, used = range(n), []\n        result = [0]*n\n        for s, e in meetings:\n            while used and used[0][0] <= s:\n                _, i = heapq.heappop(used)\n                heapq.heappush(unused, i)\n            if unused:\n                i = heapq.heappop(unused)\n                heapq.heappush(used, (e, i))\n            else:\n                e2, i = heapq.heappop(used)\n                heapq.heappush(used, (e2+(e-s), i))\n            result[i] += 1\n        return max(xrange(n), key=lambda x:result[x])",
    "explanation": "N/A",
    "time_complexity": "O(mlogm + n + mlogn)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Snapshot Array",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Binary Search, Design",
    "link": "https://leetcode.com/problems/snapshot-array",
    "slug": "snapshot-array",
    "description": "Implement a SnapshotArray that supports the following interface:\n\n\n\n\nSnapshotArray(int length)\n initializes an array-like data structure with the given length. \nInitially, each element equals 0\n.\n\n\nvoid set(index, val)\n sets the element at the given \nindex\n to be equal to \nval\n.\n\n\nint snap()\n takes a snapshot of the array and returns the \nsnap_id\n: the total number of times we called \nsnap()\n minus \n1\n.\n\n\nint get(index, snap_id)\n returns the value at the given \nindex\n, at the time we took the snapshot with the given \nsnap_id\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n [\"SnapshotArray\",\"set\",\"snap\",\"set\",\"get\"]\n[[3],[0,5],[],[0,6],[0,0]]\n\nOutput:\n [null,null,0,null,5]\n\nExplanation: \n\nSnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3\nsnapshotArr.set(0,5);  // Set array[0] = 5\nsnapshotArr.snap();  // Take a snapshot, return snap_id = 0\nsnapshotArr.set(0,6);\nsnapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= length <= 5 * 10\n4\n\n\n0 <= index < length\n\n\n0 <= val <= 10\n9\n\n\n0 <= snap_id < \n(the total number of times we call \nsnap()\n)\n\n\nAt most \n5 * 10\n4\n calls will be made to \nset\n, \nsnap\n, and \nget\n.",
    "solution": "#        get: O(logn), n is the total number of set\n\nimport collections\nimport bisect\n\n\nclass SnapshotArray(object):\n\n    def __init__(self, length):\n        \"\"\"\n        :type length: int\n        \"\"\"\n        self.__A = collections.defaultdict(lambda: [[0, 0]])\n        self.__snap_id = 0\n\n\n    def set(self, index, val):\n        \"\"\"\n        :type index: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        if self.__A[index][-1][0] == self.__snap_id:\n            self.__A[index][-1][1] = val\n        else:\n            self.__A[index].append([self.__snap_id, val])\n\n\n    def snap(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        self.__snap_id += 1\n        return self.__snap_id - 1\n\n\n    def get(self, index, snap_id):\n        \"\"\"\n        :type index: int\n        :type snap_id: int\n        :rtype: int\n        \"\"\"\n        i = bisect.bisect_left(self.__A[index], [snap_id+1, float(\"-inf\")]) - 1\n        return self.__A[index][i][1]",
    "explanation": "N/A",
    "time_complexity": "set: O(1)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Path With Maximum Minimum Value",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search, Depth-First Search, Breadth-First Search, Union Find, Heap (Priority Queue), Matrix",
    "link": "https://leetcode.com/problems/path-with-maximum-minimum-value",
    "slug": "path-with-maximum-minimum-value",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\n# binary search + dfs solution\nclass Solution(object):\n    def maximumMinimumPath(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        def check(A, val, r, c, lookup):\n            if r == len(A)-1 and c == len(A[0])-1:\n                return True\n            lookup.add((r, c))\n            for d in directions:\n                nr, nc = r + d[0], c + d[1]\n                if 0 <= nr < len(A) and \\\n                   0 <= nc < len(A[0]) and \\\n                   (nr, nc) not in lookup and \\\n                   A[nr][nc] >= val and \\\n                   check(A, val, nr, nc, lookup):\n                    return True\n            return False\n        \n        vals, ceil = [], min(A[0][0], A[-1][-1])\n        for i in xrange(len(A)):\n            for j in xrange(len(A[0])):\n                if A[i][j] <= ceil:\n                    vals.append(A[i][j])\n        vals = list(set(vals))\n        vals.sort()\n        left, right = 0, len(vals)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(A, vals[mid], 0, 0, set()):\n                right = mid-1\n            else:\n                left = mid+1\n        return vals[right]\n\n\nimport heapq\n\n\n# Dijkstra algorithm solution\nclass Solution2(object):\n    def maximumMinimumPath(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        max_heap = [(-A[0][0], 0, 0)]\n        lookup = set([(0, 0)])\n        while max_heap:\n            i, r, c = heapq.heappop(max_heap)\n            if r == len(A)-1 and c == len(A[0])-1:\n                return -i\n            for d in directions:\n                nr, nc = r+d[0], c+d[1]\n                if 0 <= nr < len(A) and \\\n                   0 <= nc < len(A[0]) and \\\n                   (nr, nc) not in lookup:\n                    heapq.heappush(max_heap, (-min(-i, A[nr][nc]), nr, nc))\n                    lookup.add((nr, nc))    \n        return -1",
    "explanation": "N/A",
    "time_complexity": "O(m * n * log(m * n))",
    "space_complexity": "O(m * n)"
  },
  {
    "title": "Search Suggestions System",
    "difficulty": "MEDIUM",
    "category": "Array, String, Binary Search, Trie, Sorting, Heap (Priority Queue)",
    "link": "https://leetcode.com/problems/search-suggestions-system",
    "slug": "search-suggestions-system",
    "description": "You are given an array of strings \nproducts\n and a string \nsearchWord\n.\n\n\nDesign a system that suggests at most three product names from \nproducts\n after each character of \nsearchWord\n is typed. Suggested products should have common prefix with \nsearchWord\n. If there are more than three products with a common prefix return the three lexicographically minimums products.\n\n\nReturn \na list of lists of the suggested products after each character of \nsearchWord\n is typed\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n products = [\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"], searchWord = \"mouse\"\n\nOutput:\n [[\"mobile\",\"moneypot\",\"monitor\"],[\"mobile\",\"moneypot\",\"monitor\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"]]\n\nExplanation:\n products sorted lexicographically = [\"mobile\",\"moneypot\",\"monitor\",\"mouse\",\"mousepad\"].\nAfter typing m and mo all products match and we show user [\"mobile\",\"moneypot\",\"monitor\"].\nAfter typing mou, mous and mouse the system suggests [\"mouse\",\"mousepad\"].\n\n\n\nExample 2:\n\n\n\n\nInput:\n products = [\"havana\"], searchWord = \"havana\"\n\nOutput:\n [[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"]]\n\nExplanation:\n The only word \"havana\" will be always suggested while typing the search word.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= products.length <= 1000\n\n\n1 <= products[i].length <= 3000\n\n\n1 <= sum(products[i].length) <= 2 * 10\n4\n\n\nAll the strings of \nproducts\n are \nunique\n.\n\n\nproducts[i]\n consists of lowercase English letters.\n\n\n1 <= searchWord.length <= 1000\n\n\nsearchWord\n consists of lowercase English letters.",
    "solution": "#                      , l is the average length of product name\n#        suggest: O(l^2)\n\nimport collections\n\n\nclass TrieNode(object):\n\n    def __init__(self):\n        self.__TOP_COUNT = 3\n        self.leaves = collections.defaultdict(TrieNode)\n        self.infos = []\n\n    def insert(self, words, i):\n        curr = self\n        for c in words[i]:\n            curr = curr.leaves[c]\n            curr.add_info(words, i)\n\n    def add_info(self, words, i):\n        self.infos.append(i)\n        self.infos.sort(key=lambda x: words[x])\n        if len(self.infos) > self.__TOP_COUNT:\n            self.infos.pop()\n\n\nclass Solution(object):\n    def suggestedProducts(self, products, searchWord):\n        \"\"\"\n        :type products: List[str]\n        :type searchWord: str\n        :rtype: List[List[str]]\n        \"\"\"\n        trie = TrieNode()\n        for i in xrange(len(products)):\n            trie.insert(products, i)\n        result = [[] for _ in xrange(len(searchWord))]\n        for i, c in enumerate(searchWord):\n            if c not in trie.leaves:\n                break\n            trie = trie.leaves[c]\n            result[i] = map(lambda x: products[x], trie.infos)\n        return result\n\n\n#                                   , l is the average length of product name\n#        suggest: O(l^2)\nclass TrieNode2(object):\n\n    def __init__(self):\n        self.__TOP_COUNT = 3\n        self.leaves = collections.defaultdict(TrieNode2)\n        self.infos = []\n\n    def insert(self, words, i):\n        curr = self\n        for c in words[i]:\n            curr = curr.leaves[c]\n            curr.add_info(i)\n\n    def add_info(self, i):\n        if len(self.infos) == self.__TOP_COUNT:\n            return\n        self.infos.append(i)\n\n\nclass Solution2(object):\n    def suggestedProducts(self, products, searchWord):\n        \"\"\"\n        :type products: List[str]\n        :type searchWord: str\n        :rtype: List[List[str]]\n        \"\"\"\n        products.sort()\n        trie = TrieNode2()\n        for i in xrange(len(products)):\n            trie.insert(products, i)\n        result = [[] for _ in xrange(len(searchWord))]\n        for i, c in enumerate(searchWord):\n            if c not in trie.leaves:\n                break\n            trie = trie.leaves[c]\n            result[i] = map(lambda x: products[x], trie.infos)\n        return result\n\n\n#                                   , l is the average length of product name\n#        suggest: O(l^2 * n)\nimport bisect\n\n\nclass Solution3(object):\n    def suggestedProducts(self, products, searchWord):\n        \"\"\"\n        :type products: List[str]\n        :type searchWord: str\n        :rtype: List[List[str]]\n        \"\"\"\n        products.sort()  # Time: O(n * l * log(n * l))\n        result = []\n        prefix = \"\"\n        for i, c in enumerate(searchWord):  # Time: O(l)\n            prefix += c\n            start = bisect.bisect_left(products, prefix)  # Time: O(log(n * l))\n            new_products = []\n            for j in xrange(start, len(products)):  # Time: O(n * l)\n                if not (i < len(products[j]) and products[j][i] == c):\n                    break\n                new_products.append(products[j])\n            products = new_products\n            result.append(products[:3])\n        return result",
    "explanation": "N/A",
    "time_complexity": "ctor: O(n * l * log(n * l)), n is the number of products",
    "space_complexity": "O(n * l)"
  },
  {
    "title": "Same Tree",
    "difficulty": "EASY",
    "category": "Tree, Depth-First Search, Breadth-First Search, Binary Tree",
    "link": "https://leetcode.com/problems/same-tree",
    "slug": "same-tree",
    "description": "Given the roots of two binary trees \np\n and \nq\n, write a function to check if they are the same or not.\n\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n p = [1,2,3], q = [1,2,3]\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n p = [1,2], q = [1,null,2]\n\nOutput:\n false\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n p = [1,2,1], q = [1,1,2]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in both trees is in the range \n[0, 100]\n.\n\n\n-10\n4\n <= Node.val <= 10\n4",
    "solution": "\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param p, a tree node\n    # @param q, a tree node\n    # @return a boolean\n    def isSameTree(self, p, q):\n        if p is None and q is None:\n            return True\n\n        if p is not None and q is not None:\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n        return False",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(h), h is height of binary tree"
  },
  {
    "title": "Course Schedule",
    "difficulty": "MEDIUM",
    "category": "Depth-First Search, Breadth-First Search, Graph, Topological Sort",
    "link": "https://leetcode.com/problems/course-schedule",
    "slug": "course-schedule",
    "description": "There are a total of \nnumCourses\n courses you have to take, labeled from \n0\n to \nnumCourses - 1\n. You are given an array \nprerequisites\n where \nprerequisites[i] = [a\ni\n, b\ni\n]\n indicates that you \nmust\n take course \nb\ni\n first if you want to take course \na\ni\n.\n\n\n\n\nFor example, the pair \n[0, 1]\n, indicates that to take course \n0\n you have to first take course \n1\n.\n\n\n\n\nReturn \ntrue\n if you can finish all courses. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [[1,0]]\n\nOutput:\n true\n\nExplanation:\n There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\n\n\nExample 2:\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [[1,0],[0,1]]\n\nOutput:\n false\n\nExplanation:\n There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numCourses <= 2000\n\n\n0 <= prerequisites.length <= 5000\n\n\nprerequisites[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < numCourses\n\n\nAll the pairs prerequisites[i] are \nunique\n.",
    "solution": "\nimport collections\n\n\n# Khan's algorithm (bfs solution)\nclass Solution(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        q = [u for u in xrange(numCourses) if u not in in_degree]\n        while q:\n            new_q = []\n            for u in q:\n                result.append(u)\n                for v in adj[u]:\n                    in_degree[v] -= 1\n                    if in_degree[v] == 0:\n                        new_q.append(v)\n            q = new_q\n        return len(result) == numCourses\n\n\nimport collections\n\n\n# dfs solution\nclass Solution2(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        stk = [u for u in xrange(numCourses) if u not in in_degree]\n        while stk:\n            u = stk.pop()\n            result.append(u)\n            for v in adj[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    stk.append(v)\n        return len(result) == numCourses",
    "explanation": "N/A",
    "time_complexity": "O(|V| + |E|)",
    "space_complexity": "O(|E|)"
  },
  {
    "title": "Reverse Integer",
    "difficulty": "MEDIUM",
    "category": "Math",
    "link": "https://leetcode.com/problems/reverse-integer",
    "slug": "reverse-integer",
    "description": "Given a signed 32-bit integer \nx\n, return \nx\n with its digits reversed\n. If reversing \nx\n causes the value to go outside the signed 32-bit integer range \n[-2\n31\n, 2\n31\n - 1]\n, then return \n0\n.\n\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 123\n\nOutput:\n 321\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = -123\n\nOutput:\n -321\n\n\n\nExample 3:\n\n\n\n\nInput:\n x = 120\n\nOutput:\n 21\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= x <= 2\n31\n - 1",
    "solution": "\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 0:\n            return -self.reverse(-x)\n\n        result = 0\n        while x:\n            result = result * 10 + x % 10\n            x //= 10\n        return result if result <= 0x7fffffff else 0  # Handle overflow.\n\n    def reverse2(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 0:\n            x = int(str(x)[::-1][-1] + str(x)[::-1][:-1])\n        else:\n            x = int(str(x)[::-1])\n        x = 0 if abs(x) > 0x7FFFFFFF else x\n        return x\n\n    def reverse3(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        s = cmp(x, 0)\n        r = int(repr(s * x)[::-1])\n        return s * r * (r < 2 ** 31)",
    "explanation": "N/A",
    "time_complexity": "O(logn) = O(1)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Number of Provinces",
    "difficulty": "MEDIUM",
    "category": "Depth-First Search, Breadth-First Search, Union Find, Graph",
    "link": "https://leetcode.com/problems/number-of-provinces",
    "slug": "number-of-provinces",
    "description": "There are \nn\n cities. Some of them are connected, while some are not. If city \na\n is connected directly with city \nb\n, and city \nb\n is connected directly with city \nc\n, then city \na\n is connected indirectly with city \nc\n.\n\n\nA \nprovince\n is a group of directly or indirectly connected cities and no other cities outside of the group.\n\n\nYou are given an \nn x n\n matrix \nisConnected\n where \nisConnected[i][j] = 1\n if the \ni\nth\n city and the \nj\nth\n city are directly connected, and \nisConnected[i][j] = 0\n otherwise.\n\n\nReturn \nthe total number of \nprovinces\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 200\n\n\nn == isConnected.length\n\n\nn == isConnected[i].length\n\n\nisConnected[i][j]\n is \n1\n or \n0\n.\n\n\nisConnected[i][i] == 1\n\n\nisConnected[i][j] == isConnected[j][i]",
    "solution": "# Solution not found in kamyu104 repository",
    "explanation": "N/A",
    "time_complexity": "N/A",
    "space_complexity": "N/A"
  },
  {
    "title": "Painting a Grid With Three Different Colors",
    "difficulty": "HARD",
    "category": "Dynamic Programming",
    "link": "https://leetcode.com/problems/painting-a-grid-with-three-different-colors",
    "slug": "painting-a-grid-with-three-different-colors",
    "description": "You are given two integers \nm\n and \nn\n. Consider an \nm x n\n grid where each cell is initially white. You can paint each cell \nred\n, \ngreen\n, or \nblue\n. All cells \nmust\n be painted.\n\n\nReturn\n the number of ways to color the grid with \nno two adjacent cells having the same color\n. Since the answer can be very large, return it \nmodulo\n \n10\n9\n + 7\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n m = 1, n = 1\n\nOutput:\n 3\n\nExplanation:\n The three possible colorings are shown in the image above.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n m = 1, n = 2\n\nOutput:\n 6\n\nExplanation:\n The six possible colorings are shown in the image above.\n\n\n\nExample 3:\n\n\n\n\nInput:\n m = 5, n = 5\n\nOutput:\n 580986\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= m <= 5\n\n\n1 <= n <= 1000",
    "solution": "\nimport collections\nimport itertools\n\n\n# better complexity for small m, super large n\n# matrix exponentiation solution\nclass Solution(object):\n    def colorTheGrid(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def backtracking(mask1, mask2, basis, result):  # Time: O(2^m), Space: O(2^m)\n            if not basis:\n                result.append(mask2)\n                return\n            for i in xrange(3):\n                if (mask1 == -1 or mask1//basis%3 != i) and (mask2 == -1 or mask2//(basis*3)%3 != i):\n                    backtracking(mask1, mask2+i*basis if mask2 != -1 else i*basis, basis//3, result)\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A]\n \n        def matrix_expo(A, K):\n            result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def normalize(basis, mask):\n            norm = {}\n            result = 0\n            while basis:\n                x = mask//basis%3\n                if x not in norm:\n                    norm[x] = len(norm)\n                result += norm[x]*basis\n                basis //= 3\n            return result\n\n        if m > n:\n            m, n = n, m\n        basis = 3**(m-1)\n        masks = []\n        backtracking(-1, -1, basis, masks)  # Time: O(2^m), Space: O(2^m)\n        assert(len(masks) == 3 * 2**(m-1))\n        lookup = {mask:normalize(basis, mask) for mask in masks}  # Time: O(m * 2^m)\n        normalized_mask_cnt = collections.Counter(lookup[mask] for mask in masks)\n        assert(len(normalized_mask_cnt) == 3*2**(m-1) // 3 // (2 if m >= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance\n        adj = collections.defaultdict(list)\n        for mask in normalized_mask_cnt.iterkeys():  # O(3^m) leaves which are all in depth m => Time: O(3^m), Space: O(3^m)\n            backtracking(mask, -1, basis, adj[mask])\n        normalized_adj = collections.defaultdict(lambda:collections.defaultdict(int))\n        for mask1, masks2 in adj.iteritems():\n            for mask2 in masks2:\n                normalized_adj[mask1][lookup[mask2]] = (normalized_adj[mask1][lookup[mask2]]+1)%MOD\n        # divided by 3 * 2 is since the first two colors in upper row are normalized to speed up performance,\n        # since first two colors in lower row which has at most 3 choices could be also normalized, lower bound is upper bound divided by at most 3\n        assert(2*3**m // 3 // 2 // 3 <= sum(len(v) for v in normalized_adj.itervalues()) <= 2*3**m // 3 // 2)\n        return reduce(lambda x,y: (x+y)%MOD,\n                      matrix_mult([normalized_mask_cnt.values()],\n                                   matrix_expo([[normalized_adj[mask1][mask2]\n                                                 for mask2 in normalized_mask_cnt.iterkeys()] \n                                                 for mask1 in normalized_mask_cnt.iterkeys()], n-1))[0],\n                      0)  # Time: O((2^m)^3 * logn), Space: O((2^m)^2)\n\n\nimport collections\n\n\n# better complexity for small m, large n\nclass Solution2(object):\n    def colorTheGrid(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def find_masks(m, basis):  # Time: 3 + 3*2 + 3*2*2 + ... + 3*2^(m-1) = 3 * (2^m - 1) = O(2^m), Space: O(2^m)\n            masks = [0]\n            for c in xrange(m):\n                new_masks = []\n                for mask in masks:\n                    choices = {0, 1, 2}\n                    if c > 0:\n                        choices.discard(mask//basis)  # get left grid\n                    for x in choices:\n                        new_masks.append((x*basis)+(mask//3))  # encoding mask\n                masks = new_masks\n            return masks\n\n        def find_adj(m, basis, dp):\n            #        3*2^(m-1) * (1+2*((3/2)^(m-1)-1)/((3/2)-1)) =\n            #        3*2^(m-1) * (1+4*((3/2)^(m-1)-1)) =\n            #        3*2^(m-1) * (4*(3/2)^(m-1)-3) =\n            #        4*3^m-9*2^(m-1) =\n            #        O(3^m),\n            adj = collections.defaultdict(list)\n            for mask in dp.iterkeys():  # O(2^m)\n                adj[mask].append(mask)\n            for c in xrange(m):\n                assert(sum(len(v) for v in adj.itervalues()) == (3**c * 2**(m-(c-1)) if c >= 1 else 3 * 2**(m-1)) // 3 // (2 if m >= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance\n                new_adj = collections.defaultdict(list)\n                for mask1, mask2s in adj.iteritems():\n                    for mask in mask2s:\n                        choices = {0, 1, 2}\n                        choices.discard(mask%3)  # get up grid\n                        if c > 0:\n                            choices.discard(mask//basis)  # get left grid\n                        for x in choices:\n                            new_adj[mask1].append((x*basis)+(mask//3))  # encoding mask\n                adj = new_adj\n            assert(sum(3**c * 2**(m-(c-1)) if c >= 1 else 3 * 2**(m-1) for c in xrange(m)) == 4*3**m-9*2**(m-1))\n            return adj\n \n        def normalize(basis, mask):\n            norm = {}\n            result = 0\n            while basis:\n                x = mask//basis%3\n                if x not in norm:\n                    norm[x] = len(norm)\n                result += norm[x]*basis\n                basis //= 3\n            return result\n\n        if m > n:\n            m, n = n, m\n        basis = 3**(m-1)\n        masks = find_masks(m, basis)  # alternative of backtracking, Time: O(2^m), Space: O(2^m)\n        assert(len(masks) == 3 * 2**(m-1))\n        lookup = {mask:normalize(basis, mask) for mask in masks}  # Time: O(m * 2^m)\n        dp = collections.Counter(lookup[mask] for mask in masks)  # normalize colors to speed up performance\n        adj = find_adj(m, basis, dp)  # alternative of backtracking, Time: O(3^m), Space: O(3^m)\n        # proof:\n        #   'o' uses the same color with its bottom-left one, \n        #   'x' uses the remaining color different from its left one and bottom-left one,\n        #   k is the cnt of 'o', \n        #     [3, 1(o), 1(x), 1(o), ..., 1(o), 1(x)] => nCr(m-1, k) * 3 * 2 * 2^k for k in xrange(m) = 3 * 2 * (2+1)^(m-1) = 2*3^m combinations\n        #     [2,    2,    1,    2, ...,  2,      1]\n        # another proof:\n        #   given previous pair of colors, each pair of '?' has 3 choices of colors\n        #     [3, ?, ?, ..., ?] => 3 * 2 * 3^(m-1) = 2*3^m combinations\n        #         |  |       |\n        #         3  3       3\n        #         |  |       |\n        #     [2, ?, ?, ..., ?]\n        normalized_adj = collections.defaultdict(lambda:collections.defaultdict(int))\n        for mask1, mask2s in adj.iteritems():\n            for mask2 in mask2s:\n                normalized_adj[lookup[mask1]][lookup[mask2]] = (normalized_adj[lookup[mask1]][lookup[mask2]]+1)%MOD\n        # divided by 3 * 2 is since the first two colors in upper row are normalized to speed up performance,\n        # since first two colors in lower row which has at most 3 choices could be also normalized, lower bound is upper bound divided by at most 3\n        assert(2*3**m // 3 // 2 // 3 <= sum(len(v) for v in normalized_adj.itervalues()) <= 2*3**m // 3 // 2)\n        for _ in xrange(n-1):  # Time: O(n * 3^m), Space: O(2^m)\n            assert(len(dp) == 3*2**(m-1) // 3 // (2 if m >= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance\n            new_dp = collections.Counter()\n            for mask, v in dp.iteritems():\n                for new_mask, cnt in normalized_adj[mask].iteritems():\n                    new_dp[lookup[new_mask]] = (new_dp[lookup[new_mask]] + v*cnt) % MOD\n            dp = new_dp\n        return reduce(lambda x,y: (x+y)%MOD, dp.itervalues(), 0)  # Time: O(2^m)\n\n\nimport collections\n\n\n# better complexity for large m, large n\nclass Solution3(object):\n    def colorTheGrid(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def normalize(basis, mask, lookup):  # compute and cache, at most O(3*2^(m-3)) time and space\n            if mask not in lookup[basis]:\n                norm = {}\n                result, b = 0, basis\n                while b:\n                    x = mask//b%3\n                    if x not in norm:\n                        norm[x] = len(norm)\n                    result += norm[x]*b\n                    b //= 3\n                lookup[basis][mask] = result\n            return lookup[basis][mask]\n\n        if m > n:\n            m, n = n, m\n        basis = b = 3**(m-1)\n        lookup = collections.defaultdict(dict)\n        dp = collections.Counter({0: 1})\n        for idx in xrange(m*n):\n            r, c = divmod(idx, m)\n            # sliding window with size m doesn't cross rows:\n            #   [3, 2, ..., 2] => 3*2^(m-1) combinations\n            assert(r != 0 or c != 0 or len(dp) == 1)\n            assert(r != 0 or c == 0 or len(dp) == 3*2**(c-1) // 3 // (2 if c >= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance\n            assert(r == 0 or c != 0 or len(dp) == 3*2**(m-1) // 3 // (2 if m >= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance\n            # sliding window with size m crosses rows:\n            #   [*, ..., *, *, 3, 2, ..., 2] => 3*3 * 2^(m-2) combinations\n            #   [2, ..., 2, 3, *, *, ..., *]\n            assert(r == 0 or c == 0 or len(dp) == (1 if m == 1 else 2 if m == 2 else 3*3 * 2**(m-2) // 3 // 2))  # divided by 3 * 2 for m >= 3 is since the first two colors of window are normalized to speed up performance\n            new_dp = collections.Counter()\n            for mask, v in dp.iteritems():\n                choices = {0, 1, 2}\n                if r > 0:\n                    choices.discard(mask%3)  # get up grid\n                if c > 0:\n                    choices.discard(mask//basis)  # get left grid\n                for x in choices:\n                    new_mask = normalize(basis//b, ((x*basis)+(mask//3))//b, lookup)*b  # encoding mask\n                    new_dp[new_mask] = (new_dp[new_mask]+v)%MOD\n            if b > 1:\n                b //= 3\n            dp = new_dp\n        return reduce(lambda x,y: (x+y)%MOD, dp.itervalues(), 0)  # Time: O(2^m)",
    "explanation": "N/A",
    "time_complexity": "(m * n grids) * (O(3*3*2^(m-2)) possible states per grid) = O(n * m * 2^m)",
    "space_complexity": "O(3*3*2^(m-2)) = O(2^m)"
  },
  {
    "title": "Merge k Sorted Lists",
    "difficulty": "HARD",
    "category": "Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort",
    "link": "https://leetcode.com/problems/merge-k-sorted-lists",
    "slug": "merge-k-sorted-lists",
    "description": "You are given an array of \nk\n linked-lists \nlists\n, each linked-list is sorted in ascending order.\n\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n lists = [[1,4,5],[1,3,4],[2,6]]\n\nOutput:\n [1,1,2,3,4,4,5,6]\n\nExplanation:\n The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted linked list:\n1->1->2->3->4->4->5->6\n\n\n\nExample 2:\n\n\n\n\nInput:\n lists = []\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n lists = [[]]\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nk == lists.length\n\n\n0 <= k <= 10\n4\n\n\n0 <= lists[i].length <= 500\n\n\n-10\n4\n <= lists[i][j] <= 10\n4\n\n\nlists[i]\n is sorted in \nascending order\n.\n\n\nThe sum of \nlists[i].length\n will not exceed \n10\n4\n.",
    "solution": "\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\t\t\n        if self:\t\t\n            return \"{} -> {}\".format(self.val, self.next)\n\n\n# Merge two by two solution.\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        if not lists:\n            return None\n        left, right = 0, len(lists) - 1\n        while right > 0:\n            lists[left] = mergeTwoLists(lists[left], lists[right])\n            left += 1\n            right -= 1\n            if left >= right:\n                left = 0\n        return lists[0]\n\n\n# Divide and Conquer solution.\nclass Solution2(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        def mergeKListsHelper(lists, begin, end):\n            if begin > end:\n                return None\n            if begin == end:\n                return lists[begin]\n            return mergeTwoLists(mergeKListsHelper(lists, begin, (begin + end) / 2), \\\n                                 mergeKListsHelper(lists, (begin + end) / 2 + 1, end))\n\n        return mergeKListsHelper(lists, 0, len(lists) - 1)\n\n\n# Heap solution.\nimport heapq\nclass Solution3(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        dummy = ListNode(0)\n        current = dummy\n\n        heap = []\n        for sorted_list in lists:\n            if sorted_list:\n                heapq.heappush(heap, (sorted_list.val, sorted_list))\n\n        while heap:\n            smallest = heapq.heappop(heap)[1]\n            current.next = smallest\n            current = current.next\n            if smallest.next:\n                heapq.heappush(heap, (smallest.next.val, smallest.next))\n\n        return dummy.next",
    "explanation": "N/A",
    "time_complexity": "O(nlogk)",
    "space_complexity": "O(k)"
  },
  {
    "title": "Reverse Nodes in k-Group",
    "difficulty": "HARD",
    "category": "Linked List, Recursion",
    "link": "https://leetcode.com/problems/reverse-nodes-in-k-group",
    "slug": "reverse-nodes-in-k-group",
    "description": "Given the \nhead\n of a linked list, reverse the nodes of the list \nk\n at a time, and return \nthe modified list\n.\n\n\nk\n is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of \nk\n then left-out nodes, in the end, should remain as it is.\n\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 2\n\nOutput:\n [2,1,4,3,5]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], k = 3\n\nOutput:\n [3,2,1,4,5]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is \nn\n.\n\n\n1 <= k <= n <= 5000\n\n\n0 <= Node.val <= 1000\n\n\n\n\n \n\n\nFollow-up:\n Can you solve the problem in \nO(1)\n extra memory space?",
    "solution": "\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution(object):\n    # @param head, a ListNode\n    # @param k, an integer\n    # @return a ListNode\n    def reverseKGroup(self, head, k):\n        dummy = ListNode(-1)\n        dummy.next = head\n\n        cur, cur_dummy = head, dummy\n        length = 0\n\n        while cur:\n            next_cur = cur.next\n            length = (length + 1) % k\n\n            if length == 0:\n                next_dummy = cur_dummy.next\n                self.reverse(cur_dummy, cur.next)\n                cur_dummy = next_dummy\n\n            cur = next_cur\n\n        return dummy.next\n\n    def reverse(self, begin, end):\n            first = begin.next\n            cur = first.next\n\n            while cur != end:\n                first.next = cur.next\n                cur.next = begin.next\n                begin.next = cur\n                cur = first.next",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Separate Squares I",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/separate-squares-i",
    "slug": "separate-squares-i",
    "description": "You are given a 2D integer array \nsquares\n. Each \nsquares[i] = [x\ni\n, y\ni\n, l\ni\n]\n represents the coordinates of the bottom-left point and the side length of a square parallel to the x-axis.\n\n\nFind the \nminimum\n y-coordinate value of a horizontal line such that the total area of the squares above the line \nequals\n the total area of the squares below the line.\n\n\nAnswers within \n10\n-5\n of the actual answer will be accepted.\n\n\nNote\n: Squares \nmay\n overlap. Overlapping areas should be counted \nmultiple times\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nsquares = [[0,0,1],[2,2,1]]\n\n\nOutput:\n \n1.00000\n\n\nExplanation:\n\n\n\n\nAny horizontal line between \ny = 1\n and \ny = 2\n will have 1 square unit above it and 1 square unit below it. The lowest option is 1.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nsquares = [[0,0,2],[1,1,1]]\n\n\nOutput:\n \n1.16667\n\n\nExplanation:\n\n\n\n\nThe areas are:\n\n\n\n\nBelow the line: \n7/6 * 2 (Red) + 1/6 (Blue) = 15/6 = 2.5\n.\n\n\nAbove the line: \n5/6 * 2 (Red) + 5/6 (Blue) = 15/6 = 2.5\n.\n\n\n\n\nSince the areas above and below the line are equal, the output is \n7/6 = 1.16667\n.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= squares.length <= 5 * 10\n4\n\n\nsquares[i] = [x\ni\n, y\ni\n, l\ni\n]\n\n\nsquares[i].length == 3\n\n\n0 <= x\ni\n, y\ni\n <= 10\n9\n\n\n1 <= l\ni\n <= 10\n9\n\n\nThe total area of all the squares will not exceed \n10\n12\n.",
    "solution": "\n# sort, line sweep\nclass Solution(object):\n    def separateSquares(self, squares):\n        \"\"\"\n        :type squares: List[List[int]]\n        :rtype: float\n        \"\"\"\n        events = []\n        for x, y, l in squares:\n            events.append((y, 1, l))\n            events.append((y+l, -1, l))\n        events.sort(key=lambda e: e[0])\n        total = curr = 0.0\n        prev = events[0][0]\n        for y, v, l in events:\n            if y != prev:\n                total += (y-prev)*curr\n                prev = y\n            curr += l*v\n        expect = total/2.0\n        total = curr = 0.0\n        prev = events[0][0]\n        for y, v, l in events:\n            if y != prev:\n                if total+(y-prev)*curr >= expect:\n                    break\n                total += (y-prev)*curr\n                prev = y\n            curr += l*v\n        return prev+(expect-total)/curr\n\n\n# binary search\nclass Solution2(object):\n    def separateSquares(self, squares):\n        \"\"\"\n        :type squares: List[List[int]]\n        :rtype: float\n        \"\"\"\n        EPS = 1e-5\n        def binary_search(left, right, check):\n            while right-left > EPS:\n                mid = left+(right-left)/2.0\n                if check(mid):\n                    right = mid\n                else:\n                    left = mid\n            return left\n    \n        def check(k):\n            result = 0\n            for x, y, l in squares:\n                if y >= k:\n                    result += l**2\n                elif y+l <= k:\n                    result -= l**2\n                else:\n                    result += l*(((y+l)-k)-(k-y))\n            return result <= 0\n    \n        return binary_search(min(y for _, y, _ in squares), max(y+l for _, y, l in squares), check)",
    "explanation": "N/A",
    "time_complexity": "O(nlogr)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Daily Temperatures",
    "difficulty": "MEDIUM",
    "category": "Array, Stack, Monotonic Stack",
    "link": "https://leetcode.com/problems/daily-temperatures",
    "slug": "daily-temperatures",
    "description": "Given an array of integers \ntemperatures\n represents the daily temperatures, return \nan array\n \nanswer\n \nsuch that\n \nanswer[i]\n \nis the number of days you have to wait after the\n \ni\nth\n \nday to get a warmer temperature\n. If there is no future day for which this is possible, keep \nanswer[i] == 0\n instead.\n\n\n \n\n\nExample 1:\n\n\nInput:\n temperatures = [73,74,75,71,69,72,76,73]\n\nOutput:\n [1,1,4,2,1,1,0,0]\n\nExample 2:\n\n\nInput:\n temperatures = [30,40,50,60]\n\nOutput:\n [1,1,1,0]\n\nExample 3:\n\n\nInput:\n temperatures = [30,60,90]\n\nOutput:\n [1,1,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= temperatures.length <= 10\n5\n\n\n30 <= temperatures[i] <= 100",
    "solution": "\nclass Solution(object):\n    def dailyTemperatures(self, temperatures):\n        \"\"\"\n        :type temperatures: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0] * len(temperatures)\n        stk = []\n        for i in xrange(len(temperatures)):\n            while stk and \\\n                  temperatures[stk[-1]] < temperatures[i]:\n                idx = stk.pop()\n                result[idx] = i-idx\n            stk.append(i)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  }
]