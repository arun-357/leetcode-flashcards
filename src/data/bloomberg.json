[
  {
    "title": "Two Sum",
    "difficulty": "EASY",
    "category": "Array, Hash Table",
    "link": "https://leetcode.com/problems/two-sum",
    "slug": "two-sum",
    "description": "Given an array of integers \nnums\n and an integer \ntarget\n, return \nindices of the two numbers such that they add up to \ntarget\n.\n\n\nYou may assume that each input would have \nexactly\n one solution\n, and you may not use the \nsame\n element twice.\n\n\nYou can return the answer in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,7,11,15], target = 9\n\nOutput:\n [0,1]\n\nExplanation:\n Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,4], target = 6\n\nOutput:\n [1,2]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,3], target = 6\n\nOutput:\n [0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n-10\n9\n <= target <= 10\n9\n\n\nOnly one valid answer exists.\n\n\n\n\n \n\n\nFollow-up: \nCan you come up with an algorithm that is less than \nO(n\n2\n)\n \ntime complexity?",
    "solution": "\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        lookup = {}\n        for i, num in enumerate(nums):\n            if target - num in lookup:\n                return [lookup[target - num], i]\n            lookup[num] = i\n\n    def twoSum2(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        for i in nums:\n            j = target - i\n            tmp_nums_start_index = nums.index(i) + 1\n            tmp_nums = nums[tmp_nums_start_index:]\n            if j in tmp_nums:\n                return [nums.index(i), tmp_nums_start_index + tmp_nums.index(j)]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "MEDIUM",
    "category": "Hash Table, String, Sliding Window",
    "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters",
    "slug": "longest-substring-without-repeating-characters",
    "description": "Given a string \ns\n, find the length of the \nlongest\n \nsubstring\n without duplicate characters.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abcabcbb\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"abc\", with the length of 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"bbbbb\"\n\nOutput:\n 1\n\nExplanation:\n The answer is \"b\", with the length of 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"pwwkew\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 5 * 10\n4\n\n\ns\n consists of English letters, digits, symbols and spaces.",
    "solution": "\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, left = 0, 0\n        lookup = {}\n        for right in xrange(len(s)):\n            if s[right] in lookup:\n                left = max(left, lookup[s[right]]+1)\n            lookup[s[right]] = right\n            result = max(result, right-left+1)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Container With Most Water",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers, Greedy",
    "link": "https://leetcode.com/problems/container-with-most-water",
    "slug": "container-with-most-water",
    "description": "You are given an integer array \nheight\n of length \nn\n. There are \nn\n vertical lines drawn such that the two endpoints of the \ni\nth\n line are \n(i, 0)\n and \n(i, height[i])\n.\n\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\n\nReturn \nthe maximum amount of water a container can store\n.\n\n\nNotice\n that you may not slant the container.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [1,8,6,2,5,4,8,3,7]\n\nOutput:\n 49\n\nExplanation:\n The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [1,1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= height[i] <= 10\n4",
    "solution": "\nclass Solution(object):\n    # @return an integer\n    def maxArea(self, height):\n        max_area, i, j = 0, 0, len(height) - 1\n        while i < j:\n            max_area = max(max_area, min(height[i], height[j]) * (j - i))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return max_area",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Decode String",
    "difficulty": "MEDIUM",
    "category": "String, Stack, Recursion",
    "link": "https://leetcode.com/problems/decode-string",
    "slug": "decode-string",
    "description": "Given an encoded string, return its decoded string.\n\n\nThe encoding rule is: \nk[encoded_string]\n, where the \nencoded_string\n inside the square brackets is being repeated exactly \nk\n times. Note that \nk\n is guaranteed to be a positive integer.\n\n\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, \nk\n. For example, there will not be input like \n3a\n or \n2[4]\n.\n\n\nThe test cases are generated so that the length of the output will never exceed \n10\n5\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"3[a]2[bc]\"\n\nOutput:\n \"aaabcbc\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"3[a2[c]]\"\n\nOutput:\n \"accaccacc\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"2[abc]3[cd]ef\"\n\nOutput:\n \"abcabccdcdcdef\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 30\n\n\ns\n consists of lowercase English letters, digits, and square brackets \n'[]'\n.\n\n\ns\n is guaranteed to be \na valid\n input.\n\n\nAll the integers in \ns\n are in the range \n[1, 300]\n.",
    "solution": "\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n, curr, nums, strs = 0, [], [], []\n        for c in s:\n            if c.isdigit():\n                n = n*10 + ord(c)-ord('0')\n            elif c.isalpha():\n                curr.append(c)\n            elif c == '[':\n                nums.append(n)\n                strs.append(curr)\n                n, curr = 0, []\n            elif c == ']':\n                strs[-1].extend(curr*nums.pop())\n                curr = strs.pop()\n        return \"\".join(curr)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Valid Anagram",
    "difficulty": "EASY",
    "category": "Hash Table, String, Sorting",
    "link": "https://leetcode.com/problems/valid-anagram",
    "slug": "valid-anagram",
    "description": "Given two strings \ns\n and \nt\n, return \ntrue\n if \nt\n is an \nanagram\n of \ns\n, and \nfalse\n otherwise.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"anagram\", t = \"nagaram\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"rat\", t = \"car\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length, t.length <= 5 * 10\n4\n\n\ns\n and \nt\n consist of lowercase English letters.\n\n\n\n\n \n\n\nFollow up:\n What if the inputs contain Unicode characters? How would you adapt your solution to such a case?",
    "solution": "\nimport collections\n\n\nclass Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s) != len(t):\n            return False\n        count = collections.defaultdict(int)\n        for c in s:\n            count[c] += 1\n        for c in t:\n            count[c] -= 1\n            if count[c] < 0:\n                return False\n        return True\n\n\nclass Solution2(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        return collections.Counter(s) == collections.Counter(t)\n\n\nclass Solution3(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        return sorted(s) == sorted(t)",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Contains Duplicate",
    "difficulty": "EASY",
    "category": "Array, Hash Table, Sorting",
    "link": "https://leetcode.com/problems/contains-duplicate",
    "slug": "contains-duplicate",
    "description": "Given an integer array \nnums\n, return \ntrue\n if any value appears \nat least twice\n in the array, and return \nfalse\n if every element is distinct.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,2,3,1]\n\n\nOutput:\n \ntrue\n\n\nExplanation:\n\n\nThe element 1 occurs at the indices 0 and 3.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,2,3,4]\n\n\nOutput:\n \nfalse\n\n\nExplanation:\n\n\nAll elements are distinct.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,1,1,3,3,4,3,2,4,2]\n\n\nOutput:\n \ntrue\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9",
    "solution": "\nclass Solution(object):\n    # @param {integer[]} nums\n    # @return {boolean}\n    def containsDuplicate(self, nums):\n        return len(nums) > len(set(nums))",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Flatten a Multilevel Doubly Linked List",
    "difficulty": "MEDIUM",
    "category": "Linked List, Depth-First Search, Doubly-Linked List",
    "link": "https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list",
    "slug": "flatten-a-multilevel-doubly-linked-list",
    "description": "You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional \nchild pointer\n. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a \nmultilevel data structure\n as shown in the example below.\n\n\nGiven the \nhead\n of the first level of the list, \nflatten\n the list so that all the nodes appear in a single-level, doubly linked list. Let \ncurr\n be a node with a child list. The nodes in the child list should appear \nafter\n \ncurr\n and \nbefore\n \ncurr.next\n in the flattened list.\n\n\nReturn \nthe \nhead\n of the flattened list. The nodes in the list must have \nall\n of their child pointers set to \nnull\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n\nOutput:\n [1,2,3,7,8,11,12,9,10,4,5,6]\n\nExplanation:\n The multilevel linked list in the input is shown.\nAfter flattening the multilevel linked list it becomes:\n\n\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [1,2,null,3]\n\nOutput:\n [1,3,2]\n\nExplanation:\n The multilevel linked list in the input is shown.\nAfter flattening the multilevel linked list it becomes:\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = []\n\nOutput:\n []\n\nExplanation:\n There could be empty list in the input.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of Nodes will not exceed \n1000\n.\n\n\n1 <= Node.val <= 10\n5\n\n\n\n\n \n\n\nHow the multilevel linked list is represented in test cases:\n\n\nWe use the multilevel linked list from \nExample 1\n above:\n\n\n\n 1---2---3---4---5---6--NULL\n         |\n         7---8---9---10--NULL\n             |\n             11--12--NULL\n\n\nThe serialization of each level is as follows:\n\n\n\n[1,2,3,4,5,6,null]\n[7,8,9,10,null]\n[11,12,null]\n\n\n\nTo serialize all levels together, we will add nulls in each level to signify no node connects to the upper node of the previous level. The serialization becomes:\n\n\n\n[1,    2,    3, 4, 5, 6, null]\n             |\n[null, null, 7,    8, 9, 10, null]\n                   |\n[            null, 11, 12, null]\n\n\n\nMerging the serialization of each level and removing trailing nulls we obtain:\n\n\n\n[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]",
    "solution": "\nclass Node(object):\n    def __init__(self, val, prev, next, child):\n        self.val = val\n        self.prev = prev\n        self.next = next\n        self.child = child\n\n\nclass Solution(object):\n    def flatten(self, head):\n        \"\"\"\n        :type head: Node\n        :rtype: Node\n        \"\"\"\n        curr = head\n        while curr:\n            if curr.child:\n                curr_next = curr.next\n                curr.child.prev = curr\n                curr.next = curr.child\n                last_child = curr\n                while last_child.next:\n                    last_child = last_child.next\n                if curr_next:\n                    last_child.next = curr_next\n                    curr_next.prev = last_child\n                curr.child = None\n            curr = curr.next\n        return head",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Word Search",
    "difficulty": "MEDIUM",
    "category": "Array, String, Backtracking, Depth-First Search, Matrix",
    "link": "https://leetcode.com/problems/word-search",
    "slug": "word-search",
    "description": "Given an \nm x n\n grid of characters \nboard\n and a string \nword\n, return \ntrue\n \nif\n \nword\n \nexists in the grid\n.\n\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == board.length\n\n\nn = board[i].length\n\n\n1 <= m, n <= 6\n\n\n1 <= word.length <= 15\n\n\nboard\n and \nword\n consists of only lowercase and uppercase English letters.\n\n\n\n\n \n\n\nFollow up:\n Could you use search pruning to make your solution faster with a larger \nboard\n?",
    "solution": "\nclass Solution(object):\n    # @param board, a list of lists of 1 length string\n    # @param word, a string\n    # @return a boolean\n    def exist(self, board, word):\n        visited = [[False for j in xrange(len(board[0]))] for i in xrange(len(board))]\n\n        for i in xrange(len(board)):\n            for j in xrange(len(board[0])):\n                if self.existRecu(board, word, 0, i, j, visited):\n                    return True\n\n        return False\n\n    def existRecu(self, board, word, cur, i, j, visited):\n        if cur == len(word):\n            return True\n\n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[cur]:\n            return False\n\n        visited[i][j] = True\n        result = self.existRecu(board, word, cur + 1, i + 1, j, visited) or\\\n                 self.existRecu(board, word, cur + 1, i - 1, j, visited) or\\\n                 self.existRecu(board, word, cur + 1, i, j + 1, visited) or\\\n                 self.existRecu(board, word, cur + 1, i, j - 1, visited)\n        visited[i][j] = False\n\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(m * n * 4 * 3^(l - 1)) ~= O(m * n * 3^l), l is the length of the word",
    "space_complexity": "O(l)"
  },
  {
    "title": "Rotate Image",
    "difficulty": "MEDIUM",
    "category": "Array, Math, Matrix",
    "link": "https://leetcode.com/problems/rotate-image",
    "slug": "rotate-image",
    "description": "You are given an \nn x n\n 2D \nmatrix\n representing an image, rotate the image by \n90\n degrees (clockwise).\n\n\nYou have to rotate the image \nin-place\n, which means you have to modify the input 2D matrix directly. \nDO NOT\n allocate another 2D matrix and do the rotation.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [[7,4,1],[8,5,2],[9,6,3]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n\nOutput:\n [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 20\n\n\n-1000 <= matrix[i][j] <= 1000",
    "solution": "\nclass Solution(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        n = len(matrix)\n\n        # anti-diagonal mirror\n        for i in xrange(n):\n            for j in xrange(n - i):\n                matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j]\n\n        # horizontal mirror\n        for i in xrange(n / 2):\n            for j in xrange(n):\n                matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]\n\n        return matrix\n\nclass Solution2(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        return [list(reversed(x)) for x in zip(*matrix)]",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n^2)"
  },
  {
    "title": "Valid Parentheses",
    "difficulty": "EASY",
    "category": "String, Stack",
    "link": "https://leetcode.com/problems/valid-parentheses",
    "slug": "valid-parentheses",
    "description": "Given a string \ns\n containing just the characters \n'('\n, \n')'\n, \n'{'\n, \n'}'\n, \n'['\n and \n']'\n, determine if the input string is valid.\n\n\nAn input string is valid if:\n\n\n\n\nOpen brackets must be closed by the same type of brackets.\n\n\nOpen brackets must be closed in the correct order.\n\n\nEvery close bracket has a corresponding open bracket of the same type.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"()\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"()[]{}\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"(]\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"([])\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"([)]\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of parentheses only \n'()[]{}'\n.",
    "solution": "\nclass Solution(object):\n    # @return a boolean\n    def isValid(self, s):\n        stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        for parenthese in s:\n            if parenthese in lookup:\n                stack.append(parenthese)\n            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:\n                return False\n        return len(stack) == 0",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Longest Common Prefix",
    "difficulty": "EASY",
    "category": "String, Trie",
    "link": "https://leetcode.com/problems/longest-common-prefix",
    "slug": "longest-common-prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings.\n\n\nIf there is no common prefix, return an empty string \n\"\"\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n strs = [\"flower\",\"flow\",\"flight\"]\n\nOutput:\n \"fl\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n strs = [\"dog\",\"racecar\",\"car\"]\n\nOutput:\n \"\"\n\nExplanation:\n There is no common prefix among the input strings.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 200\n\n\n0 <= strs[i].length <= 200\n\n\nstrs[i]\n consists of only lowercase English letters if it is non-empty.",
    "solution": "\nclass Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n\n        for i in xrange(len(strs[0])):\n            for string in strs[1:]:\n                if i >= len(string) or string[i] != strs[0][i]:\n                    return strs[0][:i]\n        return strs[0]\n\n\nclass Solution2(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        prefix = \"\"\n        \n        for chars in zip(*strs):\n            if all(c == chars[0] for c in chars):\n                prefix += chars[0]\n            else:\n                return prefix\n            \n        return prefix",
    "explanation": "N/A",
    "time_complexity": "O(n * k), k is the length of the common prefix",
    "space_complexity": "O(k)"
  },
  {
    "title": "Trapping Rain Water",
    "difficulty": "HARD",
    "category": "Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack",
    "link": "https://leetcode.com/problems/trapping-rain-water",
    "slug": "trapping-rain-water",
    "description": "Given \nn\n non-negative integers representing an elevation map where the width of each bar is \n1\n, compute how much water it can trap after raining.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [0,1,0,2,1,0,1,3,2,1,2,1]\n\nOutput:\n 6\n\nExplanation:\n The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [4,2,0,3,2,5]\n\nOutput:\n 9\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n1 <= n <= 2 * 10\n4\n\n\n0 <= height[i] <= 10\n5",
    "solution": "\nclass Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result, left, right, level = 0, 0, len(height)-1, 0\n        while left < right:\n            if height[left] < height[right]:\n                lower = height[left]\n                left += 1\n            else:\n                lower = height[right]\n                right -= 1\n            level = max(level, lower)\n            result += level-lower\n        return result\n\n\nclass Solution2(object):\n    # @param A, a list of integers\n    # @return an integer\n    def trap(self, A):\n        result = 0\n        top = 0\n        for i in xrange(len(A)):\n            if A[top] < A[i]:\n                top = i\n\n        second_top = 0\n        for i in xrange(top):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        second_top = len(A) - 1\n        for i in reversed(xrange(top, len(A))):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        return result\n\n\nclass Solution3(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        right = [0]*len(height)\n        mx = 0\n        for i in reversed(xrange(len(height))):\n            right[i] = mx\n            mx = max(mx, height[i])\n        result = left = 0\n        for i in xrange(len(height)):\n            left = max(left, height[i])\n            result += max(min(left, right[i])-height[i], 0)\n        return result\n\n\nclass Solution4(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        stk = []\n        for i in xrange(len(height)):\n            prev = 0\n            while stk and height[stk[-1]] <= height[i]:\n                j = stk.pop()\n                result += (height[j] - prev) * (i - j - 1)\n                prev = height[j]\n            if stk:\n                result += (height[i] - prev) * (i - stk[-1] - 1)\n            stk.append(i)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Subsets",
    "difficulty": "MEDIUM",
    "category": "Array, Backtracking, Bit Manipulation",
    "link": "https://leetcode.com/problems/subsets",
    "slug": "subsets",
    "description": "Given an integer array \nnums\n of \nunique\n elements, return \nall possible\n \nsubsets\n \n(the power set)\n.\n\n\nThe solution set \nmust not\n contain duplicate subsets. Return the solution in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0]\n\nOutput:\n [[],[0]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n\n\n-10 <= nums[i] <= 10\n\n\nAll the numbers of \nnums\n are \nunique\n.",
    "solution": "\nclass Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        result = [[]]\n        for i in xrange(len(nums)):\n            size = len(result)\n            for j in xrange(size):\n                result.append(list(result[j]))\n                result[-1].append(nums[i])\n        return result\n\n\nclass Solution2(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i, count = 0, 1 << len(nums)\n        nums.sort()\n\n        while i < count:\n            cur = []\n            for j in xrange(len(nums)):\n                if i & 1 << j:\n                    cur.append(nums[j])\n            result.append(cur)\n            i += 1\n\n        return result\n\n\nclass Solution3(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        return self.subsetsRecu([], sorted(nums))\n\n    def subsetsRecu(self, cur, nums):\n        if not nums:\n            return [cur]\n\n        return self.subsetsRecu(cur, nums[1:]) + self.subsetsRecu(cur + [nums[0]], nums[1:])",
    "explanation": "N/A",
    "time_complexity": "O(n * 2^n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Merge Intervals",
    "difficulty": "MEDIUM",
    "category": "Array, Sorting",
    "link": "https://leetcode.com/problems/merge-intervals",
    "slug": "merge-intervals",
    "description": "Given an array of \nintervals\n where \nintervals[i] = [start\ni\n, end\ni\n]\n, merge all overlapping intervals, and return \nan array of the non-overlapping intervals that cover all the intervals in the input\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n intervals = [[1,3],[2,6],[8,10],[15,18]]\n\nOutput:\n [[1,6],[8,10],[15,18]]\n\nExplanation:\n Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\n\n\nExample 2:\n\n\n\n\nInput:\n intervals = [[1,4],[4,5]]\n\nOutput:\n [[1,5]]\n\nExplanation:\n Intervals [1,4] and [4,5] are considered overlapping.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= intervals.length <= 10\n4\n\n\nintervals[i].length == 2\n\n\n0 <= start\ni\n <= end\ni\n <= 10\n4",
    "solution": "\nclass Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        intervals.sort()\n        result = []\n        for interval in intervals:\n            if not result or interval[0] > result[-1][1]:\n                result.append(interval)\n            else:\n                result[-1][1] = max(result[-1][1], interval[1])\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Divide Array Into Arrays With Max Difference",
    "difficulty": "MEDIUM",
    "category": "Array, Greedy, Sorting",
    "link": "https://leetcode.com/problems/divide-array-into-arrays-with-max-difference",
    "slug": "divide-array-into-arrays-with-max-difference",
    "description": "You are given an integer array \nnums\n of size \nn\n where \nn\n is a multiple of 3 and a positive integer \nk\n.\n\n\nDivide the array \nnums\n into \nn / 3\n arrays of size \n3\n satisfying the following condition:\n\n\n\n\nThe difference between \nany\n two elements in one array is \nless than or equal\n to \nk\n.\n\n\n\n\nReturn a \n2D\n array containing the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return \nany\n of them.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [1,3,4,8,7,9,3,5,1], k = 2\n\n\nOutput:\n \n[[1,1,3],[3,4,5],[7,8,9]]\n\n\nExplanation:\n\n\nThe difference between any two elements in each array is less than or equal to 2.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [2,4,2,2,5,2], k = 2\n\n\nOutput:\n \n[]\n\n\nExplanation:\n\n\nDifferent ways to divide \nnums\n into 2 arrays of size 3 are:\n\n\n\n\n[[2,2,2],[2,4,5]] (and its permutations)\n\n\n[[2,2,4],[2,2,5]] (and its permutations)\n\n\n\n\nBecause there are four 2s there will be an array with the elements 2 and 5 no matter how we divide it. since \n5 - 2 = 3 > k\n, the condition is not satisfied and so there is no valid division.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [4,2,9,8,2,12,7,12,10,5,8,5,5,7,9,2,5,11], k = 14\n\n\nOutput:\n \n[[2,2,2],[4,5,5],[5,5,7],[7,8,8],[9,9,10],[11,12,12]]\n\n\nExplanation:\n\n\nThe difference between any two elements in each array is less than or equal to 14.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n1 <= n <= 10\n5\n\n\nn \nis a multiple of 3\n\n\n1 <= nums[i] <= 10\n5\n\n\n1 <= k <= 10\n5",
    "solution": "\n# sort\nclass Solution(object):\n    def divideArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        return [nums[i:i+3] for i in xrange(0, len(nums), 3)] if all(nums[i+2]-nums[i] <= k for i in xrange(0, len(nums), 3)) else []",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Generate Tag for Video Caption",
    "difficulty": "EASY",
    "category": "String, Simulation",
    "link": "https://leetcode.com/problems/generate-tag-for-video-caption",
    "slug": "generate-tag-for-video-caption",
    "description": "You are given a string \ncaption\n representing the caption for a video.\n\n\nThe following actions must be performed \nin order\n to generate a \nvalid tag\n for the video:\n\n\n\n\n\n\nCombine all words\n in the string into a single \ncamelCase string\n prefixed with \n'#'\n. A \ncamelCase string\n is one where the first letter of all words \nexcept\n the first one is capitalized. All characters after the first character in \neach\n word must be lowercase.\n\n\n\n\n\n\nRemove\n all characters that are not an English letter, \nexcept\n the first \n'#'\n.\n\n\n\n\n\n\nTruncate\n the result to a maximum of 100 characters.\n\n\n\n\n\n\nReturn the \ntag\n after performing the actions on \ncaption\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ncaption = \"Leetcode daily streak achieved\"\n\n\nOutput:\n \n\"#leetcodeDailyStreakAchieved\"\n\n\nExplanation:\n\n\nThe first letter for all words except \n\"leetcode\"\n should be capitalized.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ncaption = \"can I Go There\"\n\n\nOutput:\n \n\"#canIGoThere\"\n\n\nExplanation:\n\n\nThe first letter for all words except \n\"can\"\n should be capitalized.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ncaption = \"hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\"\n\n\nOutput:\n \n\"#hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\"\n\n\nExplanation:\n\n\nSince the first word has length 101, we need to truncate the last two letters from the word.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= caption.length <= 150\n\n\ncaption\n consists only of English letters and \n' '\n.",
    "solution": "\n# string\nclass Solution(object):\n    def generateTag(self, caption):\n        \"\"\"\n        :type caption: str\n        :rtype: str\n        \"\"\"\n        L = 100\n        result = ['#']\n        for i in xrange(len(caption)):\n            if caption[i] == ' ':\n                continue\n            result.append(caption[i].upper() if i == 0 or caption[i-1] == ' ' else caption[i].lower())\n            if len(result) == L:\n                break\n        if 1 < len(result):\n            result[1] = result[1].lower()\n        return \"\".join(result)\n\n\n# string\nclass Solution2(object):\n    def generateTag(self, caption):\n        \"\"\"\n        :type caption: str\n        :rtype: str\n        \"\"\"\n        L = 100\n        return ('#'+\"\".join(x.lower() if i == 0 else x[0].upper()+x[1:].lower() for i, x in enumerate(caption.split())))[:L]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Maximum Difference Between Increasing Elements",
    "difficulty": "EASY",
    "category": "Array",
    "link": "https://leetcode.com/problems/maximum-difference-between-increasing-elements",
    "slug": "maximum-difference-between-increasing-elements",
    "description": "Given a \n0-indexed\n integer array \nnums\n of size \nn\n, find the \nmaximum difference\n between \nnums[i]\n and \nnums[j]\n (i.e., \nnums[j] - nums[i]\n), such that \n0 <= i < j < n\n and \nnums[i] < nums[j]\n.\n\n\nReturn \nthe \nmaximum difference\n. \nIf no such \ni\n and \nj\n exists, return \n-1\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [7,\n1\n,\n5\n,4]\n\nOutput:\n 4\n\nExplanation:\n\nThe maximum difference occurs with i = 1 and j = 2, nums[j] - nums[i] = 5 - 1 = 4.\nNote that with i = 1 and j = 0, the difference nums[j] - nums[i] = 7 - 1 = 6, but i > j, so it is not valid.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [9,4,3,2]\n\nOutput:\n -1\n\nExplanation:\n\nThere is no i and j such that i < j and nums[i] < nums[j].\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [\n1\n,5,2,\n10\n]\n\nOutput:\n 9\n\nExplanation:\n\nThe maximum difference occurs with i = 0 and j = 3, nums[j] - nums[i] = 10 - 1 = 9.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == nums.length\n\n\n2 <= n <= 1000\n\n\n1 <= nums[i] <= 10\n9",
    "solution": "\nclass Solution(object):\n    def maximumDifference(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, prefix = 0, float(\"inf\")\n        for x in nums: \n            result = max(result, x-prefix)\n            prefix = min(prefix, x)\n        return result if result else -1",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "4Sum",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers, Sorting",
    "link": "https://leetcode.com/problems/4sum",
    "slug": "4sum",
    "description": "Given an array \nnums\n of \nn\n integers, return \nan array of all the \nunique\n quadruplets\n \n[nums[a], nums[b], nums[c], nums[d]]\n such that:\n\n\n\n\n0 <= a, b, c, d < n\n\n\na\n, \nb\n, \nc\n, and \nd\n are \ndistinct\n.\n\n\nnums[a] + nums[b] + nums[c] + nums[d] == target\n\n\n\n\nYou may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,0,-1,0,-2,2], target = 0\n\nOutput:\n [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [2,2,2,2,2], target = 8\n\nOutput:\n [[2,2,2,2]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 200\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n-10\n9\n <= target <= 10\n9",
    "solution": "\nimport collections\n\n\n# Two pointer solution. (1356ms)\nclass Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        result = []\n        for i in xrange(len(nums) - 3):\n            if i and nums[i] == nums[i - 1]:\n                continue\n            for j in xrange(i + 1, len(nums) - 2):\n                if j != i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                total = target - nums[i] - nums[j]\n                left, right = j + 1, len(nums) - 1\n                while left < right:\n                    if nums[left] + nums[right] == total:\n                        result.append([nums[i], nums[j], nums[left], nums[right]])\n                        right -= 1\n                        left += 1\n                        while left < right and nums[left] == nums[left - 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right + 1]:\n                            right -= 1\n                    elif nums[left] + nums[right] > total:\n                        right -= 1\n                    else:\n                        left += 1\n        return result\n\n\n# Hash solution. (224ms)\nclass Solution2(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, lookup = sorted(nums), [], collections.defaultdict(list)\n        for i in xrange(0, len(nums) - 1):\n            for j in xrange(i + 1, len(nums)):\n                is_duplicated = False\n                for [x, y] in lookup[nums[i] + nums[j]]:\n                    if nums[x] == nums[i]:\n                        is_duplicated = True\n                        break\n                if not is_duplicated:\n                    lookup[nums[i] + nums[j]].append([i, j])\n        ans = {}\n        for c in xrange(2, len(nums)):\n            for d in xrange(c+1, len(nums)):\n                if target - nums[c] - nums[d] in lookup:\n                    for [a, b] in lookup[target - nums[c] - nums[d]]:\n                        if b < c:\n                            quad = [nums[a], nums[b], nums[c], nums[d]]\n                            quad_hash = \" \".join(str(quad))\n                            if quad_hash not in ans:\n                                ans[quad_hash] = True\n                                result.append(quad)\n        return result\n\n\nclass Solution3(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, lookup = sorted(nums), [], collections.defaultdict(list)\n        for i in xrange(0, len(nums) - 1):\n            for j in xrange(i + 1, len(nums)):\n                lookup[nums[i] + nums[j]].append([i, j])\n\n        for i in lookup.keys():\n            if target - i in lookup:\n                for x in lookup[i]:\n                    for y in lookup[target - i]:\n                        [a, b], [c, d] = x, y\n                        if a is not c and a is not d and \\\n                           b is not c and b is not d:\n                            quad = sorted([nums[a], nums[b], nums[c], nums[d]])\n                            if quad not in result:\n                                result.append(quad)\n        return sorted(result)",
    "explanation": "N/A",
    "time_complexity": "O(n^2 * p) ~ O(n^4)",
    "space_complexity": "O(n^2)"
  },
  {
    "title": "Fibonacci Number",
    "difficulty": "EASY",
    "category": "Math, Dynamic Programming, Recursion, Memoization",
    "link": "https://leetcode.com/problems/fibonacci-number",
    "slug": "fibonacci-number",
    "description": "The \nFibonacci numbers\n, commonly denoted \nF(n)\n form a sequence, called the \nFibonacci sequence\n, such that each number is the sum of the two preceding ones, starting from \n0\n and \n1\n. That is,\n\n\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\n\n\nGiven \nn\n, calculate \nF(n)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n n = 2\n\nOutput:\n 1\n\nExplanation:\n F(2) = F(1) + F(0) = 1 + 0 = 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 3\n\nOutput:\n 2\n\nExplanation:\n F(3) = F(2) + F(1) = 1 + 1 = 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 4\n\nOutput:\n 3\n\nExplanation:\n F(4) = F(3) + F(2) = 2 + 1 = 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 30",
    "solution": "\nimport itertools\n\n\nclass Solution(object):\n    def fib(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        def matrix_expo(A, K):\n            result = [[int(i==j) for j in xrange(len(A))] \\\n                      for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b for a, b in itertools.izip(row, col)) \\\n                     for col in ZB] for row in A]\n\n        T = [[1, 1],\n             [1, 0]]\n        return matrix_mult([[1, 0]], matrix_expo(T, N))[0][1]  # [a1, a0] * T^N\n\n\nclass Solution2(object):\n    def fib(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        prev, current = 0, 1\n        for i in xrange(N):\n            prev, current = current, prev + current,\n        return prev",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Longest Palindromic Substring",
    "difficulty": "MEDIUM",
    "category": "Two Pointers, String, Dynamic Programming",
    "link": "https://leetcode.com/problems/longest-palindromic-substring",
    "slug": "longest-palindromic-substring",
    "description": "Given a string \ns\n, return \nthe longest\n \npalindromic\n \nsubstring\n in \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"babad\"\n\nOutput:\n \"bab\"\n\nExplanation:\n \"aba\" is also a valid answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"cbbd\"\n\nOutput:\n \"bb\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consist of only digits and English letters.",
    "solution": "\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def preProcess(s):\n            if not s:\n                return ['^', '$']\n            T = ['^']\n            for c in s:\n                T +=  ['#', c]\n            T += ['#', '$']\n            return T\n\n        T = preProcess(s)\n        P = [0] * len(T)\n        center, right = 0, 0\n        for i in xrange(1, len(T) - 1):\n            i_mirror = 2 * center - i\n            if right > i:\n                P[i] = min(right - i, P[i_mirror])\n            else:\n                P[i] = 0\n\n            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:\n                P[i] += 1\n\n            if i + P[i] > right:\n                center, right = i, i + P[i]\n\n        max_i = 0\n        for i in xrange(1, len(T) - 1):\n            if P[i] > P[max_i]:\n                max_i = i\n        start = (max_i - 1 - P[max_i]) // 2\n        return s[start : start + P[max_i]]\n\n\nclass Solution2(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return (right-left+1)-2\n        \n        left, right = -1, -2\n        for i in xrange(len(s)):\n            l = max(expand(s, i, i), expand(s, i, i+1))\n            if l > right-left+1:\n                right = i+l//2\n                left = right-l+1\n        return s[left:right+1] if left >= 0 else \"\"",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Max Consecutive Ones",
    "difficulty": "EASY",
    "category": "Array",
    "link": "https://leetcode.com/problems/max-consecutive-ones",
    "slug": "max-consecutive-ones",
    "description": "Given a binary array \nnums\n, return \nthe maximum number of consecutive \n1\n's in the array\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,0,1,1,1]\n\nOutput:\n 3\n\nExplanation:\n The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,0,1,1,0,1]\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\nnums[i]\n is either \n0\n or \n1\n.",
    "solution": "\nclass Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, local_max = 0, 0\n        for n in nums:\n            local_max = (local_max + 1 if n else 0)\n            result = max(result, local_max)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Maximum Difference Between Even and Odd Frequency II",
    "difficulty": "HARD",
    "category": "String, Sliding Window, Enumeration, Prefix Sum",
    "link": "https://leetcode.com/problems/maximum-difference-between-even-and-odd-frequency-ii",
    "slug": "maximum-difference-between-even-and-odd-frequency-ii",
    "description": "You are given a string \ns\n and an integer \nk\n. Your task is to find the \nmaximum\n difference between the frequency of \ntwo\n characters, \nfreq[a] - freq[b]\n, in a \nsubstring\n \nsubs\n of \ns\n, such that:\n\n\n\n\nsubs\n has a size of \nat least\n \nk\n.\n\n\nCharacter \na\n has an \nodd frequency\n in \nsubs\n.\n\n\nCharacter \nb\n has a \nnon-zero\n \neven frequency\n in \nsubs\n.\n\n\n\n\nReturn the \nmaximum\n difference.\n\n\nNote\n that \nsubs\n can contain more than 2 \ndistinct\n characters.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"12233\", k = 4\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\nFor the substring \n\"12233\"\n, the frequency of \n'1'\n is 1 and the frequency of \n'3'\n is 2. The difference is \n1 - 2 = -1\n.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"1122211\", k = 3\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nFor the substring \n\"11222\"\n, the frequency of \n'2'\n is 3 and the frequency of \n'1'\n is 2. The difference is \n3 - 2 = 1\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"110\", k = 3\n\n\nOutput:\n \n-1\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= s.length <= 3 * 10\n4\n\n\ns\n consists only of digits \n'0'\n to \n'4'\n.\n\n\nThe input is generated that at least one substring has a character with an even frequency and a character with an odd frequency.\n\n\n1 <= k <= s.length",
    "solution": "\n# prefix sum, two pointers, sliding window\nclass Solution(object):\n    def maxDifference(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def diff(x, y):\n            prefix1, prefix2, prefix = [0]*(len(s)+1), [0]*(len(s)+1), [0]*(len(s)+1)\n            for i in xrange(len(s)):\n                prefix1[i+1] = prefix1[i]+int(s[i] == x)\n                prefix2[i+1] = prefix2[i]+int(s[i] == y)\n                prefix[i+1] = prefix[i]+(int(s[i] == x)-int(s[i] == y))\n            result = float(\"-inf\")\n            mn = [[float(\"inf\")]*2 for _ in xrange(2)]\n            left = 0\n            for right in xrange(k-1, len(s)):\n                while k <= right-left+1 and prefix1[right+1]-prefix1[left] and prefix2[right+1]-prefix2[left]:\n                    i, j = prefix1[left]%2, prefix2[left]%2\n                    mn[i][j] = min(mn[i][j], prefix[left])\n                    left += 1\n                i, j = prefix1[right+1]%2, prefix2[right+1]%2\n                result = max(result, prefix[right+1]-mn[i^1][j])\n            return result\n        \n        lookup = set(s)\n        return max(diff(x, y) for x in lookup for y in lookup if x != y)",
    "explanation": "N/A",
    "time_complexity": "O(d^2 * n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Invalid Transactions",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, String, Sorting",
    "link": "https://leetcode.com/problems/invalid-transactions",
    "slug": "invalid-transactions",
    "description": "A transaction is possibly invalid if:\n\n\n\n\nthe amount exceeds \n$1000\n, or;\n\n\nif it occurs within (and including) \n60\n minutes of another transaction with the \nsame name\n in a \ndifferent city\n.\n\n\n\n\nYou are given an array of strings \ntransaction\n where \ntransactions[i]\n consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.\n\n\nReturn a list of \ntransactions\n that are possibly invalid. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n\nOutput:\n [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n\nExplanation:\n The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.\n\n\nExample 2:\n\n\n\n\nInput:\n transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\n\nOutput:\n [\"alice,50,1200,mtv\"]\n\n\n\nExample 3:\n\n\n\n\nInput:\n transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\n\nOutput:\n [\"bob,50,1200,mtv\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\ntransactions.length <= 1000\n\n\nEach \ntransactions[i]\n takes the form \n\"{name},{time},{amount},{city}\"\n\n\nEach \n{name}\n and \n{city}\n consist of lowercase English letters, and have lengths between \n1\n and \n10\n.\n\n\nEach \n{time}\n consist of digits, and represent an integer between \n0\n and \n1000\n.\n\n\nEach \n{amount}\n consist of digits, and represent an integer between \n0\n and \n2000\n.",
    "solution": "\n\nimport collections\n\n\nclass Solution:\n    def invalidTransactions(self, transactions):\n        AMOUNT, MINUTES = 1000, 60\n        trans = map(lambda x: (x[0], int(x[1]), int(x[2]), x[3]),\n                    (transaction.split(',') for transaction in transactions))\n        trans.sort(key=lambda t: t[1])\n        trans_indexes = collections.defaultdict(list)\n        for i, t in enumerate(trans):\n            trans_indexes[t[0]].append(i)\n        result = []\n        for name, indexes in trans_indexes.iteritems():\n            left, right = 0, 0\n            for i, t_index in enumerate(indexes):\n                t = trans[t_index]\n                if (t[2] > AMOUNT):\n                    result.append(\"{},{},{},{}\".format(*t))\n                    continue\n                while left+1 < len(indexes) and trans[indexes[left]][1] < t[1]-MINUTES:\n                    left += 1\n                while right+1 < len(indexes) and trans[indexes[right+1]][1] <= t[1]+MINUTES:\n                    right += 1\n                for i in xrange(left, right+1):\n                    if trans[indexes[i]][3] != t[3]:\n                        result.append(\"{},{},{},{}\".format(*t))\n                        break\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Insert Delete GetRandom O(1)",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Math, Design, Randomized",
    "link": "https://leetcode.com/problems/insert-delete-getrandom-o1",
    "slug": "insert-delete-getrandom-o1",
    "description": "Implement the \nRandomizedSet\n class:\n\n\n\n\nRandomizedSet()\n Initializes the \nRandomizedSet\n object.\n\n\nbool insert(int val)\n Inserts an item \nval\n into the set if not present. Returns \ntrue\n if the item was not present, \nfalse\n otherwise.\n\n\nbool remove(int val)\n Removes an item \nval\n from the set if present. Returns \ntrue\n if the item was present, \nfalse\n otherwise.\n\n\nint getRandom()\n Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the \nsame probability\n of being returned.\n\n\n\n\nYou must implement the functions of the class such that each function works in \naverage\n \nO(1)\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], [], [1], [2], []]\n\nOutput\n\n[null, true, false, true, 2, true, false, 2]\n\n\nExplanation\n\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-2\n31\n <= val <= 2\n31\n - 1\n\n\nAt most \n2 * \n10\n5\n calls will be made to \ninsert\n, \nremove\n, and \ngetRandom\n.\n\n\nThere will be \nat least one\n element in the data structure when \ngetRandom\n is called.",
    "solution": "\nfrom random import randint\n\nclass RandomizedSet(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__set = []\n        self.__used = {}\n\n\n    def insert(self, val):\n        \"\"\"\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        if val in self.__used:\n            return False\n\n        self.__set += val,\n        self.__used[val] = len(self.__set)-1\n\n        return True\n\n\n    def remove(self, val):\n        \"\"\"\n        Removes a value from the set. Returns true if the set contained the specified element.\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        if val not in self.__used:\n            return False\n\n        self.__used[self.__set[-1]] = self.__used[val]\n        self.__set[self.__used[val]], self.__set[-1] = self.__set[-1], self.__set[self.__used[val]]\n\n        self.__used.pop(val)\n        self.__set.pop()\n\n        return True\n\n    def getRandom(self):\n        \"\"\"\n        Get a random element from the set.\n        :rtype: int\n        \"\"\"\n        return self.__set[randint(0, len(self.__set)-1)]",
    "explanation": "N/A",
    "time_complexity": "O(1)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Add Binary",
    "difficulty": "EASY",
    "category": "Math, String, Bit Manipulation, Simulation",
    "link": "https://leetcode.com/problems/add-binary",
    "slug": "add-binary",
    "description": "Given two binary strings \na\n and \nb\n, return \ntheir sum as a binary string\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n a = \"11\", b = \"1\"\n\nOutput:\n \"100\"\n\nExample 2:\n\n\nInput:\n a = \"1010\", b = \"1011\"\n\nOutput:\n \"10101\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= a.length, b.length <= 10\n4\n\n\na\n and \nb\n consist only of \n'0'\n or \n'1'\n characters.\n\n\nEach string does not contain leading zeros except for the zero itself.",
    "solution": "\nclass Solution(object):\n    # @param a, a string\n    # @param b, a string\n    # @return a string\n    def addBinary(self, a, b):\n        result, carry, val = \"\", 0, 0\n        for i in xrange(max(len(a), len(b))):\n            val = carry\n            if i < len(a):\n                val += int(a[-(i + 1)])\n            if i < len(b):\n                val += int(b[-(i + 1)])\n            carry, val = divmod(val, 2)\n            result += str(val)\n        if carry:\n            result += str(carry)\n        return result[::-1]\n\n\nfrom itertools import izip_longest\n\n\nclass Solution2(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        result = \"\"\n        carry = 0\n        for x, y in izip_longest(reversed(a), reversed(b), fillvalue=\"0\"):\n            carry, remainder = divmod(int(x)+int(y)+carry, 2)\n            result += str(remainder)\n        \n        if carry:\n            result += str(carry)\n        \n        return result[::-1]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Students and Examinations",
    "difficulty": "EASY",
    "category": "Database",
    "link": "https://leetcode.com/problems/students-and-examinations",
    "slug": "students-and-examinations",
    "description": "Table: \nStudents\n\n\n\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| student_id    | int     |\n| student_name  | varchar |\n+---------------+---------+\nstudent_id is the primary key (column with unique values) for this table.\nEach row of this table contains the ID and the name of one student in the school.\n\n\n\n \n\n\nTable: \nSubjects\n\n\n\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| subject_name | varchar |\n+--------------+---------+\nsubject_name is the primary key (column with unique values) for this table.\nEach row of this table contains the name of one subject in the school.\n\n\n\n \n\n\nTable: \nExaminations\n\n\n\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| student_id   | int     |\n| subject_name | varchar |\n+--------------+---------+\nThere is no primary key (column with unique values) for this table. It may contain duplicates.\nEach student from the Students table takes every course from the Subjects table.\nEach row of this table indicates that a student with ID student_id attended the exam of subject_name.\n\n\n\n \n\n\nWrite a solution to find the number of times each student attended each exam.\n\n\nReturn the result table ordered by \nstudent_id\n and \nsubject_name\n.\n\n\nThe result format is in the following example.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nStudents table:\n+------------+--------------+\n| student_id | student_name |\n+------------+--------------+\n| 1          | Alice        |\n| 2          | Bob          |\n| 13         | John         |\n| 6          | Alex         |\n+------------+--------------+\nSubjects table:\n+--------------+\n| subject_name |\n+--------------+\n| Math         |\n| Physics      |\n| Programming  |\n+--------------+\nExaminations table:\n+------------+--------------+\n| student_id | subject_name |\n+------------+--------------+\n| 1          | Math         |\n| 1          | Physics      |\n| 1          | Programming  |\n| 2          | Programming  |\n| 1          | Physics      |\n| 1          | Math         |\n| 13         | Math         |\n| 13         | Programming  |\n| 13         | Physics      |\n| 2          | Math         |\n| 1          | Math         |\n+------------+--------------+\n\nOutput:\n \n+------------+--------------+--------------+----------------+\n| student_id | student_name | subject_name | attended_exams |\n+------------+--------------+--------------+----------------+\n| 1          | Alice        | Math         | 3              |\n| 1          | Alice        | Physics      | 2              |\n| 1          | Alice        | Programming  | 1              |\n| 2          | Bob          | Math         | 1              |\n| 2          | Bob          | Physics      | 0              |\n| 2          | Bob          | Programming  | 1              |\n| 6          | Alex         | Math         | 0              |\n| 6          | Alex         | Physics      | 0              |\n| 6          | Alex         | Programming  | 0              |\n| 13         | John         | Math         | 1              |\n| 13         | John         | Physics      | 1              |\n| 13         | John         | Programming  | 1              |\n+------------+--------------+--------------+----------------+\n\nExplanation:\n \nThe result table should contain all students and all subjects.\nAlice attended the Math exam 3 times, the Physics exam 2 times, and the Programming exam 1 time.\nBob attended the Math exam 1 time, the Programming exam 1 time, and did not attend the Physics exam.\nAlex did not attend any exams.\nJohn attended the Math exam 1 time, the Physics exam 1 time, and the Programming exam 1 time.",
    "solution": "# Solution not found in kamyu104 repository",
    "explanation": "N/A",
    "time_complexity": "N/A",
    "space_complexity": "N/A"
  },
  {
    "title": "Palindrome Partitioning",
    "difficulty": "MEDIUM",
    "category": "String, Dynamic Programming, Backtracking",
    "link": "https://leetcode.com/problems/palindrome-partitioning",
    "slug": "palindrome-partitioning",
    "description": "Given a string \ns\n, partition \ns\n such that every \nsubstring\n of the partition is a \npalindrome\n. Return \nall possible palindrome partitioning of \ns\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"aab\"\n\nOutput:\n [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n\nExample 2:\n\n\nInput:\n s = \"a\"\n\nOutput:\n [[\"a\"]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 16\n\n\ns\n contains only lowercase English letters.",
    "solution": "\nclass Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        is_palindrome = [[False] * len(s) for i in xrange(len(s))]\n        for i in reversed(xrange(len(s))):\n            for j in xrange(i, len(s)):\n                is_palindrome[i][j] = s[i] == s[j] and ((j - i < 2) or is_palindrome[i + 1][j - 1])\n\n        sub_partition = [[] for _ in xrange(len(s))]\n        for i in reversed(xrange(len(s))):\n            for j in xrange(i, len(s)):\n                if is_palindrome[i][j]:\n                    if j + 1 < len(s):\n                        for p in sub_partition[j + 1]:\n                            sub_partition[i].append([s[i:j + 1]] + p)\n                    else:\n                        sub_partition[i].append([s[i:j + 1]])\n\n        return sub_partition[0]\n\n\n# recursive solution\nclass Solution2(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        result = []\n        self.partitionRecu(result, [], s, 0)\n        return result\n\n    def partitionRecu(self, result, cur, s, i):\n        if i == len(s):\n            result.append(list(cur))\n        else:\n            for j in xrange(i, len(s)):\n                if self.isPalindrome(s[i: j + 1]):\n                    cur.append(s[i: j + 1])\n                    self.partitionRecu(result, cur, s, j + 1)\n                    cur.pop()\n\n    def isPalindrome(self, s):\n        for i in xrange(len(s) / 2):\n            if s[i] != s[-(i + 1)]:\n                return False\n        return True",
    "explanation": "N/A",
    "time_complexity": "O(2^n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "EASY",
    "category": "Array, Dynamic Programming",
    "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
    "slug": "best-time-to-buy-and-sell-stock",
    "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nYou want to maximize your profit by choosing a \nsingle day\n to buy one stock and choosing a \ndifferent day in the future\n to sell that stock.\n\n\nReturn \nthe maximum profit you can achieve from this transaction\n. If you cannot achieve any profit, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 5\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transactions are done and the max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n4",
    "solution": "\nclass Solution(object):\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, prices):\n        max_profit, min_price = 0, float(\"inf\")\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Search a 2D Matrix",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search, Matrix",
    "link": "https://leetcode.com/problems/search-a-2d-matrix",
    "slug": "search-a-2d-matrix",
    "description": "You are given an \nm x n\n integer matrix \nmatrix\n with the following two properties:\n\n\n\n\nEach row is sorted in non-decreasing order.\n\n\nThe first integer of each row is greater than the last integer of the previous row.\n\n\n\n\nGiven an integer \ntarget\n, return \ntrue\n \nif\n \ntarget\n \nis in\n \nmatrix\n \nor\n \nfalse\n \notherwise\n.\n\n\nYou must write a solution in \nO(log(m * n))\n time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == matrix.length\n\n\nn == matrix[i].length\n\n\n1 <= m, n <= 100\n\n\n-10\n4\n <= matrix[i][j], target <= 10\n4",
    "solution": "\nclass Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not matrix:\n            return False\n\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n\n        while left < right:\n            mid = left + (right - left) / 2\n            if matrix[mid / n][mid % n] >= target:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left < m * n and matrix[left / n][left % n] == target",
    "explanation": "N/A",
    "time_complexity": "O(logm + logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Merge Sorted Array",
    "difficulty": "EASY",
    "category": "Array, Two Pointers, Sorting",
    "link": "https://leetcode.com/problems/merge-sorted-array",
    "slug": "merge-sorted-array",
    "description": "You are given two integer arrays \nnums1\n and \nnums2\n, sorted in \nnon-decreasing order\n, and two integers \nm\n and \nn\n, representing the number of elements in \nnums1\n and \nnums2\n respectively.\n\n\nMerge\n \nnums1\n and \nnums2\n into a single array sorted in \nnon-decreasing order\n.\n\n\nThe final sorted array should not be returned by the function, but instead be \nstored inside the array \nnums1\n. To accommodate this, \nnums1\n has a length of \nm + n\n, where the first \nm\n elements denote the elements that should be merged, and the last \nn\n elements are set to \n0\n and should be ignored. \nnums2\n has a length of \nn\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n\nOutput:\n [1,2,2,3,5,6]\n\nExplanation:\n The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [\n1\n,\n2\n,2,\n3\n,5,6] with the underlined elements coming from nums1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1], m = 1, nums2 = [], n = 0\n\nOutput:\n [1]\n\nExplanation:\n The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums1 = [0], m = 0, nums2 = [1], n = 1\n\nOutput:\n [1]\n\nExplanation:\n The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m + n\n\n\nnums2.length == n\n\n\n0 <= m, n <= 200\n\n\n1 <= m + n <= 200\n\n\n-10\n9\n <= nums1[i], nums2[j] <= 10\n9\n\n\n\n\n \n\n\nFollow up: \nCan you come up with an algorithm that runs in \nO(m + n)\n time?",
    "solution": "\nclass Solution(object):\n    # @param A  a list of integers\n    # @param m  an integer, length of A\n    # @param B  a list of integers\n    # @param n  an integer, length of B\n    # @return nothing\n    def merge(self, A, m, B, n):\n        last, i, j = m + n - 1, m - 1, n - 1\n\n        while i >= 0 and j >= 0:\n            if A[i] > B[j]:\n                A[last] = A[i]\n                last, i = last - 1, i - 1\n            else:\n                A[last] = B[j]\n                last, j = last - 1, j - 1\n\n        while j >= 0:\n                A[last] = B[j]\n                last, j = last - 1, j - 1",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Generate Parentheses",
    "difficulty": "MEDIUM",
    "category": "String, Dynamic Programming, Backtracking",
    "link": "https://leetcode.com/problems/generate-parentheses",
    "slug": "generate-parentheses",
    "description": "Given \nn\n pairs of parentheses, write a function to \ngenerate all combinations of well-formed parentheses\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n n = 3\n\nOutput:\n [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n\nExample 2:\n\n\nInput:\n n = 1\n\nOutput:\n [\"()\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 8",
    "solution": "\n# iterative solution\nclass Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result, curr = [], []\n        stk = [(1, (n, n))]\n        while stk:\n            step, args = stk.pop()\n            if step == 1:\n                left, right = args\n                if left == 0 and right == 0:\n                    result.append(\"\".join(curr))\n                if left < right:\n                    stk.append((3, tuple()))\n                    stk.append((1, (left, right-1)))\n                    stk.append((2, (')')))\n                if left > 0:\n                    stk.append((3, tuple()))\n                    stk.append((1, (left-1, right)))\n                    stk.append((2, ('(')))\n            elif step == 2:\n                curr.append(args[0])\n            elif step == 3:\n                curr.pop()\n        return result\n\n\n# recursive solution\nclass Solution2(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        def generateParenthesisRecu(left, right, curr, result):\n            if left == 0 and right == 0:\n                result.append(\"\".join(curr))\n            if left > 0:\n                curr.append('(')\n                generateParenthesisRecu(left-1, right, curr, result)\n                curr.pop()\n            if left < right:\n                curr.append(')')\n                generateParenthesisRecu(left, right-1, curr, result)\n                curr.pop()\n\n        result = []\n        generateParenthesisRecu(n, n, [], result)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(4^n / n^(3/2)) ~= Catalan numbers",
    "space_complexity": "O(n)"
  },
  {
    "title": "Product of Array Except Self",
    "difficulty": "MEDIUM",
    "category": "Array, Prefix Sum",
    "link": "https://leetcode.com/problems/product-of-array-except-self",
    "slug": "product-of-array-except-self",
    "description": "Given an integer array \nnums\n, return \nan array\n \nanswer\n \nsuch that\n \nanswer[i]\n \nis equal to the product of all the elements of\n \nnums\n \nexcept\n \nnums[i]\n.\n\n\nThe product of any prefix or suffix of \nnums\n is \nguaranteed\n to fit in a \n32-bit\n integer.\n\n\nYou must write an algorithm that runs in \nO(n)\n time and without using the division operation.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,2,3,4]\n\nOutput:\n [24,12,8,6]\n\nExample 2:\n\n\nInput:\n nums = [-1,1,0,-3,3]\n\nOutput:\n [0,0,9,0,0]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n5\n\n\n-30 <= nums[i] <= 30\n\n\nThe input is generated such that \nanswer[i]\n is \nguaranteed\n to fit in a \n32-bit\n integer.\n\n\n\n\n \n\n\nFollow up:\n Can you solve the problem in \nO(1)\n extra space complexity? (The output array \ndoes not\n count as extra space for space complexity analysis.)",
    "solution": "\nclass Solution(object):\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def productExceptSelf(self, nums):\n        if not nums:\n            return []\n\n        left_product = [1 for _ in xrange(len(nums))]\n        for i in xrange(1, len(nums)):\n            left_product[i] = left_product[i - 1] * nums[i - 1]\n\n        right_product = 1\n        for i in xrange(len(nums) - 2, -1, -1):\n            right_product *= nums[i + 1]\n            left_product[i] = left_product[i] * right_product\n\n        return left_product",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Max Area of Island",
    "difficulty": "MEDIUM",
    "category": "Array, Depth-First Search, Breadth-First Search, Union Find, Matrix",
    "link": "https://leetcode.com/problems/max-area-of-island",
    "slug": "max-area-of-island",
    "description": "You are given an \nm x n\n binary matrix \ngrid\n. An island is a group of \n1\n's (representing land) connected \n4-directionally\n (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n\n\nThe \narea\n of an island is the number of cells with a value \n1\n in the island.\n\n\nReturn \nthe maximum \narea\n of an island in \ngrid\n. If there is no island, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n\nOutput:\n 6\n\nExplanation:\n The answer is not 11, because the island must be connected 4-directionally.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[0,0,0,0,0,0,0,0]]\n\nOutput:\n 0\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 50\n\n\ngrid[i][j]\n is either \n0\n or \n1\n.",
    "solution": "\nclass Solution(object):\n    def maxAreaOfIsland(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [[-1,  0], [ 1,  0], [ 0,  1], [ 0, -1]]\n\n        def dfs(i, j, grid, area):\n            if not (0 <= i < len(grid) and \\\n                    0 <= j < len(grid[0]) and \\\n                    grid[i][j] > 0):\n                return False\n            grid[i][j] *= -1\n            area[0] += 1\n            for d in directions:\n                dfs(i+d[0], j+d[1], grid, area)\n            return True\n\n        result = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                area = [0]\n                if dfs(i, j, grid, area):\n                    result = max(result, area[0])\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m * n), the max depth of dfs may be m * n"
  }
]