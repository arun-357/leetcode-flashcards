[
  {
    "title": "Minimum Remove to Make Valid Parentheses",
    "difficulty": "MEDIUM",
    "category": "String, Stack",
    "link": "https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses",
    "slug": "minimum-remove-to-make-valid-parentheses",
    "description": "Given a string \ns\n of \n'('\n , \n')'\n and lowercase English characters.\n\n\nYour task is to remove the minimum number of parentheses ( \n'('\n or \n')'\n, in any positions ) so that the resulting \nparentheses string\n is valid and return \nany\n valid string.\n\n\nFormally, a \nparentheses string\n is valid if and only if:\n\n\n\n\nIt is the empty string, contains only lowercase characters, or\n\n\nIt can be written as \nAB\n (\nA\n concatenated with \nB\n), where \nA\n and \nB\n are valid strings, or\n\n\nIt can be written as \n(A)\n, where \nA\n is a valid string.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"lee(t(c)o)de)\"\n\nOutput:\n \"lee(t(c)o)de\"\n\nExplanation:\n \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"a)b(c)d\"\n\nOutput:\n \"ab(c)d\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"))((\"\n\nOutput:\n \"\"\n\nExplanation:\n An empty string is also valid.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns[i]\n is either \n'('\n , \n')'\n, or lowercase English letter.",
    "solution": "\nclass Solution(object):\n    def minRemoveToMakeValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        result = list(s)\n        count = 0\n        for i, v in enumerate(result):\n            if v == '(':\n                count += 1\n            elif v == ')':\n                if count:\n                    count -= 1\n                else:\n                    result[i] = \"\"\n        if count:\n            for i in reversed(xrange(len(result))):\n                if result[i] == '(':\n                    result[i] = \"\"\n                    count -= 1\n                    if not count:\n                        break\n        return \"\".join(result)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Valid Word Abbreviation",
    "difficulty": "EASY",
    "category": "Two Pointers, String",
    "link": "https://leetcode.com/problems/valid-word-abbreviation",
    "slug": "valid-word-abbreviation",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nclass Solution(object):\n    def validWordAbbreviation(self, word, abbr):\n        \"\"\"\n        :type word: str\n        :type abbr: str\n        :rtype: bool\n        \"\"\"\n        i , digit = 0, 0\n        for c in abbr:\n            if c.isdigit():\n                if digit == 0 and c == '0':\n                    return False\n                digit *= 10\n                digit += int(c)\n            else:\n                if digit:\n                    i += digit\n                    digit = 0\n                if i >= len(word) or word[i] != c:\n                    return False\n                i += 1\n        if digit:\n            i += digit\n\n        return i == len(word)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Binary Tree Vertical Order Traversal",
    "difficulty": "MEDIUM",
    "category": "Hash Table, Tree, Depth-First Search, Breadth-First Search, Sorting, Binary Tree",
    "link": "https://leetcode.com/problems/binary-tree-vertical-order-traversal",
    "slug": "binary-tree-vertical-order-traversal",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nimport collections\n\n\n# BFS + hash solution.\nclass Solution(object):\n    def verticalOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        cols = collections.defaultdict(list)\n        queue = [(root, 0)]\n        for node, i in queue:\n            if node:\n                cols[i].append(node.val)\n                queue += (node.left, i - 1), (node.right, i + 1)\n        return [cols[i] for i in xrange(min(cols.keys()),\n                                        max(cols.keys()) + 1)] if cols else []",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Valid Palindrome II",
    "difficulty": "EASY",
    "category": "Two Pointers, String, Greedy",
    "link": "https://leetcode.com/problems/valid-palindrome-ii",
    "slug": "valid-palindrome-ii",
    "description": "Given a string \ns\n, return \ntrue\n \nif the \ns\n can be palindrome after deleting \nat most one\n character from it\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"aba\"\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"abca\"\n\nOutput:\n true\n\nExplanation:\n You could delete the character 'c'.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"abc\"\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\ns\n consists of lowercase English letters.",
    "solution": "\nclass Solution(object):\n    def validPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        def validPalindrome(s, left, right):\n            while left < right:\n                if s[left] != s[right]:\n                    return False\n                left, right = left+1, right-1\n            return True\n\n        left, right = 0, len(s)-1\n        while left < right:\n            if s[left] != s[right]:\n                return validPalindrome(s, left, right-1) or validPalindrome(s, left+1, right)\n            left, right = left+1, right-1\n        return True",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Lowest Common Ancestor of a Binary Tree III",
    "difficulty": "MEDIUM",
    "category": "Hash Table, Two Pointers, Tree, Binary Tree",
    "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii",
    "slug": "lowest-common-ancestor-of-a-binary-tree-iii",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\n# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        pass\n\nclass Solution(object):\n    def lowestCommonAncestor(self, p, q):\n        \"\"\"\n        :type node: Node\n        :rtype: Node\n        \"\"\"\n        a, b = p, q\n        while a != b:\n            a = a.parent if a else q\n            b = b.parent if b else p\n        return a\n\n\nclass Solution2(object):\n    def lowestCommonAncestor(self, p, q):\n        \"\"\"\n        :type node: Node\n        :rtype: Node\n        \"\"\"\n        def depth(node):\n            d = 0\n            while node:\n                node = node.parent\n                d += 1\n            return d\n        \n        p_d, q_d = depth(p), depth(q)\n        while p_d > q_d:\n            p = p.parent\n            p_d -= 1\n        while p_d < q_d:\n            q = q.parent\n            q_d -= 1\n        while p != q:\n            p = p.parent\n            q = q.parent\n        return p",
    "explanation": "N/A",
    "time_complexity": "O(h)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Kth Largest Element in an Array",
    "difficulty": "MEDIUM",
    "category": "Array, Divide and Conquer, Sorting, Heap (Priority Queue), Quickselect",
    "link": "https://leetcode.com/problems/kth-largest-element-in-an-array",
    "slug": "kth-largest-element-in-an-array",
    "description": "Given an integer array \nnums\n and an integer \nk\n, return \nthe\n \nk\nth\n \nlargest element in the array\n.\n\n\nNote that it is the \nk\nth\n largest element in the sorted order, not the \nk\nth\n distinct element.\n\n\nCan you solve it without sorting?\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [3,2,1,5,6,4], k = 2\n\nOutput:\n 5\n\nExample 2:\n\n\nInput:\n nums = [3,2,3,1,2,4,5,5,6], k = 4\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4",
    "solution": "\nfrom random import randint\n\n\n# optimized for duplicated nums\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        nth_element(nums, k-1, compare=lambda a, b: a > b)\n        return nums[k-1]\n\n\nclass Solution2(object):\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = self.PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k - 1:\n                return nums[new_pivot_idx]\n            elif new_pivot_idx > k - 1:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k - 1.\n                left = new_pivot_idx + 1\n\n    def PartitionAroundPivot(self, left, right, pivot_idx, nums):\n        pivot_value = nums[pivot_idx]\n        new_pivot_idx = left\n        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n        for i in xrange(left, right):\n            if nums[i] > pivot_value:\n                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                new_pivot_idx += 1\n\n        nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n        return new_pivot_idx",
    "explanation": "N/A",
    "time_complexity": "O(n) on average, using Median of Medians could achieve O(n) (Intro Select)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Binary Tree Right Side View",
    "difficulty": "MEDIUM",
    "category": "Tree, Depth-First Search, Breadth-First Search, Binary Tree",
    "link": "https://leetcode.com/problems/binary-tree-right-side-view",
    "slug": "binary-tree-right-side-view",
    "description": "Given the \nroot\n of a binary tree, imagine yourself standing on the \nright side\n of it, return \nthe values of the nodes you can see ordered from top to bottom\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nroot = [1,2,3,null,5,null,4]\n\n\nOutput:\n \n[1,3,4]\n\n\nExplanation:\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nroot = [1,2,3,4,null,null,null,5]\n\n\nOutput:\n \n[1,3,4,5]\n\n\nExplanation:\n\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nroot = [1,null,3]\n\n\nOutput:\n \n[1,3]\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \nroot = []\n\n\nOutput:\n \n[]\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[0, 100]\n.\n\n\n-100 <= Node.val <= 100",
    "solution": "\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return a list of integers\n    def rightSideView(self, root):\n        result = []\n        self.rightSideViewDFS(root, 1, result)\n        return result\n\n    def rightSideViewDFS(self, node, depth, result):\n        if not node:\n            return\n\n        if depth > len(result):\n            result.append(node.val)\n\n        self.rightSideViewDFS(node.right, depth+1, result)\n        self.rightSideViewDFS(node.left, depth+1, result)\n\n\n# BFS solution\nclass Solution2(object):\n    # @param root, a tree node\n    # @return a list of integers\n    def rightSideView(self, root):\n        if root is None:\n            return []\n\n        result, current = [], [root]\n        while current:\n            next_level = []\n            for node in current:\n                if node.left:\n                    next_level.append(node.left)\n                if node.right:\n                    next_level.append(node.right)                \n            result.append(node.val)\n            current = next_level\n\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Basic Calculator II",
    "difficulty": "MEDIUM",
    "category": "Math, String, Stack",
    "link": "https://leetcode.com/problems/basic-calculator-ii",
    "slug": "basic-calculator-ii",
    "description": "Given a string \ns\n which represents an expression, \nevaluate this expression and return its value\n. \n\n\nThe integer division should truncate toward zero.\n\n\nYou may assume that the given expression is always valid. All intermediate results will be in the range of \n[-2\n31\n, 2\n31\n - 1]\n.\n\n\nNote:\n You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as \neval()\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n s = \"3+2*2\"\n\nOutput:\n 7\n\nExample 2:\n\n\nInput:\n s = \" 3/2 \"\n\nOutput:\n 1\n\nExample 3:\n\n\nInput:\n s = \" 3+5 / 2 \"\n\nOutput:\n 5\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 3 * 10\n5\n\n\ns\n consists of integers and operators \n('+', '-', '*', '/')\n separated by some number of spaces.\n\n\ns\n represents \na valid expression\n.\n\n\nAll the integers in the expression are non-negative integers in the range \n[0, 2\n31\n - 1]\n.\n\n\nThe answer is \nguaranteed\n to fit in a \n32-bit integer\n.",
    "solution": "\nimport operator\n\n\nclass Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def compute(operands, operators):\n            right, left = operands.pop(), operands.pop()\n            operands.append(ops[operators.pop()](left, right))\n\n        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}\n        precedence = {'+':0, '-':0, '*':1, '/':1}\n        operands, operators, operand = [], [], 0\n        for i in xrange(len(s)):\n            if s[i].isdigit():\n                operand = operand*10 + int(s[i])\n                if i == len(s)-1 or not s[i+1].isdigit():\n                    operands.append(operand)\n                    operand = 0\n            elif s[i] == '(':\n                operators.append(s[i])\n            elif s[i] == ')':\n                while operators[-1] != '(':\n                    compute(operands, operators)\n                operators.pop()\n            elif s[i] in precedence:\n                while operators and operators[-1] in precedence and \\\n                      precedence[operators[-1]] >= precedence[s[i]]:\n                    compute(operands, operators)\n                operators.append(s[i])\n        while operators:\n            compute(operands, operators)\n        return operands[-1]\n\n\nclass Solution2(object):\n    # @param {string} s\n    # @return {integer}\n    def calculate(self, s):\n        operands, operators = [], []\n        operand = \"\"\n        for i in reversed(xrange(len(s))):\n            if s[i].isdigit():\n                operand += s[i]\n                if i == 0 or not s[i-1].isdigit():\n                    operands.append(int(operand[::-1]))\n                    operand = \"\"\n            elif s[i] == ')' or s[i] == '*' or s[i] == '/':\n                operators.append(s[i])\n            elif s[i] == '+' or s[i] == '-':\n                while operators and \\\n                      (operators[-1] == '*' or operators[-1] == '/'):\n                    self.compute(operands, operators)\n                operators.append(s[i])\n            elif s[i] == '(':\n                while operators[-1] != ')':\n                    self.compute(operands, operators)\n                operators.pop()\n\n        while operators:\n            self.compute(operands, operators)\n\n        return operands[-1]\n\n    def compute(self, operands, operators):\n        left, right = operands.pop(), operands.pop()\n        op = operators.pop()\n        if op == '+':\n            operands.append(left + right)\n        elif op == '-':\n            operands.append(left - right)\n        elif op == '*':\n            operands.append(left * right)\n        elif op == '/':\n            operands.append(left / right)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Lowest Common Ancestor of a Binary Tree",
    "difficulty": "MEDIUM",
    "category": "Tree, Depth-First Search, Binary Tree",
    "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree",
    "slug": "lowest-common-ancestor-of-a-binary-tree",
    "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\n\nAccording to the \ndefinition of LCA on Wikipedia\n: “The lowest common ancestor is defined between two nodes \np\n and \nq\n as the lowest node in \nT\n that has both \np\n and \nq\n as descendants (where we allow \na node to be a descendant of itself\n).”\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n\nOutput:\n 3\n\nExplanation:\n The LCA of nodes 5 and 1 is 3.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n\nOutput:\n 5\n\nExplanation:\n The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\n\n\nExample 3:\n\n\n\n\nInput:\n root = [1,2], p = 1, q = 2\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[2, 10\n5\n]\n.\n\n\n-10\n9\n <= Node.val <= 10\n9\n\n\nAll \nNode.val\n are \nunique\n.\n\n\np != q\n\n\np\n and \nq\n will exist in the tree.",
    "solution": "\nclass Solution(object):\n    # @param {TreeNode} root\n    # @param {TreeNode} p\n    # @param {TreeNode} q\n    # @return {TreeNode}\n    def lowestCommonAncestor(self, root, p, q):\n        if root in (None, p, q):\n            return root\n\n        left, right = [self.lowestCommonAncestor(child, p, q) \\\n                         for child in (root.left, root.right)]\n        # 1. If the current subtree contains both p and q,\n        #    return their LCA.\n        # 2. If only one of them is in that subtree,\n        #    return that one of them.\n        # 3. If neither of them is in that subtree,\n        #    return the node of that subtree.\n        return root if left and right else left or right",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(h)"
  },
  {
    "title": "Find Peak Element",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/find-peak-element",
    "slug": "find-peak-element",
    "description": "A peak element is an element that is strictly greater than its neighbors.\n\n\nGiven a \n0-indexed\n integer array \nnums\n, find a peak element, and return its index. If the array contains multiple peaks, return the index to \nany of the peaks\n.\n\n\nYou may imagine that \nnums[-1] = nums[n] = -∞\n. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\n\nYou must write an algorithm that runs in \nO(log n)\n time.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,1]\n\nOutput:\n 2\n\nExplanation:\n 3 is a peak element and your function should return the index number 2.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,1,3,5,6,4]\n\nOutput:\n 5\n\nExplanation:\n Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 1000\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\nnums[i] != nums[i + 1]\n for all valid \ni\n.",
    "solution": "\nclass Solution(object):\n    def findPeakElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            mid = left + (right - left) / 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Nested List Weight Sum",
    "difficulty": "MEDIUM",
    "category": "Depth-First Search, Breadth-First Search",
    "link": "https://leetcode.com/problems/nested-list-weight-sum",
    "slug": "nested-list-weight-sum",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nclass Solution(object):\n    def depthSum(self, nestedList):\n        \"\"\"\n        :type nestedList: List[NestedInteger]\n        :rtype: int\n        \"\"\"\n        def depthSumHelper(nestedList, depth):\n            res = 0\n            for l in nestedList:\n                if l.isInteger():\n                    res += l.getInteger() * depth\n                else:\n                    res += depthSumHelper(l.getList(), depth + 1)\n            return res\n        return depthSumHelper(nestedList, 1)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(h)"
  },
  {
    "title": "Random Pick with Weight",
    "difficulty": "MEDIUM",
    "category": "Array, Math, Binary Search, Prefix Sum, Randomized",
    "link": "https://leetcode.com/problems/random-pick-with-weight",
    "slug": "random-pick-with-weight",
    "description": "You are given a \n0-indexed\n array of positive integers \nw\n where \nw[i]\n describes the \nweight\n of the \ni\nth\n index.\n\n\nYou need to implement the function \npickIndex()\n, which \nrandomly\n picks an index in the range \n[0, w.length - 1]\n (\ninclusive\n) and returns it. The \nprobability\n of picking an index \ni\n is \nw[i] / sum(w)\n.\n\n\n\n\nFor example, if \nw = [1, 3]\n, the probability of picking index \n0\n is \n1 / (1 + 3) = 0.25\n (i.e., \n25%\n), and the probability of picking index \n1\n is \n3 / (1 + 3) = 0.75\n (i.e., \n75%\n).\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"Solution\",\"pickIndex\"]\n[[[1]],[]]\n\nOutput\n\n[null,0]\n\n\nExplanation\n\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.\n\n\n\nExample 2:\n\n\n\n\nInput\n\n[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]\n[[[1,3]],[],[],[],[],[]]\n\nOutput\n\n[null,1,1,1,1,0]\n\n\nExplanation\n\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.\n\nSince this is a randomization problem, multiple answers are allowed.\nAll of the following outputs can be considered correct:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\nand so on.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= w.length <= 10\n4\n\n\n1 <= w[i] <= 10\n5\n\n\npickIndex\n will be called at most \n10\n4\n times.",
    "solution": "#        pickIndex: O(logn)\n\nimport random\nimport bisect\n\n\nclass Solution(object):\n\n    def __init__(self, w):\n        \"\"\"\n        :type w: List[int]\n        \"\"\"\n        self.__prefix_sum = list(w)\n        for i in xrange(1, len(w)):\n            self.__prefix_sum[i] += self.__prefix_sum[i-1]\n\n    def pickIndex(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        target = random.randint(0, self.__prefix_sum[-1]-1)\n        return bisect.bisect_right(self.__prefix_sum, target)",
    "explanation": "N/A",
    "time_complexity": "ctor: O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Sum Root to Leaf Numbers",
    "difficulty": "MEDIUM",
    "category": "Tree, Depth-First Search, Binary Tree",
    "link": "https://leetcode.com/problems/sum-root-to-leaf-numbers",
    "slug": "sum-root-to-leaf-numbers",
    "description": "You are given the \nroot\n of a binary tree containing digits from \n0\n to \n9\n only.\n\n\nEach root-to-leaf path in the tree represents a number.\n\n\n\n\nFor example, the root-to-leaf path \n1 -> 2 -> 3\n represents the number \n123\n.\n\n\n\n\nReturn \nthe total sum of all root-to-leaf numbers\n. Test cases are generated so that the answer will fit in a \n32-bit\n integer.\n\n\nA \nleaf\n node is a node with no children.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3]\n\nOutput:\n 25\n\nExplanation:\n\nThe root-to-leaf path \n1->2\n represents the number \n12\n.\nThe root-to-leaf path \n1->3\n represents the number \n13\n.\nTherefore, sum = 12 + 13 = \n25\n.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [4,9,0,5,1]\n\nOutput:\n 1026\n\nExplanation:\n\nThe root-to-leaf path \n4->9->5\n represents the number 495.\nThe root-to-leaf path \n4->9->1\n represents the number 491.\nThe root-to-leaf path \n4->0\n represents the number 40.\nTherefore, sum = 495 + 491 + 40 = \n1026\n.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\n0 <= Node.val <= 9\n\n\nThe depth of the tree will not exceed \n10\n.",
    "solution": "\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return an integer\n    def sumNumbers(self, root):\n        return self.sumNumbersRecu(root, 0)\n\n    def sumNumbersRecu(self, root, num):\n        if root is None:\n            return 0\n\n        if root.left is None and root.right is None:\n            return num * 10 + root.val\n\n        return self.sumNumbersRecu(root.left, num * 10 + root.val) + self.sumNumbersRecu(root.right, num * 10 + root.val)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(h), h is height of binary tree"
  },
  {
    "title": "Diameter of Binary Tree",
    "difficulty": "EASY",
    "category": "Tree, Depth-First Search, Binary Tree",
    "link": "https://leetcode.com/problems/diameter-of-binary-tree",
    "slug": "diameter-of-binary-tree",
    "description": "Given the \nroot\n of a binary tree, return \nthe length of the \ndiameter\n of the tree\n.\n\n\nThe \ndiameter\n of a binary tree is the \nlength\n of the longest path between any two nodes in a tree. This path may or may not pass through the \nroot\n.\n\n\nThe \nlength\n of a path between two nodes is represented by the number of edges between them.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5]\n\nOutput:\n 3\n\nExplanation:\n 3 is the length of the path [4,2,1,3] or [5,2,1,3].\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1,2]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n4\n]\n.\n\n\n-100 <= Node.val <= 100",
    "solution": "\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution(object):\n    def diameterOfBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def iter_dfs(node):\n            result = 0\n            stk = [(1, [node, [0]])]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, ret = params\n                    if not node:\n                        continue\n                    ret1, ret2 = [0], [0]\n                    stk.append((2, [node, ret1, ret2, ret]))\n                    stk.append((1, [node.right, ret2]))\n                    stk.append((1, [node.left, ret1]))\n                elif step == 2:\n                    node, ret1, ret2, ret = params\n                    result = max(result, ret1[0]+ret2[0])\n                    ret[0] = 1+max(ret1[0], ret2[0])\n            return result\n        \n        return iter_dfs(root)\n\n\nclass Solution2(object):\n    def diameterOfBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(root):\n            if not root: \n                return 0, 0\n            left_d, left_h = dfs(root.left)\n            right_d, right_h = dfs(root.right)\n            return max(left_d, right_d, left_h+right_h), 1+max(left_h, right_h)\n \n        return dfs(root)[0]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(h)"
  },
  {
    "title": "Top K Frequent Elements",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Divide and Conquer, Sorting, Heap (Priority Queue), Bucket Sort, Counting, Quickselect",
    "link": "https://leetcode.com/problems/top-k-frequent-elements",
    "slug": "top-k-frequent-elements",
    "description": "Given an integer array \nnums\n and an integer \nk\n, return \nthe\n \nk\n \nmost frequent elements\n. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,1,1,2,2,3], k = 2\n\nOutput:\n [1,2]\n\nExample 2:\n\n\nInput:\n nums = [1], k = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nk\n is in the range \n[1, the number of unique elements in the array]\n.\n\n\nIt is \nguaranteed\n that the answer is \nunique\n.\n\n\n\n\n \n\n\nFollow up:\n Your algorithm's time complexity must be better than \nO(n log n)\n, where n is the array's size.",
    "solution": "\nimport collections\n\n\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        counts = collections.Counter(nums)\n        buckets = [[] for _ in xrange(len(nums)+1)]\n        for i, count in counts.iteritems():\n            buckets[count].append(i)\n\n        result = []\n        for i in reversed(xrange(len(buckets))):\n            for j in xrange(len(buckets[i])):\n                result.append(buckets[i][j])\n                if len(result) == k:\n                    return result\n        return result\n\n\n# Quick Select Solution\nfrom random import randint\nclass Solution2(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        counts = collections.Counter(nums)\n        p = []\n        for key, val in counts.iteritems():\n            p.append((-val, key))\n        self.kthElement(p, k-1)\n\n        result = []\n        for i in xrange(k):\n            result.append(p[i][1])\n        return result\n\n    def kthElement(self, nums, k):\n        def PartitionAroundPivot(left, right, pivot_idx, nums):\n            pivot_value = nums[pivot_idx]\n            new_pivot_idx = left\n            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n            for i in xrange(left, right):\n                if nums[i] < pivot_value:\n                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                    new_pivot_idx += 1\n\n            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n            return new_pivot_idx\n\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k:\n                return\n            elif new_pivot_idx > k:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k.\n                left = new_pivot_idx + 1\n\n\nclass Solution3(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        return [key for key, _ in collections.Counter(nums).most_common(k)]",
    "explanation": "N/A",
    "time_complexity": "O(nlogk)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Merge Intervals",
    "difficulty": "MEDIUM",
    "category": "Array, Sorting",
    "link": "https://leetcode.com/problems/merge-intervals",
    "slug": "merge-intervals",
    "description": "Given an array of \nintervals\n where \nintervals[i] = [start\ni\n, end\ni\n]\n, merge all overlapping intervals, and return \nan array of the non-overlapping intervals that cover all the intervals in the input\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n intervals = [[1,3],[2,6],[8,10],[15,18]]\n\nOutput:\n [[1,6],[8,10],[15,18]]\n\nExplanation:\n Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\n\n\nExample 2:\n\n\n\n\nInput:\n intervals = [[1,4],[4,5]]\n\nOutput:\n [[1,5]]\n\nExplanation:\n Intervals [1,4] and [4,5] are considered overlapping.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= intervals.length <= 10\n4\n\n\nintervals[i].length == 2\n\n\n0 <= start\ni\n <= end\ni\n <= 10\n4",
    "solution": "\nclass Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        intervals.sort()\n        result = []\n        for interval in intervals:\n            if not result or interval[0] > result[-1][1]:\n                result.append(interval)\n            else:\n                result[-1][1] = max(result[-1][1], interval[1])\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Two Sum",
    "difficulty": "EASY",
    "category": "Array, Hash Table",
    "link": "https://leetcode.com/problems/two-sum",
    "slug": "two-sum",
    "description": "Given an array of integers \nnums\n and an integer \ntarget\n, return \nindices of the two numbers such that they add up to \ntarget\n.\n\n\nYou may assume that each input would have \nexactly\n one solution\n, and you may not use the \nsame\n element twice.\n\n\nYou can return the answer in any order.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [2,7,11,15], target = 9\n\nOutput:\n [0,1]\n\nExplanation:\n Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,4], target = 6\n\nOutput:\n [1,2]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,3], target = 6\n\nOutput:\n [0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n2 <= nums.length <= 10\n4\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n-10\n9\n <= target <= 10\n9\n\n\nOnly one valid answer exists.\n\n\n\n\n \n\n\nFollow-up: \nCan you come up with an algorithm that is less than \nO(n\n2\n)\n \ntime complexity?",
    "solution": "\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        lookup = {}\n        for i, num in enumerate(nums):\n            if target - num in lookup:\n                return [lookup[target - num], i]\n            lookup[num] = i\n\n    def twoSum2(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        for i in nums:\n            j = target - i\n            tmp_nums_start_index = nums.index(i) + 1\n            tmp_nums = nums[tmp_nums_start_index:]\n            if j in tmp_nums:\n                return [nums.index(i), tmp_nums_start_index + tmp_nums.index(j)]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "EASY",
    "category": "Array, Dynamic Programming",
    "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
    "slug": "best-time-to-buy-and-sell-stock",
    "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nYou want to maximize your profit by choosing a \nsingle day\n to buy one stock and choosing a \ndifferent day in the future\n to sell that stock.\n\n\nReturn \nthe maximum profit you can achieve from this transaction\n. If you cannot achieve any profit, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 5\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transactions are done and the max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n4",
    "solution": "\nclass Solution(object):\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, prices):\n        max_profit, min_price = 0, float(\"inf\")\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Merge k Sorted Lists",
    "difficulty": "HARD",
    "category": "Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort",
    "link": "https://leetcode.com/problems/merge-k-sorted-lists",
    "slug": "merge-k-sorted-lists",
    "description": "You are given an array of \nk\n linked-lists \nlists\n, each linked-list is sorted in ascending order.\n\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n lists = [[1,4,5],[1,3,4],[2,6]]\n\nOutput:\n [1,1,2,3,4,4,5,6]\n\nExplanation:\n The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted linked list:\n1->1->2->3->4->4->5->6\n\n\n\nExample 2:\n\n\n\n\nInput:\n lists = []\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n lists = [[]]\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nk == lists.length\n\n\n0 <= k <= 10\n4\n\n\n0 <= lists[i].length <= 500\n\n\n-10\n4\n <= lists[i][j] <= 10\n4\n\n\nlists[i]\n is sorted in \nascending order\n.\n\n\nThe sum of \nlists[i].length\n will not exceed \n10\n4\n.",
    "solution": "\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\t\t\n        if self:\t\t\n            return \"{} -> {}\".format(self.val, self.next)\n\n\n# Merge two by two solution.\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        if not lists:\n            return None\n        left, right = 0, len(lists) - 1\n        while right > 0:\n            lists[left] = mergeTwoLists(lists[left], lists[right])\n            left += 1\n            right -= 1\n            if left >= right:\n                left = 0\n        return lists[0]\n\n\n# Divide and Conquer solution.\nclass Solution2(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        def mergeKListsHelper(lists, begin, end):\n            if begin > end:\n                return None\n            if begin == end:\n                return lists[begin]\n            return mergeTwoLists(mergeKListsHelper(lists, begin, (begin + end) / 2), \\\n                                 mergeKListsHelper(lists, (begin + end) / 2 + 1, end))\n\n        return mergeKListsHelper(lists, 0, len(lists) - 1)\n\n\n# Heap solution.\nimport heapq\nclass Solution3(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        dummy = ListNode(0)\n        current = dummy\n\n        heap = []\n        for sorted_list in lists:\n            if sorted_list:\n                heapq.heappush(heap, (sorted_list.val, sorted_list))\n\n        while heap:\n            smallest = heapq.heappop(heap)[1]\n            current.next = smallest\n            current = current.next\n            if smallest.next:\n                heapq.heappush(heap, (smallest.next.val, smallest.next))\n\n        return dummy.next",
    "explanation": "N/A",
    "time_complexity": "O(nlogk)",
    "space_complexity": "O(k)"
  },
  {
    "title": "Valid Parentheses",
    "difficulty": "EASY",
    "category": "String, Stack",
    "link": "https://leetcode.com/problems/valid-parentheses",
    "slug": "valid-parentheses",
    "description": "Given a string \ns\n containing just the characters \n'('\n, \n')'\n, \n'{'\n, \n'}'\n, \n'['\n and \n']'\n, determine if the input string is valid.\n\n\nAn input string is valid if:\n\n\n\n\nOpen brackets must be closed by the same type of brackets.\n\n\nOpen brackets must be closed in the correct order.\n\n\nEvery close bracket has a corresponding open bracket of the same type.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"()\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"()[]{}\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"(]\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"([])\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"([)]\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of parentheses only \n'()[]{}'\n.",
    "solution": "\nclass Solution(object):\n    # @return a boolean\n    def isValid(self, s):\n        stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        for parenthese in s:\n            if parenthese in lookup:\n                stack.append(parenthese)\n            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:\n                return False\n        return len(stack) == 0",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Pow(x, n)",
    "difficulty": "MEDIUM",
    "category": "Math, Recursion",
    "link": "https://leetcode.com/problems/powx-n",
    "slug": "powx-n",
    "description": "Implement \npow(x, n)\n, which calculates \nx\n raised to the power \nn\n (i.e., \nx\nn\n).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n x = 2.00000, n = 10\n\nOutput:\n 1024.00000\n\n\n\nExample 2:\n\n\n\n\nInput:\n x = 2.10000, n = 3\n\nOutput:\n 9.26100\n\n\n\nExample 3:\n\n\n\n\nInput:\n x = 2.00000, n = -2\n\nOutput:\n 0.25000\n\nExplanation:\n 2\n-2\n = 1/2\n2\n = 1/4 = 0.25\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-100.0 < x < 100.0\n\n\n-2\n31\n <= n <= 2\n31\n-1\n\n\nn\n is an integer.\n\n\nEither \nx\n is not zero or \nn > 0\n.\n\n\n-10\n4\n <= x\nn\n <= 10\n4",
    "solution": "\nclass Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        result = 1\n        abs_n = abs(n)\n        while abs_n:\n            if abs_n & 1:\n                result *= x\n            abs_n >>= 1\n            x *= x\n\n        return 1 / result if n < 0 else result\n\n\n# Recursive solution.\nclass Solution2(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        if n < 0 and n != -n:\n            return 1.0 / self.myPow(x, -n)\n        if n == 0:\n            return 1\n        v = self.myPow(x, n / 2)\n        if n % 2 == 0:\n            return v * v\n        else:\n            return v * v * x",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(logn)"
  },
  {
    "title": "Buildings With an Ocean View",
    "difficulty": "MEDIUM",
    "category": "Array, Stack, Monotonic Stack",
    "link": "https://leetcode.com/problems/buildings-with-an-ocean-view",
    "slug": "buildings-with-an-ocean-view",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nclass Solution(object):\n    def findBuildings(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i, h in enumerate(heights):\n            while result and heights[result[-1]] <= h:\n                result.pop()\n            result.append(i)\n        return result\n\n\nclass Solution2(object):\n    def findBuildings(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i in reversed(xrange(len(heights))):\n            if not result or heights[result[-1]] < heights[i]:\n                result.append(i)\n        result.reverse()\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Custom Sort String",
    "difficulty": "MEDIUM",
    "category": "Hash Table, String, Sorting",
    "link": "https://leetcode.com/problems/custom-sort-string",
    "slug": "custom-sort-string",
    "description": "You are given two strings \norder\n and \ns\n. All the characters of \norder\n are \nunique\n and were sorted in some custom order previously.\n\n\nPermute the characters of \ns\n so that they match the order that \norder\n was sorted. More specifically, if a character \nx\n occurs before a character \ny\n in \norder\n, then \nx\n should occur before \ny\n in the permuted string.\n\n\nReturn \nany permutation of \ns\n that satisfies this property\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput: \n \n order = \"cba\", s = \"abcd\" \n\n\nOutput: \n \n \"cbad\" \n\n\nExplanation: \n \n\"a\"\n, \n\"b\"\n, \n\"c\"\n appear in order, so the order of \n\"a\"\n, \n\"b\"\n, \n\"c\"\n should be \n\"c\"\n, \n\"b\"\n, and \n\"a\"\n.\n\n\nSince \n\"d\"\n does not appear in \norder\n, it can be at any position in the returned string. \n\"dcba\"\n, \n\"cdba\"\n, \n\"cbda\"\n are also valid outputs.\n\n\n\n\nExample 2:\n\n\n\n\nInput: \n \n order = \"bcafg\", s = \"abcd\" \n\n\nOutput: \n \n \"bcad\" \n\n\nExplanation: \n The characters \n\"b\"\n, \n\"c\"\n, and \n\"a\"\n from \norder\n dictate the order for the characters in \ns\n. The character \n\"d\"\n in \ns\n does not appear in \norder\n, so its position is flexible.\n\n\nFollowing the order of appearance in \norder\n, \n\"b\"\n, \n\"c\"\n, and \n\"a\"\n from \ns\n should be arranged as \n\"b\"\n, \n\"c\"\n, \n\"a\"\n. \n\"d\"\n can be placed at any position since it's not in order. The output \n\"bcad\"\n correctly follows this rule. Other arrangements like \n\"dbca\"\n or \n\"bcda\"\n would also be valid, as long as \n\"b\"\n, \n\"c\"\n, \n\"a\"\n maintain their order.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= order.length <= 26\n\n\n1 <= s.length <= 200\n\n\norder\n and \ns\n consist of lowercase English letters.\n\n\nAll the characters of \norder\n are \nunique\n.",
    "solution": "\nimport collections\n\n\nclass Solution(object):\n    def customSortString(self, S, T):\n        \"\"\"\n        :type S: str\n        :type T: str\n        :rtype: str\n        \"\"\"\n        counter, s = collections.Counter(T), set(S)\n        result = [c*counter[c] for c in S]\n        result.extend([c*counter for c, counter in counter.iteritems() if c not in s])\n        return \"\".join(result)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "K Closest Points to Origin",
    "difficulty": "MEDIUM",
    "category": "Array, Math, Divide and Conquer, Geometry, Sorting, Heap (Priority Queue), Quickselect",
    "link": "https://leetcode.com/problems/k-closest-points-to-origin",
    "slug": "k-closest-points-to-origin",
    "description": "Given an array of \npoints\n where \npoints[i] = [x\ni\n, y\ni\n]\n represents a point on the \nX-Y\n plane and an integer \nk\n, return the \nk\n closest points to the origin \n(0, 0)\n.\n\n\nThe distance between two points on the \nX-Y\n plane is the Euclidean distance (i.e., \n√(x\n1\n - x\n2\n)\n2\n + (y\n1\n - y\n2\n)\n2\n).\n\n\nYou may return the answer in \nany order\n. The answer is \nguaranteed\n to be \nunique\n (except for the order that it is in).\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n points = [[1,3],[-2,2]], k = 1\n\nOutput:\n [[-2,2]]\n\nExplanation:\n\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n\n\n\nExample 2:\n\n\n\n\nInput:\n points = [[3,3],[5,-1],[-2,4]], k = 2\n\nOutput:\n [[3,3],[-2,4]]\n\nExplanation:\n The answer [[-2,4],[3,3]] would also be accepted.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= points.length <= 10\n4\n\n\n-10\n4\n <= x\ni\n, y\ni\n <= 10\n4",
    "solution": "\n# quick select solution\nfrom random import randint\n\n\nclass Solution(object):\n    def kClosest(self, points, K):\n        \"\"\"\n        :type points: List[List[int]]\n        :type K: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def dist(point):\n            return point[0]**2 + point[1]**2\n        \n        def kthElement(nums, k, compare):\n            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):\n                new_pivot_idx = left\n                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                for i in xrange(left, right):\n                    if compare(nums[i], nums[right]):\n                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                        new_pivot_idx += 1\n\n                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                return new_pivot_idx\n\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)\n                if new_pivot_idx == k:\n                    return\n                elif new_pivot_idx > k:\n                    right = new_pivot_idx - 1\n                else:  # new_pivot_idx < k.\n                    left = new_pivot_idx + 1\n                    \n        kthElement(points, K-1, lambda a, b: dist(a) < dist(b))\n        return points[:K]\n\n    \nimport heapq\n\n\nclass Solution2(object):\n    def kClosest(self, points, K):\n        \"\"\"\n        :type points: List[List[int]]\n        :type K: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def dist(point):\n            return point[0]**2 + point[1]**2\n        \n        max_heap = []\n        for point in points:\n            heapq.heappush(max_heap, (-dist(point), point))\n            if len(max_heap) > K:\n                heapq.heappop(max_heap)\n        return [heapq.heappop(max_heap)[1] for _ in xrange(len(max_heap))]",
    "explanation": "N/A",
    "time_complexity": "O(nlogk)",
    "space_complexity": "O(k)"
  },
  {
    "title": "Clone Graph",
    "difficulty": "MEDIUM",
    "category": "Hash Table, Depth-First Search, Breadth-First Search, Graph",
    "link": "https://leetcode.com/problems/clone-graph",
    "slug": "clone-graph",
    "description": "Given a reference of a node in a \nconnected\n undirected graph.\n\n\nReturn a \ndeep copy\n (clone) of the graph.\n\n\nEach node in the graph contains a value (\nint\n) and a list (\nList[Node]\n) of its neighbors.\n\n\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n\n\n\n \n\n\nTest case format:\n\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with \nval == 1\n, the second node with \nval == 2\n, and so on. The graph is represented in the test case using an adjacency list.\n\n\nAn adjacency list\n is a collection of unordered \nlists\n used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\n\nThe given node will always be the first node with \nval = 1\n. You must return the \ncopy of the given node\n as a reference to the cloned graph.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n adjList = [[2,4],[1,3],[2,4],[1,3]]\n\nOutput:\n [[2,4],[1,3],[2,4],[1,3]]\n\nExplanation:\n There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n adjList = [[]]\n\nOutput:\n [[]]\n\nExplanation:\n Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n\n\n\nExample 3:\n\n\n\n\nInput:\n adjList = []\n\nOutput:\n []\n\nExplanation:\n This an empty graph, it does not have any nodes.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the graph is in the range \n[0, 100]\n.\n\n\n1 <= Node.val <= 100\n\n\nNode.val\n is unique for each node.\n\n\nThere are no repeated edges and no self-loops in the graph.\n\n\nThe Graph is connected and all nodes can be visited starting from the given node.",
    "solution": "\nclass UndirectedGraphNode(object):\n    def __init__(self, x):\n        self.label = x\n        self.neighbors = []\n\nclass Solution(object):\n    # @param node, a undirected graph node\n    # @return a undirected graph node\n    def cloneGraph(self, node):\n        if node is None:\n            return None\n        cloned_node = UndirectedGraphNode(node.label)\n        cloned, queue = {node:cloned_node}, [node]\n\n        while queue:\n            current = queue.pop()\n            for neighbor in current.neighbors:\n                if neighbor not in cloned:\n                    queue.append(neighbor)\n                    cloned_neighbor = UndirectedGraphNode(neighbor.label)\n                    cloned[neighbor] = cloned_neighbor\n                cloned[current].neighbors.append(cloned[neighbor])\n        return cloned[node]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Subarray Sum Equals K",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Prefix Sum",
    "link": "https://leetcode.com/problems/subarray-sum-equals-k",
    "slug": "subarray-sum-equals-k",
    "description": "Given an array of integers \nnums\n and an integer \nk\n, return \nthe total number of subarrays whose sum equals to\n \nk\n.\n\n\nA subarray is a contiguous \nnon-empty\n sequence of elements within an array.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,1,1], k = 2\n\nOutput:\n 2\n\nExample 2:\n\n\nInput:\n nums = [1,2,3], k = 3\n\nOutput:\n 2\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2 * 10\n4\n\n\n-1000 <= nums[i] <= 1000\n\n\n-10\n7\n <= k <= 10\n7",
    "solution": "\nimport collections\n\n\nclass Solution(object):\n    def subarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        accumulated_sum = 0\n        lookup = collections.defaultdict(int)\n        lookup[0] += 1\n        for num in nums:\n            accumulated_sum += num\n            result += lookup[accumulated_sum - k]\n            lookup[accumulated_sum] += 1\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Range Sum of BST",
    "difficulty": "EASY",
    "category": "Tree, Depth-First Search, Binary Search Tree, Binary Tree",
    "link": "https://leetcode.com/problems/range-sum-of-bst",
    "slug": "range-sum-of-bst",
    "description": "Given the \nroot\n node of a binary search tree and two integers \nlow\n and \nhigh\n, return \nthe sum of values of all nodes with a value in the \ninclusive\n range \n[low, high]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [10,5,15,3,7,null,18], low = 7, high = 15\n\nOutput:\n 32\n\nExplanation:\n Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\n\nOutput:\n 23\n\nExplanation:\n Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 2 * 10\n4\n]\n.\n\n\n1 <= Node.val <= 10\n5\n\n\n1 <= low <= high <= 10\n5\n\n\nAll \nNode.val\n are \nunique\n.",
    "solution": "\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def rangeSumBST(self, root, L, R):\n        \"\"\"\n        :type root: TreeNode\n        :type L: int\n        :type R: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        s = [root]\n        while s:\n            node = s.pop()\n            if node:\n                if L <= node.val <= R:\n                    result += node.val\n                if L < node.val:\n                    s.append(node.left)\n                if node.val < R:\n                    s.append(node.right)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(h)"
  },
  {
    "title": "Dot Product of Two Sparse Vectors",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Two Pointers, Design",
    "link": "https://leetcode.com/problems/dot-product-of-two-sparse-vectors",
    "slug": "dot-product-of-two-sparse-vectors",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "#        dot_product: O(min(n, m))\n\nclass SparseVector:\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        self.lookup = {i:v for i, v in enumerate(nums) if v}\n\n    def dotProduct(self, vec):\n        \"\"\"\n        :type vec: 'SparseVector'\n        :rtype: int\n        \"\"\"\n        if len(self.lookup) > len(vec.lookup):\n            self, vec = vec, self\n        return sum(v*vec.lookup[i] for i, v in self.lookup.iteritems() if i in vec.lookup)",
    "explanation": "N/A",
    "time_complexity": "ctor: O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Valid Palindrome",
    "difficulty": "EASY",
    "category": "Two Pointers, String",
    "link": "https://leetcode.com/problems/valid-palindrome",
    "slug": "valid-palindrome",
    "description": "A phrase is a \npalindrome\n if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\n\nGiven a string \ns\n, return \ntrue\n if it is a \npalindrome\n, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"A man, a plan, a canal: Panama\"\n\nOutput:\n true\n\nExplanation:\n \"amanaplanacanalpanama\" is a palindrome.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"race a car\"\n\nOutput:\n false\n\nExplanation:\n \"raceacar\" is not a palindrome.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \" \"\n\nOutput:\n true\n\nExplanation:\n s is an empty string \"\" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 2 * 10\n5\n\n\ns\n consists only of printable ASCII characters.",
    "solution": "\nclass Solution(object):\n    # @param s, a string\n    # @return a boolean\n    def isPalindrome(self, s):\n        i, j = 0, len(s) - 1\n        while i < j:\n            while i < j and not s[i].isalnum():\n                i += 1\n            while i < j and not s[j].isalnum():\n                j -= 1\n            if s[i].lower() != s[j].lower():\n                return False\n            i, j = i + 1, j - 1\n        return True",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Next Permutation",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers",
    "link": "https://leetcode.com/problems/next-permutation",
    "slug": "next-permutation",
    "description": "A \npermutation\n of an array of integers is an arrangement of its members into a sequence or linear order.\n\n\n\n\nFor example, for \narr = [1,2,3]\n, the following are all the permutations of \narr\n: \n[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]\n.\n\n\n\n\nThe \nnext permutation\n of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the \nnext permutation\n of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n\n\n\nFor example, the next permutation of \narr = [1,2,3]\n is \n[1,3,2]\n.\n\n\nSimilarly, the next permutation of \narr = [2,3,1]\n is \n[3,1,2]\n.\n\n\nWhile the next permutation of \narr = [3,2,1]\n is \n[1,2,3]\n because \n[3,2,1]\n does not have a lexicographical larger rearrangement.\n\n\n\n\nGiven an array of integers \nnums\n, \nfind the next permutation of\n \nnums\n.\n\n\nThe replacement must be \nin place\n and use only constant extra memory.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n [1,3,2]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [3,2,1]\n\nOutput:\n [1,2,3]\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,1,5]\n\nOutput:\n [1,5,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 100\n\n\n0 <= nums[i] <= 100",
    "solution": "\nclass Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in reversed(xrange(len(nums)-1)):\n            if nums[i] < nums[i+1]:\n                k = i\n                break\n        else:\n            nums.reverse()\n            return\n\n        for i in reversed(xrange(k+1, len(nums))):\n            if nums[i] > nums[k]:\n                l = i\n                break\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]\n        \n\nclass Solution2(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in xrange(len(nums)-1):\n            if nums[i] < nums[i+1]:\n                k = i\n\n        if k == -1:\n            nums.reverse()\n            return\n\n        for i in xrange(k+1, len(nums)):\n            if nums[i] > nums[k]:\n                l = i\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Shortest Path in Binary Matrix",
    "difficulty": "MEDIUM",
    "category": "Array, Breadth-First Search, Matrix",
    "link": "https://leetcode.com/problems/shortest-path-in-binary-matrix",
    "slug": "shortest-path-in-binary-matrix",
    "description": "Given an \nn x n\n binary matrix \ngrid\n, return \nthe length of the shortest \nclear path\n in the matrix\n. If there is no clear path, return \n-1\n.\n\n\nA \nclear path\n in a binary matrix is a path from the \ntop-left\n cell (i.e., \n(0, 0)\n) to the \nbottom-right\n cell (i.e., \n(n - 1, n - 1)\n) such that:\n\n\n\n\nAll the visited cells of the path are \n0\n.\n\n\nAll the adjacent cells of the path are \n8-directionally\n connected (i.e., they are different and they share an edge or a corner).\n\n\n\n\nThe \nlength of a clear path\n is the number of visited cells of this path.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,1],[1,0]]\n\nOutput:\n 2\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,0,0],[1,1,0],[1,1,0]]\n\nOutput:\n 4\n\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[1,0,0],[1,1,0],[1,1,0]]\n\nOutput:\n -1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\nn == grid[i].length\n\n\n1 <= n <= 100\n\n\ngrid[i][j] is 0 or 1",
    "solution": "\nimport collections\n\n\nclass Solution(object):\n    def shortestPathBinaryMatrix(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(-1, -1), (-1, 0), (-1, 1), \\\n                      ( 0, -1), ( 0, 1), \\\n                      ( 1, -1), ( 1, 0), ( 1, 1)]\n        result = 0\n        q = collections.deque([(0, 0)])\n        while q:\n            result += 1\n            next_depth = collections.deque()\n            while q:\n                i, j = q.popleft()\n                if 0 <= i < len(grid) and \\\n                   0 <= j < len(grid[0]) and \\\n                    not grid[i][j]:\n                    grid[i][j] = 1\n                    if i == len(grid)-1 and j == len(grid)-1:\n                        return result\n                    for d in directions:\n                        next_depth.append((i+d[0], j+d[1]))\n            q = next_depth\n        return -1",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Copy List with Random Pointer",
    "difficulty": "MEDIUM",
    "category": "Hash Table, Linked List",
    "link": "https://leetcode.com/problems/copy-list-with-random-pointer",
    "slug": "copy-list-with-random-pointer",
    "description": "A linked list of length \nn\n is given such that each node contains an additional random pointer, which could point to any node in the list, or \nnull\n.\n\n\nConstruct a \ndeep copy\n of the list. The deep copy should consist of exactly \nn\n \nbrand new\n nodes, where each new node has its value set to the value of its corresponding original node. Both the \nnext\n and \nrandom\n pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. \nNone of the pointers in the new list should point to nodes in the original list\n.\n\n\nFor example, if there are two nodes \nX\n and \nY\n in the original list, where \nX.random --> Y\n, then for the corresponding two nodes \nx\n and \ny\n in the copied list, \nx.random --> y\n.\n\n\nReturn \nthe head of the copied linked list\n.\n\n\nThe linked list is represented in the input/output as a list of \nn\n nodes. Each node is represented as a pair of \n[val, random_index]\n where:\n\n\n\n\nval\n: an integer representing \nNode.val\n\n\nrandom_index\n: the index of the node (range from \n0\n to \nn-1\n) that the \nrandom\n pointer points to, or \nnull\n if it does not point to any node.\n\n\n\n\nYour code will \nonly\n be given the \nhead\n of the original linked list.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n\nOutput:\n [[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n head = [[1,1],[2,1]]\n\nOutput:\n [[1,1],[2,1]]\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n head = [[3,null],[3,0],[3,null]]\n\nOutput:\n [[3,null],[3,0],[3,null]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= n <= 1000\n\n\n-10\n4\n <= Node.val <= 10\n4\n\n\nNode.random\n is \nnull\n or is pointing to some node in the linked list.",
    "solution": "\nclass Node(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n        self.random = None\n\nclass Solution(object):\n    # @param head, a RandomListNode\n    # @return a RandomListNode\n    def copyRandomList(self, head):\n        # copy and combine copied list with original list\n        current = head\n        while current:\n            copied = Node(current.val)\n            copied.next = current.next\n            current.next = copied\n            current = copied.next\n\n        # update random node in copied list\n        current = head\n        while current:\n            if current.random:\n                current.next.random = current.random.next\n            current = current.next.next\n\n        # split copied list from combined one\n        dummy = Node(0)\n        copied_current, current = dummy, head\n        while current:\n            copied_current.next = current.next\n            current.next = current.next.next\n            copied_current, current = copied_current.next, current.next\n        return dummy.next\n\nclass Solution2(object):\n    # @param head, a RandomListNode\n    # @return a RandomListNode\n    def copyRandomList(self, head):\n        dummy = Node(0)\n        current, prev, copies = head, dummy, {}\n\n        while current:\n            copied = Node(current.val)\n            copies[current] = copied\n            prev.next = copied\n            prev, current = prev.next, current.next\n\n        current = head\n        while current:\n            if current.random:\n                copies[current].random = copies[current.random]\n            current = current.next\n\n        return dummy.next\n\n# time: O(n)\n# space: O(n)\nfrom collections import defaultdict\n\n\nclass Solution3(object):\n    def copyRandomList(self, head):\n        \"\"\"\n        :type head: RandomListNode\n        :rtype: RandomListNode\n        \"\"\"\n        clone = defaultdict(lambda: Node(0))\n        clone[None] = None\n        cur = head\n\n        while cur:\n            clone[cur].val = cur.val\n            clone[cur].next = clone[cur.next]\n            clone[cur].random = clone[cur.random]\n            cur = cur.next\n\n        return clone[head]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Merge Sorted Array",
    "difficulty": "EASY",
    "category": "Array, Two Pointers, Sorting",
    "link": "https://leetcode.com/problems/merge-sorted-array",
    "slug": "merge-sorted-array",
    "description": "You are given two integer arrays \nnums1\n and \nnums2\n, sorted in \nnon-decreasing order\n, and two integers \nm\n and \nn\n, representing the number of elements in \nnums1\n and \nnums2\n respectively.\n\n\nMerge\n \nnums1\n and \nnums2\n into a single array sorted in \nnon-decreasing order\n.\n\n\nThe final sorted array should not be returned by the function, but instead be \nstored inside the array \nnums1\n. To accommodate this, \nnums1\n has a length of \nm + n\n, where the first \nm\n elements denote the elements that should be merged, and the last \nn\n elements are set to \n0\n and should be ignored. \nnums2\n has a length of \nn\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n\nOutput:\n [1,2,2,3,5,6]\n\nExplanation:\n The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [\n1\n,\n2\n,2,\n3\n,5,6] with the underlined elements coming from nums1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1], m = 1, nums2 = [], n = 0\n\nOutput:\n [1]\n\nExplanation:\n The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums1 = [0], m = 0, nums2 = [1], n = 1\n\nOutput:\n [1]\n\nExplanation:\n The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m + n\n\n\nnums2.length == n\n\n\n0 <= m, n <= 200\n\n\n1 <= m + n <= 200\n\n\n-10\n9\n <= nums1[i], nums2[j] <= 10\n9\n\n\n\n\n \n\n\nFollow up: \nCan you come up with an algorithm that runs in \nO(m + n)\n time?",
    "solution": "\nclass Solution(object):\n    # @param A  a list of integers\n    # @param m  an integer, length of A\n    # @param B  a list of integers\n    # @param n  an integer, length of B\n    # @return nothing\n    def merge(self, A, m, B, n):\n        last, i, j = m + n - 1, m - 1, n - 1\n\n        while i >= 0 and j >= 0:\n            if A[i] > B[j]:\n                A[last] = A[i]\n                last, i = last - 1, i - 1\n            else:\n                A[last] = B[j]\n                last, j = last - 1, j - 1\n\n        while j >= 0:\n                A[last] = B[j]\n                last, j = last - 1, j - 1",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Sliding Window Median",
    "difficulty": "HARD",
    "category": "Array, Hash Table, Sliding Window, Heap (Priority Queue)",
    "link": "https://leetcode.com/problems/sliding-window-median",
    "slug": "sliding-window-median",
    "description": "The \nmedian\n is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\n\n\n\nFor examples, if \narr = [2,\n3\n,4]\n, the median is \n3\n.\n\n\nFor examples, if \narr = [1,\n2,3\n,4]\n, the median is \n(2 + 3) / 2 = 2.5\n.\n\n\n\n\nYou are given an integer array \nnums\n and an integer \nk\n. There is a sliding window of size \nk\n which is moving from the very left of the array to the very right. You can only see the \nk\n numbers in the window. Each time the sliding window moves right by one position.\n\n\nReturn \nthe median array for each window in the original array\n. Answers within \n10\n-5\n of the actual value will be accepted.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,3,-1,-3,5,3,6,7], k = 3\n\nOutput:\n [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\n\nExplanation:\n \nWindow position                Median\n---------------                -----\n[\n1  3  -1\n] -3  5  3  6  7        1\n 1 [\n3  -1  -3\n] 5  3  6  7       -1\n 1  3 [\n-1  -3  5\n] 3  6  7       -1\n 1  3  -1 [\n-3  5  3\n] 6  7        3\n 1  3  -1  -3 [\n5  3  6\n] 7        5\n 1  3  -1  -3  5 [\n3  6  7\n]       6\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,2,3,4,2,3,1,4,2], k = 3\n\nOutput:\n [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= nums.length <= 10\n5\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1",
    "solution": "\nfrom sortedcontainers import SortedList\n\n\nclass Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        sl = SortedList(float(nums[i])for i in xrange(k))\n        result = [(sl[k//2]+sl[k//2-(1-k%2)])/2]\n        for i in xrange(k, len(nums)):\n            sl.add(float(nums[i]))\n            sl.remove(nums[i-k])\n            result.append((sl[k//2]+sl[k//2-(1-k%2)])/2)\n        return result\n\n\nimport collections\nimport heapq\n\n\nclass Solution2(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        def lazy_delete(heap, to_remove, sign):\n            while heap and sign*heap[0] in to_remove:\n                to_remove[sign*heap[0]] -= 1\n                if not to_remove[sign*heap[0]]:\n                    del to_remove[sign*heap[0]]\n                heapq.heappop(heap)\n\n        def full_delete(heap, to_remove, sign):  # Time: O(k), Space: O(k)\n            result = []\n            for x in heap:\n                if sign*x not in to_remove:\n                    result.append(x)\n                    continue\n                to_remove[sign*x] -= 1\n                if not to_remove[sign*x]:\n                    del to_remove[sign*x]\n            heap[:] = result\n            heapq.heapify(heap)\n\n        min_heap, max_heap = [], []\n        for i in xrange(k):\n            if i%2 == 0:\n                heapq.heappush(min_heap, -heapq.heappushpop(max_heap, -nums[i]))\n            else:\n                heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))\n        result = [float(min_heap[0])] if k%2 else [(min_heap[0]-max_heap[0])/2.0]\n        to_remove = collections.defaultdict(int)\n        for i in xrange(k, len(nums)):\n            heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))\n            if nums[i-k] > -max_heap[0]:\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n            to_remove[nums[i-k]] += 1\n            lazy_delete(max_heap, to_remove, -1)\n            lazy_delete(min_heap, to_remove, 1)\n            if len(min_heap)+len(max_heap) > 2*k:\n                full_delete(max_heap, to_remove, -1)\n                full_delete(min_heap, to_remove, 1)\n            result.append(float(min_heap[0]) if k%2 else (min_heap[0]-max_heap[0])/2.0)\n        return result\n\n\nimport collections\nimport heapq\n\n\nclass Solution3(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        def lazy_delete(heap, to_remove, sign):\n            while heap and sign*heap[0] in to_remove:\n                to_remove[sign*heap[0]] -= 1\n                if not to_remove[sign*heap[0]]:\n                    del to_remove[sign*heap[0]]\n                heapq.heappop(heap)\n\n        min_heap, max_heap = [], []\n        for i in xrange(k):\n            if i%2 == 0:\n                heapq.heappush(min_heap, -heapq.heappushpop(max_heap, -nums[i]))\n            else:\n                heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))\n        result = [float(min_heap[0])] if k%2 else [(min_heap[0]-max_heap[0])/2.0]\n        to_remove = collections.defaultdict(int)\n        for i in xrange(k, len(nums)):\n            heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))\n            if nums[i-k] > -max_heap[0]:\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n            to_remove[nums[i-k]] += 1\n            lazy_delete(max_heap, to_remove, -1)\n            lazy_delete(min_heap, to_remove, 1)\n            result.append(float(min_heap[0]) if k%2 else (min_heap[0]-max_heap[0])/2.0)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(nlogn) due to lazy delete",
    "space_complexity": "O(n)"
  },
  {
    "title": "Simplify Path",
    "difficulty": "MEDIUM",
    "category": "String, Stack",
    "link": "https://leetcode.com/problems/simplify-path",
    "slug": "simplify-path",
    "description": "You are given an \nabsolute\n path for a Unix-style file system, which always begins with a slash \n'/'\n. Your task is to transform this absolute path into its \nsimplified canonical path\n.\n\n\nThe \nrules\n of a Unix-style file system are as follows:\n\n\n\n\nA single period \n'.'\n represents the current directory.\n\n\nA double period \n'..'\n represents the previous/parent directory.\n\n\nMultiple consecutive slashes such as \n'//'\n and \n'///'\n are treated as a single slash \n'/'\n.\n\n\nAny sequence of periods that does \nnot match\n the rules above should be treated as a \nvalid directory or\n \nfile \nname\n. For example, \n'...' \nand \n'....'\n are valid directory or file names.\n\n\n\n\nThe simplified canonical path should follow these \nrules\n:\n\n\n\n\nThe path must start with a single slash \n'/'\n.\n\n\nDirectories within the path must be separated by exactly one slash \n'/'\n.\n\n\nThe path must not end with a slash \n'/'\n, unless it is the root directory.\n\n\nThe path must not have any single or double periods (\n'.'\n and \n'..'\n) used to denote current or parent directories.\n\n\n\n\nReturn the \nsimplified canonical path\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \npath = \"/home/\"\n\n\nOutput:\n \n\"/home\"\n\n\nExplanation:\n\n\nThe trailing slash should be removed.\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \npath = \"/home//foo/\"\n\n\nOutput:\n \n\"/home/foo\"\n\n\nExplanation:\n\n\nMultiple consecutive slashes are replaced by a single one.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \npath = \"/home/user/Documents/../Pictures\"\n\n\nOutput:\n \n\"/home/user/Pictures\"\n\n\nExplanation:\n\n\nA double period \n\"..\"\n refers to the directory up a level (the parent directory).\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \npath = \"/../\"\n\n\nOutput:\n \n\"/\"\n\n\nExplanation:\n\n\nGoing one level up from the root directory is not possible.\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \npath = \"/.../a/../b/c/../d/./\"\n\n\nOutput:\n \n\"/.../b/d\"\n\n\nExplanation:\n\n\n\"...\"\n is a valid name for a directory in this problem.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= path.length <= 3000\n\n\npath\n consists of English letters, digits, period \n'.'\n, slash \n'/'\n or \n'_'\n.\n\n\npath\n is a valid absolute Unix path.",
    "solution": "\nclass Solution(object):\n    # @param path, a string\n    # @return a string\n    def simplifyPath(self, path):\n        stack, tokens = [], path.split(\"/\")\n        for token in tokens:\n            if token == \"..\" and stack:\n                stack.pop()\n            elif token != \"..\" and token != \".\" and token:\n                stack.append(token)\n        return \"/\" + \"/\".join(stack)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Making A Large Island",
    "difficulty": "HARD",
    "category": "Array, Depth-First Search, Breadth-First Search, Union Find, Matrix",
    "link": "https://leetcode.com/problems/making-a-large-island",
    "slug": "making-a-large-island",
    "description": "You are given an \nn x n\n binary matrix \ngrid\n. You are allowed to change \nat most one\n \n0\n to be \n1\n.\n\n\nReturn \nthe size of the largest \nisland\n in\n \ngrid\n \nafter applying this operation\n.\n\n\nAn \nisland\n is a 4-directionally connected group of \n1\ns.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n grid = [[1,0],[0,1]]\n\nOutput:\n 3\n\nExplanation:\n Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [[1,1],[1,0]]\n\nOutput:\n 4\n\nExplanation: \nChange the 0 to 1 and make the island bigger, only one island with area = 4.\n\n\nExample 3:\n\n\n\n\nInput:\n grid = [[1,1],[1,1]]\n\nOutput:\n 4\n\nExplanation:\n Can't change any 0 to 1, only one island with area = 4.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\nn == grid[i].length\n\n\n1 <= n <= 500\n\n\ngrid[i][j]\n is either \n0\n or \n1\n.",
    "solution": "\n\nclass Solution(object):\n    def largestIsland(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n        def dfs(r, c, index, grid):\n            if not (0 <= r < len(grid) and\n                    0 <= c < len(grid[0]) and\n                    grid[r][c] == 1):\n                return 0\n            result = 1\n            grid[r][c] = index\n            for d in directions:\n                result += dfs(r+d[0], c+d[1], index, grid)\n            return result\n\n        area = {}\n        index = 2\n        for r in xrange(len(grid)):\n            for c in xrange(len(grid[r])):\n                if grid[r][c] == 1:\n                    area[index] = dfs(r, c, index, grid)\n                    index += 1\n\n        result = max(area.values() or [0])\n        for r in xrange(len(grid)):\n            for c in xrange(len(grid[r])):\n                if grid[r][c] == 0:\n                    seen = set()\n                    for d in directions:\n                        nr, nc = r+d[0], c+d[1]\n                        if not (0 <= nr < len(grid) and\n                                0 <= nc < len(grid[0]) and\n                                grid[nr][nc] > 1):\n                            continue\n                        seen.add(grid[nr][nc])\n                    result = max(result, 1 + sum(area[i] for i in seen))\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n^2)"
  },
  {
    "title": "Minimum Window Substring",
    "difficulty": "HARD",
    "category": "Hash Table, String, Sliding Window",
    "link": "https://leetcode.com/problems/minimum-window-substring",
    "slug": "minimum-window-substring",
    "description": "Given two strings \ns\n and \nt\n of lengths \nm\n and \nn\n respectively, return \nthe \nminimum window\n \nsubstring\n of \ns\n such that every character in \nt\n (\nincluding duplicates\n) is included in the window\n. If there is no such substring, return \nthe empty string \n\"\"\n.\n\n\nThe testcases will be generated such that the answer is \nunique\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"ADOBECODEBANC\", t = \"ABC\"\n\nOutput:\n \"BANC\"\n\nExplanation:\n The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"a\", t = \"a\"\n\nOutput:\n \"a\"\n\nExplanation:\n The entire string s is the minimum window.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"a\", t = \"aa\"\n\nOutput:\n \"\"\n\nExplanation:\n Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == s.length\n\n\nn == t.length\n\n\n1 <= m, n <= 10\n5\n\n\ns\n and \nt\n consist of uppercase and lowercase English letters.\n\n\n\n\n \n\n\nFollow up:\n Could you find an algorithm that runs in \nO(m + n)\n time?",
    "solution": "\nimport collections\n\n\nclass Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        count, remain = collections.Counter(t), len(t)\n        i, left, right = 0, -1, -1\n        for j, c in enumerate(s):\n            remain -= count[c] > 0\n            count[c] -= 1\n            if remain:\n                continue\n            while count[s[i]] < 0:  # greedily discard uneeds\n                count[s[i]] += 1\n                i += 1\n            if right == -1 or j-i+1 < right-left+1:\n                left, right = i, j\n        return s[left:right+1]\n\n\nclass Solution2(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        current_count = [0 for i in xrange(52)]\n        expected_count = [0 for i in xrange(52)]\n\n        for char in t:\n            expected_count[ord(char) - ord('a')] += 1\n\n        i, count, start, min_width, min_start = 0, 0, 0, float(\"inf\"), 0\n        while i < len(s):\n            current_count[ord(s[i]) - ord('a')] += 1\n            if current_count[ord(s[i]) - ord('a')] <= expected_count[ord(s[i]) - ord('a')]:\n                count += 1\n\n            if count == len(t):\n                while expected_count[ord(s[start]) - ord('a')] == 0 or \\\n                      current_count[ord(s[start]) - ord('a')] > expected_count[ord(s[start]) - ord('a')]:\n                    current_count[ord(s[start]) - ord('a')] -= 1\n                    start += 1\n\n                if min_width > i - start + 1:\n                    min_width = i - start + 1\n                    min_start = start\n            i += 1\n\n        if min_width == float(\"inf\"):\n            return \"\"\n\n        return s[min_start:min_start + min_width]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(k), k is the number of different characters"
  },
  {
    "title": "Accounts Merge",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, String, Depth-First Search, Breadth-First Search, Union Find, Sorting",
    "link": "https://leetcode.com/problems/accounts-merge",
    "slug": "accounts-merge",
    "description": "Given a list of \naccounts\n where each element \naccounts[i]\n is a list of strings, where the first element \naccounts[i][0]\n is a name, and the rest of the elements are \nemails\n representing emails of the account.\n\n\nNow, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\n\n\nAfter merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails \nin sorted order\n. The accounts themselves can be returned in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\n\nOutput:\n [[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\n\nExplanation:\n\nThe first and second John's are the same person as they have the common email \"johnsmith@mail.com\".\nThe third John and Mary are different people as none of their email addresses are used by other accounts.\nWe could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], \n['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.\n\n\n\nExample 2:\n\n\n\n\nInput:\n accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]\n\nOutput:\n [[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= accounts.length <= 1000\n\n\n2 <= accounts[i].length <= 10\n\n\n1 <= accounts[i][j].length <= 30\n\n\naccounts[i][0]\n consists of English letters.\n\n\naccounts[i][j] (for j > 0)\n is a valid email.",
    "solution": "#                  and the max length ofemail is 320, p.s. {64}@{255}\n\nimport collections\n\n\nclass UnionFind(object):\n    def __init__(self):\n        self.set = []\n\n    def get_id(self):\n        self.set.append(len(self.set))\n        return len(self.set)-1\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root != y_root:\n            self.set[min(x_root, y_root)] = max(x_root, y_root)\n\n\nclass Solution(object):\n    def accountsMerge(self, accounts):\n        \"\"\"\n        :type accounts: List[List[str]]\n        :rtype: List[List[str]]\n        \"\"\"\n        union_find = UnionFind()\n        email_to_name = {}\n        email_to_id = {}\n        for account in accounts:\n            name = account[0]\n            for i in xrange(1, len(account)):\n                if account[i] not in email_to_id:\n                    email_to_name[account[i]] = name\n                    email_to_id[account[i]] = union_find.get_id()\n                union_find.union_set(email_to_id[account[1]],\n                                     email_to_id[account[i]])\n\n        result = collections.defaultdict(list)\n        for email in email_to_name.keys():\n            result[union_find.find_set(email_to_id[email])].append(email)\n        for emails in result.values():\n            emails.sort()\n        return [[email_to_name[emails[0]]] + emails\n                for emails in result.values()]",
    "explanation": "N/A",
    "time_complexity": "O(nlogn), n is the number of total emails,",
    "space_complexity": "O(n)"
  },
  {
    "title": "LRU Cache",
    "difficulty": "MEDIUM",
    "category": "Hash Table, Linked List, Design, Doubly-Linked List",
    "link": "https://leetcode.com/problems/lru-cache",
    "slug": "lru-cache",
    "description": "Design a data structure that follows the constraints of a \nLeast Recently Used (LRU) cache\n.\n\n\nImplement the \nLRUCache\n class:\n\n\n\n\nLRUCache(int capacity)\n Initialize the LRU cache with \npositive\n size \ncapacity\n.\n\n\nint get(int key)\n Return the value of the \nkey\n if the key exists, otherwise return \n-1\n.\n\n\nvoid put(int key, int value)\n Update the value of the \nkey\n if the \nkey\n exists. Otherwise, add the \nkey-value\n pair to the cache. If the number of keys exceeds the \ncapacity\n from this operation, \nevict\n the least recently used key.\n\n\n\n\nThe functions \nget\n and \nput\n must each run in \nO(1)\n average time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n\nOutput\n\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n\nExplanation\n\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= capacity <= 3000\n\n\n0 <= key <= 10\n4\n\n\n0 <= value <= 10\n5\n\n\nAt most \n2 * 10\n5\n calls will be made to \nget\n and \nput\n.",
    "solution": "\nimport collections\n\n\n# using OrderedDict\nclass LRUCache(object):\n    def __init__(self, capacity):\n        self.cache = collections.OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        val = self.cache[key]\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.cache and len(self.cache) == self.capacity:\n            self.cache.popitem(last=False)\n        self.__update(key, val)\n    \n    def __update(self, key, val):\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = val\n\n\n\n\nclass ListNode(object):\n    def __init__(self, key, val):\n        self.val = val\n        self.key = key\n        self.next = None\n        self.prev = None\n\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\n\nclass LRUCache2(object):\n\n    def __init__(self, capacity):\n        self.list = LinkedList()\n        self.dict = {}\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.dict:\n            return -1\n        val = self.dict[key].val\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.dict and len(self.dict) == self.capacity:\n            del self.dict[self.list.head.key]\n            self.list.delete(self.list.head)\n        self.__update(key, val)\n\n    def __update(self, key, val):\n        if key in self.dict:\n            self.list.delete(self.dict[key])\n        node = ListNode(key, val)\n        self.list.insert(node)\n        self.dict[key] = node",
    "explanation": "N/A",
    "time_complexity": "O(1), per operation.",
    "space_complexity": "O(k), k is the capacity of cache."
  },
  {
    "title": "Max Consecutive Ones III",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search, Sliding Window, Prefix Sum",
    "link": "https://leetcode.com/problems/max-consecutive-ones-iii",
    "slug": "max-consecutive-ones-iii",
    "description": "Given a binary array \nnums\n and an integer \nk\n, return \nthe maximum number of consecutive \n1\n's in the array if you can flip at most\n \nk\n \n0\n's.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\n\nOutput:\n 6\n\nExplanation:\n [1,1,1,0,0,\n1\n,1,1,1,1,\n1\n]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\n\nOutput:\n 10\n\nExplanation:\n [0,0,\n1,1,\n1\n,\n1\n,1,1,1,\n1\n,1,1\n,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\nnums[i]\n is either \n0\n or \n1\n.\n\n\n0 <= k <= nums.length",
    "solution": "\nclass Solution(object):\n    def longestOnes(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        result, i = 0, 0\n        for j in xrange(len(A)):\n            K -= int(A[j] == 0)\n            while K < 0:\n                K += int(A[i] == 0)\n                i += 1\n            result = max(result, j-i+1)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Kth Missing Positive Number",
    "difficulty": "EASY",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/kth-missing-positive-number",
    "slug": "kth-missing-positive-number",
    "description": "Given an array \narr\n of positive integers sorted in a \nstrictly increasing order\n, and an integer \nk\n.\n\n\nReturn \nthe\n \nk\nth\n \npositive\n integer that is \nmissing\n from this array.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n arr = [2,3,4,7,11], k = 5\n\nOutput:\n 9\n\nExplanation: \nThe missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5\nth\n missing positive integer is 9.\n\n\n\nExample 2:\n\n\n\n\nInput:\n arr = [1,2,3,4], k = 2\n\nOutput:\n 6\n\nExplanation: \nThe missing positive integers are [5,6,7,...]. The 2\nnd\n missing positive integer is 6.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= arr.length <= 1000\n\n\n1 <= arr[i] <= 1000\n\n\n1 <= k <= 1000\n\n\narr[i] < arr[j]\n for \n1 <= i < j <= arr.length\n\n\n\n\n \n\n\nFollow up:\n\n\nCould you solve this problem in less than O(n) complexity?",
    "solution": "\nclass Solution(object):\n    def findKthPositive(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def check(arr, k, x):\n            return arr[x]-(x+1) < k\n\n        left, right = 0, len(arr)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(arr, k, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right+1+k  # arr[right] + (k-(arr[right]-(right+1))) if right >= 0 else k",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Find First and Last Position of Element in Sorted Array",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array",
    "slug": "find-first-and-last-position-of-element-in-sorted-array",
    "description": "Given an array of integers \nnums\n sorted in non-decreasing order, find the starting and ending position of a given \ntarget\n value.\n\n\nIf \ntarget\n is not found in the array, return \n[-1, -1]\n.\n\n\nYou must write an algorithm with \nO(log n)\n runtime complexity.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [5,7,7,8,8,10], target = 8\n\nOutput:\n [3,4]\n\nExample 2:\n\n\nInput:\n nums = [5,7,7,8,8,10], target = 6\n\nOutput:\n [-1,-1]\n\nExample 3:\n\n\nInput:\n nums = [], target = 0\n\nOutput:\n [-1,-1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\nnums\n is a non-decreasing array.\n\n\n-10\n9\n <= target <= 10\n9",
    "solution": "\nclass Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        def binarySearch(n, check):  # usually use\n            left, right = 0, n-1  # search in [0, n-1], return n if not found\n            while left <= right:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left  # or return right+1\n\n        def binarySearch2(n, check):  # frequently use\n            left, right = 0, n  # search in [0, n), return n if not found\n            while left < right:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid\n                else:\n                    left = mid+1\n            return left  # or return right\n\n        def binarySearch3(n, check):  # never use\n            left, right = -1, n-1  # search in (-1, n-1], return n if not found\n            while left < right:\n                mid = right - (right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid\n            return left+1  # or return right+1\n\n        def binarySearch4(n, check):  # sometimes use\n            left, right = -1, n  # search in (-1, n), return n if not found\n            while right-left >= 2:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid\n                else:\n                    left = mid\n            return left+1  # or return right\n\n        # Find the first idx where nums[idx] >= target\n        left = binarySearch(len(nums), lambda i: nums[i] >= target)\n        if left == len(nums) or nums[left] != target:\n            return [-1, -1]\n        # Find the first idx where nums[idx] > target\n        right = binarySearch(len(nums), lambda i: nums[i] > target)\n        return [left, right-1]",
    "explanation": "N/A",
    "time_complexity": "O(logn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Longest Common Prefix",
    "difficulty": "EASY",
    "category": "String, Trie",
    "link": "https://leetcode.com/problems/longest-common-prefix",
    "slug": "longest-common-prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings.\n\n\nIf there is no common prefix, return an empty string \n\"\"\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n strs = [\"flower\",\"flow\",\"flight\"]\n\nOutput:\n \"fl\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n strs = [\"dog\",\"racecar\",\"car\"]\n\nOutput:\n \"\"\n\nExplanation:\n There is no common prefix among the input strings.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 200\n\n\n0 <= strs[i].length <= 200\n\n\nstrs[i]\n consists of only lowercase English letters if it is non-empty.",
    "solution": "\nclass Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n\n        for i in xrange(len(strs[0])):\n            for string in strs[1:]:\n                if i >= len(string) or string[i] != strs[0][i]:\n                    return strs[0][:i]\n        return strs[0]\n\n\nclass Solution2(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        prefix = \"\"\n        \n        for chars in zip(*strs):\n            if all(c == chars[0] for c in chars):\n                prefix += chars[0]\n            else:\n                return prefix\n            \n        return prefix",
    "explanation": "N/A",
    "time_complexity": "O(n * k), k is the length of the common prefix",
    "space_complexity": "O(k)"
  },
  {
    "title": "Squares of a Sorted Array",
    "difficulty": "EASY",
    "category": "Array, Two Pointers, Sorting",
    "link": "https://leetcode.com/problems/squares-of-a-sorted-array",
    "slug": "squares-of-a-sorted-array",
    "description": "Given an integer array \nnums\n sorted in \nnon-decreasing\n order, return \nan array of \nthe squares of each number\n sorted in non-decreasing order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-4,-1,0,3,10]\n\nOutput:\n [0,1,9,16,100]\n\nExplanation:\n After squaring, the array becomes [16,1,0,9,100].\nAfter sorting, it becomes [0,1,9,16,100].\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [-7,-3,2,3,11]\n\nOutput:\n [4,9,9,49,121]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= \n10\n4\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nnums\n is sorted in \nnon-decreasing\n order.\n\n\n\n\n \n\n\nFollow up:\n Squaring each element and sorting the new array is very trivial, could you find an \nO(n)\n solution using a different approach?",
    "solution": "\nimport bisect\n\n\nclass Solution(object):\n    def sortedSquares(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        right = bisect.bisect_left(A, 0)\n        left = right-1\n        result = []\n        while 0 <= left or right < len(A):\n            if right == len(A) or \\\n               (0 <= left and A[left]**2 < A[right]**2):\n                result.append(A[left]**2)\n                left -= 1\n            else:\n                result.append(A[right]**2)\n                right += 1\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Remove Nth Node From End of List",
    "difficulty": "MEDIUM",
    "category": "Linked List, Two Pointers",
    "link": "https://leetcode.com/problems/remove-nth-node-from-end-of-list",
    "slug": "remove-nth-node-from-end-of-list",
    "description": "Given the \nhead\n of a linked list, remove the \nn\nth\n node from the end of the list and return its head.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n head = [1,2,3,4,5], n = 2\n\nOutput:\n [1,2,3,5]\n\n\n\nExample 2:\n\n\n\n\nInput:\n head = [1], n = 1\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n head = [1,2], n = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the list is \nsz\n.\n\n\n1 <= sz <= 30\n\n\n0 <= Node.val <= 100\n\n\n1 <= n <= sz\n\n\n\n\n \n\n\nFollow up:\n Could you do this in one pass?",
    "solution": "\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self is None:\n            return \"Nil\"\n        else:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution(object):\n    # @return a ListNode\n    def removeNthFromEnd(self, head, n):\n        dummy = ListNode(-1)\n        dummy.next = head\n        slow, fast = dummy, dummy\n\n        for i in xrange(n):\n            fast = fast.next\n\n        while fast.next:\n            slow, fast = slow.next, fast.next\n\n        slow.next = slow.next.next\n\n        return dummy.next",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Diagonal Traverse",
    "difficulty": "MEDIUM",
    "category": "Array, Matrix, Simulation",
    "link": "https://leetcode.com/problems/diagonal-traverse",
    "slug": "diagonal-traverse",
    "description": "Given an \nm x n\n matrix \nmat\n, return \nan array of all the elements of the array in a diagonal order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n mat = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [1,2,4,7,5,3,6,8,9]\n\n\n\nExample 2:\n\n\n\n\nInput:\n mat = [[1,2],[3,4]]\n\nOutput:\n [1,2,3,4]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == mat.length\n\n\nn == mat[i].length\n\n\n1 <= m, n <= 10\n4\n\n\n1 <= m * n <= 10\n4\n\n\n-10\n5\n <= mat[i][j] <= 10\n5",
    "solution": "\nclass Solution(object):\n    def findDiagonalOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return []\n\n        result = []\n        row, col, d = 0, 0, 0\n        dirs = [(-1, 1), (1, -1)]\n\n        for i in xrange(len(matrix) * len(matrix[0])):\n            result.append(matrix[row][col])\n            row += dirs[d][0]\n            col += dirs[d][1]\n\n            if row >= len(matrix):\n                row = len(matrix) - 1\n                col += 2\n                d = 1 - d\n            elif col >= len(matrix[0]):\n                col = len(matrix[0]) - 1\n                row += 2\n                d = 1 - d\n            elif row < 0:\n                row = 0\n                d = 1 - d\n            elif col < 0:\n                col = 0\n                d = 1 - d\n\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Missing Ranges",
    "difficulty": "EASY",
    "category": "Array",
    "link": "https://leetcode.com/problems/missing-ranges",
    "slug": "missing-ranges",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nclass Solution(object):\n    def findMissingRanges(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: List[str]\n        \"\"\"\n        def getRange(lower, upper):\n            if lower == upper:\n                return \"{}\".format(lower)\n            else:\n                return \"{}->{}\".format(lower, upper)\n        ranges = []\n        pre = lower - 1\n\n        for i in xrange(len(nums) + 1):\n            if i == len(nums):\n                cur = upper + 1\n            else:\n                cur = nums[i]\n            if cur - pre >= 2:\n                ranges.append(getRange(pre + 1, cur - 1))\n\n            pre = cur\n\n        return ranges",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Moving Average from Data Stream",
    "difficulty": "EASY",
    "category": "Array, Design, Queue, Data Stream",
    "link": "https://leetcode.com/problems/moving-average-from-data-stream",
    "slug": "moving-average-from-data-stream",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nfrom collections import deque\n\nclass MovingAverage(object):\n\n    def __init__(self, size):\n        \"\"\"\n        Initialize your data structure here.\n        :type size: int\n        \"\"\"\n        self.__size = size\n        self.__sum = 0\n        self.__q = deque()\n\n    def next(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: float\n        \"\"\"\n        if len(self.__q) == self.__size:\n            self.__sum -= self.__q.popleft()\n        self.__sum += val\n        self.__q.append(val)\n        return 1.0 * self.__sum / len(self.__q)",
    "explanation": "N/A",
    "time_complexity": "O(1)",
    "space_complexity": "O(w)"
  },
  {
    "title": "Exclusive Time of Functions",
    "difficulty": "MEDIUM",
    "category": "Array, Stack",
    "link": "https://leetcode.com/problems/exclusive-time-of-functions",
    "slug": "exclusive-time-of-functions",
    "description": "On a \nsingle-threaded\n CPU, we execute a program containing \nn\n functions. Each function has a unique ID between \n0\n and \nn-1\n.\n\n\nFunction calls are \nstored in a \ncall stack\n: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is \nthe current function being executed\n. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.\n\n\nYou are given a list \nlogs\n, where \nlogs[i]\n represents the \ni\nth\n log message formatted as a string \n\"{function_id}:{\"start\" | \"end\"}:{timestamp}\"\n. For example, \n\"0:start:3\"\n means a function call with function ID \n0\n \nstarted at the beginning\n of timestamp \n3\n, and \n\"1:end:2\"\n means a function call with function ID \n1\n \nended at the end\n of timestamp \n2\n. Note that a function can be called \nmultiple times, possibly recursively\n.\n\n\nA function's \nexclusive time\n is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for \n2\n time units and another call executing for \n1\n time unit, the \nexclusive time\n is \n2 + 1 = 3\n.\n\n\nReturn \nthe \nexclusive time\n of each function in an array, where the value at the \ni\nth\n index represents the exclusive time for the function with ID \ni\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n n = 2, logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]\n\nOutput:\n [3,4]\n\nExplanation:\n\nFunction 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.\nFunction 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.\nFunction 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.\nSo function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.\n\n\n\nExample 2:\n\n\n\n\nInput:\n n = 1, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"]\n\nOutput:\n [8]\n\nExplanation:\n\nFunction 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\nFunction 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\nFunction 0 (initial call) resumes execution then immediately calls itself again.\nFunction 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.\nFunction 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.\nSo function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.\n\n\n\nExample 3:\n\n\n\n\nInput:\n n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:6\",\"1:end:6\",\"0:end:7\"]\n\nOutput:\n [7,1]\n\nExplanation:\n\nFunction 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\nFunction 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\nFunction 0 (initial call) resumes execution then immediately calls function 1.\nFunction 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6.\nFunction 0 resumes execution at the beginning of time 6 and executes for 2 units of time.\nSo function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= n <= 100\n\n\n2 <= logs.length <= 500\n\n\n0 <= function_id < n\n\n\n0 <= timestamp <= 10\n9\n\n\nNo two start events will happen at the same timestamp.\n\n\nNo two end events will happen at the same timestamp.\n\n\nEach function has an \n\"end\"\n log for each \n\"start\"\n log.",
    "solution": "\nclass Solution(object):\n    def exclusiveTime(self, n, logs):\n        \"\"\"\n        :type n: int\n        :type logs: List[str]\n        :rtype: List[int]\n        \"\"\"\n        result = [0] * n\n        stk, prev = [], 0\n        for log in logs:\n            tokens = log.split(\":\")\n            if tokens[1] == \"start\":\n                if stk:\n                    result[stk[-1]] += int(tokens[2]) - prev\n                stk.append(int(tokens[0]))\n                prev = int(tokens[2])\n            else:\n                result[stk.pop()] += int(tokens[2]) - prev + 1\n                prev = int(tokens[2]) + 1\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Add Strings",
    "difficulty": "EASY",
    "category": "Math, String, Simulation",
    "link": "https://leetcode.com/problems/add-strings",
    "slug": "add-strings",
    "description": "Given two non-negative integers, \nnum1\n and \nnum2\n represented as string, return \nthe sum of\n \nnum1\n \nand\n \nnum2\n \nas a string\n.\n\n\nYou must solve the problem without using any built-in library for handling large integers (such as \nBigInteger\n). You must also not convert the inputs to integers directly.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num1 = \"11\", num2 = \"123\"\n\nOutput:\n \"134\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n num1 = \"456\", num2 = \"77\"\n\nOutput:\n \"533\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n num1 = \"0\", num2 = \"0\"\n\nOutput:\n \"0\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= num1.length, num2.length <= 10\n4\n\n\nnum1\n and \nnum2\n consist of only digits.\n\n\nnum1\n and \nnum2\n don't have any leading zeros except for the zero itself.",
    "solution": "\nclass Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        result = []\n        i, j, carry = len(num1) - 1, len(num2) - 1, 0\n\n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += ord(num1[i]) - ord('0')\n                i -= 1\n            if j >= 0:\n                carry += ord(num2[j]) - ord('0')\n                j -= 1\n            result.append(str(carry % 10))\n            carry /= 10\n        result.reverse()\n\n        return \"\".join(result)\n\n    def addStrings2(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        length = max(len(num1), len(num2))\n        num1 = num1.zfill(length)[::-1]\n        num2 = num2.zfill(length)[::-1]\n        res, plus = '', 0\n        for index, num in enumerate(num1):\n            tmp = str(int(num) + int(num2[index]) + plus)\n            res += tmp[-1]\n            if int(tmp) > 9:\n                plus = 1\n            else:\n                plus = 0\n        if plus:\n            res += '1'\n        return res[::-1]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Binary Search Tree Iterator",
    "difficulty": "MEDIUM",
    "category": "Stack, Tree, Design, Binary Search Tree, Binary Tree, Iterator",
    "link": "https://leetcode.com/problems/binary-search-tree-iterator",
    "slug": "binary-search-tree-iterator",
    "description": "Implement the \nBSTIterator\n class that represents an iterator over the \nin-order traversal\n of a binary search tree (BST):\n\n\n\n\nBSTIterator(TreeNode root)\n Initializes an object of the \nBSTIterator\n class. The \nroot\n of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\n\n\nboolean hasNext()\n Returns \ntrue\n if there exists a number in the traversal to the right of the pointer, otherwise returns \nfalse\n.\n\n\nint next()\n Moves the pointer to the right, then returns the number at the pointer.\n\n\n\n\nNotice that by initializing the pointer to a non-existent smallest number, the first call to \nnext()\n will return the smallest element in the BST.\n\n\nYou may assume that \nnext()\n calls will always be valid. That is, there will be at least a next number in the in-order traversal when \nnext()\n is called.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput\n\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n\nOutput\n\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n\nExplanation\n\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 10\n5\n]\n.\n\n\n0 <= Node.val <= 10\n6\n\n\nAt most \n10\n5\n calls will be made to \nhasNext\n, and \nnext\n.\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nCould you implement \nnext()\n and \nhasNext()\n to run in average \nO(1)\n time and use \nO(h)\n memory, where \nh\n is the height of the tree?",
    "solution": "\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass BSTIterator(object):\n    # @param root, a binary search tree's root node\n    def __init__(self, root):\n        self.__stk = []\n        self.__traversalLeft(root)\n\n    # @return a boolean, whether we have a next smallest number\n    def hasNext(self):\n        return self.__stk\n\n    # @return an integer, the next smallest number\n    def next(self):\n        node = self.__stk.pop()\n        self.__traversalLeft(node.right)\n        return node.val\n    \n    def __traversalLeft(self, node):\n        while node is not None:\n            self.__stk.append(node)\n            node = node.left",
    "explanation": "N/A",
    "time_complexity": "O(1)",
    "space_complexity": "O(h), h is height of binary tree"
  },
  {
    "title": "Minimum Add to Make Parentheses Valid",
    "difficulty": "MEDIUM",
    "category": "String, Stack, Greedy",
    "link": "https://leetcode.com/problems/minimum-add-to-make-parentheses-valid",
    "slug": "minimum-add-to-make-parentheses-valid",
    "description": "A parentheses string is valid if and only if:\n\n\n\n\nIt is the empty string,\n\n\nIt can be written as \nAB\n (\nA\n concatenated with \nB\n), where \nA\n and \nB\n are valid strings, or\n\n\nIt can be written as \n(A)\n, where \nA\n is a valid string.\n\n\n\n\nYou are given a parentheses string \ns\n. In one move, you can insert a parenthesis at any position of the string.\n\n\n\n\nFor example, if \ns = \"()))\"\n, you can insert an opening parenthesis to be \n\"(\n(\n)))\"\n or a closing parenthesis to be \n\"())\n)\n)\"\n.\n\n\n\n\nReturn \nthe minimum number of moves required to make \ns\n valid\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"())\"\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"(((\"\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns[i]\n is either \n'('\n or \n')'\n.",
    "solution": "\nclass Solution(object):\n    def minAddToMakeValid(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: int\n        \"\"\"\n        add, bal, = 0, 0\n        for c in S:\n            bal += 1 if c == '(' else -1\n            if bal == -1:\n                add += 1\n                bal += 1\n        return add + bal",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Robot Room Cleaner",
    "difficulty": "HARD",
    "category": "Backtracking, Interactive",
    "link": "https://leetcode.com/problems/robot-room-cleaner",
    "slug": "robot-room-cleaner",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nclass Solution(object):\n    def cleanRoom(self, robot):\n        \"\"\"\n        :type robot: Robot\n        :rtype: None\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        def goBack(robot):\n            robot.turnLeft()\n            robot.turnLeft()\n            robot.move()\n            robot.turnRight()\n            robot.turnRight()\n\n        def dfs(pos, robot, d, lookup):\n            robot.clean()\n            for _ in directions:\n                new_pos = (pos[0]+directions[d][0],\n                           pos[1]+directions[d][1])\n                if new_pos not in lookup:\n                    lookup.add(new_pos)\n                    if robot.move():\n                        dfs(new_pos, robot, d, lookup)\n                        goBack(robot)\n                robot.turnRight()\n                d = (d+1) % len(directions)\n        \n        dfs((0, 0), robot, 0, set())",
    "explanation": "N/A",
    "time_complexity": "O(n), n is the number of cells",
    "space_complexity": "O(n)"
  },
  {
    "title": "Add Two Numbers",
    "difficulty": "MEDIUM",
    "category": "Linked List, Math, Recursion",
    "link": "https://leetcode.com/problems/add-two-numbers",
    "slug": "add-two-numbers",
    "description": "You are given two \nnon-empty\n linked lists representing two non-negative integers. The digits are stored in \nreverse order\n, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n l1 = [2,4,3], l2 = [5,6,4]\n\nOutput:\n [7,0,8]\n\nExplanation:\n 342 + 465 = 807.\n\n\n\nExample 2:\n\n\n\n\nInput:\n l1 = [0], l2 = [0]\n\nOutput:\n [0]\n\n\n\nExample 3:\n\n\n\n\nInput:\n l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n\nOutput:\n [8,9,9,9,0,0,0,1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in each linked list is in the range \n[1, 100]\n.\n\n\n0 <= Node.val <= 9\n\n\nIt is guaranteed that the list represents a number that does not have leading zeros.",
    "solution": "\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        current, carry = dummy, 0\n\n        while l1 or l2:\n            val = carry\n            if l1:\n                val += l1.val\n                l1 = l1.next\n            if l2:\n                val += l2.val\n                l2 = l2.next\n            carry, val = divmod(val, 10)\n            current.next = ListNode(val)\n            current = current.next\n\n        if carry == 1:\n            current.next = ListNode(1)\n\n        return dummy.next",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Subsets",
    "difficulty": "MEDIUM",
    "category": "Array, Backtracking, Bit Manipulation",
    "link": "https://leetcode.com/problems/subsets",
    "slug": "subsets",
    "description": "Given an integer array \nnums\n of \nunique\n elements, return \nall possible\n \nsubsets\n \n(the power set)\n.\n\n\nThe solution set \nmust not\n contain duplicate subsets. Return the solution in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3]\n\nOutput:\n [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0]\n\nOutput:\n [[],[0]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n\n\n-10 <= nums[i] <= 10\n\n\nAll the numbers of \nnums\n are \nunique\n.",
    "solution": "\nclass Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        result = [[]]\n        for i in xrange(len(nums)):\n            size = len(result)\n            for j in xrange(size):\n                result.append(list(result[j]))\n                result[-1].append(nums[i])\n        return result\n\n\nclass Solution2(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i, count = 0, 1 << len(nums)\n        nums.sort()\n\n        while i < count:\n            cur = []\n            for j in xrange(len(nums)):\n                if i & 1 << j:\n                    cur.append(nums[j])\n            result.append(cur)\n            i += 1\n\n        return result\n\n\nclass Solution3(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        return self.subsetsRecu([], sorted(nums))\n\n    def subsetsRecu(self, cur, nums):\n        if not nums:\n            return [cur]\n\n        return self.subsetsRecu(cur, nums[1:]) + self.subsetsRecu(cur + [nums[0]], nums[1:])",
    "explanation": "N/A",
    "time_complexity": "O(n * 2^n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Remove Invalid Parentheses",
    "difficulty": "HARD",
    "category": "String, Backtracking, Breadth-First Search",
    "link": "https://leetcode.com/problems/remove-invalid-parentheses",
    "slug": "remove-invalid-parentheses",
    "description": "Given a string \ns\n that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\n\n\nReturn \na list of \nunique strings\n that are valid with the minimum number of removals\n. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"()())()\"\n\nOutput:\n [\"(())()\",\"()()()\"]\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"(a)())()\"\n\nOutput:\n [\"(a())()\",\"(a)()()\"]\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \")(\"\n\nOutput:\n [\"\"]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 25\n\n\ns\n consists of lowercase English letters and parentheses \n'('\n and \n')'\n.\n\n\nThere will be at most \n20\n parentheses in \ns\n.",
    "solution": "\nclass Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        # Calculate the minimum left and right parantheses to remove\n        def findMinRemove(s):\n            left_removed, right_removed = 0, 0\n            for c in s:\n                if c == '(':\n                    left_removed += 1\n                elif c == ')':\n                    if not left_removed:\n                        right_removed += 1\n                    else:\n                        left_removed -= 1\n            return (left_removed, right_removed)\n\n        # Check whether s is valid or not.\n        def isValid(s):\n            sum = 0\n            for c in s:\n                if c == '(':\n                    sum += 1\n                elif c == ')':\n                    sum -= 1\n                if sum < 0:\n                    return False\n            return sum == 0\n\n        def removeInvalidParenthesesHelper(start, left_removed, right_removed):\n            if left_removed == 0 and right_removed == 0:\n                tmp = \"\"\n                for i, c in enumerate(s):\n                    if i not in removed:\n                        tmp += c\n                if isValid(tmp):\n                    res.append(tmp)\n                return\n\n            for i in xrange(start, len(s)):\n                if right_removed == 0 and left_removed > 0 and s[i] == '(':\n                    if i == start or s[i] != s[i - 1]:  # Skip duplicated.\n                        removed[i] = True\n                        removeInvalidParenthesesHelper(i + 1, left_removed - 1, right_removed)\n                        del removed[i]\n                elif right_removed > 0 and s[i] == ')':\n                    if i == start or s[i] != s[i - 1]:  # Skip duplicated.\n                        removed[i] = True\n                        removeInvalidParenthesesHelper(i + 1, left_removed, right_removed - 1)\n                        del removed[i]\n\n        res, removed = [], {}\n        (left_removed, right_removed) = findMinRemove(s)\n        removeInvalidParenthesesHelper(0, left_removed, right_removed)\n        return res",
    "explanation": "N/A",
    "time_complexity": "O(C(n, c)), try out all possible substrings with the minimum c deletion.",
    "space_complexity": "O(c), the depth is at most c, and it costs n at each depth"
  },
  {
    "title": "Palindromic Substrings",
    "difficulty": "MEDIUM",
    "category": "Two Pointers, String, Dynamic Programming",
    "link": "https://leetcode.com/problems/palindromic-substrings",
    "slug": "palindromic-substrings",
    "description": "Given a string \ns\n, return \nthe number of \npalindromic substrings\n in it\n.\n\n\nA string is a \npalindrome\n when it reads the same backward as forward.\n\n\nA \nsubstring\n is a contiguous sequence of characters within the string.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abc\"\n\nOutput:\n 3\n\nExplanation:\n Three palindromic strings: \"a\", \"b\", \"c\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"aaa\"\n\nOutput:\n 6\n\nExplanation:\n Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consists of lowercase English letters.",
    "solution": "\nclass Solution(object):\n    def countSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def manacher(s):\n            s = '^#' + '#'.join(s) + '#$'\n            P = [0] * len(s)\n            C, R = 0, 0\n            for i in xrange(1, len(s) - 1):\n                i_mirror = 2*C-i\n                if R > i:\n                    P[i] = min(R-i, P[i_mirror])\n                while s[i+1+P[i]] == s[i-1-P[i]]:\n                    P[i] += 1\n                if i+P[i] > R:\n                    C, R = i, i+P[i]\n            return P\n        return sum((max_len+1)//2 for max_len in manacher(s))",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Valid Number",
    "difficulty": "HARD",
    "category": "String",
    "link": "https://leetcode.com/problems/valid-number",
    "slug": "valid-number",
    "description": "Given a string \ns\n, return whether \ns\n is a \nvalid number\n.\n\n\n\nFor example, all the following are valid numbers: \n\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"\n, while the following are not valid numbers: \n\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"\n.\n\n\nFormally, a \nvalid number\n is defined using one of the following definitions:\n\n\n\n\nAn \ninteger number\n followed by an \noptional exponent\n.\n\n\nA \ndecimal number\n followed by an \noptional exponent\n.\n\n\n\n\nAn \ninteger number\n is defined with an \noptional sign\n \n'-'\n or \n'+'\n followed by \ndigits\n.\n\n\nA \ndecimal number\n is defined with an \noptional sign\n \n'-'\n or \n'+'\n followed by one of the following definitions:\n\n\n\n\nDigits\n followed by a \ndot\n \n'.'\n.\n\n\nDigits\n followed by a \ndot\n \n'.'\n followed by \ndigits\n.\n\n\nA \ndot\n \n'.'\n followed by \ndigits\n.\n\n\n\n\nAn \nexponent\n is defined with an \nexponent notation\n \n'e'\n or \n'E'\n followed by an \ninteger number\n.\n\n\nThe \ndigits\n are defined as one or more digits.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"0\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"e\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \".\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 20\n\n\ns\n consists of only English letters (both uppercase and lowercase), digits (\n0-9\n), plus \n'+'\n, minus \n'-'\n, or dot \n'.'\n.",
    "solution": "\nclass InputType(object):\n    INVALID    = 0\n    SPACE      = 1\n    SIGN       = 2\n    DIGIT      = 3\n    DOT        = 4\n    EXPONENT   = 5\n\n\n# regular expression: \"^\\s*[\\+-]?((\\d+(\\.\\d*)?)|\\.\\d+)([eE][\\+-]?\\d+)?\\s*$\"\n# automata: http://images.cnitblog.com/i/627993/201405/012016243309923.png\nclass Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        transition_table = [[-1,  0,  3,  1,  2, -1],     # next states for state 0\n                            [-1,  8, -1,  1,  4,  5],     # next states for state 1\n                            [-1, -1, -1,  4, -1, -1],     # next states for state 2\n                            [-1, -1, -1,  1,  2, -1],     # next states for state 3\n                            [-1,  8, -1,  4, -1,  5],     # next states for state 4\n                            [-1, -1,  6,  7, -1, -1],     # next states for state 5\n                            [-1, -1, -1,  7, -1, -1],     # next states for state 6\n                            [-1,  8, -1,  7, -1, -1],     # next states for state 7\n                            [-1,  8, -1, -1, -1, -1]]     # next states for state 8\n\n        state = 0\n        for char in s:\n            inputType = InputType.INVALID\n            if char.isspace():\n                inputType = InputType.SPACE\n            elif char == '+' or char == '-':\n                inputType = InputType.SIGN\n            elif char.isdigit():\n                inputType = InputType.DIGIT\n            elif char == '.':\n                inputType = InputType.DOT\n            elif char == 'e' or char == 'E':\n                inputType = InputType.EXPONENT\n\n            state = transition_table[state][inputType]\n\n            if state == -1:\n                return False\n\n        return state == 1 or state == 4 or state == 7 or state == 8\n\n\nclass Solution2(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        import re\n        return bool(re.match(\"^\\s*[\\+-]?((\\d+(\\.\\d*)?)|\\.\\d+)([eE][\\+-]?\\d+)?\\s*$\", s))",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Continuous Subarray Sum",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Math, Prefix Sum",
    "link": "https://leetcode.com/problems/continuous-subarray-sum",
    "slug": "continuous-subarray-sum",
    "description": "Given an integer array nums and an integer k, return \ntrue\n \nif \nnums\n has a \ngood subarray\n or \nfalse\n otherwise\n.\n\n\nA \ngood subarray\n is a subarray where:\n\n\n\n\nits length is \nat least two\n, and\n\n\nthe sum of the elements of the subarray is a multiple of \nk\n.\n\n\n\n\nNote\n that:\n\n\n\n\nA \nsubarray\n is a contiguous part of the array.\n\n\nAn integer \nx\n is a multiple of \nk\n if there exists an integer \nn\n such that \nx = n * k\n. \n0\n is \nalways\n a multiple of \nk\n.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [23,\n2,4\n,6,7], k = 6\n\nOutput:\n true\n\nExplanation:\n [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [\n23,2,6,4,7\n], k = 6\n\nOutput:\n true\n\nExplanation:\n [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.\n42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [23,2,6,4,7], k = 13\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n0 <= nums[i] <= 10\n9\n\n\n0 <= sum(nums[i]) <= 2\n31\n - 1\n\n\n1 <= k <= 2\n31\n - 1",
    "solution": "\nclass Solution(object):\n    def checkSubarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        count = 0\n        lookup = {0: -1}\n        for i, num in enumerate(nums):\n            count += num\n            if k:\n                count %= k\n            if count in lookup:\n                if i - lookup[count] > 1:\n                    return True\n            else:\n                lookup[count] = i\n\n        return False",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(k)"
  },
  {
    "title": "Closest Binary Search Tree Value",
    "difficulty": "EASY",
    "category": "Binary Search, Tree, Depth-First Search, Binary Search Tree, Binary Tree",
    "link": "https://leetcode.com/problems/closest-binary-search-tree-value",
    "slug": "closest-binary-search-tree-value",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nclass Solution(object):\n    def closestValue(self, root, target):\n        \"\"\"\n        :type root: TreeNode\n        :type target: float\n        :rtype: int\n        \"\"\"\n        gap = float(\"inf\")\n        closest = float(\"inf\")\n        while root:\n            if abs(root.val - target) < gap:\n                gap = abs(root.val - target)\n                closest = root.val\n            if target == root.val:\n                break\n            elif target < root.val:\n                root = root.left\n            else:\n                root = root.right\n        return closest",
    "explanation": "N/A",
    "time_complexity": "O(h)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Vertical Order Traversal of a Binary Tree",
    "difficulty": "HARD",
    "category": "Hash Table, Tree, Depth-First Search, Breadth-First Search, Sorting, Binary Tree",
    "link": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree",
    "slug": "vertical-order-traversal-of-a-binary-tree",
    "description": "Given the \nroot\n of a binary tree, calculate the \nvertical order traversal\n of the binary tree.\n\n\nFor each node at position \n(row, col)\n, its left and right children will be at positions \n(row + 1, col - 1)\n and \n(row + 1, col + 1)\n respectively. The root of the tree is at \n(0, 0)\n.\n\n\nThe \nvertical order traversal\n of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.\n\n\nReturn \nthe \nvertical order traversal\n of the binary tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,9,20,null,null,15,7]\n\nOutput:\n [[9],[3,15],[20],[7]]\n\nExplanation:\n\nColumn -1: Only node 9 is in this column.\nColumn 0: Nodes 3 and 15 are in this column in that order from top to bottom.\nColumn 1: Only node 20 is in this column.\nColumn 2: Only node 7 is in this column.\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,5,6,7]\n\nOutput:\n [[4],[2],[1,5,6],[3],[7]]\n\nExplanation:\n\nColumn -2: Only node 4 is in this column.\nColumn -1: Only node 2 is in this column.\nColumn 0: Nodes 1, 5, and 6 are in this column.\n          1 is at the top, so it comes first.\n          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.\nColumn 1: Only node 3 is in this column.\nColumn 2: Only node 7 is in this column.\n\n\n\nExample 3:\n\n\n\n\n\n\nInput:\n root = [1,2,3,4,6,5,7]\n\nOutput:\n [[4],[2],[1,5,6],[3],[7]]\n\nExplanation:\n\nThis case is the exact same as example 2, but with nodes 5 and 6 swapped.\nNote that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 1000]\n.\n\n\n0 <= Node.val <= 1000",
    "solution": "\nimport collections\n\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def verticalTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        def dfs(node, lookup, x, y):\n            if not node:\n                return\n            lookup[x][y].append(node)\n            dfs(node.left, lookup, x-1, y+1)\n            dfs(node.right, lookup, x+1, y+1)\n                \n        lookup = collections.defaultdict(lambda: collections.defaultdict(list))\n        dfs(root, lookup, 0, 0)\n\n        result = []\n        for x in sorted(lookup):\n            report = []\n            for y in sorted(lookup[x]):\n                report.extend(sorted(node.val for node in lookup[x][y]))\n            result.append(report)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Group Shifted Strings",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, String",
    "link": "https://leetcode.com/problems/group-shifted-strings",
    "slug": "group-shifted-strings",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nimport collections\n\n\nclass Solution(object):\n    # @param {string[]} strings\n    # @return {string[][]}\n    def groupStrings(self, strings):\n        groups = collections.defaultdict(list)\n        for s in strings:  # Grouping.\n            groups[self.hashStr(s)].append(s)\n\n        result = []\n        for key, val in groups.iteritems():\n            result.append(sorted(val))\n\n        return result\n\n    def hashStr(self, s):\n        base = ord(s[0])\n        hashcode = \"\"\n        for i in xrange(len(s)):\n            if ord(s[i]) - base >= 0:\n                hashcode += unichr(ord('a') + ord(s[i]) - base)\n            else:\n                hashcode += unichr(ord('a') + ord(s[i]) - base + 26)\n        return hashcode",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Course Schedule",
    "difficulty": "MEDIUM",
    "category": "Depth-First Search, Breadth-First Search, Graph, Topological Sort",
    "link": "https://leetcode.com/problems/course-schedule",
    "slug": "course-schedule",
    "description": "There are a total of \nnumCourses\n courses you have to take, labeled from \n0\n to \nnumCourses - 1\n. You are given an array \nprerequisites\n where \nprerequisites[i] = [a\ni\n, b\ni\n]\n indicates that you \nmust\n take course \nb\ni\n first if you want to take course \na\ni\n.\n\n\n\n\nFor example, the pair \n[0, 1]\n, indicates that to take course \n0\n you have to first take course \n1\n.\n\n\n\n\nReturn \ntrue\n if you can finish all courses. Otherwise, return \nfalse\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [[1,0]]\n\nOutput:\n true\n\nExplanation:\n There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\n\n\nExample 2:\n\n\n\n\nInput:\n numCourses = 2, prerequisites = [[1,0],[0,1]]\n\nOutput:\n false\n\nExplanation:\n There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= numCourses <= 2000\n\n\n0 <= prerequisites.length <= 5000\n\n\nprerequisites[i].length == 2\n\n\n0 <= a\ni\n, b\ni\n < numCourses\n\n\nAll the pairs prerequisites[i] are \nunique\n.",
    "solution": "\nimport collections\n\n\n# Khan's algorithm (bfs solution)\nclass Solution(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        q = [u for u in xrange(numCourses) if u not in in_degree]\n        while q:\n            new_q = []\n            for u in q:\n                result.append(u)\n                for v in adj[u]:\n                    in_degree[v] -= 1\n                    if in_degree[v] == 0:\n                        new_q.append(v)\n            q = new_q\n        return len(result) == numCourses\n\n\nimport collections\n\n\n# dfs solution\nclass Solution2(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        stk = [u for u in xrange(numCourses) if u not in in_degree]\n        while stk:\n            u = stk.pop()\n            result.append(u)\n            for v in adj[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    stk.append(v)\n        return len(result) == numCourses",
    "explanation": "N/A",
    "time_complexity": "O(|V| + |E|)",
    "space_complexity": "O(|E|)"
  },
  {
    "title": "Insert into a Sorted Circular Linked List",
    "difficulty": "MEDIUM",
    "category": "Linked List",
    "link": "https://leetcode.com/problems/insert-into-a-sorted-circular-linked-list",
    "slug": "insert-into-a-sorted-circular-linked-list",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nclass Node(object):\n    def __init__(self, val, next):\n        self.val = val\n        self.next = next\n\n\nclass Solution(object):\n    def insert(self, head, insertVal):\n        \"\"\"\n        :type head: Node\n        :type insertVal: int\n        :rtype: Node\n        \"\"\"\n        def insertAfter(node, val):\n            node.next = Node(val, node.next)\n        \n        if not head:\n            node = Node(insertVal, None)\n            node.next = node\n            return node\n\n        curr = head\n        while True:\n            if curr.val < curr.next.val:\n                if curr.val <= insertVal and \\\n                   insertVal <= curr.next.val:\n                    insertAfter(curr, insertVal)\n                    break\n            elif curr.val > curr.next.val:\n                if curr.val <= insertVal or \\\n                   insertVal <= curr.next.val:\n                    insertAfter(curr, insertVal)\n                    break\n            else:\n                if curr.next == head:\n                    insertAfter(curr, insertVal)\n                    break\n            curr = curr.next\n        return head",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "3Sum",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers, Sorting",
    "link": "https://leetcode.com/problems/3sum",
    "slug": "3sum",
    "description": "Given an integer array nums, return all the triplets \n[nums[i], nums[j], nums[k]]\n such that \ni != j\n, \ni != k\n, and \nj != k\n, and \nnums[i] + nums[j] + nums[k] == 0\n.\n\n\nNotice that the solution set must not contain duplicate triplets.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-1,0,1,2,-1,-4]\n\nOutput:\n [[-1,-1,2],[-1,0,1]]\n\nExplanation:\n \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [0,1,1]\n\nOutput:\n []\n\nExplanation:\n The only possible triplet does not sum up to 0.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [0,0,0]\n\nOutput:\n [[0,0,0]]\n\nExplanation:\n The only possible triplet sums up to 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n3 <= nums.length <= 3000\n\n\n-10\n5\n <= nums[i] <= 10\n5",
    "solution": "\nclass Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        nums.sort()\n        for i in reversed(xrange(2, len(nums))):\n            if i+1 < len(nums) and nums[i] == nums[i+1]:\n                continue\n            target = -nums[i]\n            left, right = 0, i-1\n            while left < right:\n                if nums[left]+nums[right] < target:\n                    left += 1\n                elif nums[left]+nums[right] > target:\n                    right -= 1\n                else:\n                    result.append([nums[left], nums[right], nums[i]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left-1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right+1]:\n                        right -= 1\n        return result\n\n\nclass Solution2(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, i = sorted(nums), [], 0\n        while i < len(nums) - 2:\n            if i == 0 or nums[i] != nums[i - 1]:\n                j, k = i + 1, len(nums) - 1\n                while j < k:\n                    if nums[i] + nums[j] + nums[k] < 0:\n                        j += 1\n                    elif nums[i] + nums[j] + nums[k] > 0:\n                        k -= 1\n                    else:\n                        result.append([nums[i], nums[j], nums[k]])\n                        j, k = j + 1, k - 1\n                        while j < k and nums[j] == nums[j - 1]:\n                            j += 1\n                        while j < k and nums[k] == nums[k + 1]:\n                            k -= 1\n            i += 1\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)"
  },
  {
    "title": "All Nodes Distance K in Binary Tree",
    "difficulty": "MEDIUM",
    "category": "Hash Table, Tree, Depth-First Search, Breadth-First Search, Binary Tree",
    "link": "https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree",
    "slug": "all-nodes-distance-k-in-binary-tree",
    "description": "Given the \nroot\n of a binary tree, the value of a target node \ntarget\n, and an integer \nk\n, return \nan array of the values of all nodes that have a distance \nk\n from the target node.\n\n\nYou can return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2\n\nOutput:\n [7,4,1]\nExplanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.\n\n\n\nExample 2:\n\n\n\n\nInput:\n root = [1], target = 1, k = 3\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 500]\n.\n\n\n0 <= Node.val <= 500\n\n\nAll the values \nNode.val\n are \nunique\n.\n\n\ntarget\n is the value of one of the nodes in the tree.\n\n\n0 <= k <= 1000",
    "solution": "\nimport collections\n\n\nclass Solution(object):\n    def distanceK(self, root, target, K):\n        \"\"\"\n        :type root: TreeNode\n        :type target: TreeNode\n        :type K: int\n        :rtype: List[int]\n        \"\"\"\n        def dfs(parent, child, neighbors):\n            if not child:\n                return\n            if parent:\n                neighbors[parent.val].append(child.val)\n                neighbors[child.val].append(parent.val)\n            dfs(child, child.left, neighbors)\n            dfs(child, child.right, neighbors)\n\n        neighbors = collections.defaultdict(list)\n        dfs(None, root, neighbors)\n        bfs = [target.val]\n        lookup = set(bfs)\n        for _ in xrange(K):\n            bfs = [nei for node in bfs\n                   for nei in neighbors[node]\n                   if nei not in lookup]\n            lookup |= set(bfs)\n        return bfs",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "String to Integer (atoi)",
    "difficulty": "MEDIUM",
    "category": "String",
    "link": "https://leetcode.com/problems/string-to-integer-atoi",
    "slug": "string-to-integer-atoi",
    "description": "Implement the \nmyAtoi(string s)\n function, which converts a string to a 32-bit signed integer.\n\n\nThe algorithm for \nmyAtoi(string s)\n is as follows:\n\n\n\n\nWhitespace\n: Ignore any leading whitespace (\n\" \"\n).\n\n\nSignedness\n: Determine the sign by checking if the next character is \n'-'\n or \n'+'\n, assuming positivity if neither present.\n\n\nConversion\n: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.\n\n\nRounding\n: If the integer is out of the 32-bit signed integer range \n[-2\n31\n, 2\n31\n - 1]\n, then round the integer to remain in the range. Specifically, integers less than \n-2\n31\n should be rounded to \n-2\n31\n, and integers greater than \n2\n31\n - 1\n should be rounded to \n2\n31\n - 1\n.\n\n\n\n\nReturn the integer as the final result.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"42\"\n\n\nOutput:\n \n42\n\n\nExplanation:\n\n\n\nThe underlined characters are what is read in and the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n42\n\" (\"42\" is read in)\n           ^\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \" -042\"\n\n\nOutput:\n \n-42\n\n\nExplanation:\n\n\n\nStep 1: \"\n   \n-042\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   \n-\n042\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -\n042\n\" (\"042\" is read in, leading zeros ignored in the result)\n               ^\n\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"1337c0d3\"\n\n\nOutput:\n \n1337\n\n\nExplanation:\n\n\n\nStep 1: \"1337c0d3\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"1337c0d3\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n1337\nc0d3\" (\"1337\" is read in; reading stops because the next character is a non-digit)\n             ^\n\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"0-1\"\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\n\nStep 1: \"0-1\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"0-1\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"\n0\n-1\" (\"0\" is read in; reading stops because the next character is a non-digit)\n          ^\n\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"words and 987\"\n\n\nOutput:\n \n0\n\n\nExplanation:\n\n\nReading stops at the first non-digit character 'w'.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 200\n\n\ns\n consists of English letters (lower-case and upper-case), digits (\n0-9\n), \n' '\n, \n'+'\n, \n'-'\n, and \n'.'\n.",
    "solution": "\nclass Solution(object):\n    def myAtoi(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: int\n        \"\"\"\n        INT_MAX =  2147483647\n        INT_MIN = -2147483648\n        result = 0\n\n        if not str:\n            return result\n\n        i = 0\n        while i < len(str) and str[i].isspace():\n            i += 1\n\n        if len(str) == i:\n            return result\n\n        sign = 1\n        if str[i] == \"+\":\n            i += 1\n        elif str[i] == \"-\":\n            sign = -1\n            i += 1\n\n        while i < len(str) and '0' <= str[i] <= '9':\n            if result > (INT_MAX - int(str[i])) / 10:\n                return INT_MAX if sign > 0 else INT_MIN\n            result = result * 10 + int(str[i])\n            i += 1\n\n        return sign * result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Contains Duplicate II",
    "difficulty": "EASY",
    "category": "Array, Hash Table, Sliding Window",
    "link": "https://leetcode.com/problems/contains-duplicate-ii",
    "slug": "contains-duplicate-ii",
    "description": "Given an integer array \nnums\n and an integer \nk\n, return \ntrue\n \nif there are two \ndistinct indices\n \ni\n and \nj\n in the array such that \nnums[i] == nums[j]\n and \nabs(i - j) <= k\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,3,1], k = 3\n\nOutput:\n true\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,0,1,1], k = 1\n\nOutput:\n true\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [1,2,3,1,2,3], k = 2\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n9\n <= nums[i] <= 10\n9\n\n\n0 <= k <= 10\n5",
    "solution": "\nclass Solution(object):\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {boolean}\n    def containsNearbyDuplicate(self, nums, k):\n        lookup = {}\n        for i, num in enumerate(nums):\n            if num not in lookup:\n                lookup[num] = i\n            else:\n                # If the value occurs before, check the difference.\n                if i - lookup[num] <= k:\n                    return True\n                # Update the index of the value.\n                lookup[num] = i\n        return False",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Zero Array Transformation III",
    "difficulty": "MEDIUM",
    "category": "Array, Greedy, Sorting, Heap (Priority Queue), Prefix Sum",
    "link": "https://leetcode.com/problems/zero-array-transformation-iii",
    "slug": "zero-array-transformation-iii",
    "description": "You are given an integer array \nnums\n of length \nn\n and a 2D array \nqueries\n where \nqueries[i] = [l\ni\n, r\ni\n]\n.\n\n\nEach \nqueries[i]\n represents the following action on \nnums\n:\n\n\n\n\nDecrement the value at each index in the range \n[l\ni\n, r\ni\n]\n in \nnums\n by \nat most\n \n1.\n\n\nThe amount by which the value is decremented can be chosen \nindependently\n for each index.\n\n\n\n\nA \nZero Array\n is an array with all its elements equal to 0.\n\n\nReturn the \nmaximum \nnumber of elements that can be removed from \nqueries\n, such that \nnums\n can still be converted to a \nzero array\n using the \nremaining\n queries. If it is not possible to convert \nnums\n to a \nzero array\n, return -1.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nnums = [2,0,2], queries = [[0,2],[0,2],[1,1]]\n\n\nOutput:\n \n1\n\n\nExplanation:\n\n\nAfter removing \nqueries[2]\n, \nnums\n can still be converted to a zero array.\n\n\n\n\nUsing \nqueries[0]\n, decrement \nnums[0]\n and \nnums[2]\n by 1 and \nnums[1]\n by 0.\n\n\nUsing \nqueries[1]\n, decrement \nnums[0]\n and \nnums[2]\n by 1 and \nnums[1]\n by 0.\n\n\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \nnums = [1,1,1,1], queries = [[1,3],[0,2],[1,3],[1,2]]\n\n\nOutput:\n \n2\n\n\nExplanation:\n\n\nWe can remove \nqueries[2]\n and \nqueries[3]\n.\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \nnums = [1,2,3,4], queries = [[0,3]]\n\n\nOutput:\n \n-1\n\n\nExplanation:\n\n\nnums\n cannot be converted to a zero array even after using all the queries.\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n0 <= nums[i] <= 10\n5\n\n\n1 <= queries.length <= 10\n5\n\n\nqueries[i].length == 2\n\n\n0 <= l\ni\n <= r\ni\n < nums.length",
    "solution": "\nimport heapq\n\n\n# sort, heap, greedy\nclass Solution(object):\n    def maxRemoval(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        queries.sort(reverse=True)\n        max_heap, min_heap = [], []\n        for i in xrange(len(nums)):\n            while queries and queries[-1][0] <= i:\n                heapq.heappush(max_heap, -queries.pop()[1])\n            while min_heap and min_heap[0] < i:\n                heapq.heappop(min_heap)\n            while len(min_heap) < nums[i]:\n                if not max_heap or -max_heap[0] < i:\n                    return -1\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        return len(max_heap)",
    "explanation": "N/A",
    "time_complexity": "O(n + qlogq)",
    "space_complexity": "O(q)"
  },
  {
    "title": "Swim in Rising Water",
    "difficulty": "HARD",
    "category": "Array, Binary Search, Depth-First Search, Breadth-First Search, Union Find, Heap (Priority Queue), Matrix",
    "link": "https://leetcode.com/problems/swim-in-rising-water",
    "slug": "swim-in-rising-water",
    "description": "You are given an \nn x n\n integer matrix \ngrid\n where each value \ngrid[i][j]\n represents the elevation at that point \n(i, j)\n.\n\n\nIt starts raining, and water gradually rises over time. At time \nt\n, the water level is \nt\n, meaning \nany\n cell with elevation less than equal to \nt\n is submerged or reachable.\n\n\nYou can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most \nt\n. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n\n\nReturn \nthe minimum time until you can reach the bottom right square \n(n - 1, n - 1)\n if you start at the top left square \n(0, 0)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n grid = [[0,2],[1,3]]\n\nOutput:\n 3\nExplanation:\nAt time 0, you are in grid location (0, 0).\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\n\nOutput:\n 16\n\nExplanation:\n The final route is shown.\nWe need to wait until time 16 so that (0, 0) and (4, 4) are connected.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == grid.length\n\n\nn == grid[i].length\n\n\n1 <= n <= 50\n\n\n0 <= grid[i][j] < n\n2\n\n\nEach value \ngrid[i][j]\n is \nunique\n.",
    "solution": "\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        return True\n\n\nclass Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        positions = [None] * (n**2)\n        for i in xrange(n):\n            for j in xrange(n):\n                positions[grid[i][j]] = (i, j)\n        directions = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n        union_find = UnionFind(n**2)\n        for elevation in xrange(n**2):\n            i, j = positions[elevation]\n            for direction in directions:\n                x, y = i+direction[0], j+direction[1]\n                if 0 <= x < n and 0 <= y < n and grid[x][y] <= elevation:\n                    union_find.union_set(i*n+j, x*n+y)\n                    if union_find.find_set(0) == union_find.find_set(n**2-1):\n                        return elevation\n        return n**2-1",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n^2)"
  },
  {
    "title": "Managers with at Least 5 Direct Reports",
    "difficulty": "MEDIUM",
    "category": "Database",
    "link": "https://leetcode.com/problems/managers-with-at-least-5-direct-reports",
    "slug": "managers-with-at-least-5-direct-reports",
    "description": "Table: \nEmployee\n\n\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| department  | varchar |\n| managerId   | int     |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the name of an employee, their department, and the id of their manager.\nIf managerId is null, then the employee does not have a manager.\nNo employee will be the manager of themself.\n\n\n\n \n\n\nWrite a solution to find managers with at least \nfive direct reports\n.\n\n\nReturn the result table in \nany order\n.\n\n\nThe result format is in the following example.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \nEmployee table:\n+-----+-------+------------+-----------+\n| id  | name  | department | managerId |\n+-----+-------+------------+-----------+\n| 101 | John  | A          | null      |\n| 102 | Dan   | A          | 101       |\n| 103 | James | A          | 101       |\n| 104 | Amy   | A          | 101       |\n| 105 | Anne  | A          | 101       |\n| 106 | Ron   | B          | 101       |\n+-----+-------+------------+-----------+\n\nOutput:\n \n+------+\n| name |\n+------+\n| John |\n+------+",
    "solution": "# Solution not found in kamyu104 repository",
    "explanation": "N/A",
    "time_complexity": "N/A",
    "space_complexity": "N/A"
  },
  {
    "title": "Maximum Swap",
    "difficulty": "MEDIUM",
    "category": "Math, Greedy",
    "link": "https://leetcode.com/problems/maximum-swap",
    "slug": "maximum-swap",
    "description": "You are given an integer \nnum\n. You can swap two digits at most once to get the maximum valued number.\n\n\nReturn \nthe maximum valued number you can get\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num = 2736\n\nOutput:\n 7236\n\nExplanation:\n Swap the number 2 and the number 7.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num = 9973\n\nOutput:\n 9973\n\nExplanation:\n No swap.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= num <= 10\n8",
    "solution": "\nclass Solution(object):\n    def maximumSwap(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        digits = list(str(num))\n        left, right = 0, 0\n        max_idx = len(digits)-1\n        for i in reversed(xrange(len(digits))):\n            if digits[i] > digits[max_idx]:\n                max_idx = i\n            elif digits[max_idx] > digits[i]:\n                left, right = i, max_idx\n        digits[left], digits[right] = digits[right], digits[left]\n        return int(\"\".join(digits))",
    "explanation": "N/A",
    "time_complexity": "O(logn), logn is the length of the number string",
    "space_complexity": "O(logn)"
  },
  {
    "title": "Container With Most Water",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers, Greedy",
    "link": "https://leetcode.com/problems/container-with-most-water",
    "slug": "container-with-most-water",
    "description": "You are given an integer array \nheight\n of length \nn\n. There are \nn\n vertical lines drawn such that the two endpoints of the \ni\nth\n line are \n(i, 0)\n and \n(i, height[i])\n.\n\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\n\nReturn \nthe maximum amount of water a container can store\n.\n\n\nNotice\n that you may not slant the container.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n height = [1,8,6,2,5,4,8,3,7]\n\nOutput:\n 49\n\nExplanation:\n The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\n\nExample 2:\n\n\n\n\nInput:\n height = [1,1]\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == height.length\n\n\n2 <= n <= 10\n5\n\n\n0 <= height[i] <= 10\n4",
    "solution": "\nclass Solution(object):\n    # @return an integer\n    def maxArea(self, height):\n        max_area, i, j = 0, 0, len(height) - 1\n        while i < j:\n            max_area = max(max_area, min(height[i], height[j]) * (j - i))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return max_area",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Cutting Ribbons",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/cutting-ribbons",
    "slug": "cutting-ribbons",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nclass Solution(object):\n    def maxLength(self, ribbons, k):\n        \"\"\"\n        :type ribbons: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def check(ribbons, k, s):\n            return reduce(lambda total,x: total+x//s, ribbons, 0) >= k\n\n        left, right = 1, sum(ribbons)//k\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(ribbons, k, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right",
    "explanation": "N/A",
    "time_complexity": "O(nlogr), r is sum(ribbons)/k",
    "space_complexity": "O(1)"
  },
  {
    "title": "Word Break",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, String, Dynamic Programming, Trie, Memoization",
    "link": "https://leetcode.com/problems/word-break",
    "slug": "word-break",
    "description": "Given a string \ns\n and a dictionary of strings \nwordDict\n, return \ntrue\n if \ns\n can be segmented into a space-separated sequence of one or more dictionary words.\n\n\nNote\n that the same word in the dictionary may be reused multiple times in the segmentation.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"leetcode\", wordDict = [\"leet\",\"code\"]\n\nOutput:\n true\n\nExplanation:\n Return true because \"leetcode\" can be segmented as \"leet code\".\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\n\nOutput:\n true\n\nExplanation:\n Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\nNote that you are allowed to reuse a dictionary word.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\nOutput:\n false\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 300\n\n\n1 <= wordDict.length <= 1000\n\n\n1 <= wordDict[i].length <= 20\n\n\ns\n and \nwordDict[i]\n consist of only lowercase English letters.\n\n\nAll the strings of \nwordDict\n are \nunique\n.",
    "solution": "\nclass Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: Set[str]\n        :rtype: bool\n        \"\"\"\n        n = len(s)\n\n        max_len = 0\n        for string in wordDict:\n            max_len = max(max_len, len(string))\n\n        can_break = [False for _ in xrange(n + 1)]\n        can_break[0] = True\n        for i in xrange(1, n + 1):\n            for l in xrange(1, min(i, max_len) + 1):\n                if can_break[i-l] and s[i-l:i] in wordDict:\n                    can_break[i] = True\n                    break\n\n        return can_break[-1]",
    "explanation": "N/A",
    "time_complexity": "O(n * l^2)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Binary Tree Maximum Path Sum",
    "difficulty": "HARD",
    "category": "Dynamic Programming, Tree, Depth-First Search, Binary Tree",
    "link": "https://leetcode.com/problems/binary-tree-maximum-path-sum",
    "slug": "binary-tree-maximum-path-sum",
    "description": "A \npath\n in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence \nat most once\n. Note that the path does not need to pass through the root.\n\n\nThe \npath sum\n of a path is the sum of the node's values in the path.\n\n\nGiven the \nroot\n of a binary tree, return \nthe maximum \npath sum\n of any \nnon-empty\n path\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [1,2,3]\n\nOutput:\n 6\n\nExplanation:\n The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [-10,9,20,null,null,15,7]\n\nOutput:\n 42\n\nExplanation:\n The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is in the range \n[1, 3 * 10\n4\n]\n.\n\n\n-1000 <= Node.val <= 1000",
    "solution": "\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return an integer\n    def maxPathSum(self, root):\n        def iter_dfs(node):\n            result = float(\"-inf\")\n            max_sum = [0]\n            stk = [(1, [node, max_sum])]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, ret = params\n                    if not node:\n                        continue\n                    ret1, ret2 = [0], [0]\n                    stk.append((2, [node, ret1, ret2, ret]))\n                    stk.append((1, [node.right, ret2]))\n                    stk.append((1, [node.left, ret1]))\n                elif step == 2:\n                    node, ret1, ret2, ret = params\n                    result = max(result, node.val+max(ret1[0], 0)+max(ret2[0], 0))\n                    ret[0] = node.val+max(ret1[0], ret2[0], 0)\n            return result\n        \n        return iter_dfs(root)\n\n\nclass Solution2(object):\n    # @param root, a tree node\n    # @return an integer\n    def maxPathSum(self, root):\n        def dfs(node):\n            if not node:\n                return (float(\"-inf\"), 0)\n            max_left, curr_left = dfs(node.left)\n            max_right, curr_right = dfs(node.right)\n            return (max(max_left, max_right, node.val+max(curr_left, 0)+max(curr_right, 0)),\n                    node.val+max(curr_left, curr_right, 0))\n        \n        return dfs(root)[0]",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(h), h is height of binary tree"
  },
  {
    "title": "Car Pooling",
    "difficulty": "MEDIUM",
    "category": "Array, Sorting, Heap (Priority Queue), Simulation, Prefix Sum",
    "link": "https://leetcode.com/problems/car-pooling",
    "slug": "car-pooling",
    "description": "There is a car with \ncapacity\n empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west).\n\n\nYou are given the integer \ncapacity\n and an array \ntrips\n where \ntrips[i] = [numPassengers\ni\n, from\ni\n, to\ni\n]\n indicates that the \ni\nth\n trip has \nnumPassengers\ni\n passengers and the locations to pick them up and drop them off are \nfrom\ni\n and \nto\ni\n respectively. The locations are given as the number of kilometers due east from the car's initial location.\n\n\nReturn \ntrue\n if it is possible to pick up and drop off all passengers for all the given trips, or \nfalse\n otherwise\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n trips = [[2,1,5],[3,3,7]], capacity = 4\n\nOutput:\n false\n\n\n\nExample 2:\n\n\n\n\nInput:\n trips = [[2,1,5],[3,3,7]], capacity = 5\n\nOutput:\n true\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= trips.length <= 1000\n\n\ntrips[i].length == 3\n\n\n1 <= numPassengers\ni\n <= 100\n\n\n0 <= from\ni\n < to\ni\n <= 1000\n\n\n1 <= capacity <= 10\n5",
    "solution": "\nclass Solution(object):\n    def carPooling(self, trips, capacity):\n        \"\"\"\n        :type trips: List[List[int]]\n        :type capacity: int\n        :rtype: bool\n        \"\"\"\n        line = [x for num, start, end in trips for x in [[start, num], [end, -num]]]\n        line.sort()\n        for _, num in line:\n            capacity -= num\n            if capacity < 0:\n                return False\n        return True",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Strobogrammatic Number",
    "difficulty": "EASY",
    "category": "Hash Table, Two Pointers, String",
    "link": "https://leetcode.com/problems/strobogrammatic-number",
    "slug": "strobogrammatic-number",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nclass Solution(object):\n    lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'}\n\n    # @param {string} num\n    # @return {boolean}\n    def isStrobogrammatic(self, num):\n        n = len(num)\n        for i in xrange((n+1) / 2):\n            if num[n-1-i] not in self.lookup or \\\n               num[i] != self.lookup[num[n-1-i]]:\n                return False\n        return True",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Capacity To Ship Packages Within D Days",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/capacity-to-ship-packages-within-d-days",
    "slug": "capacity-to-ship-packages-within-d-days",
    "description": "A conveyor belt has packages that must be shipped from one port to another within \ndays\n days.\n\n\nThe \ni\nth\n package on the conveyor belt has a weight of \nweights[i]\n. Each day, we load the ship with packages on the conveyor belt (in the order given by \nweights\n). We may not load more weight than the maximum weight capacity of the ship.\n\n\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within \ndays\n days.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n weights = [1,2,3,4,5,6,7,8,9,10], days = 5\n\nOutput:\n 15\n\nExplanation:\n A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\n1st day: 1, 2, 3, 4, 5\n2nd day: 6, 7\n3rd day: 8\n4th day: 9\n5th day: 10\n\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.\n\n\n\nExample 2:\n\n\n\n\nInput:\n weights = [3,2,2,4,1,4], days = 3\n\nOutput:\n 6\n\nExplanation:\n A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:\n1st day: 3, 2\n2nd day: 2, 4\n3rd day: 1, 4\n\n\n\nExample 3:\n\n\n\n\nInput:\n weights = [1,2,3,1,1], days = 4\n\nOutput:\n 3\n\nExplanation:\n\n1st day: 1\n2nd day: 2\n3rd day: 3\n4th day: 1, 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= days <= weights.length <= 5 * 10\n4\n\n\n1 <= weights[i] <= 500",
    "solution": "\nclass Solution(object):\n    def shipWithinDays(self, weights, D):\n        \"\"\"\n        :type weights: List[int]\n        :type D: int\n        :rtype: int\n        \"\"\"\n        def possible(weights, D, mid):\n            result, curr = 1, 0\n            for w in weights:\n                if curr+w > mid:\n                    result += 1\n                    curr = 0\n                curr += w\n            return result <= D\n    \n        left, right = max(weights), sum(weights)\n        while left <= right:\n            mid = left + (right-left)//2\n            if possible(weights, D, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left",
    "explanation": "N/A",
    "time_complexity": "O(nlogr)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "MEDIUM",
    "category": "Hash Table, String, Sliding Window",
    "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters",
    "slug": "longest-substring-without-repeating-characters",
    "description": "Given a string \ns\n, find the length of the \nlongest\n \nsubstring\n without duplicate characters.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abcabcbb\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"abc\", with the length of 3.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"bbbbb\"\n\nOutput:\n 1\n\nExplanation:\n The answer is \"b\", with the length of 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"pwwkew\"\n\nOutput:\n 3\n\nExplanation:\n The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= s.length <= 5 * 10\n4\n\n\ns\n consists of English letters, digits, symbols and spaces.",
    "solution": "\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, left = 0, 0\n        lookup = {}\n        for right in xrange(len(s)):\n            if s[right] in lookup:\n                left = max(left, lookup[s[right]]+1)\n            lookup[s[right]] = right\n            result = max(result, right-left+1)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Word Ladder",
    "difficulty": "HARD",
    "category": "Hash Table, String, Breadth-First Search",
    "link": "https://leetcode.com/problems/word-ladder",
    "slug": "word-ladder",
    "description": "A \ntransformation sequence\n from word \nbeginWord\n to word \nendWord\n using a dictionary \nwordList\n is a sequence of words \nbeginWord -> s\n1\n -> s\n2\n -> ... -> s\nk\n such that:\n\n\n\n\nEvery adjacent pair of words differs by a single letter.\n\n\nEvery \ns\ni\n for \n1 <= i <= k\n is in \nwordList\n. Note that \nbeginWord\n does not need to be in \nwordList\n.\n\n\ns\nk\n == endWord\n\n\n\n\nGiven two words, \nbeginWord\n and \nendWord\n, and a dictionary \nwordList\n, return \nthe \nnumber of words\n in the \nshortest transformation sequence\n from\n \nbeginWord\n \nto\n \nendWord\n, or \n0\n if no such sequence exists.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\nOutput:\n 5\n\nExplanation:\n One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\n\n\n\nExample 2:\n\n\n\n\nInput:\n beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n\nOutput:\n 0\n\nExplanation:\n The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= beginWord.length <= 10\n\n\nendWord.length == beginWord.length\n\n\n1 <= wordList.length <= 5000\n\n\nwordList[i].length == beginWord.length\n\n\nbeginWord\n, \nendWord\n, and \nwordList[i]\n consist of lowercase English letters.\n\n\nbeginWord != endWord\n\n\nAll the words in \nwordList\n are \nunique\n.",
    "solution": "\nfrom string import ascii_lowercase\n\n\n# two-end bfs\nclass Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        words = set(wordList)\n        if endWord not in words:\n            return 0\n        left, right = {beginWord}, {endWord}\n        ladder = 2\n        while left:\n            words -= left\n            new_left = set()\n            for word in left:\n                for new_word in (word[:i]+c+word[i+1:] for i in xrange(len(beginWord)) for c in ascii_lowercase):\n                    if new_word not in words:\n                        continue\n                    if new_word in right: \n                        return ladder\n                    new_left.add(new_word)\n            left = new_left\n            ladder += 1\n            if len(left) > len(right): \n                left, right = right, left\n        return 0\n\n\nclass Solution2(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        lookup = set(wordList)\n        if endWord not in lookup:\n            return 0\n        ladder = 2\n        q = [beginWord]\n        while q:\n            new_q = []\n            for word in q:\n                for i in xrange(len(word)):\n                    for j in ascii_lowercase:\n                        new_word = word[:i] + j + word[i+1:]\n                        if new_word == endWord:\n                            return ladder\n                        if new_word in lookup:\n                            lookup.remove(new_word)\n                            new_q.append(new_word)\n            q = new_q\n            ladder += 1\n        return 0",
    "explanation": "N/A",
    "time_complexity": "O(b^d), b is the branch factor of bfs, d is the result depth",
    "space_complexity": "O(w * l), w is the number of words, l is the max length of words"
  },
  {
    "title": "Find Median from Data Stream",
    "difficulty": "HARD",
    "category": "Two Pointers, Design, Sorting, Heap (Priority Queue), Data Stream",
    "link": "https://leetcode.com/problems/find-median-from-data-stream",
    "slug": "find-median-from-data-stream",
    "description": "The \nmedian\n is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\n\n\n\nFor example, for \narr = [2,3,4]\n, the median is \n3\n.\n\n\nFor example, for \narr = [2,3]\n, the median is \n(2 + 3) / 2 = 2.5\n.\n\n\n\n\nImplement the MedianFinder class:\n\n\n\n\nMedianFinder()\n initializes the \nMedianFinder\n object.\n\n\nvoid addNum(int num)\n adds the integer \nnum\n from the data stream to the data structure.\n\n\ndouble findMedian()\n returns the median of all elements so far. Answers within \n10\n-5\n of the actual answer will be accepted.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\n\nOutput\n\n[null, null, null, 1.5, null, 2.0]\n\n\nExplanation\n\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-10\n5\n <= num <= 10\n5\n\n\nThere will be at least one element in the data structure before calling \nfindMedian\n.\n\n\nAt most \n5 * 10\n4\n calls will be made to \naddNum\n and \nfindMedian\n.\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nIf all integer numbers from the stream are in the range \n[0, 100]\n, how would you optimize your solution?\n\n\nIf \n99%\n of all integer numbers from the stream are in the range \n[0, 100]\n, how would you optimize your solution?",
    "solution": "\nfrom heapq import heappush, heappop\n\nclass MedianFinder(object):\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__max_heap = []\n        self.__min_heap = []\n\n    def addNum(self, num):\n        \"\"\"\n        Adds a num into the data structure.\n        :type num: int\n        :rtype: void\n        \"\"\"\n        # Balance smaller half and larger half.\n        if not self.__max_heap or num > -self.__max_heap[0]:\n            heappush(self.__min_heap, num)\n            if len(self.__min_heap) > len(self.__max_heap) + 1:\n                heappush(self.__max_heap, -heappop(self.__min_heap))\n        else:\n            heappush(self.__max_heap, -num)\n            if len(self.__max_heap) > len(self.__min_heap):\n                heappush(self.__min_heap, -heappop(self.__max_heap))\n\n    def findMedian(self):\n        \"\"\"\n        Returns the median of current data stream\n        :rtype: float\n        \"\"\"\n        return (-self.__max_heap[0] + self.__min_heap[0]) / 2.0 \\\n               if len(self.__min_heap) == len(self.__max_heap) \\\n               else self.__min_heap[0]",
    "explanation": "N/A",
    "time_complexity": "O(nlogn) for total n addNums, O(logn) per addNum, O(1) per findMedian.",
    "space_complexity": "O(n), total space"
  },
  {
    "title": "Valid Palindrome III",
    "difficulty": "HARD",
    "category": "String, Dynamic Programming",
    "link": "https://leetcode.com/problems/valid-palindrome-iii",
    "slug": "valid-palindrome-iii",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nclass Solution(object):\n    def isValidPalindrome(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        if s == s[::-1]:  # optional, to optimize special case\n            return True\n\n        dp = [[1] * len(s) for _ in xrange(2)]\n        for i in reversed(xrange(len(s))):\n            for j in xrange(i+1, len(s)):\n                if s[i] == s[j]:\n                    dp[i%2][j] = 2 + dp[(i+1)%2][j-1] if i+1 <= j-1 else 2\n                else:\n                    dp[i%2][j] = max(dp[(i+1)%2][j], dp[i%2][j-1])\n        return len(s) <= k + dp[0][-1]",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Kth Smallest Element in a Sorted Matrix",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search, Sorting, Heap (Priority Queue), Matrix",
    "link": "https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix",
    "slug": "kth-smallest-element-in-a-sorted-matrix",
    "description": "Given an \nn x n\n \nmatrix\n where each of the rows and columns is sorted in ascending order, return \nthe\n \nk\nth\n \nsmallest element in the matrix\n.\n\n\nNote that it is the \nk\nth\n smallest element \nin the sorted order\n, not the \nk\nth\n \ndistinct\n element.\n\n\nYou must find a solution with a memory complexity better than \nO(n\n2\n)\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n\nOutput:\n 13\n\nExplanation:\n The elements in the matrix are [1,5,9,10,11,12,13,\n13\n,15], and the 8\nth\n smallest number is 13\n\n\n\nExample 2:\n\n\n\n\nInput:\n matrix = [[-5]], k = 1\n\nOutput:\n -5\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 300\n\n\n-10\n9\n <= matrix[i][j] <= 10\n9\n\n\nAll the rows and columns of \nmatrix\n are \nguaranteed\n to be sorted in \nnon-decreasing order\n.\n\n\n1 <= k <= n\n2\n\n\n\n\n \n\n\nFollow up:\n\n\n\n\nCould you solve the problem with a constant memory (i.e., \nO(1)\n memory complexity)?\n\n\nCould you solve the problem in \nO(n)\n time complexity? The solution may be too advanced for an interview but you may find reading \nthis paper\n fun.",
    "solution": "\nfrom heapq import heappush, heappop\n\nclass Solution(object):\n    def kthSmallest(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        kth_smallest = 0\n        min_heap = []\n\n        def push(i, j):\n            if len(matrix) > len(matrix[0]):\n                if i < len(matrix[0]) and j < len(matrix):\n                    heappush(min_heap, [matrix[j][i], i, j])\n            else:\n                if i < len(matrix) and j < len(matrix[0]):\n                    heappush(min_heap, [matrix[i][j], i, j])\n\n        push(0, 0)\n        while min_heap and k > 0:\n            kth_smallest, i, j = heappop(min_heap)\n            push(i, j + 1)\n            if j == 0:\n                push(i + 1, 0)\n            k -= 1\n\n        return kth_smallest",
    "explanation": "N/A",
    "time_complexity": "O(k * log(min(n, m, k))), with n x m matrix",
    "space_complexity": "O(min(n, m, k))"
  },
  {
    "title": "Add Two Integers",
    "difficulty": "EASY",
    "category": "Math",
    "link": "https://leetcode.com/problems/add-two-integers",
    "slug": "add-two-integers",
    "description": "Given two integers \nnum1\n and \nnum2\n, return \nthe \nsum\n of the two integers\n.\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n num1 = 12, num2 = 5\n\nOutput:\n 17\n\nExplanation:\n num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is returned.\n\n\n\nExample 2:\n\n\n\n\nInput:\n num1 = -10, num2 = 4\n\nOutput:\n -6\n\nExplanation:\n num1 + num2 = -6, so -6 is returned.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n-100 <= num1, num2 <= 100",
    "solution": "\n# math\nclass Solution(object):\n    def sum(self, num1, num2):\n        \"\"\"\n        :type num1: int\n        :type num2: int\n        :rtype: int\n        \"\"\"\n        return num1+num2",
    "explanation": "N/A",
    "time_complexity": "O(1)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Shortest Path in a Hidden Grid",
    "difficulty": "MEDIUM",
    "category": "Array, Depth-First Search, Breadth-First Search, Matrix, Interactive",
    "link": "https://leetcode.com/problems/shortest-path-in-a-hidden-grid",
    "slug": "shortest-path-in-a-hidden-grid",
    "description": "Failed to fetch description: Incoming markup is of an invalid type: None. Markup must be a string, a bytestring, or an open filehandle.",
    "solution": "\nclass GridMaster(object):\n    def canMove(self, direction):\n        pass\n\n    def move(self, direction):\n        pass\n\n    def isTarget(self):\n        pass\n\n\nimport collections\n\n\nclass Solution(object):\n    def findShortestPath(self, master):\n        \"\"\"\n        :type master: GridMaster\n        :rtype: int\n        \"\"\"\n        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        rollback = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}\n\n        def dfs(pos, target, master, lookup, adj):\n            if target[0] is None and master.isTarget():\n                target[0] = pos\n            lookup.add(pos)\n            for d, (di, dj) in directions.iteritems():\n                if not master.canMove(d):\n                    continue\n                nei = (pos[0]+di, pos[1]+dj)\n                adj[pos].add(nei)\n                adj[nei].add(pos)\n                if nei in lookup:\n                    continue\n                master.move(d)\n                dfs(nei, target, master, lookup, adj)\n                master.move(rollback[d])\n                        \n        def bi_bfs(adj, start, target):\n            left, right = {start}, {target}\n            lookup = set()\n            steps = 0\n            while left:\n                for pos in left:\n                    lookup.add(pos)\n                new_left = set()\n                for pos in left:\n                    if pos in right: \n                        return steps\n                    for nei in adj[pos]:\n                        if nei in lookup:\n                            continue\n                        new_left.add(nei)\n                left = new_left\n                steps += 1\n                if len(left) > len(right): \n                    left, right = right, left\n            return -1         \n        \n        start = (0, 0)\n        target = [None]\n        adj = collections.defaultdict(set)\n        dfs(start, target, master, set(), adj)\n        if not target[0]:\n            return -1\n        return bi_bfs(adj, start, target[0])\n\n\nclass Solution2(object):\n    def findShortestPath(self, master):\n        \"\"\"\n        :type master: GridMaster\n        :rtype: int\n        \"\"\"\n        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        rollback = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}\n\n        def dfs(pos, target, master, lookup, adj):\n            if target[0] is None and master.isTarget():\n                target[0] = pos\n            lookup.add(pos)\n            for d, (di, dj) in directions.iteritems():\n                if not master.canMove(d):\n                    continue\n                nei = (pos[0]+di, pos[1]+dj)\n                adj[pos].add(nei)\n                adj[nei].add(pos)\n                if nei in lookup:\n                    continue\n                master.move(d)\n                dfs(nei, target, master, lookup, adj)\n                master.move(rollback[d])\n                        \n        def bfs(adj, start, target):\n            q = [start]\n            lookup = set(q)\n            steps = 0\n            while q:\n                new_q = []\n                for pos in q:\n                    if pos == target:\n                        return steps\n                    for nei in adj[pos]:\n                        if nei in lookup:\n                            continue\n                        lookup.add(nei)\n                        new_q.append(nei)\n                q = new_q\n                steps += 1\n            return -1  \n        \n        start = (0, 0)\n        target = [None]\n        adj = collections.defaultdict(set)\n        dfs(start, target, master, set(), adj)\n        if not target[0]:\n            return -1\n        return bfs(adj, start, target[0])",
    "explanation": "N/A",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m * n)"
  },
  {
    "title": "Maximum Subarray",
    "difficulty": "MEDIUM",
    "category": "Array, Divide and Conquer, Dynamic Programming",
    "link": "https://leetcode.com/problems/maximum-subarray",
    "slug": "maximum-subarray",
    "description": "Given an integer array \nnums\n, find the \nsubarray\n with the largest sum, and return \nits sum\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-2,1,-3,4,-1,2,1,-5,4]\n\nOutput:\n 6\n\nExplanation:\n The subarray [4,-1,2,1] has the largest sum 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1]\n\nOutput:\n 1\n\nExplanation:\n The subarray [1] has the largest sum 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [5,4,-1,7,8]\n\nOutput:\n 23\n\nExplanation:\n The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n If you have figured out the \nO(n)\n solution, try coding another solution using the \ndivide and conquer\n approach, which is more subtle.",
    "solution": "\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, curr = float(\"-inf\"), float(\"-inf\")\n        for x in nums:\n            curr = max(curr+x, x)\n            result = max(result, curr)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Interval List Intersections",
    "difficulty": "MEDIUM",
    "category": "Array, Two Pointers, Line Sweep",
    "link": "https://leetcode.com/problems/interval-list-intersections",
    "slug": "interval-list-intersections",
    "description": "You are given two lists of closed intervals, \nfirstList\n and \nsecondList\n, where \nfirstList[i] = [start\ni\n, end\ni\n]\n and \nsecondList[j] = [start\nj\n, end\nj\n]\n. Each list of intervals is pairwise \ndisjoint\n and in \nsorted order\n.\n\n\nReturn \nthe intersection of these two interval lists\n.\n\n\nA \nclosed interval\n \n[a, b]\n (with \na <= b\n) denotes the set of real numbers \nx\n with \na <= x <= b\n.\n\n\nThe \nintersection\n of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of \n[1, 3]\n and \n[2, 4]\n is \n[2, 3]\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]\n\nOutput:\n [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]\n\n\n\nExample 2:\n\n\n\n\nInput:\n firstList = [[1,3],[5,9]], secondList = []\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\n0 <= firstList.length, secondList.length <= 1000\n\n\nfirstList.length + secondList.length >= 1\n\n\n0 <= start\ni\n < end\ni\n <= 10\n9\n\n\nend\ni\n < start\ni+1\n\n\n0 <= start\nj\n < end\nj\n <= 10\n9\n \n\n\nend\nj\n < start\nj+1",
    "solution": "\n# Definition for an interval.\nclass Interval(object):\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass Solution(object):\n    def intervalIntersection(self, A, B):\n        \"\"\"\n        :type A: List[Interval]\n        :type B: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        result = []\n        i, j = 0, 0\n        while i < len(A) and j < len(B):\n            left = max(A[i].start, B[j].start)\n            right = min(A[i].end, B[j].end)\n            if left <= right:\n                result.append(Interval(left, right))\n            if A[i].end < B[j].end:\n                i += 1\n            else:\n                j += 1\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(m + n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Range Sum Query - Immutable",
    "difficulty": "EASY",
    "category": "Array, Design, Prefix Sum",
    "link": "https://leetcode.com/problems/range-sum-query-immutable",
    "slug": "range-sum-query-immutable",
    "description": "Given an integer array \nnums\n, handle multiple queries of the following type:\n\n\n\n\nCalculate the \nsum\n of the elements of \nnums\n between indices \nleft\n and \nright\n \ninclusive\n where \nleft <= right\n.\n\n\n\n\nImplement the \nNumArray\n class:\n\n\n\n\nNumArray(int[] nums)\n Initializes the object with the integer array \nnums\n.\n\n\nint sumRange(int left, int right)\n Returns the \nsum\n of the elements of \nnums\n between indices \nleft\n and \nright\n \ninclusive\n (i.e. \nnums[left] + nums[left + 1] + ... + nums[right]\n).\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n\nOutput\n\n[null, 1, -1, -3]\n\n\nExplanation\n\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n4\n\n\n-10\n5\n <= nums[i] <= 10\n5\n\n\n0 <= left <= right < nums.length\n\n\nAt most \n10\n4\n calls will be made to \nsumRange\n.",
    "solution": "#        lookup: O(1)\n\nclass NumArray(object):\n    def __init__(self, nums):\n        \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n        self.accu = [0]\n        for num in nums:\n            self.accu.append(self.accu[-1] + num),\n\n    def sumRange(self, i, j):\n        \"\"\"\n        sum of elements nums[i..j], inclusive.\n        :type i: int\n        :type j: int\n        :rtype: int\n        \"\"\"\n        return self.accu[j + 1] - self.accu[i]",
    "explanation": "N/A",
    "time_complexity": "ctor:   O(n),",
    "space_complexity": "O(n)"
  },
  {
    "title": "Frequency of the Most Frequent Element",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search, Greedy, Sliding Window, Sorting, Prefix Sum",
    "link": "https://leetcode.com/problems/frequency-of-the-most-frequent-element",
    "slug": "frequency-of-the-most-frequent-element",
    "description": "The \nfrequency\n of an element is the number of times it occurs in an array.\n\n\nYou are given an integer array \nnums\n and an integer \nk\n. In one operation, you can choose an index of \nnums\n and increment the element at that index by \n1\n.\n\n\nReturn \nthe \nmaximum possible frequency\n of an element after performing \nat most\n \nk\n operations\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [1,2,4], k = 5\n\nOutput:\n 3\n\nExplanation:\n Increment the first element three times and the second element two times to make nums = [4,4,4].\n4 has a frequency of 3.\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1,4,8,13], k = 5\n\nOutput:\n 2\n\nExplanation:\n There are multiple optimal solutions:\n- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.\n- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.\n- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [3,9,6], k = 2\n\nOutput:\n 1\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n1 <= nums[i] <= 10\n5\n\n\n1 <= k <= 10\n5",
    "solution": "\nclass Solution(object):\n    def maxFrequency(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        left = 0\n        nums.sort()\n        for right in xrange(len(nums)):\n            k += nums[right]\n            if k < nums[right]*(right-left+1):\n                k -= nums[left]\n                left += 1\n        return right-left+1",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Random Pick Index",
    "difficulty": "MEDIUM",
    "category": "Hash Table, Math, Reservoir Sampling, Randomized",
    "link": "https://leetcode.com/problems/random-pick-index",
    "slug": "random-pick-index",
    "description": "Given an integer array \nnums\n with possible \nduplicates\n, randomly output the index of a given \ntarget\n number. You can assume that the given target number must exist in the array.\n\n\nImplement the \nSolution\n class:\n\n\n\n\nSolution(int[] nums)\n Initializes the object with the array \nnums\n.\n\n\nint pick(int target)\n Picks a random index \ni\n from \nnums\n where \nnums[i] == target\n. If there are multiple valid i's, then each index should have an equal probability of returning.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"Solution\", \"pick\", \"pick\", \"pick\"]\n[[[1, 2, 3, 3, 3]], [3], [1], [3]]\n\nOutput\n\n[null, 4, 0, 2]\n\n\nExplanation\n\nSolution solution = new Solution([1, 2, 3, 3, 3]);\nsolution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\nsolution.pick(1); // It should return 0. Since in the array only nums[0] is equal to 1.\nsolution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 2 * 10\n4\n\n\n-2\n31\n <= nums[i] <= 2\n31\n - 1\n\n\ntarget\n is an integer from \nnums\n.\n\n\nAt most \n10\n4\n calls will be made to \npick\n.",
    "solution": "#        pick: O(1)\n\nfrom random import randint\nimport collections\n\n\nclass Solution(object):\n\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        self.__lookup = collections.defaultdict(list)\n        for i, x in enumerate(nums):\n            self.__lookup[x].append(i)\n\n    def pick(self, target):\n        \"\"\"\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return self.__lookup[target][randint(0, len(self.__lookup[target])-1)]\n\n\n#        pick: O(n)\nfrom random import randint\n\n\nclass Solution_TLE(object):\n\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        self.__nums = nums\n\n    def pick(self, target):\n        \"\"\"\n        :type target: int\n        :rtype: int\n        \"\"\"\n        reservoir = -1\n        n = 0\n        for i in xrange(len(self.__nums)):\n            if self.__nums[i] != target:\n                continue\n            reservoir = i if randint(1, n+1) == 1 else reservoir\n            n += 1\n        return reservoir",
    "explanation": "N/A",
    "time_complexity": "ctor: O(1)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Kth Smallest Element in a BST",
    "difficulty": "MEDIUM",
    "category": "Tree, Depth-First Search, Binary Search Tree, Binary Tree",
    "link": "https://leetcode.com/problems/kth-smallest-element-in-a-bst",
    "slug": "kth-smallest-element-in-a-bst",
    "description": "Given the \nroot\n of a binary search tree, and an integer \nk\n, return \nthe\n \nk\nth\n \nsmallest value (\n1-indexed\n) of all the values of the nodes in the tree\n.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n root = [3,1,4,null,2], k = 1\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n root = [5,3,6,2,4,null,null,1], k = 3\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nThe number of nodes in the tree is \nn\n.\n\n\n1 <= k <= n <= 10\n4\n\n\n0 <= Node.val <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?",
    "solution": "\nclass Solution(object):\n    # @param {TreeNode} root\n    # @param {integer} k\n    # @return {integer}\n    def kthSmallest(self, root, k):\n        s, cur, rank = [], root, 0\n\n        while s or cur:\n            if cur:\n                s.append(cur)\n                cur = cur.left\n            else:\n                cur = s.pop()\n                rank += 1\n                if rank == k:\n                    return cur.val\n                cur = cur.right\n\n        return float(\"-inf\")\n\n\n# time: O(max(h, k))\n# space: O(h)\n\nfrom itertools import islice\n\n\nclass Solution2(object):\n    def kthSmallest(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def gen_inorder(root):\n            if root:\n                for n in gen_inorder(root.left):\n                    yield n\n\n                yield root.val\n\n                for n in gen_inorder(root.right):\n                    yield n\n\n        return next(islice(gen_inorder(root), k-1, k))",
    "explanation": "N/A",
    "time_complexity": "O(max(h, k))",
    "space_complexity": "O(h)"
  },
  {
    "title": "Decode String",
    "difficulty": "MEDIUM",
    "category": "String, Stack, Recursion",
    "link": "https://leetcode.com/problems/decode-string",
    "slug": "decode-string",
    "description": "Given an encoded string, return its decoded string.\n\n\nThe encoding rule is: \nk[encoded_string]\n, where the \nencoded_string\n inside the square brackets is being repeated exactly \nk\n times. Note that \nk\n is guaranteed to be a positive integer.\n\n\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, \nk\n. For example, there will not be input like \n3a\n or \n2[4]\n.\n\n\nThe test cases are generated so that the length of the output will never exceed \n10\n5\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"3[a]2[bc]\"\n\nOutput:\n \"aaabcbc\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"3[a2[c]]\"\n\nOutput:\n \"accaccacc\"\n\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"2[abc]3[cd]ef\"\n\nOutput:\n \"abcabccdcdcdef\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 30\n\n\ns\n consists of lowercase English letters, digits, and square brackets \n'[]'\n.\n\n\ns\n is guaranteed to be \na valid\n input.\n\n\nAll the integers in \ns\n are in the range \n[1, 300]\n.",
    "solution": "\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n, curr, nums, strs = 0, [], [], []\n        for c in s:\n            if c.isdigit():\n                n = n*10 + ord(c)-ord('0')\n            elif c.isalpha():\n                curr.append(c)\n            elif c == '[':\n                nums.append(n)\n                strs.append(curr)\n                n, curr = 0, []\n            elif c == ']':\n                strs[-1].extend(curr*nums.pop())\n                curr = strs.pop()\n        return \"\".join(curr)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Koko Eating Bananas",
    "difficulty": "MEDIUM",
    "category": "Array, Binary Search",
    "link": "https://leetcode.com/problems/koko-eating-bananas",
    "slug": "koko-eating-bananas",
    "description": "Koko loves to eat bananas. There are \nn\n piles of bananas, the \ni\nth\n pile has \npiles[i]\n bananas. The guards have gone and will come back in \nh\n hours.\n\n\nKoko can decide her bananas-per-hour eating speed of \nk\n. Each hour, she chooses some pile of bananas and eats \nk\n bananas from that pile. If the pile has less than \nk\n bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\n\nReturn \nthe minimum integer\n \nk\n \nsuch that she can eat all the bananas within\n \nh\n \nhours\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n piles = [3,6,7,11], h = 8\n\nOutput:\n 4\n\n\n\nExample 2:\n\n\n\n\nInput:\n piles = [30,11,23,4,20], h = 5\n\nOutput:\n 30\n\n\n\nExample 3:\n\n\n\n\nInput:\n piles = [30,11,23,4,20], h = 6\n\nOutput:\n 23\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= piles.length <= 10\n4\n\n\npiles.length <= h <= 10\n9\n\n\n1 <= piles[i] <= 10\n9",
    "solution": "\nclass Solution(object):\n    def minEatingSpeed(self, piles, H):\n        \"\"\"\n        :type piles: List[int]\n        :type H: int\n        :rtype: int\n        \"\"\"\n        def possible(piles, H, K):\n            return sum((pile-1)//K+1 for pile in piles) <= H\n\n        left, right = 1, max(piles)\n        while left <= right:\n            mid = left + (right-left)//2\n            if possible(piles, H, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left",
    "explanation": "N/A",
    "time_complexity": "O(nlogr)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Goat Latin",
    "difficulty": "EASY",
    "category": "String",
    "link": "https://leetcode.com/problems/goat-latin",
    "slug": "goat-latin",
    "description": "You are given a string \nsentence\n that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\n\n\nWe would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n\n\n\n\nIf a word begins with a vowel (\n'a'\n, \n'e'\n, \n'i'\n, \n'o'\n, or \n'u'\n), append \n\"ma\"\n to the end of the word.\n\n\t\n\n\nFor example, the word \n\"apple\"\n becomes \n\"applema\"\n.\n\n\n\n\n\n\nIf a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add \n\"ma\"\n.\n\t\n\n\nFor example, the word \n\"goat\"\n becomes \n\"oatgma\"\n.\n\n\n\n\n\n\nAdd one letter \n'a'\n to the end of each word per its word index in the sentence, starting with \n1\n.\n\t\n\n\nFor example, the first word gets \n\"a\"\n added to the end, the second word gets \n\"aa\"\n added to the end, and so on.\n\n\n\n\n\n\n\n\nReturn\n the final sentence representing the conversion from sentence to Goat Latin\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n sentence = \"I speak Goat Latin\"\n\nOutput:\n \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"\n\nExample 2:\n\n\nInput:\n sentence = \"The quick brown fox jumped over the lazy dog\"\n\nOutput:\n \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= sentence.length <= 150\n\n\nsentence\n consists of English letters and spaces.\n\n\nsentence\n has no leading or trailing spaces.\n\n\nAll the words in \nsentence\n are separated by a single space.",
    "solution": "#                    n is the length of S,\n#                    w is the number of word,\n#                    l is the average length of word\n\nclass Solution(object):\n    def toGoatLatin(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n        def convert(S):\n            vowel = set('aeiouAEIOU')\n            for i, word in enumerate(S.split(), 1):\n                if word[0] not in vowel:\n                    word = word[1:] + word[:1]\n                yield word + 'ma' + 'a'*i\n        return \" \".join(convert(S))",
    "explanation": "N/A",
    "time_complexity": "O(n + w^2), n = w * l,",
    "space_complexity": "O(n)"
  },
  {
    "title": "Longest Palindromic Substring",
    "difficulty": "MEDIUM",
    "category": "Two Pointers, String, Dynamic Programming",
    "link": "https://leetcode.com/problems/longest-palindromic-substring",
    "slug": "longest-palindromic-substring",
    "description": "Given a string \ns\n, return \nthe longest\n \npalindromic\n \nsubstring\n in \ns\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"babad\"\n\nOutput:\n \"bab\"\n\nExplanation:\n \"aba\" is also a valid answer.\n\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"cbbd\"\n\nOutput:\n \"bb\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 1000\n\n\ns\n consist of only digits and English letters.",
    "solution": "\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def preProcess(s):\n            if not s:\n                return ['^', '$']\n            T = ['^']\n            for c in s:\n                T +=  ['#', c]\n            T += ['#', '$']\n            return T\n\n        T = preProcess(s)\n        P = [0] * len(T)\n        center, right = 0, 0\n        for i in xrange(1, len(T) - 1):\n            i_mirror = 2 * center - i\n            if right > i:\n                P[i] = min(right - i, P[i_mirror])\n            else:\n                P[i] = 0\n\n            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:\n                P[i] += 1\n\n            if i + P[i] > right:\n                center, right = i, i + P[i]\n\n        max_i = 0\n        for i in xrange(1, len(T) - 1):\n            if P[i] > P[max_i]:\n                max_i = i\n        start = (max_i - 1 - P[max_i]) // 2\n        return s[start : start + P[max_i]]\n\n\nclass Solution2(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return (right-left+1)-2\n        \n        left, right = -1, -2\n        for i in xrange(len(s)):\n            l = max(expand(s, i, i), expand(s, i, i+1))\n            if l > right-left+1:\n                right = i+l//2\n                left = right-l+1\n        return s[left:right+1] if left >= 0 else \"\"",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Text Justification",
    "difficulty": "HARD",
    "category": "Array, String, Simulation",
    "link": "https://leetcode.com/problems/text-justification",
    "slug": "text-justification",
    "description": "Given an array of strings \nwords\n and a width \nmaxWidth\n, format the text such that each line has exactly \nmaxWidth\n characters and is fully (left and right) justified.\n\n\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces \n' '\n when necessary so that each line has exactly \nmaxWidth\n characters.\n\n\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n\n\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\n\n\nNote:\n\n\n\n\nA word is defined as a character sequence consisting of non-space characters only.\n\n\nEach word's length is guaranteed to be greater than \n0\n and not exceed \nmaxWidth\n.\n\n\nThe input array \nwords\n contains at least one word.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n\nOutput:\n\n[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]\n\n\nExample 2:\n\n\n\n\nInput:\n words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n\nOutput:\n\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\n\nExplanation:\n Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.\n\n\nExample 3:\n\n\n\n\nInput:\n words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n\nOutput:\n\n[\n  \"Science  is  what we\",\n  \"understand      well\",\n  \"enough to explain to\",\n  \"a  computer.  Art is\",\n  \"everything  else  we\",\n  \"do                  \"\n]\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= words.length <= 300\n\n\n1 <= words[i].length <= 20\n\n\nwords[i]\n consists of only English letters and symbols.\n\n\n1 <= maxWidth <= 100\n\n\nwords[i].length <= maxWidth",
    "solution": "\nclass Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        def addSpaces(i, spaceCnt, maxWidth, is_last):\n            if i < spaceCnt:\n                # For the last line of text, it should be left justified,\n                # and no extra space is inserted between words.\n                return 1 if is_last else (maxWidth // spaceCnt) + int(i < maxWidth % spaceCnt)\n            return 0\n\n        def connect(words, maxWidth, begin, end, length, is_last):\n            s = []  # The extra space O(k) is spent here.\n            n = end - begin\n            for i in xrange(n):\n                s += words[begin + i],\n                s += ' ' * addSpaces(i, n - 1, maxWidth - length, is_last),\n            # For only one word in a line.\n            line = \"\".join(s)\n            if len(line) < maxWidth:\n                line += ' ' * (maxWidth - len(line))\n            return line\n\n        res = []\n        begin, length = 0, 0\n        for i in xrange(len(words)):\n            if length + len(words[i]) + (i - begin) > maxWidth:\n                res += connect(words, maxWidth, begin, i, length, False),\n                begin, length = i, 0\n            length += len(words[i])\n\n        # Last line.\n        res += connect(words, maxWidth, begin, len(words), length, True),\n        return res",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(k), k is maxWidth."
  },
  {
    "title": "Remove All Adjacent Duplicates in String II",
    "difficulty": "MEDIUM",
    "category": "String, Stack",
    "link": "https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii",
    "slug": "remove-all-adjacent-duplicates-in-string-ii",
    "description": "You are given a string \ns\n and an integer \nk\n, a \nk\n \nduplicate removal\n consists of choosing \nk\n adjacent and equal letters from \ns\n and removing them, causing the left and the right side of the deleted substring to concatenate together.\n\n\nWe repeatedly make \nk\n \nduplicate removals\n on \ns\n until we no longer can.\n\n\nReturn \nthe final string after all such duplicate removals have been made\n. It is guaranteed that the answer is \nunique\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n s = \"abcd\", k = 2\n\nOutput:\n \"abcd\"\n\nExplanation: \nThere's nothing to delete.\n\n\nExample 2:\n\n\n\n\nInput:\n s = \"deeedbbcccbdaa\", k = 3\n\nOutput:\n \"aa\"\n\nExplanation: \n\nFirst delete \"eee\" and \"ccc\", get \"ddbbbdaa\"\nThen delete \"bbb\", get \"dddaa\"\nFinally delete \"ddd\", get \"aa\"\n\n\nExample 3:\n\n\n\n\nInput:\n s = \"pbbcggttciiippooaais\", k = 2\n\nOutput:\n \"ps\"\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n5\n\n\n2 <= k <= 10\n4\n\n\ns\n only contains lowercase English letters.",
    "solution": "\nclass Solution(object):\n    def removeDuplicates(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        stk = [['^', 0]]\n        for c in s:\n            if stk[-1][0] == c:\n                stk[-1][1] += 1\n                if stk[-1][1] == k:\n                    stk.pop()\n            else:\n                stk.append([c, 1])\n        return \"\".join(c*k for c, k in stk)",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Best Time to Buy and Sell Stock III",
    "difficulty": "HARD",
    "category": "Array, Dynamic Programming",
    "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii",
    "slug": "best-time-to-buy-and-sell-stock-iii",
    "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nFind the maximum profit you can achieve. You may complete \nat most two transactions\n.\n\n\nNote:\n You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [3,3,5,0,0,3,1,4]\n\nOutput:\n 6\n\nExplanation:\n Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [1,2,3,4,5]\n\nOutput:\n 4\n\nExplanation:\n Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n\n\n\nExample 3:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transaction is done, i.e. max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n5",
    "solution": "\nclass Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        hold1, hold2 = float(\"-inf\"), float(\"-inf\")\n        release1, release2 = 0, 0\n        for i in prices:\n            hold1 = max(hold1, -i)\n            release1 = max(release1, hold1 + i)\n            hold2 = max(hold2, release1 - i)\n            release2 = max(release2, hold2 + i)\n        return release2\n\n\nclass Solution2(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        def maxAtMostKPairsProfit(prices, k):\n            max_buy = [float(\"-inf\") for _ in xrange(k + 1)]\n            max_sell = [0 for _ in xrange(k + 1)]\n            for i in xrange(len(prices)):\n                for j in xrange(1, k + 1):\n                    max_buy[j] = max(max_buy[j], max_sell[j-1] - prices[i])\n                    max_sell[j] = max(max_sell[j], max_buy[j] + prices[i])\n            return max_sell[k]\n\n        return maxAtMostKPairsProfit(prices, 2)\n\n\nclass Solution3(object):\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, prices):\n        min_price, max_profit_from_left, max_profits_from_left = \\\n            float(\"inf\"), 0, []\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit_from_left = max(max_profit_from_left, price - min_price)\n            max_profits_from_left.append(max_profit_from_left)\n\n        max_price, max_profit_from_right, max_profits_from_right = 0, 0, []\n        for i in reversed(range(len(prices))):\n            max_price = max(max_price, prices[i])\n            max_profit_from_right = max(max_profit_from_right,\n                                        max_price - prices[i])\n            max_profits_from_right.insert(0, max_profit_from_right)\n\n        max_profit = 0\n        for i in range(len(prices)):\n            max_profit = max(max_profit,\n                             max_profits_from_left[i] +\n                             max_profits_from_right[i])\n\n        return max_profit",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Median of Two Sorted Arrays",
    "difficulty": "HARD",
    "category": "Array, Binary Search, Divide and Conquer",
    "link": "https://leetcode.com/problems/median-of-two-sorted-arrays",
    "slug": "median-of-two-sorted-arrays",
    "description": "Given two sorted arrays \nnums1\n and \nnums2\n of size \nm\n and \nn\n respectively, return \nthe median\n of the two sorted arrays.\n\n\nThe overall run time complexity should be \nO(log (m+n))\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums1 = [1,3], nums2 = [2]\n\nOutput:\n 2.00000\n\nExplanation:\n merged array = [1,2,3] and median is 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums1 = [1,2], nums2 = [3,4]\n\nOutput:\n 2.50000\n\nExplanation:\n merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n\n \n\n\nConstraints:\n\n\n\n\nnums1.length == m\n\n\nnums2.length == n\n\n\n0 <= m <= 1000\n\n\n0 <= n <= 1000\n\n\n1 <= m + n <= 2000\n\n\n-10\n6\n <= nums1[i], nums2[i] <= 10\n6",
    "solution": "\nclass Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(A, B, k):\n            m, n = len(A), len(B)\n            if m > n:\n                m, n = n, m\n                A, B = B, A\n            i = binary_search(max(k-n, 0), min(m, k)-1, lambda i: A[i] >= B[k-1-i])\n            return max(A[i-1] if i-1 >= 0 else float(\"-inf\"), B[k-1-i] if k-1-i >= 0 else float(\"-inf\"))\n\n        len1, len2 = len(nums1), len(nums2)\n        if (len1+len2) % 2 == 1:\n            return getKth(nums1, nums2, (len1+len2)//2+1)\n        else:\n            return (getKth(nums1, nums2, (len1+len2)//2)+getKth(nums1, nums2, (len1+len2)//2+1))*0.5    \n\n\n# Generic solution.\nclass Solution_Generic(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def getKth(arrays, k):\n            def check(num):\n                # count the number of values which are less or equal to num\n                return sum(binary_search(0, len(arr)-1, lambda x: arr[x] > num) for arr in arrays) >= k\n    \n            return binary_search(min(arr[0] for arr in arrays if arr), max(arr[-1] for arr in arrays if arr), check)\n\n        array = [nums1, nums2]\n        total = sum(len(nums) for nums in array)\n        if total % 2 == 1:\n            return getKth(array, total//2+1)\n        else:\n            return (getKth(array, total//2)+getKth(array, total//2+1))*0.5",
    "explanation": "N/A",
    "time_complexity": "O(log(max(m, n)) * log(max_val - min_val))",
    "space_complexity": "O(1)"
  }
]