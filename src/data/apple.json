[
  {
    "title": "LRU Cache",
    "difficulty": "MEDIUM",
    "category": "Hash Table, Linked List, Design, Doubly-Linked List",
    "link": "https://leetcode.com/problems/lru-cache",
    "slug": "lru-cache",
    "description": "Design a data structure that follows the constraints of a \nLeast Recently Used (LRU) cache\n.\n\n\nImplement the \nLRUCache\n class:\n\n\n\n\nLRUCache(int capacity)\n Initialize the LRU cache with \npositive\n size \ncapacity\n.\n\n\nint get(int key)\n Return the value of the \nkey\n if the key exists, otherwise return \n-1\n.\n\n\nvoid put(int key, int value)\n Update the value of the \nkey\n if the \nkey\n exists. Otherwise, add the \nkey-value\n pair to the cache. If the number of keys exceeds the \ncapacity\n from this operation, \nevict\n the least recently used key.\n\n\n\n\nThe functions \nget\n and \nput\n must each run in \nO(1)\n average time complexity.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput\n\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n\nOutput\n\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n\nExplanation\n\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= capacity <= 3000\n\n\n0 <= key <= 10\n4\n\n\n0 <= value <= 10\n5\n\n\nAt most \n2 * 10\n5\n calls will be made to \nget\n and \nput\n.",
    "solution": "\nimport collections\n\n\n# using OrderedDictclass LRUCache(object):\n    def __init__(self, capacity):\n        self.cache = collections.OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        val = self.cache[key]\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.cache and len(self.cache) == self.capacity:\n            self.cache.popitem(last=False)\n        self.__update(key, val)\n    \n    def __update(self, key, val):\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = val\n\n\n\nclass ListNode(object):\n    def __init__(self, key, val):\n        self.val = val\n        self.key = key\n        self.next = None\n        self.prev = None\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\nclass LRUCache2(object):\n\n    def __init__(self, capacity):\n        self.list = LinkedList()\n        self.dict = {}\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.dict:\n            return -1\n        val = self.dict[key].val\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.dict and len(self.dict) == self.capacity:\n            del self.dict[self.list.head.key]\n            self.list.delete(self.list.head)\n        self.__update(key, val)\n\n    def __update(self, key, val):\n        if key in self.dict:\n            self.list.delete(self.dict[key])\n        node = ListNode(key, val)\n        self.list.insert(node)\n        self.dict[key] = node",
    "explanation": "N/A",
    "time_complexity": "O(1), per operation.",
    "space_complexity": "O(k), k is the capacity of cache."
  },
  {
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "EASY",
    "category": "Array, Dynamic Programming",
    "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
    "slug": "best-time-to-buy-and-sell-stock",
    "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nYou want to maximize your profit by choosing a \nsingle day\n to buy one stock and choosing a \ndifferent day in the future\n to sell that stock.\n\n\nReturn \nthe maximum profit you can achieve from this transaction\n. If you cannot achieve any profit, return \n0\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 5\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transactions are done and the max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n4",
    "solution": "class Solution(object):\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, prices):\n        max_profit, min_price = 0, float(\"inf\")\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Top K Frequent Elements",
    "difficulty": "MEDIUM",
    "category": "Array, Hash Table, Divide and Conquer, Sorting, Heap (Priority Queue), Bucket Sort, Counting, Quickselect",
    "link": "https://leetcode.com/problems/top-k-frequent-elements",
    "slug": "top-k-frequent-elements",
    "description": "Given an integer array \nnums\n and an integer \nk\n, return \nthe\n \nk\n \nmost frequent elements\n. You may return the answer in \nany order\n.\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [1,1,1,2,2,3], k = 2\n\nOutput:\n [1,2]\n\nExample 2:\n\n\nInput:\n nums = [1], k = 1\n\nOutput:\n [1]\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\nk\n is in the range \n[1, the number of unique elements in the array]\n.\n\n\nIt is \nguaranteed\n that the answer is \nunique\n.\n\n\n\n\n \n\n\nFollow up:\n Your algorithm's time complexity must be better than \nO(n log n)\n, where n is the array's size.",
    "solution": "\nimport collections\n\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        counts = collections.Counter(nums)\n        buckets = [[] for _ in xrange(len(nums)+1)]\n        for i, count in counts.iteritems():\n            buckets[count].append(i)\n\n        result = []\n        for i in reversed(xrange(len(buckets))):\n            for j in xrange(len(buckets[i])):\n                result.append(buckets[i][j])\n                if len(result) == k:\n                    return result\n        return result\n\n\n# Quick Select Solution\nfrom random import randintclass Solution2(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        counts = collections.Counter(nums)\n        p = []\n        for key, val in counts.iteritems():\n            p.append((-val, key))\n        self.kthElement(p, k-1)\n\n        result = []\n        for i in xrange(k):\n            result.append(p[i][1])\n        return result\n\n    def kthElement(self, nums, k):\n        def PartitionAroundPivot(left, right, pivot_idx, nums):\n            pivot_value = nums[pivot_idx]\n            new_pivot_idx = left\n            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n            for i in xrange(left, right):\n                if nums[i] < pivot_value:\n                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                    new_pivot_idx += 1\n\n            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n            return new_pivot_idx\n\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k:\n                return\n            elif new_pivot_idx > k:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k.\n                left = new_pivot_idx + 1\n\nclass Solution3(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        return [key for key, _ in collections.Counter(nums).most_common(k)]",
    "explanation": "N/A",
    "time_complexity": "O(nlogk)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Best Time to Buy and Sell Stock II",
    "difficulty": "MEDIUM",
    "category": "Array, Dynamic Programming, Greedy",
    "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii",
    "slug": "best-time-to-buy-and-sell-stock-ii",
    "description": "You are given an integer array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold \nat most one\n share of the stock at any time. However, you can buy it then immediately sell it on the \nsame day\n.\n\n\nFind and return \nthe \nmaximum\n profit you can achieve\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [7,1,5,3,6,4]\n\nOutput:\n 7\n\nExplanation:\n Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [1,2,3,4,5]\n\nOutput:\n 4\n\nExplanation:\n Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n\n\n\nExample 3:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 3 * 10\n4\n\n\n0 <= prices[i] <= 10\n4",
    "solution": "\nclass Solution(object):\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, prices):\n        profit = 0\n        for i in xrange(len(prices) - 1):\n            profit += max(0, prices[i + 1] - prices[i])\n        return profit\n\n    def maxProfit2(self, prices):\n        return sum(map(lambda x: max(prices[x + 1] - prices[x], 0),\n                       xrange(len(prices[:-1]))))",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Longest Common Prefix",
    "difficulty": "EASY",
    "category": "String, Trie",
    "link": "https://leetcode.com/problems/longest-common-prefix",
    "slug": "longest-common-prefix",
    "description": "Write a function to find the longest common prefix string amongst an array of strings.\n\n\nIf there is no common prefix, return an empty string \n\"\"\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n strs = [\"flower\",\"flow\",\"flight\"]\n\nOutput:\n \"fl\"\n\n\n\nExample 2:\n\n\n\n\nInput:\n strs = [\"dog\",\"racecar\",\"car\"]\n\nOutput:\n \"\"\n\nExplanation:\n There is no common prefix among the input strings.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= strs.length <= 200\n\n\n0 <= strs[i].length <= 200\n\n\nstrs[i]\n consists of only lowercase English letters if it is non-empty.",
    "solution": "class Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n\n        for i in xrange(len(strs[0])):\n            for string in strs[1:]:\n                if i >= len(string) or string[i] != strs[0][i]:\n                    return strs[0][:i]\n        return strs[0]\n\nclass Solution2(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        prefix = \"\"\n        \n        for chars in zip(*strs):\n            if all(c == chars[0] for c in chars):\n                prefix += chars[0]\n            else:\n                return prefix\n            \n        return prefix",
    "explanation": "N/A",
    "time_complexity": "O(n * k), k is the length of the common prefix",
    "space_complexity": "O(k)"
  },
  {
    "title": "Maximum Subarray",
    "difficulty": "MEDIUM",
    "category": "Array, Divide and Conquer, Dynamic Programming",
    "link": "https://leetcode.com/problems/maximum-subarray",
    "slug": "maximum-subarray",
    "description": "Given an integer array \nnums\n, find the \nsubarray\n with the largest sum, and return \nits sum\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n nums = [-2,1,-3,4,-1,2,1,-5,4]\n\nOutput:\n 6\n\nExplanation:\n The subarray [4,-1,2,1] has the largest sum 6.\n\n\n\nExample 2:\n\n\n\n\nInput:\n nums = [1]\n\nOutput:\n 1\n\nExplanation:\n The subarray [1] has the largest sum 1.\n\n\n\nExample 3:\n\n\n\n\nInput:\n nums = [5,4,-1,7,8]\n\nOutput:\n 23\n\nExplanation:\n The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4\n\n\n\n\n \n\n\nFollow up:\n If you have figured out the \nO(n)\n solution, try coding another solution using the \ndivide and conquer\n approach, which is more subtle.",
    "solution": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, curr = float(\"-inf\"), float(\"-inf\")\n        for x in nums:\n            curr = max(curr+x, x)\n            result = max(result, curr)\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Best Time to Buy and Sell Stock III",
    "difficulty": "HARD",
    "category": "Array, Dynamic Programming",
    "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii",
    "slug": "best-time-to-buy-and-sell-stock-iii",
    "description": "You are given an array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day.\n\n\nFind the maximum profit you can achieve. You may complete \nat most two transactions\n.\n\n\nNote:\n You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n prices = [3,3,5,0,0,3,1,4]\n\nOutput:\n 6\n\nExplanation:\n Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n\n\nExample 2:\n\n\n\n\nInput:\n prices = [1,2,3,4,5]\n\nOutput:\n 4\n\nExplanation:\n Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n\n\n\nExample 3:\n\n\n\n\nInput:\n prices = [7,6,4,3,1]\n\nOutput:\n 0\n\nExplanation:\n In this case, no transaction is done, i.e. max profit = 0.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= prices.length <= 10\n5\n\n\n0 <= prices[i] <= 10\n5",
    "solution": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        hold1, hold2 = float(\"-inf\"), float(\"-inf\")\n        release1, release2 = 0, 0\n        for i in prices:\n            hold1 = max(hold1, -i)\n            release1 = max(release1, hold1 + i)\n            hold2 = max(hold2, release1 - i)\n            release2 = max(release2, hold2 + i)\n        return release2\n\nclass Solution2(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        def maxAtMostKPairsProfit(prices, k):\n            max_buy = [float(\"-inf\") for _ in xrange(k + 1)]\n            max_sell = [0 for _ in xrange(k + 1)]\n            for i in xrange(len(prices)):\n                for j in xrange(1, k + 1):\n                    max_buy[j] = max(max_buy[j], max_sell[j-1] - prices[i])\n                    max_sell[j] = max(max_sell[j], max_buy[j] + prices[i])\n            return max_sell[k]\n\n        return maxAtMostKPairsProfit(prices, 2)\n\nclass Solution3(object):\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, prices):\n        min_price, max_profit_from_left, max_profits_from_left = \\\n            float(\"inf\"), 0, []\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit_from_left = max(max_profit_from_left, price - min_price)\n            max_profits_from_left.append(max_profit_from_left)\n\n        max_price, max_profit_from_right, max_profits_from_right = 0, 0, []\n        for i in reversed(range(len(prices))):\n            max_price = max(max_price, prices[i])\n            max_profit_from_right = max(max_profit_from_right,\n                                        max_price - prices[i])\n            max_profits_from_right.insert(0, max_profit_from_right)\n\n        max_profit = 0\n        for i in range(len(prices)):\n            max_profit = max(max_profit,\n                             max_profits_from_left[i] +\n                             max_profits_from_right[i])\n\n        return max_profit",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Kth Largest Element in an Array",
    "difficulty": "MEDIUM",
    "category": "Array, Divide and Conquer, Sorting, Heap (Priority Queue), Quickselect",
    "link": "https://leetcode.com/problems/kth-largest-element-in-an-array",
    "slug": "kth-largest-element-in-an-array",
    "description": "Given an integer array \nnums\n and an integer \nk\n, return \nthe\n \nk\nth\n \nlargest element in the array\n.\n\n\nNote that it is the \nk\nth\n largest element in the sorted order, not the \nk\nth\n distinct element.\n\n\nCan you solve it without sorting?\n\n\n \n\n\nExample 1:\n\n\nInput:\n nums = [3,2,1,5,6,4], k = 2\n\nOutput:\n 5\n\nExample 2:\n\n\nInput:\n nums = [3,2,3,1,2,4,5,5,6], k = 4\n\nOutput:\n 4\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= nums.length <= 10\n5\n\n\n-10\n4\n <= nums[i] <= 10\n4",
    "solution": "\nfrom random import randint\n\n\n# optimized for duplicated numsclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        nth_element(nums, k-1, compare=lambda a, b: a > b)\n        return nums[k-1]\n\nclass Solution2(object):\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = self.PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k - 1:\n                return nums[new_pivot_idx]\n            elif new_pivot_idx > k - 1:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k - 1.\n                left = new_pivot_idx + 1\n\n    def PartitionAroundPivot(self, left, right, pivot_idx, nums):\n        pivot_value = nums[pivot_idx]\n        new_pivot_idx = left\n        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n        for i in xrange(left, right):\n            if nums[i] > pivot_value:\n                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                new_pivot_idx += 1\n\n        nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n        return new_pivot_idx",
    "explanation": "N/A",
    "time_complexity": "O(n) on average, using Median of Medians could achieve O(n) (Intro Select)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Merge k Sorted Lists",
    "difficulty": "HARD",
    "category": "Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort",
    "link": "https://leetcode.com/problems/merge-k-sorted-lists",
    "slug": "merge-k-sorted-lists",
    "description": "You are given an array of \nk\n linked-lists \nlists\n, each linked-list is sorted in ascending order.\n\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n lists = [[1,4,5],[1,3,4],[2,6]]\n\nOutput:\n [1,1,2,3,4,4,5,6]\n\nExplanation:\n The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted linked list:\n1->1->2->3->4->4->5->6\n\n\n\nExample 2:\n\n\n\n\nInput:\n lists = []\n\nOutput:\n []\n\n\n\nExample 3:\n\n\n\n\nInput:\n lists = [[]]\n\nOutput:\n []\n\n\n\n \n\n\nConstraints:\n\n\n\n\nk == lists.length\n\n\n0 <= k <= 10\n4\n\n\n0 <= lists[i].length <= 500\n\n\n-10\n4\n <= lists[i][j] <= 10\n4\n\n\nlists[i]\n is sorted in \nascending order\n.\n\n\nThe sum of \nlists[i].length\n will not exceed \n10\n4\n.",
    "solution": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\t\t\n        if self:\t\t\n            return \"{} -> {}\".format(self.val, self.next)\n\n\n# Merge two by two solution.class Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        if not lists:\n            return None\n        left, right = 0, len(lists) - 1\n        while right > 0:\n            lists[left] = mergeTwoLists(lists[left], lists[right])\n            left += 1\n            right -= 1\n            if left >= right:\n                left = 0\n        return lists[0]\n\n\n# Divide and Conquer solution.class Solution2(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        def mergeKListsHelper(lists, begin, end):\n            if begin > end:\n                return None\n            if begin == end:\n                return lists[begin]\n            return mergeTwoLists(mergeKListsHelper(lists, begin, (begin + end) / 2), \\\n                                 mergeKListsHelper(lists, (begin + end) / 2 + 1, end))\n\n        return mergeKListsHelper(lists, 0, len(lists) - 1)\n\n\n# Heap solution.\nimport heapqclass Solution3(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        dummy = ListNode(0)\n        current = dummy\n\n        heap = []\n        for sorted_list in lists:\n            if sorted_list:\n                heapq.heappush(heap, (sorted_list.val, sorted_list))\n\n        while heap:\n            smallest = heapq.heappop(heap)[1]\n            current.next = smallest\n            current = current.next\n            if smallest.next:\n                heapq.heappush(heap, (smallest.next.val, smallest.next))\n\n        return dummy.next",
    "explanation": "N/A",
    "time_complexity": "O(nlogk)",
    "space_complexity": "O(k)"
  },
  {
    "title": "Number of Islands",
    "difficulty": "MEDIUM",
    "category": "Array, Depth-First Search, Breadth-First Search, Union Find, Matrix",
    "link": "https://leetcode.com/problems/number-of-islands",
    "slug": "number-of-islands",
    "description": "Given an \nm x n\n 2D binary grid \ngrid\n which represents a map of \n'1'\ns (land) and \n'0'\ns (water), return \nthe number of islands\n.\n\n\nAn \nisland\n is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\n\nOutput:\n 1\n\n\n\nExample 2:\n\n\n\n\nInput:\n grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\n\nOutput:\n 3\n\n\n\n \n\n\nConstraints:\n\n\n\n\nm == grid.length\n\n\nn == grid[i].length\n\n\n1 <= m, n <= 300\n\n\ngrid[i][j]\n is \n'0'\n or \n'1'\n.",
    "solution": "class UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n       if self.set[x] != x:\n           self.set[x] = self.find_set(self.set[x])  # path compression.\n       return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root != y_root:\n            self.set[min(x_root, y_root)] = max(x_root, y_root)\n            self.count -= 1\n\nclass Solution(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        def index(n, i, j):\n            return i*n + j\n    \n        if not grid:\n            return 0\n\n        zero_count = 0\n        union_find = UnionFind(len(grid)*len(grid[0]))\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j] == '1':\n                    if i and grid[i-1][j] == '1':\n                        union_find.union_set(index(len(grid[0]), i-1, j),\n                                             index(len(grid[0]),i, j))\n                    if j and grid[i][j-1] == '1':\n                        union_find.union_set(index(len(grid[0]), i, j-1),\n                                             index(len(grid[0]), i, j))\n                else:\n                    zero_count += 1        \n        return union_find.count-zero_count\n\n\n# dfs solutionclass Solution2(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def dfs(grid, i, j):\n            if grid[i][j] == '0':\n                return False\n            grid[i][j] = '0'\n            stk = [(i, j)]\n            while stk:\n                r, c = stk.pop()\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(grid) and\n                            0 <= nc < len(grid[0]) and\n                            grid[nr][nc] == '1'):\n                        continue\n                    grid[nr][nc] = '0'\n                    stk.append((nr, nc))\n            return True\n\n        count = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if dfs(grid, i, j):\n                    count += 1\n        return count\n\n \nimport collections\n\n\n# bfs solutionclass Solution3(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def bfs(grid, i, j):\n            if grid[i][j] == '0':\n                return False\n            grid[i][j] ='0'\n            q = collections.deque([(i, j)])\n            while q:\n                r, c = q.popleft()\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(grid) and\n                            0 <= nc < len(grid[0]) and\n                            grid[nr][nc] == '1'):\n                        continue\n                    grid[nr][nc] = '0'\n                    q.append((nr, nc))\n            return True\n\n        count = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if bfs(grid, i, j):\n                    count += 1\n        return count",
    "explanation": "N/A",
    "time_complexity": "O(m * n)",
    "space_complexity": "O(m * n)"
  },
  {
    "title": "Rotate Image",
    "difficulty": "MEDIUM",
    "category": "Array, Math, Matrix",
    "link": "https://leetcode.com/problems/rotate-image",
    "slug": "rotate-image",
    "description": "You are given an \nn x n\n 2D \nmatrix\n representing an image, rotate the image by \n90\n degrees (clockwise).\n\n\nYou have to rotate the image \nin-place\n, which means you have to modify the input 2D matrix directly. \nDO NOT\n allocate another 2D matrix and do the rotation.\n\n\n \n\n\nExample 1:\n\n\n\n\n\n\nInput:\n matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput:\n [[7,4,1],[8,5,2],[9,6,3]]\n\n\n\nExample 2:\n\n\n\n\n\n\nInput:\n matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n\nOutput:\n [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\n\n \n\n\nConstraints:\n\n\n\n\nn == matrix.length == matrix[i].length\n\n\n1 <= n <= 20\n\n\n-1000 <= matrix[i][j] <= 1000",
    "solution": "class Solution(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        n = len(matrix)\n\n        # anti-diagonal mirror\n        for i in xrange(n):\n            for j in xrange(n - i):\n                matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j]\n\n        # horizontal mirror\n        for i in xrange(n / 2):\n            for j in xrange(n):\n                matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]\n\n        return matrix\nclass Solution2(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        return [list(reversed(x)) for x in zip(*matrix)]",
    "explanation": "N/A",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n^2)"
  },
  {
    "title": "Best Time to Buy and Sell Stock IV",
    "difficulty": "HARD",
    "category": "Array, Dynamic Programming",
    "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv",
    "slug": "best-time-to-buy-and-sell-stock-iv",
    "description": "You are given an integer array \nprices\n where \nprices[i]\n is the price of a given stock on the \ni\nth\n day, and an integer \nk\n.\n\n\nFind the maximum profit you can achieve. You may complete at most \nk\n transactions: i.e. you may buy at most \nk\n times and sell at most \nk\n times.\n\n\nNote:\n You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n k = 2, prices = [2,4,1]\n\nOutput:\n 2\n\nExplanation:\n Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n\n\n\nExample 2:\n\n\n\n\nInput:\n k = 2, prices = [3,2,6,5,0,3]\n\nOutput:\n 7\n\nExplanation:\n Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= k <= 100\n\n\n1 <= prices.length <= 1000\n\n\n0 <= prices[i] <= 1000",
    "solution": "\nimport random\n\nclass Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        profits = []\n        v_p_stk = []  # mono stack, where v is increasing and p is strictly decreasing\n        v, p = -1, -1\n        while p+1 < len(prices): # at most O(n) peaks, so v_p_stk and profits are both at most O(n) space\n            for v in xrange(p+1, len(prices)-1):\n                if prices[v] < prices[v+1]:\n                    break\n            else:\n                v = len(prices)-1\n            for p in xrange(v, len(prices)-1):\n                if prices[p] > prices[p+1]:\n                    break \n            else:\n                p = len(prices)-1\n            while v_p_stk and prices[v_p_stk[-1][0]] > prices[v]:  # not overlapped\n                last_v, last_p = v_p_stk.pop()\n                profits.append(prices[last_p]-prices[last_v])  # count [prices[last_v], prices[last_p]] interval\n            while v_p_stk and prices[v_p_stk[-1][1]] <= prices[p]:  # overlapped\n                # prices[last_v] <= prices[v] <= prices[last_p] <= prices[p],\n                # treat overlapped as [prices[v], prices[last_p]], [prices[last_v], prices[p]] intervals due to invariant max profit\n                last_v, last_p = v_p_stk.pop()\n                profits.append(prices[last_p]-prices[v])  # count [prices[v], prices[last_p]] interval\n                v = last_v\n            v_p_stk.append((v, p))  # keep [prices[last_v], prices[p]] interval to check overlapped      \n        while v_p_stk:\n            last_v, last_p = v_p_stk.pop()\n            profits.append(prices[last_p]-prices[last_v])  # count [prices[last_v], prices[last_p]] interval\n        if k > len(profits):\n            k = len(profits)\n        else:\n            nth_element(profits, k-1, compare=lambda a, b: a > b)\n        return sum(profits[i] for i in xrange(k))  # top k profits of nonoverlapped intervals\n\nclass Solution2(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        def maxAtMostNPairsProfit(sprices):\n            profit = 0\n            for i in xrange(len(prices) - 1):\n                profit += max(0, prices[i + 1] - prices[i])\n            return profit\n\n        def maxAtMostKPairsProfit(prices, k):\n            max_buy = [float(\"-inf\") for _ in xrange(k + 1)]\n            max_sell = [0 for _ in xrange(k + 1)]\n            for i in xrange(len(prices)):\n                for j in xrange(1, k + 1):\n                    max_buy[j] = max(max_buy[j], max_sell[j-1] - prices[i])\n                    max_sell[j] = max(max_sell[j], max_buy[j] + prices[i])\n            return max_sell[k]\n\n        if k >= len(prices) // 2:\n            return maxAtMostNPairsProfit(prices)\n\n        return maxAtMostKPairsProfit(prices, k)",
    "explanation": "N/A",
    "time_complexity": "O(k * n)",
    "space_complexity": "O(k)"
  },
  {
    "title": "Merge Intervals",
    "difficulty": "MEDIUM",
    "category": "Array, Sorting",
    "link": "https://leetcode.com/problems/merge-intervals",
    "slug": "merge-intervals",
    "description": "Given an array of \nintervals\n where \nintervals[i] = [start\ni\n, end\ni\n]\n, merge all overlapping intervals, and return \nan array of the non-overlapping intervals that cover all the intervals in the input\n.\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n intervals = [[1,3],[2,6],[8,10],[15,18]]\n\nOutput:\n [[1,6],[8,10],[15,18]]\n\nExplanation:\n Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\n\n\nExample 2:\n\n\n\n\nInput:\n intervals = [[1,4],[4,5]]\n\nOutput:\n [[1,5]]\n\nExplanation:\n Intervals [1,4] and [4,5] are considered overlapping.\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= intervals.length <= 10\n4\n\n\nintervals[i].length == 2\n\n\n0 <= start\ni\n <= end\ni\n <= 10\n4",
    "solution": "class Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        intervals.sort()\n        result = []\n        for interval in intervals:\n            if not result or interval[0] > result[-1][1]:\n                result.append(interval)\n            else:\n                result[-1][1] = max(result[-1][1], interval[1])\n        return result",
    "explanation": "N/A",
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Valid Parentheses",
    "difficulty": "EASY",
    "category": "String, Stack",
    "link": "https://leetcode.com/problems/valid-parentheses",
    "slug": "valid-parentheses",
    "description": "Given a string \ns\n containing just the characters \n'('\n, \n')'\n, \n'{'\n, \n'}'\n, \n'['\n and \n']'\n, determine if the input string is valid.\n\n\nAn input string is valid if:\n\n\n\n\nOpen brackets must be closed by the same type of brackets.\n\n\nOpen brackets must be closed in the correct order.\n\n\nEvery close bracket has a corresponding open bracket of the same type.\n\n\n\n\n \n\n\nExample 1:\n\n\n\n\nInput:\n \ns = \"()\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 2:\n\n\n\n\nInput:\n \ns = \"()[]{}\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 3:\n\n\n\n\nInput:\n \ns = \"(]\"\n\n\nOutput:\n \nfalse\n\n\n\n\nExample 4:\n\n\n\n\nInput:\n \ns = \"([])\"\n\n\nOutput:\n \ntrue\n\n\n\n\nExample 5:\n\n\n\n\nInput:\n \ns = \"([)]\"\n\n\nOutput:\n \nfalse\n\n\n\n\n \n\n\nConstraints:\n\n\n\n\n1 <= s.length <= 10\n4\n\n\ns\n consists of parentheses only \n'()[]{}'\n.",
    "solution": "class Solution(object):\n    # @return a boolean\n    def isValid(self, s):\n        stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        for parenthese in s:\n            if parenthese in lookup:\n                stack.append(parenthese)\n            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:\n                return False\n        return len(stack) == 0",
    "explanation": "N/A",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  }
]